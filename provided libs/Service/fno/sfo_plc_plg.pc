/*	Program				:	SFO_PLC_PLG																											*/
/* 																																									*/
/*	Input					:																																	*/	
/*								FFO_USR_ID																												*/
/*								FFO_SSSN_ID																												*/
/*								FFO_DP_CLNT_ID 																										*/
/*								FFO_DPID																													*/
/*								FFO_EBA_MTCH_ACT_NO																								*/
/*								FFO_STCK_CD																												*/ 
/*								FFO_ORD_TOT_QTY																										*/
/*								FFO_OPT_TYP																												*/
/*																																									*/
/*	Output				:	FFO_ORDR_RFRNC(for spot)																				*/
/*								FFO_ACTN_ID																												*/
/*								FFO_ERR_MSG																												*/
/*								FFO_PLG_ORDR_RFRNC																								*/ 
/*																																									*/
/*	Description		: To place pledge/withdraw/invoke requests for equity shares			*/
/*							  that will be taken as collateral for raising											*/
/*							  the limits.																												*/
/*	Log						:	1.0 13-Sep-2004		Krishnan.V																		*/
/*									1.1	02-Sep-2005   Krishnan.V | 3i Infotech                      */
/*									1.2 26-May-2006		Krishnan.V	| 3i Infotech											*/
/*                  1.3 25-Sep-2006   Vikash | Vidya | 3i Infotech                  */
/*                  1.4 26-Sep-2006   Vidya | 3i Infotech                  					*/
/*							    1.5 27-Sep-2006   Vidyayini | Vikash | 3i Infotech							*/
/*                  1.6 23-Jan-2008   Smitha | Vikash | 3i Infotech                 */
/*									1.7 14-Mar-2007		Sushil Sharma | 3i Infotech										*/
/*                  1.8 07-Feb-2008   Vidyayini | 3i-Infotech                       */
/*									1.9 20-May-2008		Shamili | 3i-Infotech													*/
/*									2.0 26-May-2009		Renuka Easy Margin Changes(Restrict customer  */
/*																			from pledging if EM position exists)  				*/
/*                  2.1 02-Sep-2009   CRCSN35839																		*/
/*                                    DisableSpot in NSE and enable in BSE					*/
/*                  2.2 23-Dec-2009   CRCON38802-Bulk Withdrawal Vidyayini Krish    */
/*									2.3	08-Nov-2010		Shamili | Reallocation of Buffer and					*/ 
/*									 									optimisation																	*/
/*                  2.4 13-Dec-2011   Shamili | Log added to check plg rate,plgqty  */
/*                                    and   haircut                                 */
/*                  2.5 20-Jan-2010   CRCSN43521 EQ SAM changes                     */
/*                  2.6 17-Feb-2012   Bug-Fix (Incorrect PML order qty)             */
/*                  2.7 24-Sep-2012   Message changes and FNO BSE limit     (DS)    */
/*									2.8 03-Jul-2013   Bhushan Sonwane           										*/
/*                  2.9 11-Sep-2013   Akshay Joshi                                  */
/*                  3.0 04-Jun-2014   Rajvi Kadam                                   */ 
/*                  3.1 04-Jun-2014   Swati A.B																			*/ 
/*									3.2	10-Nov-2014		Tanmay Warkhade																*/ 
/*                  3.3 11-Dec-2014   Sachin Birje                                  */
/*                  3.5 05-Nov-2015   Samip M 																			*/
/*                  3.6 15-Jan-2016   Kishor B 																			*/
/*                  3.7 04-Dec-2015   Tanmay W                                      */
/*                  3.8 29-Jun-2016   Samip M																				*/
/*                  3.9 29-Jun-2016   Samip M																				*/
/*                  4.0 10-May-2017   Samip M																				*/
/*                  4.1 05-Mar-2019   Tanmay Patel                                  */
/*                  4.2 23-Oct-2019   Tanmay Patel                                  */
/*                  4.3 31-Aug-2020   Anand Dhopte                                  */
/*                  4.4 01-Jul-2020   Samip M																				*/
/*                  4.5 15-Sep-2020   Tanmay Patel                                  */
/*                  4.6 19-Sep-2020   Tanmay Patel                                  */
/*									4.7 10-Oct-2020 	Shlok Ghan	                                  */ 
/*                  4.8 17-Feb-2021   Anand Dhopte                                  */
/*                  4.9 13-Dec-2022   Tanmay Patel                                  */
/*                  5.0 06-Jan-2023   Samip M                                       */
/*                  5.1 09-Feb-2023   Samip M                                       */
/*                  5.2 17-May-2023   Karthik Sujit                                 */
/************************************************************************************/
/*	1.0		-		New Release																														*/
/*	1.1		-   In case a customer has never allocated money in F&O, there would			*/
/*						be no entry in FAB_FO_ALC_BFT_SMRY table and while trying to pledge		*/
/*						the update will fail with NO_DATA_FOUND.															*/
/*						To rectify this in case of no data found during pledge, a record is		*/
/*						inserted in FAB table with amounts as zero and bank account from CLB	*/
/*						table.																																*/
/*	1.2		-		Changes done to implement Force withdrwal. In case of call from 			*/
/*						force withdrwal program, various validations of withdrawal have to be */
/*						bypassed. 																														*/
/*  1.3   -   To Populate the new coulmn POD_PRCSD_QTY with 0 while inserting into  */
/*            POD_PLG_ORDR_DTLS for Placing Pledge, Withdraw and Invoke             */ 
/*  1.4   -   Return error in cases for handling for BULK pledge only							  */
/*  1.5   -   PAN DEMAT suspension CR - 1698 																				*/
/*  1.6   -   Set null for order number                                             */
/*	1.7		-		DL Revamp																															*/
/*  1.8   -   IBM Changes                                                           */
/*	1.9		-		In case there is any pending wihdrawal or invocation request in				*/
/*						POD_PLG_ORDR_DTLS in 'I'status, don't allow placement of 							*/
/*	 					another withdrawal or invocation for the same set of match account    */
/*					  and stock code. CR No.- CRARP10522																		*/ 						  
/*  2.2   -   In addition to Ver 1.2 checks another check on plg_allwd status of    */
/*  2.5   -   EQ SAM Changes  - diwakar                                             */
/*  2.6   -   Bug Fix - Swati A.B                                                   */
/*  2.7   -   Message changes and FNO BSE limit     (DS)                            */
/*  2.8		-		Source flag for New DL .NET																						*/
/*  2.9   -   Change in Error Code                                                  */
/*	3.0   -   Changes for Easy Margin BSE (Rajvi)																		*/
/*	3.1   -   FNO Common TNC Changes (Swati A.B)																		*/
/*	3.2		-		SAM Block/Unblock changes																							*/
/*  3.3   -   View to FML Changes                                                   */
/*  3.5   -   Core fix																															*/
/*  3.6   -   Core fix																															*/
/*  3.7   -   Check for PLEDGE_REVELATION                                           */
/*  3.8   -   Check Session IP Common Function																			*/
/*  3.9   -   Query optimization																										*/
/*  4.0   -   No data handle																												*/
/*  4.1   -   Applying Different SAM Haircut % for different Stocks                 */
/*  4.2   -   Ipv6 Format                                                           */ 
/*  4.3   -   CR-ISEC04-141575 - Margin Pledge Migration plan related requirement   */
/*  4.4   -   CR-ISEC14-138293 Margin Pledge Changes																*/
/*  4.5   -   CR-ISEC04-142511                                                      */
/*  4.6   -   CR-ISEC04-142904-SAM withdrawal & invocation order clubbing           */
/*	4.7   -		CR-ISEC14-144001 : Segment Preference for Allocating Securities limit */
/*  4.8   -   Library function call introduced to get channel                       */
/*  4.9   -   Currency SAM */
/*  5.0   -   System/Customer Spot Invocation                                       */
/*  5.1   -   Prev SAM                                                              */
/*  5.2   -   Disallow Currency and Commodity Alloc                                 */
/************************************************************************************/

#include <stdio.h>      /* C Header File                */
#include <stdlib.h>     /* C Header File                */
#include <sqlca.h>      /* Oracle header file           */
#include <atmi.h>       /* TUXEDO Header File           */
#include <userlog.h>    /* TUXEDO Header File           */
#include <fml32.h>      /* TUXEDO Header File           */
#include <Usysflds.h>   /* TUXEDO Field Definitions  */

/* User defined h files */

#include <fml_def.h>    /* created for FML handling */
#include <fo.h>
#include <fo_fml_def.h>

/*** #include <fo_view_def.h> ** Ver 3.3 **/
#include <fo_view_def.h>  /** Ver 3.3 **/
#include <fn_pos.h>

#include <fn_log.h>
#include <fn_session.h>
#include <fn_tuxlib.h>
#include <fn_ddr.h>
#include <string.h> /* Ver 1.8 */
#include <fn_read_debug_lvl.h> /* Ver 1.8 */
#include <fn_eqsam.h> /* Ver 2.5 */
#include <fn_val_ord.h>		/** Ver 3.8 **/
#include <fn_cod_pos.h>   /** Ver 4.9 **/

EXEC SQL INCLUDE "table/pps_plg_pstn.h";
EXEC SQL INCLUDE "table/pod_plg_ordr_dtls.h";
EXEC SQL INCLUDE "table/dbd_dp_blck_dtls.h";
EXEC SQL INCLUDE "table/clm_clnt_mstr.h";
EXEC SQL INCLUDE "table/ppp_par_plg_prmtr.h";
EXEC SQL INCLUDE "table/stk_stk_mstr.h";
EXEC SQL INCLUDE "table/ltq_trd_qt.h";
EXEC SQL INCLUDE "table/pml_plg_mod_log.h";
EXEC SQL INCLUDE "table/fab_fo_alc_bft_smry.h";
EXEC SQL INCLUDE "table/eab_eq_alc_bft_smry.h";

int Z;
#define INIT(x,y)  for(Z=0; Z< y; Z++) x[Z] =0
#define TOTAL_FML 12    /** Changed from 10 to 11 for Ver 4.4 **//** 12 for Ver 5.0 **/
/** #define MEMSET(A) memset(A.arr,0,sizeof(A.arr));		** Ver 1.7: Commented	***/
#define  BUF_MULTIPLY 1
#define PLG_PLC_REQ 225

#define MIN(x,y)  ( (x < y) ? x : y ); /* Ver 2.5 **/
#define MAX(x,y)  ( (x > y) ? x : y ); /* Ver 2.5 **/

int fn_get_em_ord_dtls(char *c_mtch_accnt,char *c_xchng_cd,long l_crnnt_settlement,
                        char *c_stck_cd,char *c_em_trd_exists);   /* Ver 2.0 */

/** Ver 4.9 **/
int fn_cdx_get_trd_limit(char *c_ServiceName,
                     char *c_mtch_id,
                     char *c_trd_dt,
                     char *c_xchng_cd,
                     long l_grp_id,
                     double *d_trd_limit,
                     char *c_err_msg
                    );
/** Ver 4.9 **/

int fn_mrgplg_sms_mail ( char *c_ServiceName,
                         char *c_clm_mtch_accnt,
                         long l_psn_no,
                         int  i_msg_code );

void SFO_PLC_PLG( TPSVCINFO *rqst)
{
	FBFR32 *ptr_fml_Ibuf;
	FBFR32 *ptr_fml_Obuf;
	FBFR32 *ptr_fml_Ibuf1;		/** Ver 3.2 **/
	FBFR32 *ptr_fml_Obuf1;		/** Ver 3.2 **/
	FBFR32 *ptr_fml_temp;    /** 2.3 **/

	struct vw_usr_prfl st_usr_prfl;
  struct vw_err_msg st_err_msg;
	struct vw_gt_lmt_dtls st_gt_lmt;

	int i,j;
  int i_count = 0 ;           /** Ver 3.7 **/
	char c_ServiceName[33];
	char c_narration[255+1];		/* Ver 2.5 */
	int i_err[TOTAL_FML];
	int   i_trnsctn = 0;
	int   i_rowcount = 0;
	int   i_level_exists = 0;	
	int   i_returncode = 0;	
	long l_pod_ordr_qty = 0; /** Ver 1.9 **/
	long l_conf_qty = 0; /** Ver 1.9 **/	
	int i_order_exists = 0; /** Ver 1.9 **/
	int i_inorder_exists = 0; /** Ver 1.9 **/
  int i_ptd_count =0;       /** Ver 4.4 **/
  int i_new_ptd_count =0;   /** Ver 4.4 **/

	char c_err_msg[256];
	char c_null_msg [ 18 ];
	varchar v_out_msg[360];		/** Ver 4.4 **/
	char c_cov_plc_flg;
	char c_pan_exist_flag = 'N';  /* 1.5 Ver */
	long l_pan_exists; /* 1.5 Ver */
	char c_dp_id[9];
  char c_dp_clnt_id[9];
	long l_ip_len  = 0;
	int i_pod_cnt = 0 ;
	char c_force_flag = 'N'; /*1.2 Force Withdrawal flag*/
	char c_bkubk_flg;			/*** Ver 3.2 ***/
	char c_trd_psswd[LEN_USR_TRDNG_PSSWRD];		/** Ver 3.8 **/
	char c_trd_psswd_flg = 'N';								/** Ver 3.8 **/
	char c_txn_flg='Y';												/** Ver 3.8 **/
	char c_ip_address[45+1]; /** Changed from 15 to 45 in Ver 4.2 **/	/** Ver 3.8 **/

	char c_em_trd_exists = 'N'; 	/* 2.0.Easy Margin Changes */
	long l_crrnt_sttlmnt = 0; 		/* 2.0.Easy Margin Changes */

	int i_counter;	  						/** 2.3 **/
	int i_plg_ord_cnt = 0;				/** Ver 4.4 **/
	char c_req_conf_flg = 'R';		/* Ver 4.4 **/
	int i_cutoff_exist = 0;				/* Ver 4.4 **/
	/** char c_ordr_rfrnc[19];				** Ver 4.4 **/
	char v_plg_day[4];						/** Ver 4.4 **/

	/** Ver 2.5 EQSAM ****/

	double d_eq_sam_limit	=0.0;
	double d_free_sam_limit=0.0;
	/***** V2.5 ends *****/

	/** Ver 2.7 **/
	double d_nfo_limit=0.0;
	double d_bfo_limit=0.0;
	double d_net_fno_limit=0.0;
	/** V2.7 ends **/

  /** Ver 4.9 **/

  double d_cab_cdx_plg_amt =0.0;
  double d_cab_cod_plg_amt =0.0;
  double d_cdx_limit = 0.0; 
  double d_mco_limit = 0.0;
  double d_fno_min_limit = 0.0; 
  double d_cdx_min_limit = 0.0;
  double d_cod_min_limit = 0.0;
  /** Ver 4.9 **/ 

	EXEC SQL BEGIN DECLARE SECTION;
	varchar sql_usr_id[10];
	varchar sql_mtch_accnt[11];
	long sql_sssn_id;
	varchar pod_ordr_seq[16];
	varchar sql_alias[10];
	char sql_oprn_typ;
	long sql_qty_plg = 0;
	long sql_tot_pod_ordr_qty = 0;
	long sql_pps_seq = 0;
	long sql_prs_seq = 0 ;
	long li_tot_blck_qty = 0;
/**	long l_acnt_id = 0;		*** Ver 1.7 : Commented ***/
	double sql_stck_plg_val = 0.0;
	long long ll_stck_plg_val = 0;
	varchar sql_nxt_trd_dt[13];
	char c_usr_fno_accpt_flg = '\0' ;   /*** Ver 3.1 ***/
	varchar vc_exec_dt[12];
	long l_plg_prcs_qty = 0;		/** Ver 4.4 **/
	char sql_req_typ ='\0';   /* ver 4.7 */
  char c_sup_usr_typ = '\0'; /*** Ver 4.8 ***/

	EXEC SQL END DECLARE SECTION;	

	/****************************2.3  Calculate Buffer Length **************************/

  const long l_bufferlength =  (  sizeof(c_null_msg) )
                            + (  sizeof(sql_stk_stck_cd) )
                            + (  sizeof(sql_stck_plg_val))
                            + (  sizeof(sql_pod_ordr_no))
                            + (  sizeof(sql_stk_plg_haircut))
														+  200;


	ptr_fml_Ibuf = (FBFR32 *)rqst->data;
	ptr_fml_Obuf = (FBFR32 *)NULL;
  ptr_fml_Ibuf1 = (FBFR32 *)NULL;	/** Ver 3.2 **/
  ptr_fml_Obuf1 = (FBFR32 *)NULL; /** Ver 3.2 **/
	ptr_fml_temp = (FBFR32 *)NULL;   /** 2.3**/

	strcpy( c_ServiceName, rqst->name );
	INITDBGLVL(c_ServiceName);
	
	INIT(i_err,TOTAL_FML);
  memset(c_dp_id,0,sizeof(c_dp_id));
	memset(c_dp_clnt_id,0,sizeof(c_dp_clnt_id));

  MEMSET(st_usr_prfl);          /** Ver 3.8 **/
  MEMSET(st_err_msg);           /** Ver 3.8 **/

	strcpy(c_null_msg,"\0");
	i_err[0] = Fget32(ptr_fml_Ibuf,FFO_USR_ID,0,(char *)sql_usr_id.arr,0);
	i_err[1] = Fget32(ptr_fml_Ibuf,FFO_EBA_MTCH_ACT_NO,0,(char *)sql_mtch_accnt.arr,0);
	i_err[2] = Fget32(ptr_fml_Ibuf,FFO_SSSN_ID,0,(char *)&sql_sssn_id,0);
	i_err[3] = Fget32(ptr_fml_Ibuf,FFO_OPT_TYP,0,(char *)&sql_oprn_typ,0);
	i_err[4] = Fget32(ptr_fml_Ibuf,FFO_CHANNEL,0,(char *)sql_pml_channel.arr,0);
	i_err[5] = Fget32(ptr_fml_Ibuf,FFO_DPID,0,(char *)c_dp_id,0);
  i_err[6] = Fget32(ptr_fml_Ibuf,FFO_DP_CLNT_ID,0,(char *)c_dp_clnt_id,0);

	for( i=0; i <7; i++ )
	{
		if(i_err[i] == -1)
		{
			fn_errlog( c_ServiceName, "S31005", FMLMSG, c_err_msg  );
			fn_userlog(c_ServiceName, "The Fget32 error at [%d]",i);
/**		l_acnt_id = -1;
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			**	Ver 1.7: Commented	***/
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
	} 

	/*** Error Handling Ver 4.7 ***/

  i_err[0] = Fget32(ptr_fml_Ibuf,FFO_PRDCT_TYP,0,(char *)&sql_req_typ,0); /* ver 4.7 */

  if((i_err[0] == -1) && (Ferror32 != FNOTPRES))
  {
    fn_errlog( c_ServiceName, "S31010", FMLMSG, c_err_msg  );
  /**  l_acnt_id = -1;
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );  **/
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  if ( (i_err[0] == -1) && (Ferror32 == FNOTPRES) )
  {
    fn_userlog(c_ServiceName,"Request flag not found.");
	  sql_req_typ = 'N';
  }

	/** Ver 5.2 starts **/
	if (sql_req_typ == 'C' || sql_req_typ == 'X')
	{
    fn_errlog(c_ServiceName, "S31015", "Currently this facility is not enabled.", c_err_msg);
		strcpy(c_err_msg, "Currently this facility is not enabled.");
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    tpreturn(TPFAIL, 0L, (char *)ptr_fml_Ibuf, 0, 0 );
	}
	/** Ver 5.2 ends **/

	/*** End of Ver 4.7 ***/ 
	SETLEN(sql_usr_id);
	SETLEN(sql_mtch_accnt);
	SETLEN(sql_pml_channel);

  /************************ VER 1.7 ADDITION START  **************************/

  /***   Commented in Ver 4.8 **************************

  if ( strcmp( sql_pml_channel.arr, "1" ) == 0 )
  {
    strcpy( (char *)sql_pml_channel.arr, "APP" );
  }
  else if ( strcmp( sql_pml_channel.arr, "2" ) == 0 )
  {
    strcpy( (char *)sql_pml_channel.arr, "VSA" );
  }

	*** Ver 2.8 ** Starts ***

	else if ( strcmp( sql_pml_channel.arr, "Y" ) == 0 )    *** For New Trade Racer ***
	{
		strcpy( (char *)sql_pml_channel.arr, "NET" );
	}
	else if ( strcmp( sql_pml_channel.arr, "Z" ) == 0 )		 *** For New Trade Racer by super user ***
	{
		strcpy( (char *)sql_pml_channel.arr, "CN2" );
	}

	*** Ver 2.8 ** Ends ***


  *** Ver 4.8 Comment Ends *************************/
  
  /*** Ver 4.8 Starts ***/

  if(DEBUG_MSG_LVL_3){
    fn_userlog(c_ServiceName, "The Channel from input is [%s]",sql_pml_channel.arr);
  }

  if( strcmp(sql_pml_channel.arr,"SYS") != 0 ) /*** if user is not system ***/
  {
   EXEC SQL
		 SELECT NVL(USM_SUP_USR_TYP,'*')
			 INTO :c_sup_usr_typ
			 FROM USM_SSSN_MNGR
		  WHERE USM_USR_ID = :sql_usr_id
        AND USM_SSSN_ID = :sql_sssn_id  ;
 
     if ( SQLCODE != 0 )
     {
        fn_errlog( c_ServiceName, "S31020", SQLMSG, c_err_msg  );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     }

     fn_userlog(c_ServiceName, "Super User Type is :%c:",c_sup_usr_typ);
    
     fn_get_channel(c_sup_usr_typ, sql_pml_channel.arr);
  }

  /*** Ver 4.8 Ends ***/ 

  SETLEN(sql_pml_channel);

  if(DEBUG_MSG_LVL_3){
    fn_userlog(c_ServiceName, "The Channel after fn call is [%s]",sql_pml_channel.arr);
	}

  /************************ VER 1.7 ADDITION ENDS   **************************/

	/**************************** Check Session of User ****************************/

	if(DEBUG_MSG_LVL_4){
  	fn_userlog( c_ServiceName, "Checking Session ");
	}

  strcpy( st_usr_prfl.c_user_id, sql_usr_id.arr );
  st_usr_prfl.l_session_id = sql_sssn_id;
  strcpy( st_usr_prfl.c_cln_mtch_accnt,sql_mtch_accnt.arr);

  fn_cpy_ddr ( st_usr_prfl.c_rout_crt );       /*** Added for Order Routing ***/

	/*** Commented for Ver 3.8 ***
  i_returncode = fn_chk_sssn( c_ServiceName, &st_usr_prfl, &st_err_msg );
	*** Ver 3.8 ***/

	/*** Added for Ver 3.8 ***/
	i_returncode = fn_check_user_ip ( c_ServiceName,
																		&st_usr_prfl ,
																		c_trd_psswd,
																		c_trd_psswd_flg,
																		c_ip_address,
																		c_txn_flg,
																		&st_err_msg );
	/**** Ver 3.8 ***/

  if ( i_returncode == -1 )
  {
  	fn_errlog( c_ServiceName,"S31025",LIBMSG , st_err_msg.c_err_msg  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg,0);
/** l_acnt_id = -1;
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
    tpreturn(TPFAIL, 0L, (char *)ptr_fml_Ibuf, 0, 0 );
  }

	if(DEBUG_MSG_LVL_4){
  	fn_userlog( c_ServiceName, "Checking Session DONE ");
	}

	/*** tpfree ( ( char * )ptr_fml_Obuf); *** Commented for Ver 3.5 ***/
  ptr_fml_Obuf = (FBFR32 *)tpalloc( "FML32", NULL, MIN_FML_BUF_LEN * BUF_MULTIPLY );

	if ( ptr_fml_Obuf == NULL )   /****** Ver. 1.7 : Error Condition Check Added  *********/
  {
    fn_errlog( c_ServiceName, "S31030", TPMSG, c_err_msg  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/** l_acnt_id = -1;
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

	/*** Added for Ver 3.2 **/
  /*** tpfree ( ( char * )ptr_fml_Ibuf1); *** Commented for Ver 3.5 ***/
  ptr_fml_Ibuf1 = (FBFR32 *)tpalloc( "FML32", NULL, MIN_FML_BUF_LEN * BUF_MULTIPLY );

  if ( ptr_fml_Ibuf1 == NULL )
  {
    fn_errlog( c_ServiceName, "S31035", TPMSG, c_err_msg  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
		tpfree ( ( char * )ptr_fml_Obuf);		/** 3.6 **/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  /*** tpfree ( ( char * )ptr_fml_Obuf1); *** Commented for Ver 3.5 ***/
  ptr_fml_Obuf1 = (FBFR32 *)tpalloc( "FML32", NULL, MIN_FML_BUF_LEN * BUF_MULTIPLY );

  if ( ptr_fml_Obuf1 == NULL )
  {
    fn_errlog( c_ServiceName, "S31040", TPMSG, c_err_msg  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
		tpfree ( ( char * )ptr_fml_Obuf);   /** 3.6 **/
		tpfree ( ( char * )ptr_fml_Ibuf1);	/** 3.6 **/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

	/*** Ver 3.2 **/

	if(DEBUG_MSG_LVL_3){
		fn_userlog(c_ServiceName, "The value of oprn type is [%c]",sql_oprn_typ);
	}

	/*** Ver 3.1 starts here ****/
   if( sql_usr_id.arr[0] != BPID && ( strcmp(sql_usr_id.arr,"system") != 0 ))
   {
		 SETLEN(sql_usr_id);
		 fn_userlog(c_ServiceName,"sql_usr_id :%s:",sql_usr_id.arr);

		 c_usr_fno_accpt_flg='\0';

		 EXEC SQL
		 SELECT  USR_FNO_ACCPT_FLG
			 INTO  :c_usr_fno_accpt_flg
			 FROM  USR_USER_MASTER
			 WHERE  USR_USR_ID  = :sql_usr_id;

		 if ( SQLCODE != 0 )
		 {
				fn_errlog( c_ServiceName, "S31045", TPMSG, c_err_msg  );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			  tpfree ( ( char * )ptr_fml_Obuf);   /** 3.6 **/
      	tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      	tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		 }

		 fn_userlog(c_ServiceName," c_usr_fno_accpt_flg :%c:",c_usr_fno_accpt_flg);

		 if( c_usr_fno_accpt_flg != 'Y' )
		 {
				fn_errlog( c_ServiceName, "B31017",DEFMSG,c_err_msg);
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			  tpfree ( ( char * )ptr_fml_Obuf);   /** 3.6 **/
      	tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      	tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		 }
    }

    /*** Ver 3.1 Ends Here ****/

	if(sql_usr_id.arr[0] == BPID)
  {
		MEMSET(sql_alias);
    if((Fget32(ptr_fml_Ibuf,FFO_ALIAS,0,(char *)sql_alias.arr,0)) == -1)
    {
      fn_errlog( c_ServiceName, "S31050", FMLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**   l_acnt_id = -1;
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
      tpfree ( ( char * )ptr_fml_Obuf);
      tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
		SETLEN(sql_alias);

    i_level_exists = 0;

    EXEC SQL
    SELECT 1
    INTO   :i_level_exists
    FROM   clm_clnt_mstr
    WHERE  clm_mtch_accnt = :sql_mtch_accnt
    AND    clm_bp_id      = :sql_usr_id
    AND    clm_alias_name = :sql_alias;

   if(( SQLCODE !=0 ) && (SQLCODE != NO_DATA_FOUND))
    {
      fn_errlog( c_ServiceName, "S31055", SQLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**   l_acnt_id = -1;
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			**  Ver 1.7: Commented  ***/
      tpfree ( ( char * )ptr_fml_Obuf);
      tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

		if(SQLCODE == NO_DATA_FOUND)
		{
     	strcpy((char *)c_err_msg,"Nick Name is incorrect"); 
			fn_userlog(c_ServiceName,"%s",c_err_msg);
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**   l_acnt_id = -1;
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
      tpfree ( ( char * )ptr_fml_Obuf);
      tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

		if(DEBUG_MSG_LVL_3){
    	fn_userlog(c_ServiceName,"BP alias  is [%s]",sql_alias.arr);
    	fn_userlog(c_ServiceName,"BP channel  is [%s]",sql_pml_channel.arr);
		}

    if(i_level_exists != 1 )
    {
      fn_errlog( c_ServiceName, "B55006", "", c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**		l_acnt_id = -1;
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
      tpfree ( ( char * )ptr_fml_Obuf);
      tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
    strcpy(sql_pod_bp_id.arr,sql_usr_id.arr);
    SETLEN(sql_pod_bp_id);
  }
  else
  {
    strcpy(sql_pod_bp_id.arr,"*");
    SETLEN(sql_pod_bp_id);
  }


	sql_ppp_min_dep_amt =  0;

/*The parameter master table contains system wide parameters and this table should be a single row table.*/
/*PPP_PLG_OPNCLS_FLG if 'N' means Pledging is not allowed*/
/*PPP_MIN_DEP_AMT contains the minimum amount for the value to be pledged*/

	EXEC SQL 
	SELECT 
	PPP_PLG_OPNCLS_FLG, 
	PPP_MIN_DEP_AMT 
	INTO 
	:sql_ppp_plg_opncls_flg,
	:sql_ppp_min_dep_amt
	FROM PPP_PAR_PLG_PRMTR;

	if( SQLCODE !=0 )
	{
 		fn_errlog( c_ServiceName, "S31060", SQLMSG, c_err_msg  );
		fn_userlog(c_ServiceName, "The value flag is [%c]",sql_ppp_plg_opncls_flg);
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**	l_acnt_id = -1;
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
		tpfree ( ( char * )ptr_fml_Obuf);
    tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
    tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}

	if(DEBUG_MSG_LVL_3){
		fn_userlog(c_ServiceName, "The pledge allwd flag is [%c]",sql_ppp_plg_opncls_flg);
	}

	/* Ver 1.5 STARTS */

	l_pan_exists = 0;

	EXEC SQL
	SELECT 1
	INTO :l_pan_exists
	FROM PAR_SYSTM_PRMTR 
	WHERE trunc(sysdate) >= PAR_PAN_DT;

	if(SQLCODE !=0 )
	{
  	fn_errlog( c_ServiceName, "S31065", SQLMSG, c_err_msg  );
  	fn_userlog(c_ServiceName, "The PAN validation begin date could not be obtained");
  	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**	l_acnt_id = -1;
  	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			**  Ver 1.7: Commented  ***/
  	tpfree ( ( char * )ptr_fml_Obuf);
		tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
		tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
  	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}

	if(DEBUG_MSG_LVL_3){
		fn_userlog(c_ServiceName,"DP ID is :%s:",c_dp_id);
		fn_userlog(c_ServiceName,"DP CLIENT ID is :%s:",c_dp_clnt_id);
		fn_userlog(c_ServiceName,"Match ID is :%s:",sql_mtch_accnt.arr);
	}

	if(l_pan_exists == 1)
	{
			EXEC SQL 
			SELECT NVL(CLD_PAN_EXIST_FLAG,'N')
  		INTO :c_pan_exist_flag
  		FROM CLD_DP_ACCTS
  		WHERE CLD_CLM_MTCH_ACCNT=:sql_mtch_accnt
  		AND   CLD_DP_ID=:c_dp_id
  		AND   CLD_DP_CLNT_ID=:c_dp_clnt_id;

			if(SQLCODE !=0 )
  		{
    		fn_errlog( c_ServiceName, "S31070", SQLMSG, c_err_msg  );
    		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**  		l_acnt_id = -1;
    		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			**  Ver 1.7: Commented  ***/
    		tpfree ( ( char * )ptr_fml_Obuf);
				tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
				tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
    		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  		}

			if(c_pan_exist_flag != 'Y')
			{
				fn_userlog(c_ServiceName, "Withdout PAN proof you cannot pledge/withdraw/invoke in Collateral");
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "Without PAN proof of all holders you cannot pledge/withdraw/invoke" , 0 );
			  fn_errlog( c_ServiceName, "B56021", "", c_err_msg  );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );	
/**  		l_acnt_id = -1;
    		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			**  Ver 1.7: Commented  ***/
    		tpfree ( ( char * )ptr_fml_Obuf);
				tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
				tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
    		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
	}

 	/* Ver 1.5 ENDS */

	if( sql_ppp_plg_opncls_flg == 'N')
	{
		/* Commented in ver 2.9 fn_userlog(c_ServiceName, "At present the facility of Shares as Margin has been suspended");
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "At present the facility of Shares as Margin has been suspended" , 0 ); */
    fn_userlog(c_ServiceName,"Please try later as shares as margin process is underway");   /* Ver 2.9*/	
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "Please try later as shares as margin process is underway", 0 ); /* Ver 2.9 */
/**	l_acnt_id = -1;
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			**  Ver 1.7: Commented  ***/
		tpfree ( ( char * )ptr_fml_Obuf);
		tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
		tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}

	EXEC SQL 
	SELECT nvl(CLM_PLG_ALLWD_FLG,'N') ,NVL(CLM_PLG_MODE,'P')	/** Ver 4.4 CLM_PLG_MODE added ***/
	INTO :sql_clm_plg_allwd_flg,:sql_clm_plg_mode
	FROM CLM_CLNT_MSTR 
	WHERE CLM_MTCH_ACCNT = :sql_mtch_accnt;

	if( SQLCODE !=0 && SQLCODE != NO_DATA_FOUND )
	{
		fn_errlog( c_ServiceName, "S31075", SQLMSG, c_err_msg  );
		fn_userlog(c_ServiceName, "The value for mtch [%s][%ld] is [%c]",sql_mtch_accnt.arr,sql_mtch_accnt.len,sql_clm_plg_allwd_flg);
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**	l_acnt_id = -1;
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			**  Ver 1.7: Commented  ***/
		tpfree ( ( char * )ptr_fml_Obuf);
		tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
		tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}
	
	if( SQLCODE == NO_DATA_FOUND)
	{
		fn_userlog(c_ServiceName, "Client does not exist");
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "Client does not exist",0 );
/**	l_acnt_id = -1;
		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );	
		tpfree ( ( char * )ptr_fml_Obuf);
		tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
		tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}

	if ( sql_clm_plg_allwd_flg == 'N' )
	{
		fn_userlog(c_ServiceName, "At present the facility of Shares as Margin has been suspended");
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "At present the facility of Shares as Margin has been suspended",0 );
/**	l_acnt_id = -1;
		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );	**  Ver 1.7: Commented  ***/
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
		tpfree ( ( char * )ptr_fml_Obuf);
		tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
		tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}

	/*** Added for Ver 4.4 ***/
	if ( sql_clm_plg_mode == 'B' && sql_oprn_typ == 'P')
	{
		fn_userlog(c_ServiceName, "You are under SAM Block Model. Kindly convert to Margin Pledge first.");
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "You are under SAM Block Model. Kindly convert to Margin Pledge first.",0 );
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
		tpfree ( ( char * )ptr_fml_Obuf);
		tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
		tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}
	/** End for Ver 4.4 **/

  /********* Added in Ver 3.7 ***************/

  EXEC SQL
  select count(*)
  INTO   :i_count
  FROM   SPP_STCK_PLG_PRCSNG
  WHERE  SPP_CLM_MTCH_ACCNT = :sql_mtch_accnt
  AND    SPP_PRCS_FLG in ('I','N');

  if( SQLCODE !=0 )
  {
      fn_errlog( c_ServiceName, "S31080", SQLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      tpfree ( ( char * )ptr_fml_Obuf);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
  if(i_count > 0 )
  {
    fn_userlog(c_ServiceName,"Please try later as shares as margin process is underway");
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "Please try later as shares as margin process is underway", 0
 );
    tpfree ( ( char * )ptr_fml_Obuf);
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  /********** Added in Ver 3.7 ***************/

	
	/* The old pledge amount is required for inserting in FAL (log) table*/
	EXEC SQL 
	SELECT 	FAB_PLG_AMT ,
					nvl(FAB_NWB_AMT,0)			/*V2.5*/
	INTO 	:sql_fab_plg_amt ,
				:sql_fab_nwb_amt					/*V2.5*/
	FROM FAB_FO_ALC_BFT_SMRY
	WHERE FAB_CLM_MTCH_ACCNT = :sql_mtch_accnt;
	
	if(( SQLCODE !=0 ) && (SQLCODE != NO_DATA_FOUND))/*Ver 1.7 NO_DATA_FOUND ignore added*/
  {
    fn_errlog( c_ServiceName, "S31085", SQLMSG, c_err_msg  );
/**	l_acnt_id = -1;
		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
		tpfree ( ( char * )ptr_fml_Obuf);
		tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
		tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
/*Ver 1.1 starts*/
/*NO_DATA_FOUND ingnored as in case of pledge new entry will be inserted
and there will never be lack of data in withdrawal or invoke*/

	if(SQLCODE == NO_DATA_FOUND)
	{
		sql_fab_plg_amt = 0;
		sql_fab_nwb_amt = 0;					/*V2.5*/
	}

/*Ver 1.1 ends*/

	if(DEBUG_MSG_LVL_3){
		fn_userlog(c_ServiceName, "The value of old plg is [%lf]",sql_fab_plg_amt);
	}

	MEMSET(vc_exec_dt);

	/** Added for Ver 4.4 **/

	if(sql_oprn_typ == 'P')
	{

		EXEC SQL
			SELECT COUNT(1) 
			INTO :i_cutoff_exist
			FROM PPP_PAR_PLG_PRMTR 
			WHERE NVL(PPP_CUT_OFF_TIME,24) <= TO_CHAR(SYSDATE,'HH24');

		if(SQLCODE != 0)
		{
			fn_errlog( c_ServiceName, "S31090", SQLMSG, c_err_msg  );
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    	tpfree ( ( char * )ptr_fml_Obuf);
			tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
			tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/	
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}

		MEMSET(v_plg_day);

		EXEC SQL
			SELECT TO_CHAR(SYSDATE,'DY')
			INTO :v_plg_day
			FROM DUAL;

		if(SQLCODE != 0)
		{
			fn_errlog( c_ServiceName, "S31095", SQLMSG, c_err_msg  );
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    	tpfree ( ( char * )ptr_fml_Obuf);
			tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
			tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/	
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}

		fn_userlog(c_ServiceName,"Value of v_plg_day :%s:",v_plg_day);

		if(strcmp(v_plg_day,"SAT") == 0 || strcmp(v_plg_day,"SUN") == 0)
		{
			i_cutoff_exist = 1;
		}

	}
	else
		i_cutoff_exist = 0;

	fn_userlog(c_ServiceName,"Value of i_cutoff_exist :%d:",i_cutoff_exist);

	if(i_cutoff_exist == 0)
	{

		EXEC SQL
			SELECT TO_CHAR(SYSDATE,'DD-Mon-YYYY')
			INTO	:vc_exec_dt
			FROM 	DUAL;
	
	}
	else
	{
		EXEC SQL
			SELECT TO_CHAR(MIN(SPD_TRD_FRM_DT),'DD-Mon-YYYY')
			INTO	:vc_exec_dt
			FROM SPD_STTLMNT_PRCS_DTLS 
			WHERE SPD_TRD_FRM_DT>TRUNC(SYSDATE) 
			AND SPD_XCHNG_CD='BSE';
	}

	if(SQLCODE != 0)
	{
		fn_errlog( c_ServiceName, "S31100", SQLMSG, c_err_msg  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    tpfree ( ( char * )ptr_fml_Obuf);
		tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
		tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/	
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}

	/** End for Ver 4.4 **/

	SETLEN(vc_exec_dt);
	SETNULL(vc_exec_dt);

	switch (sql_oprn_typ)
	{
		/* Pledging (Deposit of shares) */
		case 'P' :
		{	
				i_rowcount = Foccur32((FBFR32 *)ptr_fml_Ibuf,FFO_STCK_CD);

				if(DEBUG_MSG_LVL_3){
					fn_userlog(c_ServiceName, "The number of records to be pledged is [%d]",i_rowcount);
				}

        EXEC SQL
        SELECT Count(1)
        into   :i_ptd_count
        FROM   PTD_TIFP_DTLS
        WHERE  ptd_leg_no = 'L1'
        AND    ptd_tifp_stts = 'P'
        AND    PTD_PLG_REV_TYP = 'P'
        AND    PTD_CLM_MTCH_ACCNT = :sql_mtch_accnt
        AND    trunc(ptd_tifp_run_dt) = trunc(sysdate);

        if(SQLCODE != 0)
        {
           fn_errlog( c_ServiceName, "S31105", SQLMSG, c_err_msg  );
           Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
           tpfree ( ( char * )ptr_fml_Obuf);
           tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
           tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
           tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }

				for(i=0;i < i_rowcount; i++)
				{
					/*** Added for Ver 3.2 ****/
					Finit32(ptr_fml_Ibuf1,(FLDLEN32) Fsizeof32(ptr_fml_Ibuf1));
					Finit32(ptr_fml_Obuf1,(FLDLEN32) Fsizeof32(ptr_fml_Obuf1));
					/*** Ver 3.2 **/

					memset(sql_stk_stck_cd,'\0',sizeof(sql_stk_stck_cd));
					i_err[5] = Fget32(ptr_fml_Ibuf,FFO_DPID,i,(char *)sql_dbd_dp_id,0);
  				i_err[6] = Fget32(ptr_fml_Ibuf,FFO_DP_CLNT_ID,i,(char *)sql_dbd_dp_clnt_id,0);
					i_err[7] = Fget32(ptr_fml_Ibuf,FFO_STCK_CD,i,(char *)sql_stk_stck_cd,0);
					i_err[8] = Fget32(ptr_fml_Ibuf,FFO_ORD_TOT_QTY,i,(char *)&sql_qty_plg,0);
				
					for(j = 5;j < 9; j++)
					{
						if(i_err[j] == -1 )
						{
							fn_errlog( c_ServiceName, "S31110", FMLMSG, c_err_msg  );
							fn_userlog(c_ServiceName, "The Fget32 error  at [%d]",j);
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
							tpfree ( ( char * )ptr_fml_Obuf);
							tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
							tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}
					}
					
					SETLEN(sql_usr_id);
					SETLEN(sql_mtch_accnt);
					
					sql_stk_stck_cd[strlen(sql_stk_stck_cd)+1]='\0';	
					
			
					if(DEBUG_MSG_LVL_3){
					fn_userlog(c_ServiceName,"The value is FFO_DPID is [%s][%ld]",sql_dbd_dp_id,sizeof(sql_dbd_dp_id));
					fn_userlog(c_ServiceName,"The value is FFO_DP_CLNT_ID  is [%s][%ld]",sql_dbd_dp_clnt_id,sizeof(sql_dbd_dp_clnt_id));
					fn_userlog(c_ServiceName,"The value is FFO_STCK_CD is [%s][%ld]",sql_stk_stck_cd,strlen(sql_stk_stck_cd));
					fn_userlog(c_ServiceName,"The value is FFO_ORD_TOT_QTY is [%ld]",sql_qty_plg);
					}	

					/*** Added for Ver 4.4 ***/
					EXEC SQL
						SELECT NVL(DBD_PLG_MODE,'P')
						INTO :sql_dbd_plg_mode
						FROM dbd_dp_blck_dtls
						WHERE	DBD_CLM_MTCH_ACCNT = :sql_mtch_accnt
						AND DBD_DP_ID = :sql_dbd_dp_id
						AND DBD_DP_CLNT_ID = :sql_dbd_dp_clnt_id
						AND DBD_STCK_CD = :sql_stk_stck_cd;

					if(SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31115", SQLMSG, c_err_msg  );
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
            tpfree ( ( char * )ptr_fml_Obuf);
						tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
						tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/	
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

					if(sql_dbd_plg_mode == 'B')
					{
						fn_errlog( c_ServiceName, "S31120", SQLMSG, c_err_msg  );
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "Stock is under SAM Block Model. Kindly convert to Margin First.", 0 );
            tpfree ( ( char * )ptr_fml_Obuf);
						tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
						tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/	
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
					
					/********Ver 2.0.EM Check ******/
					/****** Select current settlement ******/
  				EXEC  SQL
        				SELECT  SPD_STTLMNT_NMBR
        				INTO    :l_crrnt_sttlmnt
        				FROM    SPD_STTLMNT_PRCS_DTLS,EXG_XCHNG_MSTR
        				WHERE   SPD_TRD_TO_DT = EXG_NXT_TRD_DT
        				AND     SPD_XCHNG_CD  = EXG_XCHNG_CD
        				AND     SPD_XCHNG_CD  = 'NSE'
        				AND     ROWNUM=1;
						if(SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31125", SQLMSG, c_err_msg  );
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              tpfree ( ( char * )ptr_fml_Obuf);
							tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
							tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/	
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}
				  c_em_trd_exists = 'N';
					/*** Commented in Ver. 3.0 ***			
					if(fn_get_em_ord_dtls(sql_mtch_accnt.arr,
																"NSE",
																l_crrnt_sttlmnt,
                        				sql_stk_stck_cd,
																&c_em_trd_exists) == -1)	
					{
						fn_userlog(c_ServiceName,"Error calling fn_get_em_ord_dtls");
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
            tpfree ( ( char * )ptr_fml_Obuf);
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
					if(c_em_trd_exists == 'Y')
					{
						MEMSET(c_null_msg);
						fn_userlog(c_ServiceName,"EM trade exists for stock |%s|",sql_stk_stck_cd);
						strcpy(c_err_msg,"You have a Margin Position marked under 'Client square off' in this stock. Please block another security towards 'Shares as Margin'.");
						Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 );
						Fadd32( ptr_fml_Obuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
            Fadd32( ptr_fml_Obuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
						continue;
					}	
					****** Ver 2.0.EM check Ends *****
					********** Ver. 3.0 comment ends ******/	
	
					if (sql_ppp_plg_opncls_flg != 'Y' )
					{
						/* Commented in ver 2.9 fn_userlog(c_ServiceName, "At present depositing additonal shares as margin has been suspended"); */
						fn_userlog(c_ServiceName,"Please try blocking later as shares as margin process is underway"); /*Ver 2.9*/
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
						/* Commented in ver 2.9 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "At present depositing additonal shares as margin has been suspended" , 0 );*/
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "Please try blocking later as shares as margin process is underway" , 0 );/* Ver 2.9 */
						tpfree ( ( char * )ptr_fml_Obuf);
						tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
						tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );	
					}	

					if ( sql_clm_plg_allwd_flg == 'W')
					{
						fn_userlog(c_ServiceName, "At present blocking additional shares as margin has been suspended");
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			**  Ver 1.7: Commented  ***/
						Fadd32(ptr_fml_Ibuf, FFO_ERR_MSG,"At present blocking additional shares as margin has been suspended", 0 );
						tpfree ( ( char * )ptr_fml_Obuf);
						tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
						tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
					
					EXEC SQL 
					SELECT 
					nvl(STK_PLG_ALLWD,'N'),
					nvl(STK_PLG_CONC,0),
					nvl(STK_PLG_CLNT_CONC,0),
					/**nvl(STK_PLG_HAIRCUT,0), ** Commented V2.5*/
					nvl(STK_PLG_MIN_DPST,0)   
					INTO 
					:sql_stk_plg_allwd,
					:sql_stk_plg_conc,
					:sql_stk_plg_clnt_conc,
					/**:sql_stk_plg_haircut,  ** Commented V2.5*/
					:sql_stk_plg_min_dpst
					FROM STK_STK_MSTR 
					WHERE STK_STCK_CD = :sql_stk_stck_cd;	
				
					if( SQLCODE !=0 )
					{
						fn_errlog( c_ServiceName, "S31130", SQLMSG, c_err_msg  );
						fn_userlog(c_ServiceName, "For stck code : [%s][%ld]",sql_stk_stck_cd,sizeof(sql_stk_stck_cd));
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
						tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

					/** Ver 2.5 EQ SAM  Get haircut percentage  **/

					i_returncode = fn_get_haircut(c_ServiceName , 
																				sql_mtch_accnt.arr,
																				sql_stk_stck_cd,
																				&sql_stk_plg_haircut,
																				c_err_msg);

					if(i_returncode == -1)
					{
						fn_errlog( c_ServiceName, "S31135", SQLMSG, c_err_msg  );
            fn_userlog(c_ServiceName, "For stck code : [%s][%ld]",sql_stk_stck_cd,sizeof(sql_stk_stck_cd));
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
            tpfree ( ( char * )ptr_fml_Obuf);
						tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
						tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          }

					/** Ver 2.5 ends ***/

					/* 1.4 Starts */
    			i_err[0] = Fget32(ptr_fml_Ibuf,FML_PLG_FLG,0,(char *)&c_force_flag,0);

 					if((i_err[0] == -1) && (Ferror32 != FNOTPRES))
    			{
      			fn_errlog( c_ServiceName, "S31140", FMLMSG, c_err_msg  );
/**    			l_acnt_id = -1;
      			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
      			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
            tpfree ( ( char * )ptr_fml_Obuf);		/** 3.6 **/
						tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
						tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
      			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    			}
    			if(Ferror32 == FNOTPRES  && i_err[0] == -1)  /* Ver 4.3 */
    			{
      			c_force_flag = 'N';
    			}

					if(DEBUG_MSG_LVL_0){
						fn_userlog(c_ServiceName,"The Force flag is [%c]",c_force_flag);
					}
					/* 1.4 Ends */


					if((sql_stk_plg_haircut < 0 )||(sql_stk_plg_haircut > 100 ) )
					{
						sprintf((char *) c_err_msg, "Invalid Haircut value for stock code : [%s]",sql_stk_stck_cd);

						if(DEBUG_MSG_LVL_3){
							fn_userlog(c_ServiceName, "Invalid Haircut value for stock code : [%s]",sql_stk_stck_cd);
						}

						Fadd32( ptr_fml_Obuf,FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Obuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			**  Ver 1.7: Commented  ***/
						Fadd32( ptr_fml_Obuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
						Fadd32( ptr_fml_Obuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );

						/*  1.4 Starts */
						if(c_force_flag == 'B')
						{
							tpfree ( ( char * )ptr_fml_Obuf);
            	tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
            	tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}	
						/* 1.4 Ends */
						continue ;
					}

					if(DEBUG_MSG_LVL_3){
					fn_userlog(c_ServiceName,"The value is STK_PLG_ALLWD is [%c]",sql_stk_plg_allwd);
					fn_userlog(c_ServiceName,"The value is STK_PLG_CONC  is [%ld]",sql_stk_plg_conc);
					fn_userlog(c_ServiceName,"The value is STK_PLG_CLNT_CONC is [%ld]",sql_stk_plg_clnt_conc);
					fn_userlog(c_ServiceName,"The value is STK_PLG_HAIRCUT is [%ld]",sql_stk_plg_haircut);
					fn_userlog(c_ServiceName,"The value is STK_PLG_MIN_DPST is [%ld]",sql_stk_plg_min_dpst);
					}	

					if (sql_stk_plg_allwd == 'N' || sql_stk_plg_allwd == 'R' || sql_stk_plg_allwd == 'W')
					{
						if(sql_stk_plg_allwd == 'N')
						{
							if(DEBUG_MSG_LVL_3){
								fn_userlog(c_ServiceName, "At present the scrip has been disabled from the facility of Shares as Margin ");
							}

							strcpy(c_err_msg,"At present the scrip has been disabled from the facility of Shares as Margin");
							Fadd32( ptr_fml_Obuf,FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Obuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			**  Ver 1.7: Commented  ***/
							Fadd32( ptr_fml_Obuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
							Fadd32( ptr_fml_Obuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );

							/* 1.4 Starts */
							if(c_force_flag == 'B')
            	{
              	tpfree ( ( char * )ptr_fml_Obuf);
            		tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
            		tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
              	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            	}
							/* 1.4 Ends */
							continue ;
						}
						else
						if(sql_stk_plg_allwd =='R')
						{
							if(DEBUG_MSG_LVL_3){
								/** fn_userlog(c_ServiceName, "Cannot deposit as the scrip is under revaluation "); *** Commented for Ver 3.2 ***/
								fn_userlog(c_ServiceName, "Cannot block as the scrip is under revaluation ");
							}

							strcpy(c_err_msg,"Cannot block as the scrip is under revaluation");
							Fadd32( ptr_fml_Obuf,FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Obuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
							Fadd32( ptr_fml_Obuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
							Fadd32( ptr_fml_Obuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );

							/* 1.4 Starts */
							if(c_force_flag == 'B')
            	{
              	tpfree ( ( char * )ptr_fml_Obuf);
            		tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
            		tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/				
              	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            	}
							/* 1.4 Ends */
							continue ;
						}
						else
						{
							if(DEBUG_MSG_LVL_3){
								fn_userlog(c_ServiceName, "At present blocking additional shares of the scrip has been suspended ");
							}

							strcpy(c_err_msg,"At present blocking additional shares of the scrip has been suspended");
							Fadd32( ptr_fml_Obuf,FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Obuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
							Fadd32( ptr_fml_Obuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
							Fadd32( ptr_fml_Obuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );

							/* 1.4 Starts */
							if(c_force_flag == 'B')
            	{
              	tpfree ( ( char * )ptr_fml_Obuf);
            		tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
            		tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
              	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            	}
							/* 1.4 Ends */
							continue ;
						}
					}

					if(sql_stk_plg_min_dpst > sql_qty_plg)
					{
						if(DEBUG_MSG_LVL_3){
							fn_userlog( c_ServiceName, "The quantity requested is less than the minimum required");
						}

						/**strcpy(c_err_msg,"The quantity requested is less than the minimum required"); ** Ver 2.5 **/
						strcpy(c_err_msg,"Please enter quantity more than the minimum acceptable quantity."); /** Ver 2.5**/
						Fadd32( ptr_fml_Obuf,FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Obuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
						Fadd32( ptr_fml_Obuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
						Fadd32( ptr_fml_Obuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );

						/* 1.4 Starts */
						if(c_force_flag == 'B')
            {
              tpfree ( ( char * )ptr_fml_Obuf);
            	tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
            	tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }
						/* 1.4 Ends */
						continue ;
					}	

					EXEC SQL 
					/** SELECT (SUM(nvl(DBD_PLG_REQ_QTY,0))+ SUM(nvl(DBD_TIFP_QTY,0)))  *** Commented and changed for Ver 3.2 ***/
					/** SELECT (SUM(nvl(DBD_SAM_BLCKD_QTY,0)))  ** Commented for Ver 4.0 **/
					SELECT nvl(SUM(DBD_SAM_BLCKD_QTY) + SUM(DBD_PLG_REQ_QTY),0) /** Modified for Ver 4.0 **//** Added for Ver 4.4 Req Qty */
					INTO :sql_tot_pod_ordr_qty
					FROM DBD_DP_BLCK_DTLS
					WHERE DBD_STCK_CD = :sql_stk_stck_cd
					AND		DBD_SAM_BLCKD_QTY > 0;			/** Added for Ver 3.9 **/
					
					if(SQLCODE !=0 	&& SQLCODE != NO_DATA_FOUND) 
					{
						fn_errlog( c_ServiceName, "S31145", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
            tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
            tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );				
					}
				
					if(SQLCODE == NO_DATA_FOUND)
					{
						fn_errlog( c_ServiceName, "S31150", "Allocation not Found for Stock", c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
            tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
            tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
					
					/*This picks the pledge rate for the stock for BSE. (ver 2.1)
					Pledge rate is populated by the 52wk Hi-Lo program
					and also can be manully changed by the operation team*/
					
					EXEC SQL 
					SELECT LTQ_PLG_RT 
					INTO :sql_ltq_plg_rt 
					FROM LTQ_TRD_QT
					WHERE LTQ_STCK_CD = :sql_stk_stck_cd
					AND LTQ_XCHNG_CD = 'BSE'; /* ver 2.1 */
						
					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31155", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			**  Ver 1.7: Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
            tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
            tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
			
					EXEC SQL 
					SELECT nvl(DBD_TOT_QTY,0),
					nvl(DBD_QTY_BLCKD,0),
					/***	nvl(DBD_PLG_REQ_QTY,0),
					nvl(DBD_TIFP_QTY,0),nvl(DBD_REV_REQ_QTY,0),
					nvl(DBD_REV_COV_QTY,0),nvl(DBD_INV_REQ_QTY,0),
					nvl(DBD_INV_COV_QTY,0), ***** Commented and added for Ver 3.2 ****/
					/*** Added for Ver 4.4 ***/
					nvl(DBD_PLG_REQ_QTY,0),
					nvl(DBD_REV_REQ_QTY,0),
					nvl(DBD_REV_COV_QTY,0),
					nvl(DBD_INV_REQ_QTY,0),
					nvl(DBD_INV_COV_QTY,0),
					/*** Ver 4.4 **/
					nvl(DBD_SAM_BLCKD_QTY,0),
					nvl(DBD_BLOCK_FOR_SALE,0),
					DBD_ISIN_NMBR
					INTO :sql_dbd_tot_qty,
					:sql_dbd_qty_blckd, 
					/***	:sql_dbd_plg_req_qty,
					:sql_dbd_tifp_qty, :sql_dbd_rev_req_qty,
					:sql_dbd_rev_cov_qty, :sql_dbd_inv_req_qty,
					:sql_dbd_inv_cov_qty, ***** Commented and added for Ver 3.2 ****/
					/** Added for Ver 4.4 **/
					:sql_dbd_plg_req_qty,
					:sql_dbd_rev_req_qty,
					:sql_dbd_rev_cov_qty, 
					:sql_dbd_inv_req_qty,
					:sql_dbd_inv_cov_qty, 
					/** Ver 4.4 **/
					:sql_dbd_sam_blckd_qty,
					:sql_dbd_block_for_sale,					
					:sql_dbd_isin_nmbr
					FROM DBD_DP_BLCK_DTLS
					WHERE DBD_STCK_CD = :sql_stk_stck_cd
					AND DBD_CLM_MTCH_ACCNT = :sql_mtch_accnt
					AND DBD_DP_ID = :sql_dbd_dp_id
					AND DBD_DP_CLNT_ID = :sql_dbd_dp_clnt_id;

					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31160", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
            tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
            tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}	

					if(DEBUG_MSG_LVL_3){
					fn_userlog(c_ServiceName,"The value of DBD_TOT_QTY is [%ld]",sql_dbd_tot_qty);
					fn_userlog(c_ServiceName,"The value of DBD_QTY_BLCKD is [%ld]",sql_dbd_qty_blckd);
					fn_userlog(c_ServiceName,"The value of DBD_PLG_REQ_QTY is [%ld]",sql_dbd_plg_req_qty);
					/** fn_userlog(c_ServiceName,"The value of DBD_TIFP_QTY is [%ld]",sql_dbd_tifp_qty); ** Commented for Ver 4.4 **/
					fn_userlog(c_ServiceName,"The value of DBD_REV_REQ_QTY is [%ld]",sql_dbd_rev_req_qty);
					fn_userlog(c_ServiceName,"The value of DBD_REV_COV_QTY is [%ld]",sql_dbd_rev_cov_qty);
					fn_userlog(c_ServiceName,"The value of DBD_INV_REQ_QTY is [%ld]",sql_dbd_inv_req_qty);
					fn_userlog(c_ServiceName,"The value of DBD_INV_COV_QTY is [%ld]",sql_dbd_inv_cov_qty); 
					fn_userlog(c_ServiceName,"The value of DBD_SAM_BLCKD_QTY is [%ld]",sql_dbd_sam_blckd_qty); /*** Ver 3.2 ***/
					fn_userlog(c_ServiceName,"The value of DBD_BLOCK_FOR_SALE is [%ld]",sql_dbd_block_for_sale);
					}

					if(sql_qty_plg <= 0)
					{
						fn_userlog(c_ServiceName,"The quantity cannot be zero or negative");
						strcpy(c_err_msg,"The quantity cannot be zero or negative");
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			**  Ver 1.7: Commented  ***/
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
						tpfree ( ( char * )ptr_fml_Obuf);
            tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
            tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

				/** Uncommented below for Ver 4.4 ****/
				/*** Commented for Ver 3.2 ***/
					if(sql_dbd_rev_req_qty > 0)
					{
						if(DEBUG_MSG_LVL_3){
							fn_userlog(c_ServiceName,"The Revoke quantity is [%ld]. Hence rejected.",sql_dbd_rev_req_qty);
						}

						strcpy(c_err_msg,"There is a pending withdrawal request present.Please cancel/modify the same.");
						Fadd32( ptr_fml_Obuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
						Fadd32( ptr_fml_Obuf,FFO_ERR_MSG, c_err_msg, 0 );
						Fadd32( ptr_fml_Obuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );

						/*  1.4 Starts */
            if(c_force_flag == 'B')
            {
              tpfree ( ( char * )ptr_fml_Obuf);
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }
            /* 1.4 Ends */
						continue ;				
					}
			/*** Commented for Ver 3.2 ***/
			/** End for Ver 4.4 **/

					if((sql_dbd_tot_qty - sql_dbd_qty_blckd ) < sql_qty_plg)
					{
						if(DEBUG_MSG_LVL_3){
							fn_userlog(c_ServiceName,"The value free is [%ld] and pledged is [%ld]",li_tot_blck_qty,sql_qty_plg); 
						}

						strcpy(c_err_msg,"The free quantity for pledge is less than that requested");
						Fadd32( ptr_fml_Obuf,FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Obuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			**  Ver 1.7: Commented  ***/
						Fadd32( ptr_fml_Obuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
						Fadd32( ptr_fml_Obuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );

						/*  1.4 Starts */
            if(c_force_flag == 'B')
            {
              tpfree ( ( char * )ptr_fml_Obuf);
            	tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
            	tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }
            /* 1.4 Ends */
						continue ;
					}
					
					/*** if(sql_stk_plg_clnt_conc < (sql_qty_plg + sql_dbd_plg_req_qty + sql_dbd_tifp_qty)) *** Condition changed for Ver 3.2 ***/
					if(sql_stk_plg_clnt_conc < (sql_qty_plg + sql_dbd_sam_blckd_qty + sql_dbd_plg_req_qty )) /***  sql_dbd_plg_req_qty Adder for Ver 4.4 ***/
					{
						if(DEBUG_MSG_LVL_3){
							fn_userlog( c_ServiceName, "Block concentration for this stock for you has been exceeded." );
						}

						/**strcpy(c_err_msg,"Pledge concentration for this stock for you has been exceeded."); ** Ver 2.7*/
						strcpy(c_err_msg,"Please enter quantity less than the maximum acceptable quantity."); /** Ver 2.7*/
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Obuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			**  Ver 1.7: Commented  ***/
						Fadd32( ptr_fml_Obuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
						Fadd32( ptr_fml_Obuf,FFO_ERR_MSG, c_err_msg, 0 );
						Fadd32( ptr_fml_Obuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );

						/*  1.4 Starts */
            if(c_force_flag == 'B')
            {
              tpfree ( ( char * )ptr_fml_Obuf);
            	tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
            	tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }
            /* 1.4 Ends */
						continue ;
					}
		/* As required by the product team during testing, the global concentration is checked after
		client level concetration*/
					if( sql_stk_plg_conc < (sql_tot_pod_ordr_qty + sql_qty_plg))	
					{
						if(DEBUG_MSG_LVL_3){
							fn_userlog( c_ServiceName, "Block concentration for this stock has been exceeded.[%s]",sql_stk_stck_cd );
						}

						/**strcpy(c_err_msg,"Pledge concentration for this stock has been exceeded."); ** Ver 2.5 **/
						/**strcpy(c_err_msg,"Please enter quantity less than the maximum acceptable quantity."); * Ver 2.5 *V2.7*/
						strcpy(c_err_msg,"Block concentration for this stock has exceeded. Please try blocking another stock."); /*V2.7*/
						Fadd32( ptr_fml_Obuf,FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Obuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
						Fadd32( ptr_fml_Obuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
						Fadd32( ptr_fml_Obuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );

						/*  1.4 Starts */
            if(c_force_flag == 'B')
            {
              tpfree ( ( char * )ptr_fml_Obuf);
            	tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
            	tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }
            /* 1.4 Ends */
						continue ;
					}

					/*The following variable will be used to hold the value of the stock pledged in paise*/	

					/*** Log added in 2.4 *****/
           if(DEBUG_MSG_LVL_3){
           fn_userlog(c_ServiceName,"sql_qty_plg :%ld:",sql_qty_plg);
           fn_userlog(c_ServiceName,"sql_stk_plg_haircut :%ld:",sql_stk_plg_haircut);
           fn_userlog(c_ServiceName,"sql_ltq_plg_rt :%lf:",sql_ltq_plg_rt);
           }

					sql_stck_plg_val = (sql_qty_plg * (sql_ltq_plg_rt *(1 - ((double)(sql_stk_plg_haircut)/100))))*100; /** diwa typecast of float made double **/
					
					/*The following is done to round off*/


					if((long long)(sql_stck_plg_val * 100)%100 > 50)
					{
						sql_stck_plg_val = sql_stck_plg_val + 1.0;

						if(DEBUG_MSG_LVL_3){
							fn_userlog( c_ServiceName, "The rounded off amount is [%lf]",sql_stck_plg_val);
						}
					}
					
					ll_stck_plg_val = (long long) sql_stck_plg_val;

					sql_stck_plg_val = (double) ll_stck_plg_val;

					if ( ll_stck_plg_val <= (sql_ppp_min_dep_amt*100))
					{
						if(DEBUG_MSG_LVL_3){
							fn_userlog(c_ServiceName,"The value pledge is [%lld] and minimu reqd is [%ld]",ll_stck_plg_val,sql_ppp_min_dep_amt); 
						}

						sprintf(c_err_msg,"Request Value less than Rs.<%ld> :Please modify the request",sql_ppp_min_dep_amt);
						Fadd32( ptr_fml_Obuf,FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Obuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
						Fadd32( ptr_fml_Obuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
						Fadd32( ptr_fml_Obuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );

						/*  1.4 Starts */
            if(c_force_flag == 'B')
            {
              tpfree ( ( char * )ptr_fml_Obuf);
            	tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
            	tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }
            /* 1.4 Ends */
						continue ;

					}	

					i_trnsctn = fn_begintran( c_ServiceName, c_err_msg );
					if ( i_trnsctn == -1 )
					{
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
						fn_errlog( c_ServiceName, "S31165",LIBMSG,c_err_msg);
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
            tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
            tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

					if(DEBUG_MSG_LVL_3){
						fn_userlog(c_ServiceName,"The plg val is [%lld] for rate [%lf]",ll_stck_plg_val, sql_ltq_plg_rt);
					}
					
		/*Check if there exists any pledge request that has not been taken for DP processing
		if found, then the original pledge request is updated*/

					/** Added for Ver 4.4 ****/

					EXEC SQL
						SELECT count(1) 
						INTO :i_plg_ord_cnt
						FROM POD_PLG_ORDR_DTLS
						WHERE POD_CLNT_MTCH_ACCNT = :sql_mtch_accnt
            AND POD_DP_ACCNT = :sql_dbd_dp_id
            AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
            AND POD_PLG_REV_TYP = 'P'
            AND POD_ORDR_STTS = 'R'
            AND POD_STCK_CD = :sql_stk_stck_cd;

						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31170", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
							tpfree ( ( char * )ptr_fml_Obuf);
							fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}

					/*** Uncommented for Ver 4.4 ***/
		/**** Commented for Ver 3.2 ****/
					/*** if (sql_dbd_plg_req_qty > 0) ** Condition changed for Ver 4.4 **/
					if (i_plg_ord_cnt > 0)
					{

						EXEC SQL
							SELECT POD_ORDR_NO
							INTO :sql_pod_ordr_no
							FROM POD_PLG_ORDR_DTLS
							WHERE POD_CLNT_MTCH_ACCNT = :sql_mtch_accnt
            	AND POD_DP_ACCNT = :sql_dbd_dp_id
            	AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
            	AND POD_PLG_REV_TYP = 'P'
            	AND POD_ORDR_STTS = 'R'
            	AND POD_STCK_CD = :sql_stk_stck_cd
							AND ROWNUM < 2;

						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31175", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
							tpfree ( ( char * )ptr_fml_Obuf);
							fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}
						SETNULL(sql_pod_ordr_no);

						sql_pml_mod_type ='M';
						MEMSET(sql_pml_rmrks);
						strcpy(sql_pml_rmrks.arr,"Auto - modified for Addl. Deposit");
						SETLEN(sql_pml_rmrks);

						if(DEBUG_MSG_LVL_3){
   						fn_userlog(c_ServiceName, "Selecting next sequence value" );
 						}

						EXEC SQL SELECT PRS_PLG_REV_SEQ.nextval INTO :sql_prs_seq
						FROM DUAL;

						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31180", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
							tpfree ( ( char * )ptr_fml_Obuf);
							fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}

						EXEC SQL UPDATE POD_PLG_ORDR_DTLS SET
						POD_ORDR_QTY = POD_ORDR_QTY + :sql_qty_plg,
						POD_HAIRCUT = :sql_stk_plg_haircut,
						POD_ORDR_VL = POD_ORDR_VL + :sql_stck_plg_val,
						POD_RMRKS = :sql_pml_rmrks
						WHERE POD_CLNT_MTCH_ACCNT = :sql_mtch_accnt
						AND POD_DP_ACCNT = :sql_dbd_dp_id
						AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
						AND POD_PLG_REV_TYP = 'P'
						AND POD_ORDR_STTS = 'R'
						AND POD_STCK_CD = :sql_stk_stck_cd
						AND POD_ORDR_NO = :sql_pod_ordr_no
						RETURNING 
						POD_ORDR_VL ,
						POD_ORDR_QTY
						INTO 
						:sql_pod_ordr_vl,
						:l_plg_prcs_qty;
						
						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31185", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			**  Ver 1.7: Commented  ***/
							tpfree ( ( char * )ptr_fml_Obuf);
							fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}


						if(DEBUG_MSG_LVL_3){
							fn_userlog(c_ServiceName," The returned Old order no is [%s]",sql_pod_ordr_no.arr);
							fn_userlog(c_ServiceName," The returned Old order value is [%lf]",sql_pod_ordr_vl);
							fn_userlog(c_ServiceName,"Value of l_plg_prcs_qty :%ld:",l_plg_prcs_qty);	/** Added for Ver 4.4 **/
						}

						EXEC SQL 
						SELECT (COUNT(*)+1) 
						INTO :sql_pml_mod_cntr 
						FROM PML_PLG_MOD_LOG
						WHERE PML_ORDR_NO = :sql_pod_ordr_no
						AND PML_CLNT_MTCH_ACCNT = :sql_mtch_accnt
						AND PML_DP_ACCNT = :sql_dbd_dp_id
						AND PML_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
						AND PML_PLG_REV_TYP = 'P'
						AND PML_MOD_TYPE IN ('N','M','C');
			
						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31190", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
							tpfree ( ( char * )ptr_fml_Obuf);
							fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}
						
						if(DEBUG_MSG_LVL_3){
							fn_userlog(c_ServiceName,"The mod counter is [%ld]",sql_pml_mod_cntr);
						}
			
					}

					/*end of if for sql_dbd_plg_req_qty > 0*/
					/*Else new order for pledge*/
					else
					{

						EXEC SQL SELECT PRS_PLG_REV_SEQ.nextval INTO :sql_prs_seq
						FROM DUAL;

						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31195", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
							tpfree ( ( char * )ptr_fml_Obuf);
							fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}	

						EXEC SQL 
						SELECT TO_CHAR(sysdate,'YYYYMMDD')||LPAD((PPS_PLG_SEQ+1),8,0)
						INTO :sql_pod_ordr_no
						FROM PPS_PLG_PLACED_SEQ 
						WHERE PPS_PLG_ORDR_DT = TO_DATE(TO_CHAR(sysdate,'DD-Mon-YYYY'),'DD-Mon-YYYY')
            FOR UPDATE OF PPS_PLG_SEQ;  /***For update added in  Ver 4.5 ***/

						if ((SQLCODE != 0) && (SQLCODE != NO_DATA_FOUND))
						{
							fn_errlog( c_ServiceName, "S31200", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
							tpfree ( ( char * )ptr_fml_Obuf);
							fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}

            /* Ver 1.6 add */
            SETNULL(sql_pod_ordr_no);
				
						if (SQLCODE == NO_DATA_FOUND)
						{
							EXEC SQL 
							INSERT INTO PPS_PLG_PLACED_SEQ
							(PPS_PLG_SEQ,
							PPS_PLG_ORDR_DT)
							VALUES
							(1,
							TO_DATE(TO_CHAR(sysdate,'DD-Mon-YYYY'),'DD-Mon-YYYY'));
							
							if (SQLCODE != 0)
							{
								fn_errlog( c_ServiceName, "S31205", SQLMSG, c_err_msg  );
								Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**							l_acnt_id = -1;
								Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
								tpfree ( ( char * )ptr_fml_Obuf);
								fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
								tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
							}
		/**********Pledge order reference number is created**************************/
							EXEC SQL 
							SELECT TO_CHAR(sysdate,'YYYYMMDD')||LPAD(1,8,0) 
							INTO :sql_pod_ordr_no
							FROM DUAL;

							if (SQLCODE != 0)
							{
								fn_errlog( c_ServiceName, "S31210", SQLMSG, c_err_msg  );
								Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**							l_acnt_id = -1;
								Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
								tpfree ( ( char * )ptr_fml_Obuf);
								fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
								tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
							}

              /* Ver 1.6 add */
              SETNULL(sql_pod_ordr_no);
			
						}
						else
						{
							EXEC SQL 
							UPDATE PPS_PLG_PLACED_SEQ SET 
							PPS_PLG_SEQ = PPS_PLG_SEQ +1
							WHERE PPS_PLG_ORDR_DT = TO_DATE(TO_CHAR(sysdate,'DD-Mon-YYYY'),'DD-Mon-YYYY');
			
							if (SQLCODE != 0)
							{
								fn_errlog( c_ServiceName, "S31215", SQLMSG, c_err_msg  );
								Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**							l_acnt_id = -1;
								Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
								tpfree ( ( char * )ptr_fml_Obuf);
								fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
								tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
							}
						}
						
						EXEC SQL INSERT INTO POD_PLG_ORDR_DTLS
						(POD_ORDR_NO,
						POD_STCK_CD,
						POD_ORDR_QTY,
						POD_ORDR_DT,
						POD_HAIRCUT,
						POD_ORDR_VL,
						POD_ISIN_NO,
						POD_DP_CLNT_ACCNT,
						POD_DP_ACCNT,
						POD_CLNT_MTCH_ACCNT ,
						POD_PLG_REV_TYP,
						POD_ORDR_STTS,
						POD_CONF_QTY,
            POD_PRCSD_QTY,   /*******1.3*****/
						POD_RMRKS,
						POD_BP_ID,
						POD_CHANNEL,
				    POD_ALLOC_TYP)   /*** ver 4.7 ***/
						VALUES
						(:sql_pod_ordr_no,
						:sql_stk_stck_cd,
						:sql_qty_plg,
						sysdate,
						:sql_stk_plg_haircut,
						:sql_stck_plg_val,
						:sql_dbd_isin_nmbr,
						:sql_dbd_dp_clnt_id,
						:sql_dbd_dp_id,
						:sql_mtch_accnt,
						'P',
						'R',
						0,
            0,              /*******1.3*****/
						null,
						:sql_pod_bp_id,
						:sql_pml_channel,
						:sql_req_typ);  /*** ver 4.7 ***/ 	
				
						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31220", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
							tpfree ( ( char * )ptr_fml_Obuf);
							fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}

						sql_pml_mod_type ='N';
						sql_pml_mod_cntr = 1;
						/** sql_pod_ordr_vl = 0.0 ; ** Commented for Ver 4.4 **/
						sql_pod_ordr_vl = sql_stck_plg_val;	/** Ver 4.4 **/
						l_plg_prcs_qty = sql_qty_plg;		/** Added for 4.4 **/

						fn_userlog(c_ServiceName,"Value of l_plg_prcs_qty :%ld:",l_plg_prcs_qty);	/** Added for Ver 4.4 **/
						MEMSET(sql_pml_rmrks);
		/*Commented as not required by Product Team
							strcpy(sql_pml_rmrks.arr,"New Pledge Request");
							SETLEN(sql_pml_rmrks);*/

					}/* end of else for new pledge order*/

		/*****On Pledging quantity is reduced from Total Quantity and added in Pledge Request quantity****/
					EXEC SQL 
					UPDATE DBD_DP_BLCK_DTLS SET
					DBD_TOT_QTY = DBD_TOT_QTY - :sql_qty_plg,
					DBD_PLG_REQ_QTY = DBD_PLG_REQ_QTY + :sql_qty_plg
					WHERE DBD_STCK_CD = :sql_stk_stck_cd
					AND DBD_CLM_MTCH_ACCNT = :sql_mtch_accnt
					AND DBD_DP_ID = :sql_dbd_dp_id
					AND DBD_DP_CLNT_ID = :sql_dbd_dp_clnt_id;
					
					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31225", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

					/*** Commented for ver 4.4 ***
					MEMSET(sql_fab_bnk_accnt);

					EXEC SQL 
					UPDATE FAB_FO_ALC_BFT_SMRY SET
					**FAB_PLG_AMT = FAB_PLG_AMT + :sql_stck_plg_val	 *** Commented V2.5 *
					FAB_NWB_AMT = nvl(FAB_NWB_AMT,0) + :sql_stck_plg_val				** Ver 2.5 Increasing NWB on pledging **
					WHERE FAB_CLM_MTCH_ACCNT = :sql_mtch_accnt
					RETURNING FAB_BNK_ACCNT,FAB_ALCTD_AMT,FAB_BFT_AMT
					INTO :sql_fab_bnk_accnt,:sql_fab_alctd_amt,:sql_fab_bft_amt;

					if ((SQLCODE != 0) && (SQLCODE !=NO_DATA_FOUND)) *Ver 1.1 NO_DATA_FOUND ignore added*
					{
						fn_errlog( c_ServiceName, "S31230", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
					
					SETNULL(sql_fab_bnk_accnt);

*Ver 1.1 starts*
					if(SQLCODE  == NO_DATA_FOUND)
					{
						EXEC SQL SELECT CLB_BNK_ACCT_NMBR
						INTO :sql_fab_bnk_accnt
						FROM CLB_BNK_ACCTS
						WHERE CLB_CLM_MTCH_ACCNT = :sql_mtch_accnt;
				
						if (SQLCODE != 0)
          	{
           	 fn_errlog( c_ServiceName, "S31235", SQLMSG, c_err_msg  );
           	 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
**        	 l_acnt_id = -1;
           	 Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***
           	 tpfree ( ( char * )ptr_fml_Obuf);
           	 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
           	 tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }
						
						SETNULL(sql_fab_bnk_accnt);

						EXEC SQL INSERT INTO FAB_FO_ALC_BFT_SMRY
						(FAB_CLM_MTCH_ACCNT,
						FAB_BNK_ACCNT,
						FAB_ALCTD_AMT,
						FAB_BFT_AMT,
						FAB_PLG_AMT,
						FAB_NWB_AMT)				** Ver 2.5 **
						VALUES
						(:sql_mtch_accnt,
						:sql_fab_bnk_accnt,
						0,
						0,
						0,								  ** Ver 2.5 **
						:sql_stck_plg_val);

						if (SQLCODE != 0)
            {
             fn_errlog( c_ServiceName, "S31240", SQLMSG, c_err_msg  );
             Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
**         l_acnt_id = -1;
             Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***
             tpfree ( ( char * )ptr_fml_Obuf);
             fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
             tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }
				*The following will be required for FAL entry*
						sql_fab_alctd_amt = 0;
						sql_fab_bft_amt = 0;

					}*End of insertion of new entry in FAB*
*Ver 1.1 ends*
				

					EXEC SQL INSERT INTO FAL_FO_ALCBFT_LOG
					(FAL_CLM_MTCH_ACCNT,
					FAL_BNK_ACCNT,
					FAL_ALCTD_AMT,
					FAL_BFT_AMT,
					FAL_TRN_DT,
					FAL_OLD_PLG_AMT,
					FAL_NARRATION,
					FAL_NWB_AMT,				** Ver 2.5 *
					FAL_NWB_CHG_AMT)    ** Ver 2.5 *
					VALUES
					(:sql_mtch_accnt,
					:sql_fab_bnk_accnt,
					:sql_fab_alctd_amt,
					:sql_fab_bft_amt,
					sysdate,
					:sql_fab_plg_amt,
					'PL'
					:sql_fab_nwb_amt,		** Ver 2.5 *
					:sql_stck_plg_val); ** Ver 2.5 *

					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31245", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

					**** End for Ver 4.4 ***/

					if(DEBUG_MSG_LVL_4){ /**2.3 **/

					fn_userlog(c_ServiceName,"The PML_STCK_CD is [%s]",sql_stk_stck_cd);
					fn_userlog(c_ServiceName,"The PML_HAIRCUT is [%ld]",sql_stk_plg_haircut);
					fn_userlog(c_ServiceName,"The PML_DP_CLNT_ACCNT is [%s]",sql_dbd_dp_clnt_id);
					fn_userlog(c_ServiceName,"The PML_DP_ACCNT is [%s]",sql_dbd_dp_id);
					fn_userlog(c_ServiceName,"The PML_ORDR_VL is [%lld]",(ll_stck_plg_val + sql_pod_ordr_vl));
					}


					if(DEBUG_MSG_LVL_3){
					fn_userlog(c_ServiceName,"The PML_ORDR_NO is [%s]",sql_pod_ordr_no.arr);
					fn_userlog(c_ServiceName,"The PML_ORDR_QTY is [%ld]",(sql_dbd_plg_req_qty + sql_qty_plg));
					fn_userlog(c_ServiceName,"The PML_ISIN_NO is [%s]",sql_dbd_isin_nmbr);
					fn_userlog(c_ServiceName,"The PML_CLNT_MTCH_ACCNT is [%s]",sql_mtch_accnt.arr);
					fn_userlog(c_ServiceName,"The PML_MOD_TYPE is [%c]",sql_pml_mod_type);
					fn_userlog(c_ServiceName,"The PML_MOD_CNTR is [%ld]",sql_pml_mod_cntr);
					fn_userlog(c_ServiceName,"The PML_PLCD_SQNC is [%ld]",sql_prs_seq);
					fn_userlog(c_ServiceName,"The PML_CHANNEL is [%s]",sql_pml_channel.arr);
					}	

					EXEC SQL INSERT INTO PML_PLG_MOD_LOG
					(PML_ORDR_NO,
					PML_STCK_CD,
					PML_ORDR_QTY,
					PML_ORDR_TM,
					PML_HAIRCUT,
					PML_ORDR_VL,
					PML_ISIN_NO,
					PML_DP_CLNT_ACCNT,
					PML_DP_ACCNT,
					PML_CLNT_MTCH_ACCNT,
					PML_PLG_REV_TYP,
					PML_MOD_TYPE,
					PML_STTS,
					PML_MOD_CNTR,
					PML_PLCD_SQNC,
					PML_BP_ID,
					PML_CHANNEL,
					PML_RMRKS)
					VALUES
					(:sql_pod_ordr_no,
					:sql_stk_stck_cd,
					/** (:sql_dbd_plg_req_qty + :sql_qty_plg), ** Commented by Ver 4.4 **/
					:l_plg_prcs_qty,												/** Ver 4.4 **/
					sysdate,
					:sql_stk_plg_haircut,
					/** (:sql_pod_ordr_vl + :sql_stck_plg_val), ** Commented for Ver 4.4 and removed the variable sql_stck_plg_val **/
					:sql_pod_ordr_vl,
					:sql_dbd_isin_nmbr,
					:sql_dbd_dp_clnt_id,
					:sql_dbd_dp_id,
					:sql_mtch_accnt,
					'P',
					:sql_pml_mod_type,
					'R',
					:sql_pml_mod_cntr,
					:sql_prs_seq,	
					:sql_pod_bp_id,
					:sql_pml_channel,
					:sql_pml_rmrks);
					
					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31250", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

					EXEC SQL INSERT INTO DLD_DP_LOG_DTLS
					(DLD_CLM_MTCH_ACCNT,
					DLD_DP_ID,
					DLD_DP_CLNT_ID,
					DLD_ISIN_NMBR,
					DLD_STCK_CD,
					DLD_TOT_QTY_CHG,
					DLD_QTY_BLCKD_CHG,
					DLD_PLG_REQ_QTY_CHG,
					/** DLD_TIFP_QTY_CHG, ** Commented for Ver 4.4 **/
					DLD_SAM_BLCKD_QTY_CHG,	/** Ver 4.4 **/
					DLD_REV_COV_QTY_CHG,
					DLD_REV_REQ_QTY_CHG,
					DLD_CHG_TM,
					DLD_BLK_FR_SALE_CHG,
					DLD_INV_REQ_QTY_CHG,
					DLD_INV_COV_QTY_CHG,
					DLD_RMRKS)
					VALUES
					(:sql_mtch_accnt,
					:sql_dbd_dp_id,
					:sql_dbd_dp_clnt_id,
					:sql_dbd_isin_nmbr,
					:sql_stk_stck_cd,
					-(:sql_qty_plg),
					0,
					:sql_qty_plg,
					0,
					0,
					0,
					sysdate,
					0,
					0,
					0,
					'Pledge Placement');

					 if(DEBUG_MSG_LVL_3){	
					 	 fn_userlog(c_ServiceName,"After DLD Insert [%s]",sql_pml_rmrks.arr);
					 }

					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31255", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

			/**** Commented for Ver 3.2 ****/
			/*** End of Uncomment for Ver 4.4 ***/

					if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg ) == -1 )
					{
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 ); 
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
            tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
            tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn ( TPFAIL, ERR_BFR, ( char * )ptr_fml_Ibuf, 0, 0 );
					}

/*** Added for Ver 3.2 *******/

		/************** Commented for Ver 4.4 ****
	c_bkubk_flg = 'B';

					if(DEBUG_MSG_LVL_3){
					fn_userlog(c_ServiceName,"The sql_mtch_accnt.arr is [%s]",sql_mtch_accnt.arr);
					fn_userlog(c_ServiceName,"The c_bkubk_flg is [%c]",c_bkubk_flg);
					fn_userlog(c_ServiceName,"The st_usr_prfl.c_user_id is [%s]",st_usr_prfl.c_user_id);
					fn_userlog(c_ServiceName,"The sql_stk_stck_cd is [%s]",sql_stk_stck_cd);
					fn_userlog(c_ServiceName,"The sql_qty_plg is [%ld]",sql_qty_plg);
					fn_userlog(c_ServiceName,"The sql_dbd_dp_id is [%s]",sql_dbd_dp_id);
					fn_userlog(c_ServiceName,"The sql_dbd_dp_clnt_id is [%s]",sql_dbd_dp_clnt_id);
					fn_userlog(c_ServiceName,"The sql_pml_channel.arr is [%s]",sql_pml_channel.arr);
					}	

	i_err [0] = Fchg32(ptr_fml_Ibuf1,FFO_EBA_MTCH_ACT_NO, 0,(char *)sql_mtch_accnt.arr,0);
  i_err [1] = Fchg32(ptr_fml_Ibuf1,FFO_BK_UBK_FLG, 0, (char *)&c_bkubk_flg,0);
  i_err [2] = Fchg32(ptr_fml_Ibuf1,FFO_USR_ID, 0,(char*)st_usr_prfl.c_user_id,0);
  i_err [3] = Fchg32(ptr_fml_Ibuf1,FFO_STCK_CD, 0,(char *)sql_stk_stck_cd ,0);
  i_err [4] = Fchg32(ptr_fml_Ibuf1,FFO_ORD_TOT_QTY, 0,(char *)&sql_qty_plg,0);
  i_err [5] = Fchg32(ptr_fml_Ibuf1,FFO_DPID, 0,(char *)sql_dbd_dp_id ,0);
  i_err [6] = Fchg32(ptr_fml_Ibuf1,FFO_DP_CLNT_ID, 0,(char *)sql_dbd_dp_clnt_id ,0);
  i_err [7] = Fchg32(ptr_fml_Ibuf1,FFO_CHANNEL, 0,sql_pml_channel.arr,0);
  i_err [8] = Fchg32(ptr_fml_Ibuf1,FFO_SSSN_ID, 0,(char*)&st_usr_prfl.l_session_id,0);

		*** Comment end for Ver 4.4 **/

/**	i_err [0] = Fchg32(ptr_fml_Ibuf,FFO_EBA_MTCH_ACT_NO,0, (char *)sql_mtch_accnt.arr,0);
  i_err [1] = Fadd32(ptr_fml_Ibuf,FFO_BK_UBK_FLG, (char *)&c_bkubk_flg,0);
  i_err [2] = Fchg32(ptr_fml_Ibuf,FFO_USR_ID,0, (char*)st_usr_prfl.c_user_id,0);
  i_err [3] = Fchg32(ptr_fml_Ibuf,FFO_STCK_CD,0, (char *)sql_stk_stck_cd ,0);
  i_err [4] = Fchg32(ptr_fml_Ibuf,FFO_ORD_TOT_QTY,0, (char *)&sql_qty_plg,0);
  i_err [5] = Fchg32(ptr_fml_Ibuf,FFO_DPID,0, (char *)sql_dbd_dp_id ,0);
  i_err [6] = Fchg32(ptr_fml_Ibuf,FFO_DP_CLNT_ID,0, (char *)sql_dbd_dp_clnt_id ,0);
  i_err [7] = Fchg32(ptr_fml_Ibuf,FFO_CHANNEL,0, sql_pml_channel.arr,0);
  i_err [8] = Fchg32(ptr_fml_Ibuf,FFO_SSSN_ID,0, (char*)&st_usr_prfl.l_session_id,0);**/

		/*** Added for Ver 4.4 ***/
		c_req_conf_flg = 'R';

    fn_userlog(c_ServiceName,"Before The Force Withdrawal flag is [%c]",c_force_flag);
		fn_userlog(c_ServiceName,"Values before passing SFO_MRGN_PLG");
		fn_userlog(c_ServiceName,"Value of sql_mtch_accnt :%s:",sql_mtch_accnt.arr);
		fn_userlog(c_ServiceName,"Value of sql_dbd_dp_id :%s:",sql_dbd_dp_id);
		fn_userlog(c_ServiceName,"Value of sql_dbd_dp_clnt_id :%s:",sql_dbd_dp_clnt_id);
		fn_userlog(c_ServiceName,"Value of sql_stk_stck_cd :%s:",sql_stk_stck_cd);
		fn_userlog(c_ServiceName,"Value of sql_qty_plg :%ld:",sql_qty_plg);
		fn_userlog(c_ServiceName,"Value of l_plg_prcs_qty :%ld:",l_plg_prcs_qty);		/** Added for Ver 4.4 **/
		fn_userlog(c_ServiceName,"Value of sql_pod_ordr_no :%s:",sql_pod_ordr_no.arr);
		fn_userlog(c_ServiceName,"Value of c_req_conf_flg :%c:",c_req_conf_flg);
		fn_userlog(c_ServiceName,"Value of sql_oprn_typ :%c:",sql_oprn_typ);
		fn_userlog(c_ServiceName,"Value of vc_exec_dt :%s:",vc_exec_dt.arr);
		fn_userlog(c_ServiceName,"Value of sql_dbd_isin_nmbr :%s:",sql_dbd_isin_nmbr);

    i_err [0] = Fadd32(ptr_fml_Ibuf1,FFO_EBA_MTCH_ACT_NO, (char *)sql_mtch_accnt.arr,0);
    i_err [1] = Fadd32(ptr_fml_Ibuf1,FFO_DPID, (char *)sql_dbd_dp_id ,0);
    i_err [2] = Fadd32(ptr_fml_Ibuf1,FFO_DP_CLNT_ID, (char *)sql_dbd_dp_clnt_id ,0);
    i_err [3] = Fadd32(ptr_fml_Ibuf1,FFO_STCK_CD, sql_stk_stck_cd ,0);
    i_err [4] = Fadd32(ptr_fml_Ibuf1,FFO_TIFP_QTY, (char *)&l_plg_prcs_qty,0);
    i_err [5] = Fadd32(ptr_fml_Ibuf1,FFO_SPRD_ORD_REF, sql_pod_ordr_no.arr,0);
    i_err [6] = Fadd32(ptr_fml_Ibuf1,FFO_OPERATION_TYP, (char *)&c_req_conf_flg,0);
    i_err [7] = Fadd32(ptr_fml_Ibuf1,FFO_PLG_TYP, (char *)&sql_oprn_typ,0);
    i_err [8] = Fadd32(ptr_fml_Ibuf1,FFO_EXECN_DT, (char *)vc_exec_dt.arr,0);
    i_err [9] = Fadd32(ptr_fml_Ibuf1,FFO_ISIN_NMBR , (char *)sql_dbd_isin_nmbr,0);
		i_err [10] = Fadd32(ptr_fml_Ibuf1,FFO_REQ_TYP, (char *)&sql_req_typ,0); /***ver 4.7***/
    i_err [11] = Fadd32(ptr_fml_Ibuf1,FFO_CHANNEL, (char *)sql_pml_channel.arr,0); /***ver 5.0 **/

    for ( j=0; j <= 11; j++ ) /***Ver 3.5 replace 1 with 0***//***ver 4.7 ***//** 11 for Ver 5.0**/
  	{
    	if ( i_err[ j ] == -1 )
    	{
      	sprintf(c_err_msg, "ERROR : At FML no :%d:",j);
				fn_errlog( c_ServiceName,"S31260",FMLMSG,c_err_msg );      
				tpfree ( ( char * )ptr_fml_Obuf);   /** 3.6 **/
    		tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
				tpfree ( ( char * )ptr_fml_Obuf1);	/** 3.6 **/
      	strcpy( c_err_msg,"Contact System Support" );
      	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );		/*** Ver 3.5 ***/
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );		/*** Ver 3.5 ***/
    	}
  	}	

   /*** i_returncode = tpcall( "SFO_SAM_BKUBK", *** Commented for Ver 4.4 **/
   i_returncode = tpcall( "SFO_MRGN_PLG",		/** Service name changed for Ver 4.4 ***/
                      (char*)ptr_fml_Ibuf1,
                      0,
                      (char**)&ptr_fml_Obuf1,
                      &l_ip_len,0);

			if( i_returncode == -1)
  		{
    		if ( tperrno != TPESVCFAIL )
    		{
        		fn_errlog ( c_ServiceName, "S31265", TPMSG,c_err_msg);
    		}
        fn_errlog( c_ServiceName, "S31270", LIBMSG, c_err_msg );
				Fget32(ptr_fml_Obuf1,FFO_ERR_MSG,0,c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        tpfree ( ( char * )ptr_fml_Obuf);
        tpfree ( ( char * )ptr_fml_Ibuf1);
        tpfree ( ( char * )ptr_fml_Obuf1);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );

  		}

	/*** Commented for Ver 4.4 ***
	i_err[0] = Fget32(ptr_fml_Obuf1,FFO_PLG_ORDR_RFRNC,0,(char *)sql_pod_ordr_no.arr,0);
	i_err[1] = Fget32(ptr_fml_Obuf1,FFO_HAIRCUT ,0,(char *)&sql_stk_plg_haircut,0);
	i_err[2] = Fget32(ptr_fml_Obuf1,FFO_PLG_ORD_VAL,0,(char *)&sql_stck_plg_val,0);
	i_err[3] = Fget32(ptr_fml_Obuf1,FFO_STCK_CD,0,(char *)sql_stk_stck_cd, 0 ); 
	i_err[4] = Fget32(ptr_fml_Obuf1,FFO_ERR_MSG,0,c_err_msg, 0 ); 

  for(j = 0;j < 5; j++)
  {
		if(i_err[j] == -1 )
    {
			fn_errlog( c_ServiceName, "S31275", FMLMSG, c_err_msg  );
      fn_userlog(c_ServiceName, "The Fget32 error  at [%d]",j);
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      tpfree ( ( char * )ptr_fml_Obuf);
      tpfree ( ( char * )ptr_fml_Ibuf1);
      tpfree ( ( char * )ptr_fml_Obuf1);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
	}
	*** Ver 4.4 ***/

	/******* Added end for Ver 3.2******/

				sprintf(c_err_msg,"Your request has been accepted Request id is %s",
								sql_pod_ordr_no.arr);

				if(DEBUG_MSG_LVL_3){
					fn_userlog(c_ServiceName,c_err_msg);
				}

				strcpy(c_null_msg,"Success ");

				MEMSET(v_out_msg);
				strcpy(v_out_msg.arr,"You have successfully placed your pledge request. You will shortly receive an SMS, email from the Depository on your mobile number and email id registered with the Depository/ICICI Bank Demat. Please confirm your pledge request using OTP generated through this link to avail securities limit for trading.");

				SETLEN(v_out_msg);
				SETNULL(v_out_msg);

				i_counter = 1;				/** 2.3 **/


				/***************2.3  Allocate Memory and add to buffer ************************/

				if(DEBUG_MSG_LVL_3){
				fn_userlog(c_ServiceName,"Fneeded l_bufferlength :%ld:",Fneeded32( 1, l_bufferlength ));
			  fn_userlog(c_ServiceName,"Funused32 ptr_fml_Obuf :%ld:",Funused32( ptr_fml_Obuf ));
				}

				if ( Fneeded32( 1, l_bufferlength ) > Funused32( ptr_fml_Obuf ) )
        {

						fn_userlog(c_ServiceName, " ----In Reallocating loop------");

					  i_counter++;

					  ptr_fml_temp = ( FBFR32 *)tprealloc( (char *)ptr_fml_Obuf,
                           (Fsizeof32(ptr_fml_Obuf) + (i_counter * l_bufferlength )));


					  if (ptr_fml_temp == NULL )
            {
                fn_errlog( c_ServiceName, "S31280", TPMSG, c_err_msg  );
                fn_userlog(c_ServiceName, "Fail in reallocating");
                Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
                tpfree ( ( char * )ptr_fml_Obuf);
            		tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
            		tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
                tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }
						else
						{

							ptr_fml_Obuf = ptr_fml_temp;
              ptr_fml_temp = (FBFR32 *) NULL  ;

						}

				}
				

				/***************2.3 ends ********************************/
				

/**			l_acnt_id = 0;		**  Ver 1.7: Commented  ***/
				i_err[0] = Fadd32(ptr_fml_Obuf,FFO_PLG_ORDR_RFRNC,(char *)sql_pod_ordr_no.arr,0);
				i_err[1] = Fadd32(ptr_fml_Obuf,FFO_HAIRCUT ,(char *)&sql_stk_plg_haircut,0);
				i_err[2] = Fadd32(ptr_fml_Obuf,FFO_PLG_ORD_VAL,(char *)&sql_stck_plg_val,0);
/**			i_err[3] = Fadd32(ptr_fml_Obuf,FFO_ACTN_ID,(char *)&l_acnt_id, 0 );	**  Ver 1.7: Commented  ***/
				i_err[3] = Fadd32(ptr_fml_Obuf,FFO_STCK_CD,(char *)sql_stk_stck_cd, 0 ); 
				/** i_err[4] = Fadd32(ptr_fml_Obuf,FFO_ERR_MSG,c_null_msg, 0 ); *** Ver 1.7 : Added	 *** ** Commented for Ver 4.4 **/
				i_err[4] = Fadd32(ptr_fml_Obuf,FFO_ERR_MSG,v_out_msg.arr, 0 ); 


      	for(j = 0;j < 5; j++)   /********* Ver 1.7 : ERROR CONDITION CHECK ADDED ***********/
      	{
        	if(i_err[j] == -1 )
        	{


          			fn_errlog( c_ServiceName, "S31285", FMLMSG, c_err_msg  );
          			fn_userlog(c_ServiceName, "The Fget32 error  at [%d]",j);
          			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**        			l_acnt_id = -1;
          			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
          			tpfree ( ( char * )ptr_fml_Obuf);
								tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
								tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
          			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						
					
        	}
      	}

				/*** Ver 3.2 ****
				tpfree(( char * )ptr_fml_Ibuf1);
				tpfree(( char * )ptr_fml_Obuf1);
				*** Ver 3.2 ****/
	

			}/*end of for loop for getting rowcount*/

   /*** Ver 4.4 Starts ***/

      EXEC SQL
      SELECT Count(1)
      into   :i_new_ptd_count
      FROM   PTD_TIFP_DTLS
      WHERE  ptd_leg_no      = 'L1'
      AND    ptd_tifp_stts   = 'P'
      AND    PTD_PLG_REV_TYP = 'P'
      AND    PTD_CLM_MTCH_ACCNT = :sql_mtch_accnt
      AND    trunc(ptd_tifp_run_dt) = trunc(sysdate);

      if (SQLCODE != 0)
      {
         fn_errlog( c_ServiceName, "S31290", SQLMSG, c_err_msg  );
         Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
         tpfree ( ( char * )ptr_fml_Obuf);
         tpfree(( char * )ptr_fml_Ibuf1);
         tpfree(( char * )ptr_fml_Obuf1);
         tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

      if ( i_new_ptd_count > i_ptd_count )
      {
        fn_userlog(c_ServiceName,"Sens sms/mail....");
        if ( fn_mrgplg_sms_mail(c_ServiceName,sql_mtch_accnt.arr,0,PLG_PLC_REQ) != 0 )
        {
          fn_errlog( c_ServiceName, "S31295", SQLMSG, c_err_msg  );
          fn_userlog(c_ServiceName,"Error in fn_mrgplg_sms..");
        }
     }

  /*** Ver 4.4 Ends **/

				tpfree(( char * )ptr_fml_Ibuf1);
				tpfree(( char * )ptr_fml_Obuf1);
			/** tpfree( (char*)ptr_fml_Ibuf);	*** Ver 3.2 ***   *** Commented for Ver 3.5 **/
			tpreturn( TPSUCCESS, 0, (char *)ptr_fml_Obuf, 0, 0 );

			
			break; /*break of case Pledge*/	
	}
	/* WITHDRAWAL/REVOCATION STARTS HERE */

	case 'W': /*** withdraw ****/
	{
		/*** Added for Ver 3.2 ****/
		Finit32(ptr_fml_Ibuf1,(FLDLEN32) Fsizeof32(ptr_fml_Ibuf1));
		Finit32(ptr_fml_Obuf1,(FLDLEN32) Fsizeof32(ptr_fml_Obuf1));
		/*** Ver 3.2 **/

		memset(sql_stk_stck_cd,'\0',sizeof(sql_stk_stck_cd));

		i_err[5] = Fget32(ptr_fml_Ibuf,FFO_DPID,0,(char *)sql_dbd_dp_id,0);
		i_err[6] = Fget32(ptr_fml_Ibuf,FFO_DP_CLNT_ID,0,(char *)sql_dbd_dp_clnt_id,0);
		i_err[7] = Fget32(ptr_fml_Ibuf,FFO_STCK_CD,0,(char *)sql_stk_stck_cd,0);
		i_err[8] = Fget32(ptr_fml_Ibuf,FFO_ORD_TOT_QTY,0,(char *)&sql_qty_plg,0);
		/** i_err[9] = Fget32(ptr_fml_Ibuf,FML_PLG_FLG,0,(char *)&c_force_flag,0); *** Ver 3.2 ***/

		for(j=5;j<9;j++)
		{	
			if(i_err[j] == -1 )
			{
			fn_errlog( c_ServiceName, "S31300", FMLMSG, c_err_msg  );
			fn_userlog(c_ServiceName, "The Fget32 error  at [%d]",j);
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**		l_acnt_id = -1;
			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
			tpfree ( ( char * )ptr_fml_Obuf);
      tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
		}
/***	
		if((i_err[9] == -1) && (Ferror32 != FNOTPRES))
    {
      fn_errlog( c_ServiceName, "S31305", FMLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

    if(Ferror32 == FNOTPRES)
    {
      fn_userlog(c_ServiceName,"Inside FNOTPRES");
      c_force_flag = 'N';
    } 
***/

		SETLEN(sql_usr_id);
		SETLEN(sql_mtch_accnt);

		sql_stk_stck_cd[strlen(sql_stk_stck_cd)+1]='\0';


		/* 2.2 Begins */ 

    i_err[0] = Fget32(ptr_fml_Ibuf,FML_PLG_FLG,0,(char *)&c_force_flag,0);

    if((i_err[0] == -1) && (Ferror32 != FNOTPRES))
    {
      fn_errlog( c_ServiceName, "S31310", FMLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      tpfree ( ( char * )ptr_fml_Obuf);		/** 3.6 **/
      tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

    if(Ferror32 == FNOTPRES && (i_err[0] == -1))   /* Ver 4.3 */
    {
			fn_userlog(c_ServiceName,"Inside FNOTPRES");
      c_force_flag = 'N';
    } 

    fn_userlog(c_ServiceName,"The Force Withdrawal flag is [%c]",c_force_flag);

    /* end of 2.2 */
		
		if(DEBUG_MSG_LVL_3){
			fn_userlog(c_ServiceName, "For stck code : [%s] with len [%ld]",sql_stk_stck_cd,sizeof(sql_stk_stck_cd));		
		}

    /*** Added for Ver 4.4 ***/
    EXEC SQL
    	SELECT NVL(DBD_PLG_MODE,'P')
      INTO :sql_dbd_plg_mode
      FROM dbd_dp_blck_dtls
      WHERE DBD_CLM_MTCH_ACCNT = :sql_mtch_accnt
      AND DBD_DP_ID = :sql_dbd_dp_id
      AND DBD_DP_CLNT_ID = :sql_dbd_dp_clnt_id
      AND DBD_STCK_CD = :sql_stk_stck_cd;

    if(SQLCODE != 0)
    {
      fn_errlog( c_ServiceName, "S31315", SQLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      tpfree ( ( char * )ptr_fml_Obuf);
      tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
		/** Ver 4.4 **/


		if ((sql_ppp_plg_opncls_flg != 'Y') && (sql_ppp_plg_opncls_flg != 'W'))
		{
			/* Commented in ver 2.9 fn_userlog(c_ServiceName, "At present the facility of Shares as Margin has been suspended");
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "At present the facility of Shares as Margin has been suspended" , 0 );*/
			fn_userlog(c_ServiceName,"Please try later as shares as margin process is underway");   /* Ver 2.9*/
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "Please try later as shares as margin process is underway",0); /* Ver 2.9 */
/**		l_acnt_id = -1;
			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
			Fadd32( ptr_fml_Ibuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
			tpfree ( ( char * )ptr_fml_Obuf);
      tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );	
		}	

		if(c_force_flag != 'F')  /* 2.2 */
    {
			if ( sql_clm_plg_allwd_flg != 'Y' && sql_clm_plg_allwd_flg != 'W')
			{
				fn_userlog(c_ServiceName, "At present the facility of Shares as Margin has been suspended");
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "At present the facility of Shares as Margin has been suspended", 0 ); 
/**			l_acnt_id = -1;
				Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
				Fadd32( ptr_fml_Ibuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
      	tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      	tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
		}
			
		/***** Commented Ver 2.5 EQ SAM ***********
		EXEC SQL 
		SELECT nvl(STK_PLG_ALLWD,0),nvl(STK_PLG_HAIRCUT,0)   
		INTO :sql_stk_plg_allwd,:sql_stk_plg_haircut
		FROM STK_STK_MSTR 
		WHERE STK_STCK_CD = :sql_stk_stck_cd;	
		******************************************/

		/**** Ver 2.5 EQ SAM****/
		EXEC SQL
    SELECT nvl(STK_PLG_ALLWD,0)
    INTO :sql_stk_plg_allwd
    FROM STK_STK_MSTR
    WHERE STK_STCK_CD = :sql_stk_stck_cd;
		/**** Ver 2.5 ends ****/
			
		if( SQLCODE !=0 )
		{
			fn_errlog( c_ServiceName, "S31320", SQLMSG, c_err_msg  );
			fn_userlog(c_ServiceName, "For stck code : [%s] with len [%ld]",sql_stk_stck_cd,sizeof(sql_stk_stck_cd));
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			tpfree ( ( char * )ptr_fml_Obuf);
      tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}

		/** Ver 2.5 EQ SAM  Get haircut percentage  **/

    i_returncode = fn_get_haircut(c_ServiceName ,
                                  sql_mtch_accnt.arr,
                                  sql_stk_stck_cd,
                                  &sql_stk_plg_haircut,
                                  c_err_msg);

    if(i_returncode == -1)
    {
      fn_errlog( c_ServiceName, "S31325", SQLMSG, c_err_msg  );
      fn_userlog(c_ServiceName, "For stck code : [%s][%ld]",sql_stk_stck_cd,sizeof(sql_stk_stck_cd));
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      tpfree ( ( char * )ptr_fml_Obuf);
      tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

    /** Ver 2.5 ends ***/

		if( sql_stk_plg_haircut == 0)
		{
			fn_errlog( c_ServiceName, "S31330", "Invalid Haircut value ", c_err_msg  );
			fn_userlog(c_ServiceName, "Invalid Haircut value For stck code : [%s]",sql_stk_stck_cd);
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			tpfree ( ( char * )ptr_fml_Obuf);
      tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
		
		if( sql_qty_plg <= 0)
		{
			strcpy( c_err_msg, "Quantity cannot be neagtive or zero"  );
			fn_userlog(c_ServiceName, "Quantity cannot be neagtive or zero ");
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			tpfree ( ( char * )ptr_fml_Obuf);
      tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
		
		if(DEBUG_MSG_LVL_3){
		fn_userlog(c_ServiceName,"The value is STK_PLG_ALLWD is [%c]",sql_stk_plg_allwd);
		fn_userlog(c_ServiceName,"The value is STK_PLG_HAIRCUT is [%ld]",sql_stk_plg_haircut);
		}	

/*******		if (sql_stk_plg_allwd == 'N' || sql_stk_plg_allwd == 'R' )
		{       *****   Commented in Ver 4.1 *****/

			if(sql_stk_plg_allwd == 'N')
			{
				fn_userlog(c_ServiceName, "At present the scrip has been disabled from the facility of Shares as Margin");
				strcpy( c_err_msg, "At present the scrip has been disabled from the facility of Shares as Margin" );
				Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
				Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
      	tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      	tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}

 /**** Commenetd in Ver 4.1 ********
			else
			{
				fn_userlog(c_ServiceName, "Cannot Unblock as the scrip is under revaluation");
				strcpy( c_err_msg, "Cannot Unblock as the scrip is under revaluation");
				Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
				Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
      	tpfree ( ( char * )ptr_fml_Ibuf1);  ** 3.6 **
      	tpfree ( ( char * )ptr_fml_Obuf1);  ** 3.6 **
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
		}
 ******  Comment Ends Ver 4.1 *******/

		EXEC SQL 
		SELECT LTQ_PLG_RT 
		INTO :sql_ltq_plg_rt 
		FROM LTQ_TRD_QT
		WHERE LTQ_STCK_CD = :sql_stk_stck_cd
		AND LTQ_XCHNG_CD = 'BSE'; /* ver 2.1 */
				
		if (SQLCODE != 0)
		{
			fn_errlog( c_ServiceName, "S31335", SQLMSG, c_err_msg  );
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			tpfree ( ( char * )ptr_fml_Obuf);
      tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
		
		EXEC SQL 
		SELECT nvl(DBD_TOT_QTY,0),
		nvl(DBD_QTY_BLCKD,0),
		/***	nvl(DBD_PLG_REQ_QTY,0),
		nvl(DBD_TIFP_QTY,0),nvl(DBD_REV_REQ_QTY,0),
		nvl(DBD_REV_COV_QTY,0),nvl(DBD_INV_REQ_QTY,0),
		nvl(DBD_INV_COV_QTY,0), **** Commented and added for Ver 3.2 ***/
		/** Added for Ver 4.4 **/
		nvl(DBD_PLG_REQ_QTY,0),
		nvl(DBD_REV_REQ_QTY,0),
		nvl(DBD_REV_COV_QTY,0),
		nvl(DBD_INV_REQ_QTY,0),
		nvl(DBD_INV_COV_QTY,0), 
		/*** Ver 4.4 ***/
		nvl(DBD_SAM_BLCKD_QTY,0),
		nvl(DBD_BLOCK_FOR_SALE,0),
		DBD_ISIN_NMBR
		INTO :sql_dbd_tot_qty,:sql_dbd_qty_blckd,
		/**	:sql_dbd_plg_req_qty,
		:sql_dbd_tifp_qty,:sql_dbd_rev_req_qty,:sql_dbd_rev_cov_qty,
		:sql_dbd_inv_req_qty,:sql_dbd_inv_cov_qty, *** Commented and added for Ver 3.2 ***/
		/*** Added for Ver 4.4 ***/
		:sql_dbd_plg_req_qty,
		:sql_dbd_rev_req_qty,:sql_dbd_rev_cov_qty,
		:sql_dbd_inv_req_qty,:sql_dbd_inv_cov_qty,
		/*** Ver 4.4 ***/
		:sql_dbd_sam_blckd_qty,
		:sql_dbd_block_for_sale,
		:sql_dbd_isin_nmbr
		FROM DBD_DP_BLCK_DTLS
		WHERE DBD_STCK_CD = :sql_stk_stck_cd
		AND DBD_CLM_MTCH_ACCNT = :sql_mtch_accnt
		AND DBD_DP_ID = :sql_dbd_dp_id
		AND DBD_DP_CLNT_ID = :sql_dbd_dp_clnt_id;

		if (SQLCODE != 0)
		{
			fn_errlog( c_ServiceName, "S31340", SQLMSG, c_err_msg  );
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			tpfree ( ( char * )ptr_fml_Obuf);
      tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}	
		
		if(DEBUG_MSG_LVL_3){
		fn_userlog(c_ServiceName,"The value of DBD_TOT_QTY is [%ld]",sql_dbd_tot_qty);
		fn_userlog(c_ServiceName,"The value of DBD_QTY_BLCKD is [%ld]",sql_dbd_qty_blckd);
		/*** Uncommented for Ver 4.4 ***/
		fn_userlog(c_ServiceName,"The value of DBD_PLG_REQ_QTY is [%ld]",sql_dbd_plg_req_qty);
		/** fn_userlog(c_ServiceName,"The value of DBD_TIFP_QTY is [%ld]",sql_dbd_tifp_qty); ** Ver 4.4 **/
		fn_userlog(c_ServiceName,"The value of DBD_REV_REQ_QTY is [%ld]",sql_dbd_rev_req_qty);
		fn_userlog(c_ServiceName,"The value of DBD_REV_COV_QTY is [%ld]",sql_dbd_rev_cov_qty);
		fn_userlog(c_ServiceName,"The value of DBD_INV_REQ_QTY is [%ld]",sql_dbd_inv_req_qty);
		fn_userlog(c_ServiceName,"The value of DBD_INV_COV_QTY is [%ld]",sql_dbd_inv_cov_qty); /*** Commented for Ver 3.2 ***/
		fn_userlog(c_ServiceName,"The value of DBD_SAM_BLCKD_QTY is [%ld]",sql_dbd_sam_blckd_qty);
		fn_userlog(c_ServiceName,"The value of DBD_BLOCK_FOR_SALE is [%ld]",sql_dbd_block_for_sale);
		}

  	/** Added in ver 1.9 **/
/*** Commented for Ver 3.2 ****
  	if(sql_dbd_block_for_sale > 0)		
		{
			fn_userlog(c_ServiceName,"You have a Spot Sell request pending, Cannot place Fresh Withdrawal. Match Id :%s: Stock Code :%s:",sql_mtch_accnt.arr,sql_stk_stck_cd);
	    sprintf(c_err_msg,"You have a Spot Sell request pending, Cannot place Fresh Withdrawal.");		
			fn_errlog( c_ServiceName, "B56051", "", c_err_msg  );
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			tpfree ( ( char * )ptr_fml_Obuf);
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}

		EXEC SQL
		SELECT 1
		INTO    :i_order_exists
		from dual
		WHERE EXISTS
		(
		SELECT 1 FROM POD_PLG_ORDR_DTLS
		WHERE POD_CLNT_MTCH_ACCNT = :sql_mtch_accnt
		AND POD_DP_ACCNT = :sql_dbd_dp_id
		AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
		AND POD_PLG_REV_TYP = 'I'
		AND (POD_ORDR_STTS = 'R' OR POD_ORDR_STTS = 'I')
		AND POD_STCK_CD = :sql_stk_stck_cd
		);

		if ((SQLCODE != 0) && (SQLCODE != NO_DATA_FOUND))
  	{
      fn_errlog( c_ServiceName, "S31345", SQLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      tpfree ( ( char * )ptr_fml_Obuf);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }	

		if(i_order_exists == 1)
		{
		fn_userlog(c_ServiceName,"You have an Invocation request pending, Cannot place Fresh Withdrawal. Match Id :%s: Stock Code :%s:",sql_mtch_accnt.arr,sql_stk_stck_cd);
		 sprintf(c_err_msg,"You have an Invocation request pending, Cannot place Fresh Withdrawal.");
		 fn_errlog( c_ServiceName, "B56052", "", c_err_msg  );
		 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
		 tpfree ( ( char * )ptr_fml_Obuf);
		 tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	  }

		********* Withdrawal inprocess request pending ******************

	  EXEC SQL
    SELECT 1
    INTO    :i_inorder_exists
    from dual
    WHERE EXISTS
    (
    SELECT 1 FROM POD_PLG_ORDR_DTLS
    WHERE POD_CLNT_MTCH_ACCNT = :sql_mtch_accnt
    AND POD_DP_ACCNT = :sql_dbd_dp_id
    AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
    AND POD_PLG_REV_TYP = 'W'
    AND (POD_ORDR_STTS = 'I')
    AND POD_STCK_CD = :sql_stk_stck_cd
    );

    if ((SQLCODE != 0) && (SQLCODE != NO_DATA_FOUND))
    {
      fn_errlog( c_ServiceName, "S31350", SQLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      tpfree ( ( char * )ptr_fml_Obuf);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

	   if(i_inorder_exists == 1)
    {
    fn_userlog(c_ServiceName,"You have an withdrawal inprocess request pending, Cannot place Fresh Withdrawal. Match Id :%s: Stock Code :%s:",sql_mtch_accnt.arr,sql_stk_stck_cd);
     sprintf(c_err_msg,"You have an withdrawal request pending, Cannot place Fresh Withdrawal.");
     fn_errlog( c_ServiceName, "B56056", "", c_err_msg  );
     Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
     tpfree ( ( char * )ptr_fml_Obuf);
     tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
		

		EXEC SQL
		SELECT nvl(sum(pod_ordr_qty),0) into :l_pod_ordr_qty
		FROM POD_PLG_ORDR_DTLS
		WHERE POD_CLNT_MTCH_ACCNT = :sql_mtch_accnt
		AND POD_DP_ACCNT = :sql_dbd_dp_id
		AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
		AND POD_PLG_REV_TYP = 'P'
		AND POD_ORDR_STTS = 'I'
		AND POD_STCK_CD = :sql_stk_stck_cd;

		if ((SQLCODE != 0) && (SQLCODE != NO_DATA_FOUND))
    {
      fn_errlog( c_ServiceName, "S31355", SQLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      tpfree ( ( char * )ptr_fml_Obuf);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }



    l_conf_qty = sql_dbd_tifp_qty - l_pod_ordr_qty - sql_dbd_rev_req_qty;

		fn_userlog(c_ServiceName,"Withdrawal request = :%d: and l_conf_qty = :%ld:",sql_qty_plg,l_conf_qty);
		
		if(sql_qty_plg > l_conf_qty)
		{
	
		 fn_userlog(c_ServiceName,"You have only :%ld: confirmed quantity in Pledge. Please place withdrawal for lesser quantity. For match :%s: and stock code :%s:",l_conf_qty,sql_mtch_accnt.arr,sql_stk_stck_cd);				   
		**sprintf(c_err_msg,"You have only %ld confirmed quantity in Pledge. Please place withdrawal for lesser quantity.",l_conf_qty); *** ver 2.5 **
		sprintf(c_err_msg,"Your withdrawal request is more than the confirmed quantity pledged. Please place withdrawal request for less than or equal to confirmed quantity pledged."); ** Ver 2.5 **
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
		tpfree ( ( char * )ptr_fml_Obuf);
		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	 }
		********* Ver 3.2 ***/ 

		/** Added for Ver 4.4 ***/
    l_conf_qty = sql_dbd_sam_blckd_qty - sql_dbd_rev_req_qty - sql_dbd_rev_cov_qty;

		fn_userlog(c_ServiceName,"Withdrawal request = :%d: and l_conf_qty = :%ld:",sql_qty_plg,l_conf_qty);
		
		if(sql_qty_plg > l_conf_qty)
		{
	
		 fn_userlog(c_ServiceName,"You have only :%ld: confirmed quantity in Pledge. Please place withdrawal for lesser quantity. For match :%s: and stock code :%s:",l_conf_qty,sql_mtch_accnt.arr,sql_stk_stck_cd);				   
		/**sprintf(c_err_msg,"You have only %ld confirmed quantity in Pledge. Please place withdrawal for lesser quantity.",l_conf_qty); *** ver 2.5 **/
		sprintf(c_err_msg,"Your withdrawal request is more than the confirmed quantity pledged. Please place withdrawal request for less than or equal to confirmed quantity pledged."); /** Ver 2.5 **/
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
		tpfree ( ( char * )ptr_fml_Obuf);
		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	 }
		/** Ver 4.4 **/
		/*ver 1.9 ends **/

		/* 2.2 Has been moved up

		/1.2 starts/
		i_err[0] = Fget32(ptr_fml_Ibuf,FML_PLG_FLG,0,(char *)&c_force_flag,0);

		if((i_err[0] == -1) && (Ferror32 != FNOTPRES))
  	{
    	fn_errlog( c_ServiceName, "S31360", FMLMSG, c_err_msg  );
  	l_acnt_id = -1;
    	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	}
		
		if(Ferror32 == FNOTPRES)
		{
			c_force_flag = 'N';
		}

		fn_userlog(c_ServiceName,"The Force Withdrawal flag is [%c]",c_force_flag);

		end of 2.2 */
		
		if(c_force_flag != 'F')
		{ /*1.2 ends*/
			/*** Commented for Ver 3.2 ****
			if(sql_dbd_plg_req_qty > 0)
			{
				fn_userlog(c_ServiceName,"The Pledge request quantity is [%ld]. Hence rejected.",sql_dbd_plg_req_qty);
				strcpy(c_err_msg,"There is a pending pledge request present.Please cancel/modify the same.");
				Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
				Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
			*** Commented for Ver 3.2 ****/
		}/*end if of force flag 1.2*/


		/*li_tot_blck_qty = (sql_dbd_rev_req_qty + sql_dbd_rev_cov_qty + sql_dbd_inv_req_qty + sql_dbd_inv_cov_qty + sql_dbd_block_for_sale);*/

		/*** Commented for Ver 3.2 ****
		li_tot_blck_qty = (sql_dbd_rev_req_qty + sql_dbd_rev_cov_qty + sql_dbd_inv_req_qty + sql_dbd_inv_cov_qty );

		if((sql_dbd_tifp_qty - li_tot_blck_qty) < sql_qty_plg)
		{
			fn_userlog(c_ServiceName,"The value in tifp is [%ld] and in rest is [%ld]",sql_dbd_tifp_qty,li_tot_blck_qty); 
			fn_userlog(c_ServiceName,"The free quantity for withdrawal is less than that requested"); 
			strcpy(c_err_msg,"The free quantity for withdrawal is less than that requested");
			Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
			Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
			tpfree ( ( char * )ptr_fml_Obuf);
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
		*** Commented for Ver 3.2 ****/
			/*The following variable will be used to hold the value of the stock withdrawal*/	

		/*** Log added in 2.4 *****/

    if(DEBUG_MSG_LVL_3){
    fn_userlog(c_ServiceName,"sql_qty_plg :%ld:",sql_qty_plg);
    fn_userlog(c_ServiceName,"sql_stk_plg_haircut :%ld:",sql_stk_plg_haircut);
    fn_userlog(c_ServiceName,"sql_ltq_plg_rt :%lf:",sql_ltq_plg_rt);
    }

		sql_stck_plg_val = (sql_qty_plg * (sql_ltq_plg_rt *(1 - ((double)(sql_stk_plg_haircut)/100))))*100; /*diwa
 typecast float to double **/

		if((long long)(sql_stck_plg_val * 100)%100 > 50)
		{
			sql_stck_plg_val = sql_stck_plg_val + 1.0;

			if(DEBUG_MSG_LVL_3){
				fn_userlog( c_ServiceName, "The rounded off amount is [%lf]",sql_stck_plg_val);
			}
		}
					
		ll_stck_plg_val = (long long) sql_stck_plg_val;
		sql_stck_plg_val = (double) ll_stck_plg_val;
		
		if(DEBUG_MSG_LVL_3){
			fn_userlog(c_ServiceName,"The withdraw val is [%lld] for rate [%lf]",ll_stck_plg_val,sql_ltq_plg_rt);
		}

		/*1.2 starts*/

		/** Added for Ver 4.4 ***/
		if(sql_dbd_plg_mode == 'B')
		{
			fn_userlog(c_ServiceName,"The record is for SAM Block Model");
			goto BLOCK_MODEL_W;
		}
		/** Ver 4.4 **/

		/*** Commented for Ver 3.2 ****/ /*** Uncommented for Ver 4.4 ***/
		if(c_force_flag != 'F')
		{	/*1.2ends*/
			/*****The following portion gets the Limits avaliable for the user***/
		
			memset(&st_gt_lmt,'\0' , sizeof( struct vw_gt_lmt_dtls) );
			strcpy(st_gt_lmt.c_xchng_cd , "NFO" );
		
			MEMSET(sql_nxt_trd_dt);

			EXEC SQL 
			SELECT EXG_NXT_TRD_DT 
			INTO :sql_nxt_trd_dt 
			FROM EXG_XCHNG_MSTR
			WHERE EXG_XCHNG_CD = 'NFO';
		
			if (SQLCODE != 0)
			{
				fn_errlog( c_ServiceName, "S31365", SQLMSG, c_err_msg  );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
		
			SETNULL(sql_nxt_trd_dt);
	
			strcpy(st_gt_lmt.c_trd_dt, sql_nxt_trd_dt.arr );
			strcpy(st_gt_lmt.c_cln_mtch_accnt, sql_mtch_accnt.arr);
			l_ip_len = (long) sizeof ( struct vw_gt_lmt_dtls);
			st_gt_lmt.c_rqst_typ = LIMIT_X;
			fn_cpy_ddr ( st_gt_lmt.c_rout_crt );

			/*** Commented by Samip ****
			i_returncode = fn_call_svc( c_ServiceName, c_err_msg, &st_gt_lmt, &st_gt_lmt,
																		"vw_gt_lmt_dtls", "vw_gt_lmt_dtls", l_ip_len,
																		l_ip_len, 0, "SFO_GET_LIMITS" );

			if ( i_returncode == -1 )
			{
				fn_errlog( c_ServiceName, "S31370", LIBMSG, c_err_msg );
				fn_userlog(c_ServiceName,"SFO_GET_LIMITS FAIL  ");
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
			***** By Samip **/

			/*** Added by Samip ****/
      i_returncode = fo_get_trd_limit(c_ServiceName,
                                    st_gt_lmt.c_cln_mtch_accnt,
                                    st_gt_lmt.c_trd_dt,
                                    st_gt_lmt.c_rqst_typ,
                                    st_gt_lmt.c_xchng_cd,
                                    st_gt_lmt.l_gid,
                                    &st_gt_lmt.d_amt,
                                    c_err_msg
                                    );
      if ( i_returncode != SUCC_BFR  )
      {
        fn_errlog( c_ServiceName, "S31375", LIBMSG, c_err_msg  ); /** Changed SQLMSG to LIBMSG in VQC **/
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );        /** .arr added in VQC **/
				tpfree ( ( char * )ptr_fml_Obuf);
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

			/**** By Samip ***/

			if(DEBUG_MSG_LVL_3){
				fn_userlog( c_ServiceName,"NFO Limit Calculated :%lf:",st_gt_lmt.d_amt); /** Ver 2.7 **/
			}

			/*** Ver 2.7  Get the FNO BSE limit. Net fno limit will be minimum of NSE and BSE limit  **************/
			d_nfo_limit = st_gt_lmt.d_amt;

      memset(&st_gt_lmt,'\0' , sizeof( struct vw_gt_lmt_dtls) );
      strcpy(st_gt_lmt.c_xchng_cd , "BFO" );

      MEMSET(sql_nxt_trd_dt);

      EXEC SQL
      SELECT EXG_NXT_TRD_DT
      INTO :sql_nxt_trd_dt
      FROM EXG_XCHNG_MSTR
      WHERE EXG_XCHNG_CD = 'BFO';

      if (SQLCODE != 0)
      {
        fn_errlog( c_ServiceName, "S31380", SQLMSG, c_err_msg  );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        tpfree ( ( char * )ptr_fml_Obuf);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

      SETNULL(sql_nxt_trd_dt);

      strcpy(st_gt_lmt.c_trd_dt, sql_nxt_trd_dt.arr );
      strcpy(st_gt_lmt.c_cln_mtch_accnt, sql_mtch_accnt.arr);
      l_ip_len = (long) sizeof ( struct vw_gt_lmt_dtls);
      st_gt_lmt.c_rqst_typ = LIMIT_X;
      fn_cpy_ddr ( st_gt_lmt.c_rout_crt );

			/*** Commented by Samip ****
      i_returncode = fn_call_svc( c_ServiceName, c_err_msg, &st_gt_lmt, &st_gt_lmt,
                                    "vw_gt_lmt_dtls", "vw_gt_lmt_dtls", l_ip_len,
                                    l_ip_len, 0, "SFO_GET_LIMITS" );

      if ( i_returncode == -1 )
      {
        fn_errlog( c_ServiceName, "S31385", LIBMSG, c_err_msg );
        fn_userlog(c_ServiceName,"SFO_GET_LIMITS FAIL  ");
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
        tpfree ( ( char * )ptr_fml_Obuf);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

			*** By Samip ***/

			/*** Added by Samip ***/

			i_returncode = fo_get_trd_limit(c_ServiceName,
                                    st_gt_lmt.c_cln_mtch_accnt,
                                    st_gt_lmt.c_trd_dt,
                                    st_gt_lmt.c_rqst_typ,
                                    st_gt_lmt.c_xchng_cd,
                                    st_gt_lmt.l_gid,
                                    &st_gt_lmt.d_amt,
                                    c_err_msg
                                    );
      if ( i_returncode != SUCC_BFR  )
      {
        fn_errlog( c_ServiceName, "S31390", LIBMSG, c_err_msg  ); /** Changed SQLMSG to LIBMSG in VQC **/
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );        /** .arr added in VQC **/
        tpfree ( ( char * )ptr_fml_Obuf);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
			/*** By Samip ***/

			d_bfo_limit = st_gt_lmt.d_amt;

			d_net_fno_limit =  MIN(d_nfo_limit,d_bfo_limit);

      if(DEBUG_MSG_LVL_3){
        fn_userlog( c_ServiceName,"BFO Limit Calculated :%lf:",st_gt_lmt.d_amt);
        fn_userlog( c_ServiceName,"Net FNO limit        :%lf:",d_net_fno_limit);
      }
			/****   Ver 2.7 ends **************/

	 		/** check if limit is available for withdrawal **/
			/** Ver 2.5 EQ SAM calculate the free sam limit available to withdraw **/
			/** Free SAM limit is Net withdrawable balance + min(fno limit , fno sam allocation) + equity sam limit **/

			i_returncode = fn_get_eqsam_limit ( c_ServiceName,
                                          sql_mtch_accnt.arr,
                                          &d_eq_sam_limit,
                                          sql_usr_id.arr,
                                          sql_sssn_id,
                                          c_err_msg
                                        );

			if(i_returncode == -1)
      {
				fn_errlog( c_ServiceName, "S31395", LIBMSG, c_err_msg  );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

      /***** Ver 4.9 Starts *****/
      EXEC SQL
      SELECT  nvl(CAB_PLG_AMT,0) * 100
      INTO    :d_cab_cdx_plg_amt
      FROM    CAB_CDX_ALC_BFT_SMRY
      WHERE   CAB_CLM_MTCH_ACCNT = :st_usr_prfl.c_cln_mtch_accnt;  

      if(( SQLCODE !=0 ) && (SQLCODE != NO_DATA_FOUND))
      {
        fn_errlog( c_ServiceName, "S31400", SQLMSG, c_err_msg  );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        tpfree ( ( char * )ptr_fml_Obuf);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

      if(SQLCODE == NO_DATA_FOUND)
      {
        d_cab_cdx_plg_amt = 0;
      }

      if(DEBUG_MSG_LVL_3)
      {
        fn_userlog(c_ServiceName, "The value of plg is [%lf]",d_cab_cdx_plg_amt);
      }

      memset(&st_gt_lmt,'\0' , sizeof( struct vw_gt_lmt_dtls) );
      strcpy(st_gt_lmt.c_xchng_cd , "NDX" );

      MEMSET(sql_nxt_trd_dt);

      EXEC SQL
      SELECT EXG_NXT_TRD_DT
      INTO :sql_nxt_trd_dt
      FROM EXG_XCHNG_MSTR
      WHERE EXG_XCHNG_CD = 'NDX';


      if (SQLCODE != 0)
      {
        fn_errlog( c_ServiceName, "S31405", SQLMSG, c_err_msg  );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        tpfree ( ( char * )ptr_fml_Obuf);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

      SETNULL(sql_nxt_trd_dt);

      strcpy(st_gt_lmt.c_trd_dt, sql_nxt_trd_dt.arr );
      strcpy(st_gt_lmt.c_cln_mtch_accnt, st_usr_prfl.c_cln_mtch_accnt);
      l_ip_len = (long) sizeof ( struct vw_gt_lmt_dtls);
      fn_cpy_ddr ( st_gt_lmt.c_rout_crt );
      st_gt_lmt.l_gid =1;
 
      i_returncode = fn_cdx_get_trd_limit(c_ServiceName,
                                    st_gt_lmt.c_cln_mtch_accnt,
                                    st_gt_lmt.c_trd_dt,
                                    st_gt_lmt.c_xchng_cd,
                                    st_gt_lmt.l_gid,
                                    &st_gt_lmt.d_amt,
                                    c_err_msg
                                    );

      if ( i_returncode != SUCC_BFR  )
      {
        fn_errlog( c_ServiceName, "S31410", SQLMSG, c_err_msg  );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        tpfree ( ( char * )ptr_fml_Obuf);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

      if(DEBUG_MSG_LVL_3){
        fn_userlog( c_ServiceName,"NDX Limit Calculated :%lf:",st_gt_lmt.d_amt);
      }

      d_cdx_limit = st_gt_lmt.d_amt;
			d_cdx_limit = d_cdx_limit * 100;


      EXEC SQL
      SELECT  nvl(CAB_PLG_AMT,0)
      INTO    :d_cab_cod_plg_amt 
      FROM    CAB_COD_ALC_BFT_SMRY
      WHERE   CAB_CLM_MTCH_ACCNT = :st_usr_prfl.c_cln_mtch_accnt;  

      if(( SQLCODE !=0 ) && (SQLCODE != NO_DATA_FOUND))
      {
        fn_errlog( c_ServiceName, "S31415", SQLMSG, c_err_msg  );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        tpfree ( ( char * )ptr_fml_Obuf);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

      if(SQLCODE == NO_DATA_FOUND)
      {
        d_cab_cod_plg_amt  = 0;
      }

      if(DEBUG_MSG_LVL_3)
      {
        fn_userlog(c_ServiceName, "The value of plg is [%lf]",d_cab_cod_plg_amt );
      }

      memset(&st_gt_lmt,'\0' , sizeof( struct vw_gt_lmt_dtls) );
      strcpy(st_gt_lmt.c_xchng_cd , "MCO" );

      MEMSET(sql_nxt_trd_dt);

      EXEC SQL
      SELECT EXG_NXT_TRD_DT
      INTO :sql_nxt_trd_dt
      FROM EXG_XCHNG_MSTR
      WHERE EXG_XCHNG_CD = 'MCO';


      if (SQLCODE != 0)
      {
        fn_errlog( c_ServiceName, "S31420", SQLMSG, c_err_msg  );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        tpfree ( ( char * )ptr_fml_Obuf);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

      SETNULL(sql_nxt_trd_dt);

      strcpy(st_gt_lmt.c_trd_dt, sql_nxt_trd_dt.arr );
      strcpy(st_gt_lmt.c_cln_mtch_accnt, st_usr_prfl.c_cln_mtch_accnt);
      l_ip_len = (long) sizeof ( struct vw_gt_lmt_dtls);
      st_gt_lmt.c_rqst_typ = LIMIT_X;
      fn_cpy_ddr ( st_gt_lmt.c_rout_crt );
 
      i_returncode = fo_cod_get_trd_limit(c_ServiceName,
                                    st_gt_lmt.c_cln_mtch_accnt,
                                    st_gt_lmt.c_trd_dt,
                                    st_gt_lmt.c_rqst_typ,
                                    st_gt_lmt.c_xchng_cd,
                                    st_gt_lmt.l_gid,
                                    &st_gt_lmt.d_amt,
                                    c_err_msg
                                    );

      if ( i_returncode != SUCC_BFR  )
      {
        fn_errlog( c_ServiceName, "S31425", SQLMSG, c_err_msg  );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        tpfree ( ( char * )ptr_fml_Obuf);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

      if(DEBUG_MSG_LVL_3)
      {
        fn_userlog( c_ServiceName,"MCO Limit Calculated :%lf:",st_gt_lmt.d_amt);
      }

      d_mco_limit = st_gt_lmt.d_amt;
      d_fno_min_limit = MIN(sql_fab_plg_amt , d_net_fno_limit );
      d_cdx_min_limit = MIN(d_cab_cdx_plg_amt,d_cdx_limit);
      d_cod_min_limit = MIN(d_cab_cod_plg_amt,d_mco_limit);


      d_free_sam_limit = sql_fab_nwb_amt + d_eq_sam_limit + d_fno_min_limit + d_cdx_min_limit + d_cod_min_limit;

     /** d_free_sam_limit =  sql_fab_nwb_amt + d_eq_sam_limit + MIN(sql_fab_plg_amt , d_net_fno_limit )
                                                            + MIN(d_cab_cdx_plg_amt,d_cdx_limit)
                                                            + MIN(d_cab_cod_plg_amt,d_mco_limit) ; **/
      /***** Ver 4.9 Ends *****/			

			/** d_free_sam_limit = 	sql_fab_nwb_amt + d_eq_sam_limit + MIN(sql_fab_plg_amt , d_net_fno_limit ) ; ** Ver 4.9 **/ /** Ve 2.7 d_net_fno_limit added for st_gt_lmt.d_amt **/

			if(DEBUG_MSG_LVL_3)
      {
        fn_userlog(c_ServiceName,"d_cash_lmt 			= :%lf:",d_eq_sam_limit);
        /**fn_userlog(c_ServiceName,"st_gt_lmt.d_amt = :%lf:",st_gt_lmt.d_amt); ** Ver 2.7 */
        fn_userlog(c_ServiceName,"d_net_fno_limit = :%lf:",d_net_fno_limit); /** Ver 2.7 */
        fn_userlog(c_ServiceName,"sql_fab_plg_amt = :%lf:",sql_fab_plg_amt); 
        fn_userlog(c_ServiceName,"sql_fab_nwb_amt = :%lf:",sql_fab_nwb_amt);
        fn_userlog(c_ServiceName,"d_free_sam_limit= :%lf:",d_free_sam_limit);
      }

			if(sql_stck_plg_val > d_free_sam_limit)
      {
        fn_userlog(c_ServiceName,"The request for withdrawal is [%lf]", sql_stck_plg_val );
        fn_userlog(c_ServiceName,"Free sam limit is [%lf]",d_free_sam_limit );
        fn_userlog(c_ServiceName,"Cannot withdraw this quantity as the limit has been used.");
        /**strcpy(c_err_msg,"Cannot withdraw this quantity as the limit has been used."); ** 2.5**/
        strcpy(c_err_msg,"Please try again as your withdrawal request is more than the free securities limit available."); /** Ver 2.5 **/
        Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
        tpfree ( ( char * )ptr_fml_Obuf);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
			
			/*********** Ver 2.5 EQ SAM ends ************************************/
																				
		}/*end of if for c_force_flag 1.2*/
		
		/** i_pod_cnt = 1; ** Commented for Ver 4.4 **/
		i_pod_cnt = 0;		/** Change from 1 to 0 for Ver 4.4 **/

		/*** Commented and moved below for Ver 4.4 ****
		MEMSET(sql_pod_ordr_qty);    *** Ver 2.6 -Bug Fix ***

		EXEC SQL 
		** SELECT POD_ORDR_QTY, POD_ORDR_VL - Commented In Ver 2.6 ***
		SELECT NVL(POD_ORDR_QTY,0), NVL(POD_ORDR_VL,0)   *** Ver 2.6 ***
		INTO :sql_pod_ordr_qty, :sql_pod_ordr_vl
		FROM POD_PLG_ORDR_DTLS
		WHERE POD_CLNT_MTCH_ACCNT = :sql_mtch_accnt
		AND POD_DP_ACCNT = :sql_dbd_dp_id
		AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
		AND POD_PLG_REV_TYP = 'W'
		AND POD_ORDR_STTS = 'R'
		AND POD_STCK_CD = :sql_stk_stck_cd;

		**** Ver 4.4 ***/

		/** Added for Ver 4.4 ***/
		EXEC SQL
			SELECT 1
    	INTO    :i_pod_cnt
    	from dual
    	WHERE EXISTS(
			SELECT 1
			FROM POD_PLG_ORDR_DTLS
    	WHERE POD_CLNT_MTCH_ACCNT = :sql_mtch_accnt
    	AND POD_DP_ACCNT = :sql_dbd_dp_id
    	AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
    	AND POD_PLG_REV_TYP = 'W'
    	AND POD_ORDR_STTS = 'R'
    	AND POD_STCK_CD = :sql_stk_stck_cd);
		
		if ((SQLCODE != 0) && (SQLCODE != NO_DATA_FOUND))
		{
			fn_errlog( c_ServiceName, "S31430", SQLMSG, c_err_msg  );
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			tpfree ( ( char * )ptr_fml_Obuf);
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}

		if(SQLCODE == NO_DATA_FOUND)
		{
			i_pod_cnt = 0;
			sql_pod_ordr_vl = 0;

			if(DEBUG_MSG_LVL_3){
				fn_userlog(c_ServiceName,"No data Found for existing withdraw request");
			}
		}

		i_trnsctn = fn_begintran( c_ServiceName, c_err_msg );
			if ( i_trnsctn == -1 )
			{
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				fn_errlog( c_ServiceName, "S31435",LIBMSG,c_err_msg);
				Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
				Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}


	/*Check if there exists any withdraw request that has not been taken for DP processing
	if found, then the original withdrawal request is updated*/

		if (i_pod_cnt > 0)
		{
			if(DEBUG_MSG_LVL_3){
				fn_userlog(c_ServiceName,"The dbd_rev_req_qty is [%ld], dbd_rev_cov_qty is [%ld] and pod_cnt is [%d]",sql_dbd_rev_req_qty, sql_dbd_rev_cov_qty,i_pod_cnt);
			}
			/** Added for Ver 4.4 ***/
			sql_pod_ordr_qty = 0;

			EXEC SQL 
				SELECT NVL(POD_ORDR_QTY,0), NVL(POD_ORDR_VL,0),POD_ORDR_NO
				INTO :sql_pod_ordr_qty, :sql_pod_ordr_vl,sql_pod_ordr_no
				FROM POD_PLG_ORDR_DTLS
				WHERE POD_CLNT_MTCH_ACCNT = :sql_mtch_accnt
				AND POD_DP_ACCNT = :sql_dbd_dp_id
				AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
				AND POD_PLG_REV_TYP = 'W'
				AND POD_ORDR_STTS = 'R'
				AND POD_STCK_CD = :sql_stk_stck_cd
				AND ROWNUM < 2;

			if (SQLCODE != 0)
      {
        fn_errlog( c_ServiceName, "S31440", SQLMSG, c_err_msg  );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        tpfree ( ( char * )ptr_fml_Obuf);
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

			SETNULL(sql_pod_ordr_no);
			/** Ver 4.4 **/

			sql_pml_mod_type ='M';
			MEMSET(sql_pml_rmrks);
			strcpy(sql_pml_rmrks.arr,"Auto - Modify for Addl. Withdrawal");
			SETLEN(sql_pml_rmrks);

			EXEC SQL SELECT PRS_PLG_REV_SEQ.nextval INTO :sql_prs_seq
			FROM DUAL;
		
			if (SQLCODE != 0)
			{
				fn_errlog( c_ServiceName, "S31445", SQLMSG, c_err_msg  );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}

			EXEC SQL 
			UPDATE POD_PLG_ORDR_DTLS SET
			POD_ORDR_QTY = POD_ORDR_QTY + :sql_qty_plg,
			POD_HAIRCUT = :sql_stk_plg_haircut,
			POD_ORDR_VL = POD_ORDR_VL + :sql_stck_plg_val,
			POD_RMRKS = :sql_pml_rmrks
			WHERE POD_CLNT_MTCH_ACCNT = :sql_mtch_accnt
			AND POD_DP_ACCNT = :sql_dbd_dp_id
			AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
			AND POD_PLG_REV_TYP = 'W'
			AND POD_ORDR_STTS = 'R'
			AND POD_STCK_CD = :sql_stk_stck_cd
			AND POD_ORDR_NO = :sql_pod_ordr_no		/** Added for Ver 4.4 **/
			RETURNING POD_ORDR_VL,POD_ORDR_QTY 								/** POD_ORDR_NO removed from Return for Ver 4.4 **/
			INTO :sql_pod_ordr_vl,:l_plg_prcs_qty;

			if (SQLCODE != 0)
			{
				fn_errlog( c_ServiceName, "S31450", SQLMSG, c_err_msg  );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);	
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
						
			/** SETNULL(sql_pod_ordr_no); ** Commented and moved up for Ver 4.4 **/
			
			if(DEBUG_MSG_LVL_3){
				fn_userlog(c_ServiceName,"The returned Old order ref number is [%s]",sql_pod_ordr_no.arr);
				fn_userlog(c_ServiceName,"The returned Old order value is [%lf]",sql_pod_ordr_vl);
			}

			EXEC SQL 
			SELECT (COUNT(*)+1) 
			INTO :sql_pml_mod_cntr
			FROM PML_PLG_MOD_LOG
			WHERE PML_ORDR_NO = :sql_pod_ordr_no
			AND PML_CLNT_MTCH_ACCNT = :sql_mtch_accnt
			AND PML_DP_ACCNT = :sql_dbd_dp_id
			AND PML_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
			AND PML_PLG_REV_TYP = 'W'
			AND PML_MOD_TYPE IN ('N','M','C');

			if (SQLCODE != 0)
			{
				fn_errlog( c_ServiceName, "S31455", SQLMSG, c_err_msg  );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}	
		}
		/*end of if for sql_dbd_rev_req_qty > 0*/
		/*Else new order for withdraw*/

		else
		{
			EXEC SQL 
			SELECT PRS_PLG_REV_SEQ.nextval 
			INTO :sql_prs_seq
			FROM DUAL;

			if (SQLCODE != 0)
			{
				fn_errlog( c_ServiceName, "S31460", SQLMSG, c_err_msg  );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}

			EXEC SQL 
			SELECT TO_CHAR(sysdate,'YYYYMMDD')||LPAD((PPS_PLG_SEQ+1),8,0)
			INTO :sql_pod_ordr_no
			FROM PPS_PLG_PLACED_SEQ 
			WHERE PPS_PLG_ORDR_DT = TO_DATE(TO_CHAR(sysdate,'DD-Mon-YYYY'),'DD-Mon-YYYY')
      FOR UPDATE OF PPS_PLG_SEQ;  /** For update added in Ver 4.5 **/

			if ((SQLCODE != 0) && (SQLCODE != NO_DATA_FOUND))
			{
				fn_errlog( c_ServiceName, "S31465", SQLMSG, c_err_msg  );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}

      /* Ver 1.6 */
      SETNULL(sql_pod_ordr_no);
			
			if (SQLCODE == NO_DATA_FOUND)
			{
				EXEC SQL 
				INSERT INTO PPS_PLG_PLACED_SEQ
				(PPS_PLG_SEQ,
				PPS_PLG_ORDR_DT)
				VALUES
				(1,
				TO_DATE(TO_CHAR(sysdate,'DD-Mon-YYYY'),'DD-Mon-YYYY'));
				
				if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31470", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
						
				EXEC SQL 
				SELECT TO_CHAR(sysdate,'YYYYMMDD')||LPAD(1,8,0) 
				INTO :sql_pod_ordr_no
				FROM DUAL;

				if (SQLCODE != 0)
				{
					fn_errlog( c_ServiceName, "S31475", SQLMSG, c_err_msg  );
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
					tpfree ( ( char * )ptr_fml_Obuf);
					fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
        /* Ver 1.6 */
        SETNULL(sql_pod_ordr_no);
		
			}
			else
			{
				EXEC SQL 
				UPDATE PPS_PLG_PLACED_SEQ SET 
				PPS_PLG_SEQ = PPS_PLG_SEQ +1
				WHERE PPS_PLG_ORDR_DT = TO_DATE(TO_CHAR(sysdate,'DD-Mon-YYYY'),'DD-Mon-YYYY');
		
				if (SQLCODE != 0)
				{
					fn_errlog( c_ServiceName, "S31480", SQLMSG, c_err_msg  );
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
					tpfree ( ( char * )ptr_fml_Obuf);
					fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
			}
						
			EXEC SQL INSERT INTO POD_PLG_ORDR_DTLS
			(POD_ORDR_NO,
			POD_STCK_CD,
			POD_ORDR_QTY,
			POD_ORDR_DT,
			POD_HAIRCUT,
			POD_ORDR_VL,
			POD_ISIN_NO,
			POD_DP_CLNT_ACCNT,
			POD_DP_ACCNT,
			POD_CLNT_MTCH_ACCNT ,
			POD_PLG_REV_TYP,
			POD_ORDR_STTS,
			POD_CONF_QTY,
      POD_PRCSD_QTY,               /*******1.3*****/
			POD_RMRKS,
			POD_BP_ID,
			POD_CHANNEL,
			POD_ALLOC_TYP )       /*** ver 4.7 ***/
			VALUES
			(:sql_pod_ordr_no,
			:sql_stk_stck_cd,
			:sql_qty_plg,
			sysdate,
			:sql_stk_plg_haircut,
			:sql_stck_plg_val,
			:sql_dbd_isin_nmbr,
			:sql_dbd_dp_clnt_id,
			:sql_dbd_dp_id,
			:sql_mtch_accnt,
			'W',
			'R',
			0,
      0,                         /*******1.3*****/
			null,
			:sql_pod_bp_id,
			:sql_pml_channel,
			:sql_req_typ);    /*** ver 4.7 ***/	
			
			if (SQLCODE != 0)
						{
				fn_errlog( c_ServiceName, "S31485", SQLMSG, c_err_msg  );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
			
			sql_pml_mod_type ='N';
			sql_pml_mod_cntr = 1;
			MEMSET(sql_pml_rmrks);
	/*Commented as not required by Product Team
			strcpy(sql_pml_rmrks.arr,"New Withdrawal Request");
			SETLEN(sql_pml_rmrks);*/

			sql_pod_ordr_vl = sql_stck_plg_val; /** Ver 4.4 **/
			l_plg_prcs_qty = sql_qty_plg;   /** Added for 4.4 **/

		}/* end of else for new withdrawal order*/

		fn_userlog(c_ServiceName,"New quantity for Unpledge is :%ld:",l_plg_prcs_qty);		/** Ver 4.4 **/

			EXEC SQL 
			UPDATE DBD_DP_BLCK_DTLS SET
			DBD_REV_REQ_QTY = DBD_REV_REQ_QTY + :sql_qty_plg
			WHERE DBD_STCK_CD = :sql_stk_stck_cd
			AND DBD_CLM_MTCH_ACCNT = :sql_mtch_accnt
			AND DBD_DP_ID = :sql_dbd_dp_id
			AND DBD_DP_CLNT_ID = :sql_dbd_dp_clnt_id;
			
			if (SQLCODE != 0)
			{
				fn_errlog( c_ServiceName, "S31490", SQLMSG, c_err_msg  );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
		
			EXEC SQL INSERT INTO DLD_DP_LOG_DTLS
			(DLD_CLM_MTCH_ACCNT,
			DLD_DP_ID,
			DLD_DP_CLNT_ID,
			DLD_ISIN_NMBR,
			DLD_STCK_CD,
			DLD_TOT_QTY_CHG,
			DLD_QTY_BLCKD_CHG,
			DLD_PLG_REQ_QTY_CHG,
			/** DLD_TIFP_QTY_CHG, ** Commented for Ver 4.4 **/
			DLD_SAM_BLCKD_QTY_CHG,	/** Ver 4.4 **/
			DLD_REV_COV_QTY_CHG,
			DLD_REV_REQ_QTY_CHG,
			DLD_CHG_TM,
			DLD_BLK_FR_SALE_CHG,
			DLD_INV_REQ_QTY_CHG,
			DLD_INV_COV_QTY_CHG,
			DLD_RMRKS)
			VALUES
			(:sql_mtch_accnt,
			:sql_dbd_dp_id,
			:sql_dbd_dp_clnt_id,
			:sql_dbd_isin_nmbr,
			:sql_stk_stck_cd,
			:sql_dbd_tot_qty,
			:sql_dbd_qty_blckd,
			0,
			0,
			0,
			:sql_qty_plg,
			sysdate,
			0,
			0,
			0,
			'Withdraw Placement');


			if (SQLCODE != 0)
			{
				fn_errlog( c_ServiceName, "S31495", SQLMSG, c_err_msg  );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
	
			EXEC SQL UPDATE POD_PLG_ORDR_DTLS SET
			POD_CONF_QTY = POD_CONF_QTY + :sql_qty_plg
			WHERE  POD_DP_ACCNT = :sql_dbd_dp_id
			AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
			AND POD_PLG_REV_TYP = 'W'
			AND POD_ORDR_STTS = 'R'
			AND POD_STCK_CD = :sql_stk_stck_cd
			AND POD_ORDR_NO = TRIM(:sql_pod_ordr_no);

			if (SQLCODE != 0)
			{
				fn_errlog( c_ServiceName, "S31500", SQLMSG, c_err_msg  );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
		

		/*** Commented for Ver 4.4 ***

		c_cov_plc_flg = 'N';

		EXEC SQL 
		SELECT nvl(PPS_L1_POS,0), nvl(PPS_L5_POS,0)
		INTO :sql_pps_l1_pos,:sql_pps_l5_pos
		FROM PPS_PLG_PSTN
		WHERE PPS_CLM_MTCH_ACCNT = :sql_mtch_accnt
		AND PPS_STCK_CD = :sql_stk_stck_cd
		AND PPS_DP_ACCNT = :sql_dbd_dp_id
		AND PPS_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id;

		if ((SQLCODE != 0) && (SQLCODE != NO_DATA_FOUND))
		{
			fn_errlog( c_ServiceName, "S31505", SQLMSG, c_err_msg  );
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			tpfree ( ( char * )ptr_fml_Obuf);
			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
	*No data found in PPS_PLG_PSTN means Run TIFP (sfo_prcs_tifp) has not been done for the
	pledge stocks. Hence the records have to be updated in Cover qty*


		if(SQLCODE == NO_DATA_FOUND)
		{
			c_cov_plc_flg = 'Y';
			sql_pps_l5_pos = 0 ;
			sql_pps_l1_pos = 0 ;
		}

		if(DEBUG_MSG_LVL_3){
		fn_userlog(c_ServiceName,"The value of PPS_L5_POS is [%ld] and PPS_L1_POS is [%ld]",sql_pps_l5_pos,sql_pps_l1_pos);
		}

		if ((sql_qty_plg + sql_dbd_rev_req_qty) <= sql_pps_l5_pos)
		{
			EXEC SQL 
			UPDATE DBD_DP_BLCK_DTLS SET
			DBD_REV_REQ_QTY = DBD_REV_REQ_QTY + :sql_qty_plg
			WHERE DBD_STCK_CD = :sql_stk_stck_cd
			AND DBD_CLM_MTCH_ACCNT = :sql_mtch_accnt
			AND DBD_DP_ID = :sql_dbd_dp_id
			AND DBD_DP_CLNT_ID = :sql_dbd_dp_clnt_id;
			
			if (SQLCODE != 0)
			{
				fn_errlog( c_ServiceName, "S31510", SQLMSG, c_err_msg  );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
		
			EXEC SQL INSERT INTO DLD_DP_LOG_DTLS
			(DLD_CLM_MTCH_ACCNT,
			DLD_DP_ID,
			DLD_DP_CLNT_ID,
			DLD_ISIN_NMBR,
			DLD_STCK_CD,
			DLD_TOT_QTY_CHG,
			DLD_QTY_BLCKD_CHG,
			DLD_PLG_REQ_QTY_CHG,
			** DLD_TIFP_QTY_CHG, ** Commented for Ver 4.4 **
			DLD_SAM_BLCKD_QTY_CHG,	** Ver 4.4 **
			DLD_REV_COV_QTY_CHG,
			DLD_REV_REQ_QTY_CHG,
			DLD_CHG_TM,
			DLD_BLK_FR_SALE_CHG,
			DLD_INV_REQ_QTY_CHG,
			DLD_INV_COV_QTY_CHG,
			DLD_RMRKS)
			VALUES
			(:sql_mtch_accnt,
			:sql_dbd_dp_id,
			:sql_dbd_dp_clnt_id,
			:sql_dbd_isin_nmbr,
			:sql_stk_stck_cd,
			:sql_dbd_tot_qty,
			:sql_dbd_qty_blckd,
			0,
			0,
			0,
			:sql_qty_plg,
			sysdate,
			0,
			0,
			0,
			'Withdraw Placement');


			if (SQLCODE != 0)
			{
				fn_errlog( c_ServiceName, "S31515", SQLMSG, c_err_msg  );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
	
			EXEC SQL UPDATE POD_PLG_ORDR_DTLS SET
			POD_CONF_QTY = POD_CONF_QTY + :sql_qty_plg
			WHERE  POD_DP_ACCNT = :sql_dbd_dp_id
			AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
			AND POD_PLG_REV_TYP = 'W'
			AND POD_ORDR_STTS = 'R'
			AND POD_STCK_CD = :sql_stk_stck_cd
			AND POD_ORDR_NO = TRIM(:sql_pod_ordr_no);

			if (SQLCODE != 0)
			{
				fn_errlog( c_ServiceName, "S31520", SQLMSG, c_err_msg  );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
		}
		else
	* that is the withdraw request exceeds the quantity of fully pledged quantity for
	the stock. The exceess quantity is updated in the revoke cover field of the DBD table*
		{
			if( sql_qty_plg > sql_pps_l5_pos + sql_pps_l1_pos)
			{
	* This checks again if the position table and requested quantityy for withdrawal matches*
				
				fn_userlog(c_ServiceName,"The value for withdrawal is [%ld] and in PPS is [%ld]",sql_qty_plg, (sql_pps_l5_pos + sql_pps_l1_pos));
				fn_userlog(c_ServiceName,"The free quantity for withdrawal is less than that requested");
				strcpy(c_err_msg,"The free quantity for withdrawal is less than that requested");
				Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}

			sql_dbd_rev_cov_qty = (sql_qty_plg + sql_dbd_rev_req_qty) - sql_pps_l5_pos;
		
			if(c_cov_plc_flg == 'Y')
			{
				EXEC SQL 
				UPDATE DBD_DP_BLCK_DTLS SET
				DBD_REV_COV_QTY = DBD_REV_COV_QTY + :sql_qty_plg
				WHERE DBD_STCK_CD = :sql_stk_stck_cd
				AND DBD_CLM_MTCH_ACCNT = :sql_mtch_accnt
				AND DBD_DP_ID = :sql_dbd_dp_id
				AND DBD_DP_CLNT_ID = :sql_dbd_dp_clnt_id;

				if (SQLCODE != 0)
			 	{
					fn_errlog( c_ServiceName, "S31525", SQLMSG, c_err_msg  );
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
					tpfree ( ( char * )ptr_fml_Obuf);
					fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
			
			}
			else
			{
				EXEC SQL 
				UPDATE DBD_DP_BLCK_DTLS SET
				DBD_REV_REQ_QTY = :sql_pps_l5_pos,
				DBD_REV_COV_QTY = DBD_REV_COV_QTY + :sql_dbd_rev_cov_qty
				WHERE DBD_STCK_CD = :sql_stk_stck_cd
				AND DBD_CLM_MTCH_ACCNT = :sql_mtch_accnt
				AND DBD_DP_ID = :sql_dbd_dp_id
				AND DBD_DP_CLNT_ID = :sql_dbd_dp_clnt_id;

				if (SQLCODE != 0)
			 	{
					fn_errlog( c_ServiceName, "S31530", SQLMSG, c_err_msg  );
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
					tpfree ( ( char * )ptr_fml_Obuf);
					fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
		
				EXEC SQL UPDATE POD_PLG_ORDR_DTLS SET
				POD_CONF_QTY = :sql_pps_l5_pos
				WHERE  POD_DP_ACCNT = :sql_dbd_dp_id
				AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
				AND POD_PLG_REV_TYP = 'W'
				AND POD_ORDR_STTS = 'R'
				AND POD_STCK_CD = :sql_stk_stck_cd
				AND POD_ORDR_NO = TRIM(:sql_pod_ordr_no);
				
				if (SQLCODE != 0)
			 	{
					fn_errlog( c_ServiceName, "S31535", SQLMSG, c_err_msg  );
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
					tpfree ( ( char * )ptr_fml_Obuf);
					fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}

			}

			if(DEBUG_MSG_LVL_3){
			fn_userlog(c_ServiceName,"The value of Cover qty is [%ld]",sql_dbd_rev_cov_qty);
			}

			EXEC SQL 
			INSERT INTO DLD_DP_LOG_DTLS
			(DLD_CLM_MTCH_ACCNT,
			DLD_DP_ID,
			DLD_DP_CLNT_ID,
			DLD_ISIN_NMBR,
			DLD_STCK_CD,
			DLD_TOT_QTY_CHG,
			DLD_QTY_BLCKD_CHG,
			DLD_PLG_REQ_QTY_CHG,
			** DLD_TIFP_QTY_CHG, *** Commented for ver 4.4 **
			DLD_SAM_BLCKD_QTY_CHG,	** Ver 4.4 **
			DLD_REV_COV_QTY_CHG,
			DLD_REV_REQ_QTY_CHG,
			DLD_CHG_TM,
			DLD_BLK_FR_SALE_CHG,
			DLD_INV_REQ_QTY_CHG,
			DLD_INV_COV_QTY_CHG,
			DLD_RMRKS)
			VALUES
			(:sql_mtch_accnt,
			:sql_dbd_dp_id,
			:sql_dbd_dp_clnt_id,
			:sql_dbd_isin_nmbr,
			:sql_stk_stck_cd,
			:sql_dbd_tot_qty,
			0,
			0,
			0,
			:sql_dbd_rev_cov_qty,
			:sql_pps_l5_pos,
			sysdate,
			0,
			0,
			0,
			'Withdraw Cover Placement');


			if (SQLCODE != 0)
			{
				fn_errlog( c_ServiceName, "S31540", SQLMSG, c_err_msg  );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
		}

		** Commented for Ver 4.4 **/
		
		MEMSET(sql_fab_bnk_accnt);

		/********  Ver 2.5 commented in EQ SAM  ***********************
		EXEC SQL 
		UPDATE FAB_FO_ALC_BFT_SMRY SET
		FAB_PLG_AMT = FAB_PLG_AMT - :sql_stck_plg_val
		WHERE FAB_CLM_MTCH_ACCNT = :sql_mtch_accnt
		RETURNING FAB_BNK_ACCNT,FAB_ALCTD_AMT,FAB_BFT_AMT
		INTO :sql_fab_bnk_accnt,:sql_fab_alctd_amt,:sql_fab_bft_amt;

		if (SQLCODE != 0)
    {
      fn_errlog( c_ServiceName, "S31545", SQLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      tpfree ( ( char * )ptr_fml_Obuf);
      fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

		SETNULL(sql_fab_bnk_accnt);

    EXEC SQL
    INSERT INTO FAL_FO_ALCBFT_LOG
    (FAL_CLM_MTCH_ACCNT,
    FAL_BNK_ACCNT,
    FAL_ALCTD_AMT,
    FAL_BFT_AMT,
    FAL_TRN_DT,
    FAL_OLD_PLG_AMT,
    FAL_PLG_CHG_AMT,
    FAL_NARRATION)
    VALUES
    (:sql_mtch_accnt,
    :sql_fab_bnk_accnt,
    :sql_fab_alctd_amt,
    :sql_fab_bft_amt,
    sysdate,
    :sql_fab_plg_amt,
    -(:sql_stck_plg_val),
    'WL');

    if (SQLCODE != 0)
    {
      fn_errlog( c_ServiceName, "S31550", SQLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      tpfree ( ( char * )ptr_fml_Obuf);
      fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

		********* Comment 2.5 ends ***************************************/

		/**** Ver 2.5 Starts ******/

		strcpy(c_narration,"WL");

		i_returncode = fn_reduce_sam_limit(c_ServiceName,
																	sql_mtch_accnt.arr,
																	sql_stck_plg_val,
																	c_narration,
																	c_err_msg);
		

		if (i_returncode == -1 )
		{
			fn_errlog( c_ServiceName, "S31555", SQLMSG, c_err_msg  );
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			tpfree ( ( char * )ptr_fml_Obuf);
			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}

		/******** Ver 2.5 Ends *****/
    /** Added for Ver 5.1 **/
    i_returncode = fn_get_prev_sam(c_ServiceName,
                                  sql_mtch_accnt.arr,
                                  c_err_msg);

    if (i_returncode == -1 )
    {
      fn_errlog( c_ServiceName, "S31560", SQLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      tpfree ( ( char * )ptr_fml_Obuf);
      fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
    /*** Ver 5.1 **/
						
		if(DEBUG_MSG_LVL_3){ /** 2.3 **/
		fn_userlog(c_ServiceName,"The PML_STCK_CD is [%s]",sql_stk_stck_cd);
		fn_userlog(c_ServiceName,"The PML_HAIRCUT is [%ld]",sql_stk_plg_haircut);
		fn_userlog(c_ServiceName,"The PML_ORDR_VL is [%lld]",(ll_stck_plg_val + sql_pod_ordr_vl));
		fn_userlog(c_ServiceName,"The PML_DP_CLNT_ACCNT is [%s]",sql_dbd_dp_clnt_id);
		fn_userlog(c_ServiceName,"The PML_DP_ACCNT is [%s]",sql_dbd_dp_id);
		}


		if(DEBUG_MSG_LVL_3){
		fn_userlog(c_ServiceName,"The PML_ORDR_NO is [%s]",sql_pod_ordr_no.arr);
		fn_userlog(c_ServiceName,"The sql_pod_ordr_qty is [%ld]",sql_pod_ordr_qty);    /*** Ver 2.6 ***/
		fn_userlog(c_ServiceName,"The PML_ORDR_QTY is [%ld]",(sql_pod_ordr_qty + sql_qty_plg));
		fn_userlog(c_ServiceName,"The PML_ISIN_NO is [%s]",sql_dbd_isin_nmbr);
		fn_userlog(c_ServiceName,"The PML_CLNT_MTCH_ACCNT is [%s]",sql_mtch_accnt.arr);
		fn_userlog(c_ServiceName,"The PML_MOD_TYPE is [%c]",sql_pml_mod_type);
		fn_userlog(c_ServiceName,"The PML_MOD_CNTR is [%ld]",sql_pml_mod_cntr);
		fn_userlog(c_ServiceName,"The PML_PLCD_SQNC is [%ld]",sql_prs_seq);
		fn_userlog(c_ServiceName,"The PML_CHANNEL is [%s]",sql_pml_channel.arr);
		}	

		EXEC SQL 
		INSERT INTO PML_PLG_MOD_LOG
		(PML_ORDR_NO,
		PML_STCK_CD,
		PML_ORDR_QTY,
		PML_ORDR_TM,
		PML_HAIRCUT,
		PML_ORDR_VL,
		PML_ISIN_NO,
		PML_DP_CLNT_ACCNT,
		PML_DP_ACCNT,
		PML_CLNT_MTCH_ACCNT,
		PML_PLG_REV_TYP,
		PML_MOD_TYPE,
		PML_STTS,
		PML_MOD_CNTR,
		PML_PLCD_SQNC,
		PML_BP_ID,
		PML_CHANNEL,
		PML_RMRKS)
		VALUES
		(:sql_pod_ordr_no,
		:sql_stk_stck_cd,
		(:sql_pod_ordr_qty + :sql_qty_plg),
		sysdate,
		:sql_stk_plg_haircut,
		/** (:sql_pod_ordr_vl + :sql_stck_plg_val), **/
		(:sql_pod_ordr_vl),
		:sql_dbd_isin_nmbr,
		:sql_dbd_dp_clnt_id,
		:sql_dbd_dp_id,
		:sql_mtch_accnt,
		'W',
		:sql_pml_mod_type,
		'R',
		:sql_pml_mod_cntr,
		:sql_prs_seq,	
		:sql_pod_bp_id,
		:sql_pml_channel,
		:sql_pml_rmrks);
		
		if (SQLCODE != 0)
		{
			fn_errlog( c_ServiceName, "S31565", SQLMSG, c_err_msg  );
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			tpfree ( ( char * )ptr_fml_Obuf);
			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}

		if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg ) == -1 )
		{
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 ); 
			tpfree ( ( char * )ptr_fml_Obuf);
			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
			tpreturn ( TPFAIL, ERR_BFR, ( char * )ptr_fml_Ibuf, 0, 0 );
		}

		/*** Commented for Ver 3.2 ****//*** Uncomment end for Ver 4.4 ***/

				/************************** Added in ver 3.2**** Start *******************/

		/** Added for Ver 4.4 ****/
		BLOCK_MODEL_W :

		if( sql_dbd_plg_mode == 'B')
		{
			fn_userlog(c_ServiceName,"Insuder SAM Block Model.");
		/** End for Ver 4.4 **/
		c_bkubk_flg = 'U';

		fn_userlog(c_ServiceName,"Before The Force Withdrawal flag is [%c]",c_force_flag);

	i_err [0] = Fadd32(ptr_fml_Ibuf1,FFO_EBA_MTCH_ACT_NO, (char *)sql_mtch_accnt.arr,0);
  i_err [1] = Fadd32(ptr_fml_Ibuf1,FFO_BK_UBK_FLG, (char *)&c_bkubk_flg,0);
  i_err [2] = Fadd32(ptr_fml_Ibuf1,FFO_USR_ID, (char*)st_usr_prfl.c_user_id,0);
  i_err [3] = Fadd32(ptr_fml_Ibuf1,FFO_STCK_CD, sql_stk_stck_cd ,0);
  i_err [4] = Fadd32(ptr_fml_Ibuf1,FFO_ORD_TOT_QTY, (char *)&sql_qty_plg,0); 
  i_err [5] = Fadd32(ptr_fml_Ibuf1,FFO_DPID, (char *)sql_dbd_dp_id ,0);
  i_err [6] = Fadd32(ptr_fml_Ibuf1,FFO_DP_CLNT_ID, (char *)sql_dbd_dp_clnt_id ,0);
  i_err [7] = Fadd32(ptr_fml_Ibuf1,FFO_CHANNEL, sql_pml_channel.arr,0);
  i_err [8] = Fadd32(ptr_fml_Ibuf1,FFO_SSSN_ID, (char*)&st_usr_prfl.l_session_id,0);
  i_err [9] = Fadd32(ptr_fml_Ibuf1,FML_PLG_FLG, (char*)&c_force_flag,0);
	

  for ( j=0; j < 10; j++ )
  {
    if ( i_err[ j ] == -1 )
    {
      sprintf(c_err_msg, "ERROR : At FML no :%d:",j);
      fn_errlog( c_ServiceName,"S31570",Fstrerror32(i_err[j]),c_err_msg );
      fn_userlog(c_ServiceName,c_err_msg);
      /*** tpfree((char *)ptr_fml_Ibuf); *** Commented for Ver 3.5 ***/
      strcpy( c_err_msg,"Contact System Support" );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );		/*** Ver 3.5 ***/
			tpfree ( ( char * )ptr_fml_Obuf);   /** 3.6 **/
			tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
			tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );		/*** Ver 3.5 ***/
    }
  }

   i_returncode = tpcall( "SFO_SAM_BKUBK",
                      (char*)ptr_fml_Ibuf1,
                      0,
                      (char**)&ptr_fml_Obuf1,
                      &l_ip_len,0);

			if( i_returncode == -1)
  		{
    		if ( tperrno != TPESVCFAIL )
    		{
      		  fn_errlog ( c_ServiceName, "S31575", TPMSG,c_err_msg);
    		}
        fn_errlog( c_ServiceName, "S31580", LIBMSG, c_err_msg );
        Fget32(ptr_fml_Obuf1,FFO_ERR_MSG,0,c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        tpfree ( ( char * )ptr_fml_Obuf);
        tpfree ( ( char * )ptr_fml_Ibuf1);
        tpfree ( ( char * )ptr_fml_Obuf1);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); 

  		}

	i_err[0] = Fget32(ptr_fml_Obuf1,FFO_PLG_ORDR_RFRNC,0,(char *)sql_pod_ordr_no.arr,0);
	i_err[1] = Fget32(ptr_fml_Obuf1,FFO_HAIRCUT ,0,(char *)&sql_stk_plg_haircut,0);
	i_err[2] = Fget32(ptr_fml_Obuf1,FFO_PLG_ORD_VAL,0,(char *)&sql_stck_plg_val,0);
	i_err[3] = Fget32(ptr_fml_Obuf1,FFO_STCK_CD,0,(char *)sql_stk_stck_cd, 0 ); 
	i_err[4] = Fget32(ptr_fml_Obuf1,FFO_ERR_MSG,0,c_err_msg, 0 ); 

  for(j = 0;j < 5; j++)
  {
		if(i_err[j] == -1 )
    {
			fn_errlog( c_ServiceName, "S31585", FMLMSG, c_err_msg  );
      fn_userlog(c_ServiceName, "The Fget32 error  at [%d]",j);
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      tpfree ( ( char * )ptr_fml_Obuf);
      tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
	}
	}		/** Ver 4.4 **/
	/** Added for Ver 4.4 **/
  /*************** Commented in Ver 4.6 ****************
	if( sql_dbd_plg_mode == 'P')
	{
		fn_userlog(c_ServiceName,"Insuder SAM Block Model.");
		** End for Ver 4.4 **
		c_req_conf_flg = 'R';

		fn_userlog(c_ServiceName,"Before The Force Withdrawal flag is [%c]",c_force_flag);

		i_err [0] = Fadd32(ptr_fml_Ibuf1,FFO_EBA_MTCH_ACT_NO, (char *)sql_mtch_accnt.arr,0);
  	i_err [1] = Fadd32(ptr_fml_Ibuf1,FFO_DPID, (char *)sql_dbd_dp_id ,0);
  	i_err [2] = Fadd32(ptr_fml_Ibuf1,FFO_DP_CLNT_ID, (char *)sql_dbd_dp_clnt_id ,0);
  	i_err [3] = Fadd32(ptr_fml_Ibuf1,FFO_STCK_CD, sql_stk_stck_cd ,0);
  	** i_err [4] = Fadd32(ptr_fml_Ibuf1,FFO_TIFP_QTY, (char *)&sql_qty_plg,0); **
  	i_err [4] = Fadd32(ptr_fml_Ibuf1,FFO_TIFP_QTY, (char *)&l_plg_prcs_qty,0);
  	i_err [5] = Fadd32(ptr_fml_Ibuf1,FFO_SPRD_ORD_REF, sql_pod_ordr_no.arr,0);
  	i_err [6] = Fadd32(ptr_fml_Ibuf1,FFO_OPERATION_TYP, (char *)&c_req_conf_flg,0);
  	i_err [7] = Fadd32(ptr_fml_Ibuf1,FFO_PLG_TYP, (char *)&sql_oprn_typ,0);
  	i_err [8] = Fadd32(ptr_fml_Ibuf1,FFO_EXECN_DT, (char *)vc_exec_dt.arr,0);
    i_err [9] = Fadd32(ptr_fml_Ibuf1,FFO_ISIN_NMBR , (char *)sql_dbd_isin_nmbr,0);

  	for ( j=0; j <= 9; j++ )
  	{
    	if ( i_err[ j ] == -1 )
    	{
      	sprintf(c_err_msg, "ERROR : At FML no :%d:",j);
      	fn_errlog( c_ServiceName,"S31590",Fstrerror32(i_err[j]),c_err_msg );
      	fn_userlog(c_ServiceName,c_err_msg);
      	strcpy( c_err_msg,"Contact System Support" );
      	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );		*** Ver 3.5 ***
				tpfree ( ( char * )ptr_fml_Obuf);   ** 3.6 **
				tpfree ( ( char * )ptr_fml_Ibuf1);  ** 3.6 **
				tpfree ( ( char * )ptr_fml_Obuf1);  ** 3.6 **
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );		*** Ver 3.5 ***
    	}
  	}

  	i_returncode = tpcall( "SFO_MRGN_PLG",
                      		(char*)ptr_fml_Ibuf1,
                      		0,
                      		(char**)&ptr_fml_Obuf1,
                      		&l_ip_len,0);

    if( i_returncode == -1)
    {
       if ( tperrno != TPESVCFAIL )
       {
           fn_errlog ( c_ServiceName, "S31595", TPMSG,c_err_msg);
       }
       fn_errlog( c_ServiceName, "S31600", LIBMSG, c_err_msg );
       Fget32(ptr_fml_Obuf1,FFO_ERR_MSG,0,c_err_msg, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
       tpfree ( ( char * )ptr_fml_Obuf);
       tpfree ( ( char * )ptr_fml_Ibuf1);
       tpfree ( ( char * )ptr_fml_Obuf1);
       tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
	}
	** End for Ver 4.4 **
  *************** Commente Ends Ver 4.6 ****************/

		/**************************Added in ver 3.2**** Ends *********************/
		
/**	l_acnt_id = 0; 			 **  Ver 1.7: Commented  ***/
		sprintf(c_err_msg,"Your request has been accepted Request id is %s",sql_pod_ordr_no.arr);

		if(DEBUG_MSG_LVL_3){
			fn_userlog(c_ServiceName,c_err_msg);
		}
		i_counter = 1; 			/** Ver 2.3 **/

		 /***************2.3  Allocate Memory and add to buffer ************************/


			if(DEBUG_MSG_LVL_3){
			fn_userlog(c_ServiceName,"Fneeded32 l_bufferlength :%ld:",Fneeded32( 1, l_bufferlength ));
      fn_userlog(c_ServiceName,"Funused32 ptr_fml_Obuf :%ld:",Funused32( ptr_fml_Obuf ));
			}

        if ( Fneeded32( 1, l_bufferlength ) > Funused32( ptr_fml_Obuf ) )
        {

						fn_userlog(c_ServiceName, " ----In Reallocating loop------");

            i_counter++;

            ptr_fml_temp = ( FBFR32 *)tprealloc( (char *)ptr_fml_Obuf,
                           (Fsizeof32(ptr_fml_Obuf) + (i_counter * l_bufferlength )));


            if ( ptr_fml_temp == NULL )
            {
                fn_errlog( c_ServiceName, "S31605", TPMSG, c_err_msg  );
                fn_userlog(c_ServiceName, "Fail in reallocating");
                Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
                tpfree ( ( char * )ptr_fml_Obuf);
      					tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      					tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
                tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }
						else
						{

								ptr_fml_Obuf = ptr_fml_temp;
                ptr_fml_temp = (FBFR32 *) NULL  ;

						}

        }


        /***************2.3 ends ********************************/


		i_err[0] = Fadd32(ptr_fml_Obuf,FFO_PLG_ORDR_RFRNC,(char *)sql_pod_ordr_no.arr,0);
		i_err[1] = Fadd32(ptr_fml_Obuf,FFO_HAIRCUT ,(char *)&sql_stk_plg_haircut,0);
		i_err[2] = Fadd32(ptr_fml_Obuf,FFO_PLG_ORD_VAL,(char *)&sql_stck_plg_val,0);
		i_err[3] = Fadd32(ptr_fml_Obuf,FFO_ERR_MSG,c_err_msg, 0 ); 
		
    for(j = 0;j < 4; j++)   /********* Ver 1.7 : ERROR CONDITION CHECK ADDED ***********/
    {
      if(i_err[j] == -1 )
      {
        		fn_errlog( c_ServiceName, "S31610", FMLMSG, c_err_msg  );
        		fn_userlog(c_ServiceName, "The Fget32 error  at [%d]",j);
        		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**     		l_acnt_id = -1;
        		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
        		tpfree ( ( char * )ptr_fml_Obuf);
      			tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      			tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
        		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
    }
		/*** Ver 3.2 ***/
		tpfree ( ( char * )ptr_fml_Ibuf1);
		tpfree ( ( char * )ptr_fml_Obuf1);
		/*** Ver 3.2 ***/

		/*** tpfree( (char*)ptr_fml_Ibuf);	*** Ver 3.2 *** *** Commented for Ver 3.5 ***/
		tpreturn( TPSUCCESS, 0, (char *)ptr_fml_Obuf, 0, 0 );

		break;
	}
/* INVOCATION STARTS HERE */
	case 'I': /*** Invoke ****/
	{
		/*** Added for Ver 3.2 ****/
		Finit32(ptr_fml_Ibuf1,(FLDLEN32) Fsizeof32(ptr_fml_Ibuf1));
		Finit32(ptr_fml_Obuf1,(FLDLEN32) Fsizeof32(ptr_fml_Obuf1));
		/*** Ver 3.2 **/
			memset(sql_stk_stck_cd,'\0',sizeof(sql_stk_stck_cd));
			/** MEMSET(c_ordr_rfrnc);			** Ver 4.4 **/

			i_err[5] = Fget32(ptr_fml_Ibuf,FFO_DPID,0,(char *)sql_dbd_dp_id,0);
			i_err[6] = Fget32(ptr_fml_Ibuf,FFO_DP_CLNT_ID,0,(char *)sql_dbd_dp_clnt_id,0);
			i_err[7] = Fget32(ptr_fml_Ibuf,FFO_STCK_CD,0,(char *)sql_stk_stck_cd,0);
			i_err[8] = Fget32(ptr_fml_Ibuf,FFO_ORD_TOT_QTY,0,(char *)&sql_qty_plg,0);
			/** i_err[9] = Fget32(ptr_fml_Ibuf,FFO_ORDR_RFRNC,0,(char *)c_ordr_rfrnc,0);		** Ver 4.4 **/

      for(j = 5;j < 9; j++)		/********* Ver 1.7 : ERROR CONDITION CHECK ADDED ***********/
      {
      	if(i_err[j] == -1 )
        {
        	fn_errlog( c_ServiceName, "S31615", FMLMSG, c_err_msg  );
          fn_userlog(c_ServiceName, "The Fget32 error  at [%d]",j);
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**       l_acnt_id = -1;
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.7: Commented  ***/
          tpfree ( ( char * )ptr_fml_Obuf);
      		tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      		tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      }

			SETLEN(sql_usr_id);
			SETLEN(sql_mtch_accnt);

			/** fn_userlog(c_ServiceName,"Value of c_ordr_rfrnc :%s:",c_ordr_rfrnc);	** Ver 4.4 **/
		
			sql_stk_stck_cd[strlen(sql_stk_stck_cd)+1]='\0';	

   		/*** Added for Ver 4.4 ***/
			MEMSET(sql_dbd_plg_mode);

    	EXEC SQL
      	SELECT NVL(DBD_PLG_MODE,'P')
      	INTO :sql_dbd_plg_mode
      	FROM dbd_dp_blck_dtls
      	WHERE DBD_CLM_MTCH_ACCNT = :sql_mtch_accnt
      	AND DBD_DP_ID = :sql_dbd_dp_id
      	AND DBD_DP_CLNT_ID = :sql_dbd_dp_clnt_id
      	AND DBD_STCK_CD = :sql_stk_stck_cd;

    	if(SQLCODE != 0)
    	{
      	fn_errlog( c_ServiceName, "S31620", SQLMSG, c_err_msg  );
      	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      	tpfree ( ( char * )ptr_fml_Obuf);
      	tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      	tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    	}
    	/** Ver 4.4 **/
			
			if (sql_ppp_plg_opncls_flg == 'N' )
			{
				/* Commented in Ver 2.9 fn_userlog(c_ServiceName, "At present the facility of Shares as Margin has been suspended ");
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "At present the facility of Shares as Margin has been suspended" , 0 ); */
				fn_userlog(c_ServiceName,"Please try blocking later as shares as margin process is underway");   /* Ver 2.9*/
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "Please try blocking later as shares as margin process is underway",0); /* Ver 2.9 */
				tpfree ( ( char * )ptr_fml_Obuf);
      	tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      	tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );	
			}	
		
			if ( sql_clm_plg_allwd_flg == 'N' )
			{
				fn_userlog(c_ServiceName, "At present the facility of Shares as Margin has been suspended");
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "At present the facility of Shares as Margin has been suspended" , 0 ); 
				tpfree ( ( char * )ptr_fml_Obuf);
      	tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      	tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
		
			/***** Commented Ver 2.5 EQ SAM ***********
			EXEC SQL 
			SELECT nvl(STK_PLG_ALLWD,0),nvl(STK_PLG_HAIRCUT,0)   
			INTO :sql_stk_plg_allwd,:sql_stk_plg_haircut
			FROM STK_STK_MSTR 
			WHERE STK_STCK_CD = :sql_stk_stck_cd;	
			******************************************/

			/**** Ver 2.5 EQ SAM****/
    	EXEC SQL
    	SELECT nvl(STK_PLG_ALLWD,0)
    	INTO :sql_stk_plg_allwd
    	FROM STK_STK_MSTR
    	WHERE STK_STCK_CD = :sql_stk_stck_cd;
    	/**** Ver 2.5 ends ****/
				
			if( SQLCODE !=0 )
			{
				fn_errlog( c_ServiceName, "S31625", SQLMSG, c_err_msg  );
				fn_userlog(c_ServiceName, "For stck code : [%s]",sql_stk_stck_cd);
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
      	tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      	tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}

    	/** Ver 2.5 EQ SAM  Get haircut percentage  **/
	
    	i_returncode = fn_get_haircut(c_ServiceName ,
                                  	sql_mtch_accnt.arr,
                                  	sql_stk_stck_cd,
                                  	&sql_stk_plg_haircut,
                                 		c_err_msg);
	
    	if(i_returncode == -1)
    	{
      	fn_errlog( c_ServiceName, "S31630", SQLMSG, c_err_msg  );
      	fn_userlog(c_ServiceName, "For stck code : [%s][%ld]",sql_stk_stck_cd,sizeof(sql_stk_stck_cd));
      	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      	tpfree ( ( char * )ptr_fml_Obuf);
      	tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      	tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    	}

    	/** Ver 2.5 ends ***/

			if (sql_stk_plg_haircut == 0)	
			{
				fn_errlog( c_ServiceName, "S31635", "Invalid Haircut value ", c_err_msg  );
				fn_userlog(c_ServiceName, "Invalid Haircut value For stck code : [%s]",sql_stk_stck_cd);
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
      	tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      	tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
			
			if (sql_qty_plg <= 0)	
			{
				strcpy( c_err_msg, "Quantity cannot be negative or zero" );
				fn_userlog(c_ServiceName, "Quantity cannot be negative or zero");
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
      	tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      	tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}

			if(DEBUG_MSG_LVL_3){
			fn_userlog(c_ServiceName,"The value is STK_PLG_ALLWD is [%c]",sql_stk_plg_allwd);
			fn_userlog(c_ServiceName,"The value is STK_PLG_HAIRCUT is [%ld]",sql_stk_plg_haircut);
			}	
		
 /****			if (sql_stk_plg_allwd == 'N' || sql_stk_plg_allwd == 'R' )
			{     **** Commented in Ver 4.1 ****/
				if(sql_stk_plg_allwd == 'N')
				{
					fn_userlog(c_ServiceName, "At present the scrip has been disabled from the facility of Shares as Margin");
					strcpy( c_err_msg,  "At present the scrip has been disabled from the facility of Shares as Margin" );
					Fadd32( ptr_fml_Obuf,FFO_ERR_MSG, c_err_msg, 0 );
					tpfree ( ( char * )ptr_fml_Obuf);
      		tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      		tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
 /****  commented in Ver 4.1 ****
				else
				{
					fn_userlog(c_ServiceName, "Cannot block as the stock is under revaluation");
					strcpy(c_err_msg, "Cannot bloc k asthe stock is under revaluation" );
					Fadd32( ptr_fml_Obuf,FFO_ERR_MSG, c_err_msg, 0 );
					tpfree ( ( char * )ptr_fml_Obuf);
      		tpfree ( ( char * )ptr_fml_Ibuf1);  ** 3.6 **
      		tpfree ( ( char * )ptr_fml_Obuf1);  ** 3.6 **
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
			}
 ******  Comment Ends Ver 4.1 *****/		
			EXEC SQL 
			SELECT LTQ_PLG_RT 
			INTO :sql_ltq_plg_rt 
			FROM LTQ_TRD_QT
			WHERE LTQ_STCK_CD = :sql_stk_stck_cd
			AND LTQ_XCHNG_CD = 'BSE'; /* ver 2.1 */
					
			if (SQLCODE != 0)
			{
				fn_errlog( c_ServiceName, "S31640", SQLMSG, c_err_msg  );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
      	tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      	tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/				
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
			
			EXEC SQL 
			SELECT nvl(DBD_TOT_QTY,0),
			nvl(DBD_QTY_BLCKD,0),
			/**	nvl(DBD_PLG_REQ_QTY,0),
			nvl(DBD_TIFP_QTY,0),nvl(DBD_REV_REQ_QTY,0),
			nvl(DBD_REV_COV_QTY,0),nvl(DBD_INV_REQ_QTY,0),
			nvl(DBD_INV_COV_QTY,0), *** Commented and added for Ver 3.2 ***/
			/*** Added for Ver 4.4 **/
			nvl(DBD_PLG_REQ_QTY,0),
			nvl(DBD_REV_REQ_QTY,0),
			nvl(DBD_REV_COV_QTY,0),
			nvl(DBD_INV_REQ_QTY,0),
			nvl(DBD_INV_COV_QTY,0),
			/** Ver 4.4 **/
			nvl(DBD_SAM_BLCKD_QTY,0),
			nvl(DBD_BLOCK_FOR_SALE,0),
			DBD_ISIN_NMBR
			INTO :sql_dbd_tot_qty,:sql_dbd_qty_blckd,
			/**	:sql_dbd_plg_req_qty,
			:sql_dbd_tifp_qty,:sql_dbd_rev_req_qty,:sql_dbd_rev_cov_qty,
			:sql_dbd_inv_req_qty,:sql_dbd_inv_cov_qty, **** Commented and added for Ver 3.2 ***/
			/** Added for Ver 4.4 **/
			:sql_dbd_plg_req_qty,
			:sql_dbd_rev_req_qty,:sql_dbd_rev_cov_qty,
			:sql_dbd_inv_req_qty,:sql_dbd_inv_cov_qty, 
			/** Ver 4.4 **/
			:sql_dbd_sam_blckd_qty,
			:sql_dbd_block_for_sale,
			:sql_dbd_isin_nmbr
			FROM DBD_DP_BLCK_DTLS
			WHERE DBD_STCK_CD = :sql_stk_stck_cd
			AND DBD_CLM_MTCH_ACCNT = :sql_mtch_accnt
			AND DBD_DP_ID = :sql_dbd_dp_id
			AND DBD_DP_CLNT_ID = :sql_dbd_dp_clnt_id;
		
			if (SQLCODE != 0)
			{
				fn_errlog( c_ServiceName, "S31645", SQLMSG, c_err_msg  );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
      	tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      	tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}	
			
			if(DEBUG_MSG_LVL_3){
			fn_userlog(c_ServiceName,"The value of DBD_TOT_QTY is [%ld]",sql_dbd_tot_qty);
			fn_userlog(c_ServiceName,"The value of DBD_QTY_BLCKD is [%ld]",sql_dbd_qty_blckd);
			/*** Uncommented for Ver 4.4 ***/
			fn_userlog(c_ServiceName,"The value of DBD_PLG_REQ_QTY is [%ld]",sql_dbd_plg_req_qty);
			/** fn_userlog(c_ServiceName,"The value of DBD_TIFP_QTY is [%ld]",sql_dbd_tifp_qty); ** Commented for Ver 4.4 **/
			fn_userlog(c_ServiceName,"The value of DBD_REV_REQ_QTY is [%ld]",sql_dbd_rev_req_qty);
			fn_userlog(c_ServiceName,"The value of DBD_REV_COV_QTY is [%ld]",sql_dbd_rev_cov_qty);
			fn_userlog(c_ServiceName,"The value of DBD_INV_REQ_QTY is [%ld]",sql_dbd_inv_req_qty);
			fn_userlog(c_ServiceName,"The value of DBD_INV_COV_QTY is [%ld]",sql_dbd_inv_cov_qty); /**** Commented for Ver 3.2 ***/
			fn_userlog(c_ServiceName,"The value of DBD_SAM_BLCKD_QTY is [%ld]",sql_dbd_sam_blckd_qty);	/*** Ver 3.2 ***/
			fn_userlog(c_ServiceName,"The value of DBD_BLOCK_FOR_SALE is [%ld]",sql_dbd_block_for_sale);
			fn_userlog(c_ServiceName,"The value of sql_ltq_plg_rt is [%ld]",sql_ltq_plg_rt);	/*V2.5*/
			}
		
			if(sql_dbd_block_for_sale < sql_qty_plg)
			{
				fn_userlog(c_ServiceName,"The value in Block for sale is [%ld] and requested is [%ld]",sql_dbd_block_for_sale,sql_qty_plg); 
				strcpy(c_err_msg,"The free quantity in block for sale is less than that requested");
				Fadd32( ptr_fml_Obuf,FFO_ERR_MSG, c_err_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
      	tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      	tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
		
			/*The following variable will be used to hold the value of the stock invocation*/	

			/*** Log added in 2.4 *****/

      if(DEBUG_MSG_LVL_3){
      fn_userlog(c_ServiceName,"sql_qty_plg :%ld:",sql_qty_plg);
      fn_userlog(c_ServiceName,"sql_stk_plg_haircut :%ld:",sql_stk_plg_haircut);
      fn_userlog(c_ServiceName,"sql_ltq_plg_rt :%lf:",sql_ltq_plg_rt);
      }
		
			sql_stck_plg_val = (sql_qty_plg * (sql_ltq_plg_rt *(1 - ((double)sql_stk_plg_haircut/100))))*100; /*diwa typecast float to double **/
		
	
			if((long long)(sql_stck_plg_val * 100)%100 > 50)
			{
				sql_stck_plg_val = sql_stck_plg_val + 1.0;

				if(DEBUG_MSG_LVL_3){
					fn_userlog( c_ServiceName, "The rounded off amount is [%lf]",sql_stck_plg_val);
				}
			}
					
			ll_stck_plg_val = (long long) sql_stck_plg_val;		

			sql_stck_plg_val = (double) ll_stck_plg_val;

			/*** Added for Ver 4.4 ***/
			if( sql_dbd_plg_mode == 'B')
			{
				fn_userlog( c_ServiceName, "Record found for SAM Block Model");
				goto BLOCK_MODEL_I;
			}
			/** Ver 4.4 **/

			/*** Uncommented for Ver 4.4 ***/
			/*** Commented for Ver 3.2 ****/
			i_pod_cnt = 0;		/*** Changed from 1 to 0 for Ver 4.4 **/
		
			/*** Commented for Ver 4.4 **
			MEMSET(sql_pod_ordr_qty);    *** Ver 2.6 - Bug Fix ***
	
			EXEC SQL
    	*** SELECT POD_ORDR_QTY, POD_ORDR_VL - commented In Ver 2.6 ***
    	SELECT NVL(POD_ORDR_QTY,0), NVL(POD_ORDR_VL,0)    *** Ver 2.6 ***
    	INTO :sql_pod_ordr_qty, :sql_pod_ordr_vl
    	FROM POD_PLG_ORDR_DTLS
    	WHERE POD_CLNT_MTCH_ACCNT = :sql_mtch_accnt
    	AND POD_DP_ACCNT = :sql_dbd_dp_id
    	AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
    	AND POD_PLG_REV_TYP = 'I'
    	AND POD_ORDR_STTS = 'R'
    	AND POD_STCK_CD = :sql_stk_stck_cd;

			*** Ver 4.4 ***/
			/** Added for Ver 4.4 ***/

			EXEC SQL
				SELECT 1
				INTO :i_pod_cnt
				FROM DUAL
				WHERE EXISTS(SELECT 1 
										FROM POD_PLG_ORDR_DTLS
      							WHERE POD_CLNT_MTCH_ACCNT = :sql_mtch_accnt
      							AND POD_DP_ACCNT = :sql_dbd_dp_id
      							AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
      							AND POD_PLG_REV_TYP = 'I'
      							AND POD_ORDR_STTS = 'R'
      							AND POD_STCK_CD = :sql_stk_stck_cd
                    AND POD_CHANNEL = :sql_pml_channel);    /** Ver 5.0 **/

			/*** Ver 4.4 **/
			
			if ((SQLCODE != 0) && (SQLCODE != NO_DATA_FOUND))
	    {
 	    	fn_errlog( c_ServiceName, "S31650", SQLMSG, c_err_msg  );
 	    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
 	    	tpfree ( ( char * )ptr_fml_Obuf);
 	    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
 		  }

   		if(SQLCODE == NO_DATA_FOUND)
    	{
      	i_pod_cnt = 0;
      	sql_pod_ordr_vl = 0;

				if(DEBUG_MSG_LVL_3){
      		fn_userlog(c_ServiceName,"No data Found for existing invoke request");
				}
    	}
	
			if(DEBUG_MSG_LVL_3)  /**** Ver 2.6 ****/
			{
          fn_userlog(c_ServiceName," The  sql_pod_ordr_qty Is :%ld:",sql_pod_ordr_qty);
      }
	
		  /*Check if there exists any invoke request that has not been taken for DP processing
  if found, then the original invoke request is updated*/

      /*** Added in Ver 4.6 ***/
      i_trnsctn = fn_begintran( c_ServiceName, c_err_msg );
      if ( i_trnsctn == -1 )
      {
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        fn_errlog( c_ServiceName, "S31655",LIBMSG,c_err_msg);
        Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
        tpfree ( ( char * )ptr_fml_Obuf);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
      /*** Ver 4.6 Ends ***/

    	if (i_pod_cnt == 1)
    	{
				if(DEBUG_MSG_LVL_3){
      		fn_userlog(c_ServiceName,"The dbd_inv_req_qty is [%ld], dbd_inv_cov_qty is [%ld] and pod_cnt is [%d]",sql_dbd_inv_req_qty, sql_dbd_inv_cov_qty,i_pod_cnt);
				}

				/*** Added for Ver 4.4 ***/

				sql_pod_ordr_qty = 0;
				MEMSET(sql_pod_ordr_no);
	
      	EXEC SQL
      		SELECT NVL(POD_ORDR_QTY,0), NVL(POD_ORDR_VL,0),POD_ORDR_NO
      		INTO :sql_pod_ordr_qty, :sql_pod_ordr_vl,sql_pod_ordr_no
      		FROM POD_PLG_ORDR_DTLS
      		WHERE POD_CLNT_MTCH_ACCNT = :sql_mtch_accnt
      		AND POD_DP_ACCNT = :sql_dbd_dp_id
      		AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
      		AND POD_PLG_REV_TYP = 'I'
      		AND POD_ORDR_STTS = 'R'
      		AND POD_STCK_CD = :sql_stk_stck_cd
          AND POD_CHANNEL = :sql_pml_channel      /** Ver 5.0 **/
					AND ROWNUM < 2;

  			if (SQLCODE != 0)
        {
          fn_errlog( c_ServiceName, "S31660", SQLMSG, c_err_msg  );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /** Ver 4.6 **/
          tpfree ( ( char * )ptr_fml_Obuf);
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }

      	SETNULL(sql_pod_ordr_no);

			/** Ver 4.4 **/

	      sql_pml_mod_type ='M';
 		    MEMSET(sql_pml_rmrks);
      	strcpy(sql_pml_rmrks.arr,"Auto - Modify for Addl. Invocation");
      	SETLEN(sql_pml_rmrks);
			

				EXEC SQL SELECT PRS_PLG_REV_SEQ.nextval INTO :sql_prs_seq
				FROM DUAL;
		
				if (SQLCODE != 0)
				{
					fn_errlog( c_ServiceName, "S31665", SQLMSG, c_err_msg  );
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /** Ver 4.6 **/
					tpfree ( ( char * )ptr_fml_Obuf);
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}

				EXEC SQL
	      UPDATE POD_PLG_ORDR_DTLS SET
 		    POD_ORDR_QTY = POD_ORDR_QTY + :sql_qty_plg,
      	POD_HAIRCUT = :sql_stk_plg_haircut,
      	POD_ORDR_VL = POD_ORDR_VL + :sql_stck_plg_val,
      	POD_RMRKS = :sql_pml_rmrks
      	WHERE POD_CLNT_MTCH_ACCNT = :sql_mtch_accnt
      	AND POD_DP_ACCNT = :sql_dbd_dp_id
      	AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
      	AND POD_PLG_REV_TYP = 'I'
      	AND POD_ORDR_STTS = 'R'
      	AND POD_STCK_CD = :sql_stk_stck_cd
				AND POD_ORDR_NO = :sql_pod_ordr_no			/** Ver 4.4 **/
        AND POD_CHANNEL = :sql_pml_channel      /** Ver 5.0 **/
      	RETURNING POD_ORDR_VL,POD_ORDR_QTY		/** Removed POD_ORDR_NO and added POD_ORDR_QTY from return for Ver 4.4 **/
      	INTO :sql_pod_ordr_vl,:l_plg_prcs_qty;
    
				if (SQLCODE != 0)
      	{
       		fn_errlog( c_ServiceName, "S31670", SQLMSG, c_err_msg  );
        	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /** Ver 4.6 **/
        	tpfree ( ( char * )ptr_fml_Obuf);
        	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      	}

      	/** SETNULL(sql_pod_ordr_no); ** Commented for Ver 4.4 **/

				if(DEBUG_MSG_LVL_3){
      		fn_userlog(c_ServiceName,"The returned Old order ref number is [%s]",sql_pod_ordr_no.arr);
      		fn_userlog(c_ServiceName,"The returned Old order value is [%lf]",sql_pod_ordr_vl);
				}

				EXEC SQL
 		    SELECT (COUNT(*)+1)
 	     	INTO :sql_pml_mod_cntr
      	FROM PML_PLG_MOD_LOG
      	WHERE PML_ORDR_NO = :sql_pod_ordr_no
      	AND PML_CLNT_MTCH_ACCNT = :sql_mtch_accnt
      	AND PML_DP_ACCNT = :sql_dbd_dp_id
      	AND PML_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
      	AND PML_PLG_REV_TYP = 'I'
      	AND PML_MOD_TYPE IN ('N','M','C');

      	if (SQLCODE != 0)
      	{
        	fn_errlog( c_ServiceName, "S31675", SQLMSG, c_err_msg  );
        	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /** Ver 4.6 **/
        	tpfree ( ( char * )ptr_fml_Obuf);
        	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
    	}
    /*end of if for sql_dbd_inv_req_qty > 0*/
    /*Else new order for invoke*/

    	else
    	{
				EXEC SQL
 		    SELECT PRS_PLG_REV_SEQ.nextval
      	INTO :sql_prs_seq
      	FROM DUAL;

      	if (SQLCODE != 0)
      	{
        	fn_errlog( c_ServiceName, "S31680", SQLMSG, c_err_msg  );
        	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /** Ver 4.6 **/
        	tpfree ( ( char * )ptr_fml_Obuf);
        	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      	}
	
				EXEC SQL 
				SELECT TO_CHAR(sysdate,'YYYYMMDD')||LPAD((PPS_PLG_SEQ+1),8,0)
				INTO :sql_pod_ordr_no
				FROM PPS_PLG_PLACED_SEQ 
				WHERE PPS_PLG_ORDR_DT = TO_DATE(TO_CHAR(sysdate,'DD-Mon-YYYY'),'DD-Mon-YYYY')
        FOR UPDATE OF PPS_PLG_SEQ;  /** For update added in Ver 4.5 **/
		
				if ((SQLCODE != 0) && (SQLCODE != NO_DATA_FOUND))
				{
					fn_errlog( c_ServiceName, "S31685", SQLMSG, c_err_msg  );
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /** Ver 4.6 **/
					tpfree ( ( char * )ptr_fml_Obuf);
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}

        /* Ver 1.6 */
        SETNULL(sql_pod_ordr_no);
				
				if (SQLCODE == NO_DATA_FOUND)
				{
					EXEC SQL 
					INSERT INTO PPS_PLG_PLACED_SEQ
					(PPS_PLG_SEQ,
					PPS_PLG_ORDR_DT)
					VALUES
					(1,
					TO_DATE(TO_CHAR(sysdate,'DD-Mon-YYYY'),'DD-Mon-YYYY'));
					
					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31690", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
            fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /** Ver 4.6 **/
						tpfree ( ( char * )ptr_fml_Obuf);
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
							
					EXEC SQL 
					SELECT TO_CHAR(sysdate,'YYYYMMDD')||LPAD(1,8,0) 
					INTO :sql_pod_ordr_no
					FROM DUAL;
			
					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31695", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
            fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /** Ver 4.6 **/
						tpfree ( ( char * )ptr_fml_Obuf);
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
 
          /* Ver 1.6 */
          SETNULL(sql_pod_ordr_no);
			
				}
				else
				{
					EXEC SQL 
					UPDATE PPS_PLG_PLACED_SEQ SET 
					PPS_PLG_SEQ = PPS_PLG_SEQ +1
					WHERE PPS_PLG_ORDR_DT = TO_DATE(TO_CHAR(sysdate,'DD-Mon-YYYY'),'DD-Mon-YYYY');
	
					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31700", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
            fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /** Ver 4.6 **/
						tpfree ( ( char * )ptr_fml_Obuf);
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
				}
							
				EXEC SQL INSERT INTO POD_PLG_ORDR_DTLS
				(POD_ORDR_NO,
				POD_STCK_CD,
				POD_ORDR_QTY,
				POD_ORDR_DT,
				POD_HAIRCUT,
				POD_ORDR_VL,
				POD_ISIN_NO,
				POD_DP_CLNT_ACCNT,
				POD_DP_ACCNT,
				POD_CLNT_MTCH_ACCNT ,
				POD_PLG_REV_TYP,
				POD_ORDR_STTS,
				POD_CONF_QTY,
        POD_PRCSD_QTY,                   /*******1.3*****/
				POD_RMRKS,
				POD_BP_ID,
				POD_CHANNEL,
				POD_ALLOC_TYP )    /*** ver 4.7 ***/
				VALUES
				(:sql_pod_ordr_no,
				:sql_stk_stck_cd,
				:sql_qty_plg,
				sysdate,
				:sql_stk_plg_haircut,
				:sql_stck_plg_val,
				:sql_dbd_isin_nmbr,
				:sql_dbd_dp_clnt_id,
				:sql_dbd_dp_id,
				:sql_mtch_accnt,
				'I',
				'R',
				0,
        0,                               /*******1.3*****/
				null,
				:sql_pod_bp_id,
				:sql_pml_channel,
				:sql_req_typ);    /*** ver 4.7 ***/	
				
				if (SQLCODE != 0)
				{
					fn_errlog( c_ServiceName, "S31705", SQLMSG, c_err_msg  );
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /** Ver 4.6 **/
					tpfree ( ( char * )ptr_fml_Obuf);
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
				
				sql_pml_mod_type ='N';
				sql_pml_mod_cntr = 1;
				MEMSET(sql_pml_rmrks);
				strcpy(sql_pml_rmrks.arr,"New Invocation Request");
				SETLEN(sql_pml_rmrks);

				sql_pod_ordr_vl = sql_stck_plg_val; /** Ver 4.4 **/
      	l_plg_prcs_qty = sql_qty_plg;   /** Added for 4.4 **/
		
			}/*end of else for new Invoke request*/

				/** Added for Ver 4.4 ***/

				EXEC SQL 
				UPDATE DBD_DP_BLCK_DTLS SET
				DBD_INV_REQ_QTY = DBD_INV_REQ_QTY + :sql_qty_plg,
				DBD_BLOCK_FOR_SALE = DBD_BLOCK_FOR_SALE - :sql_qty_plg
				WHERE DBD_STCK_CD = :sql_stk_stck_cd
				AND DBD_CLM_MTCH_ACCNT = :sql_mtch_accnt
				AND DBD_DP_ID = :sql_dbd_dp_id
				AND DBD_DP_CLNT_ID = :sql_dbd_dp_clnt_id;
				
				if (SQLCODE != 0)
				{
					fn_errlog( c_ServiceName, "S31710", SQLMSG, c_err_msg  );
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /** Ver 4.6 **/
					tpfree ( ( char * )ptr_fml_Obuf);
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
			
				EXEC SQL 
				INSERT INTO DLD_DP_LOG_DTLS
				(DLD_CLM_MTCH_ACCNT,
				DLD_DP_ID,
				DLD_DP_CLNT_ID,
				DLD_ISIN_NMBR,
				DLD_STCK_CD,
				DLD_TOT_QTY_CHG,
				DLD_QTY_BLCKD_CHG,
				DLD_PLG_REQ_QTY_CHG,
				/** DLD_TIFP_QTY_CHG, ** Commented for Ver 4.4 **/
				DLD_SAM_BLCKD_QTY_CHG,	/** Ver 4.4 **/
				DLD_REV_COV_QTY_CHG,
				DLD_REV_REQ_QTY_CHG,
				DLD_CHG_TM,
				DLD_BLK_FR_SALE_CHG,
				DLD_INV_REQ_QTY_CHG,
				DLD_INV_COV_QTY_CHG,
				DLD_RMRKS)
				VALUES
				(:sql_mtch_accnt,
				:sql_dbd_dp_id,
				:sql_dbd_dp_clnt_id,
				:sql_dbd_isin_nmbr,
				:sql_stk_stck_cd,
				:sql_dbd_tot_qty,
				0,
				0,
				0,
				0,
				0,
				sysdate,
				0,
				:sql_qty_plg,
				0,
				'Invocation Placement');
		
		
				if (SQLCODE != 0)
				{
					fn_errlog( c_ServiceName, "S31715", SQLMSG, c_err_msg  );
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /** Ver 4.6 **/
					tpfree ( ( char * )ptr_fml_Obuf);
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
	
				EXEC SQL UPDATE POD_PLG_ORDR_DTLS SET
				POD_CONF_QTY = POD_CONF_QTY + :sql_qty_plg
				WHERE  POD_DP_ACCNT = :sql_dbd_dp_id
				AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
				AND POD_PLG_REV_TYP = 'I'
				AND POD_ORDR_STTS = 'R'
				AND POD_STCK_CD = :sql_stk_stck_cd
				AND POD_ORDR_NO = TRIM(:sql_pod_ordr_no);										/** Ver 2.3 **/
				
				if (SQLCODE != 0)
				{
					fn_errlog( c_ServiceName, "S31720", SQLMSG, c_err_msg  );
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /** Ver 4.6 **/
					tpfree ( ( char * )ptr_fml_Obuf);
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
				/*** End for Ver 4.4 ***/

			/*** Commented for Ver 4.4 ****
			
			EXEC SQL 
			SELECT 
			nvl(PPS_L1_POS,0),nvl(PPS_L5_POS,0)
			INTO :sql_pps_l1_pos,:sql_pps_l5_pos
			FROM PPS_PLG_PSTN
			WHERE PPS_CLM_MTCH_ACCNT = :sql_mtch_accnt
			AND PPS_STCK_CD = :sql_stk_stck_cd
			AND PPS_DP_ACCNT = :sql_dbd_dp_id
			AND PPS_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id;

			if ((SQLCODE != 0) && (SQLCODE != NO_DATA_FOUND))
			{
				fn_errlog( c_ServiceName, "S31725", SQLMSG, c_err_msg  );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				tpfree ( ( char * )ptr_fml_Obuf);
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}

			c_cov_plc_flg = 'N';
		
			if(SQLCODE == NO_DATA_FOUND)
			{
				c_cov_plc_flg = 'Y';
				sql_pps_l1_pos = 0 ;
				sql_pps_l5_pos = 0 ;
			}

		
			if(DEBUG_MSG_LVL_3){
			fn_userlog(c_ServiceName,"The value of PPS_L5_POS is [%ld]",sql_pps_l5_pos);
			}
		
			if ((sql_qty_plg + sql_dbd_inv_req_qty) <= sql_pps_l5_pos)
			{
				EXEC SQL 
				UPDATE DBD_DP_BLCK_DTLS SET
				DBD_INV_REQ_QTY = DBD_INV_REQ_QTY + :sql_qty_plg,
				DBD_BLOCK_FOR_SALE = DBD_BLOCK_FOR_SALE - :sql_qty_plg
				WHERE DBD_STCK_CD = :sql_stk_stck_cd
				AND DBD_CLM_MTCH_ACCNT = :sql_mtch_accnt
				AND DBD_DP_ID = :sql_dbd_dp_id
				AND DBD_DP_CLNT_ID = :sql_dbd_dp_clnt_id;
				
				if (SQLCODE != 0)
				{
					fn_errlog( c_ServiceName, "S31730", SQLMSG, c_err_msg  );
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
					tpfree ( ( char * )ptr_fml_Obuf);
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
			
				EXEC SQL 
				INSERT INTO DLD_DP_LOG_DTLS
				(DLD_CLM_MTCH_ACCNT,
				DLD_DP_ID,
				DLD_DP_CLNT_ID,
				DLD_ISIN_NMBR,
				DLD_STCK_CD,
				DLD_TOT_QTY_CHG,
				DLD_QTY_BLCKD_CHG,
				DLD_PLG_REQ_QTY_CHG,
				** DLD_TIFP_QTY_CHG, ** Commented for Ver 4.4 **
				DLD_SAM_BLCKD_QTY_CHG,	** Ver 4.4 **
				DLD_REV_COV_QTY_CHG,
				DLD_REV_REQ_QTY_CHG,
				DLD_CHG_TM,
				DLD_BLK_FR_SALE_CHG,
				DLD_INV_REQ_QTY_CHG,
				DLD_INV_COV_QTY_CHG,
				DLD_RMRKS)
				VALUES
				(:sql_mtch_accnt,
				:sql_dbd_dp_id,
				:sql_dbd_dp_clnt_id,
				:sql_dbd_isin_nmbr,
				:sql_stk_stck_cd,
				:sql_dbd_tot_qty,
				0,
				0,
				0,
				0,
				0,
				sysdate,
				0,
				:sql_qty_plg,
				0,
				'Invocation Placement');
		
		
				if (SQLCODE != 0)
				{
					fn_errlog( c_ServiceName, "S31735", SQLMSG, c_err_msg  );
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
					tpfree ( ( char * )ptr_fml_Obuf);
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
	
				EXEC SQL UPDATE POD_PLG_ORDR_DTLS SET
				POD_CONF_QTY = POD_CONF_QTY + :sql_qty_plg
				WHERE  POD_DP_ACCNT = :sql_dbd_dp_id
				AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
				AND POD_PLG_REV_TYP = 'I'
				AND POD_ORDR_STTS = 'R'
				AND POD_STCK_CD = :sql_stk_stck_cd
				AND POD_ORDR_NO = TRIM(:sql_pod_ordr_no);										** Ver 2.3 **
				*AND trim(POD_ORDR_NO) = TRIM(:sql_pod_ordr_no);*					** Ver 2.3 **
				
				if (SQLCODE != 0)
				{
					fn_errlog( c_ServiceName, "S31740", SQLMSG, c_err_msg  );
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
					tpfree ( ( char * )ptr_fml_Obuf);
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}

			}
			else
			{
				sql_dbd_inv_cov_qty = (sql_qty_plg + sql_dbd_inv_req_qty) - sql_pps_l5_pos;
		
				if(c_cov_plc_flg == 'Y')
				{	
						EXEC SQL 
						UPDATE DBD_DP_BLCK_DTLS SET
						DBD_INV_COV_QTY = DBD_INV_COV_QTY + :sql_qty_plg,
						DBD_BLOCK_FOR_SALE = DBD_BLOCK_FOR_SALE - :sql_qty_plg
						WHERE DBD_STCK_CD = :sql_stk_stck_cd
						AND DBD_CLM_MTCH_ACCNT = :sql_mtch_accnt
						AND DBD_DP_ID = :sql_dbd_dp_id
						AND DBD_DP_CLNT_ID = :sql_dbd_dp_clnt_id;
		
						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31745", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}
					}
					else
					{
						EXEC SQL 
						UPDATE DBD_DP_BLCK_DTLS SET
						DBD_INV_REQ_QTY = :sql_pps_l5_pos,
						DBD_INV_COV_QTY = DBD_INV_COV_QTY + :sql_dbd_inv_cov_qty,
						DBD_BLOCK_FOR_SALE = DBD_BLOCK_FOR_SALE - :sql_qty_plg
						WHERE DBD_STCK_CD = :sql_stk_stck_cd
						AND DBD_CLM_MTCH_ACCNT = :sql_mtch_accnt
						AND DBD_DP_ID = :sql_dbd_dp_id
						AND DBD_DP_CLNT_ID = :sql_dbd_dp_clnt_id;
		
						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31750", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}
					
						EXEC SQL UPDATE POD_PLG_ORDR_DTLS SET
						POD_CONF_QTY = :sql_pps_l5_pos
						WHERE  POD_DP_ACCNT = :sql_dbd_dp_id
						AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
						AND POD_PLG_REV_TYP = 'I'
						AND POD_ORDR_STTS = 'R'
						AND POD_STCK_CD = :sql_stk_stck_cd
						AND POD_ORDR_NO = TRIM(:sql_pod_ordr_no);										** Ver 2.3 **
						*AND trim(POD_ORDR_NO) = TRIM(:sql_pod_ordr_no); *				** Ver 2.3 **
				
						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31755", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}
					}
		
					if(DEBUG_MSG_LVL_3){
					fn_userlog(c_ServiceName,"The value of Cover qty is [%ld]",sql_dbd_inv_cov_qty);
					}
		
					EXEC SQL INSERT INTO DLD_DP_LOG_DTLS
					(DLD_CLM_MTCH_ACCNT,
					DLD_DP_ID,
					DLD_DP_CLNT_ID,
					DLD_ISIN_NMBR,
					DLD_STCK_CD,
					DLD_TOT_QTY_CHG,
					DLD_QTY_BLCKD_CHG,
					DLD_PLG_REQ_QTY_CHG,
					** DLD_TIFP_QTY_CHG, ** Commented for Ver 4.4 **
					DLD_SAM_BLCKD_QTY_CHG, ** Ver 4.4 **
					DLD_REV_COV_QTY_CHG,
					DLD_REV_REQ_QTY_CHG,
					DLD_CHG_TM,
					DLD_BLK_FR_SALE_CHG,
					DLD_INV_REQ_QTY_CHG,
					DLD_INV_COV_QTY_CHG,
					DLD_RMRKS)
					VALUES
					(:sql_mtch_accnt,
					:sql_dbd_dp_id,
					:sql_dbd_dp_clnt_id,
					:sql_dbd_isin_nmbr,
					:sql_stk_stck_cd,
					:sql_dbd_tot_qty,
					0,
					0,
					0,
					0,
					0,
					sysdate,
					0,
					:sql_pps_l5_pos,
					:sql_dbd_inv_cov_qty,
					'Invocation Cover Placement');
		
		
					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31760", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
						tpfree ( ( char * )ptr_fml_Obuf);
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
				}

			**** Commented for Ver 4.4 **/
		
			/*** Commented for Ver 3.2 ****//** Uncomment end for Ver 4.4 ***/
				/********* Commented in Ver 2.5 EQ SAM *************************
				MEMSET(sql_fab_bnk_accnt);

				EXEC SQL 
				UPDATE FAB_FO_ALC_BFT_SMRY SET
				FAB_PLG_AMT = FAB_PLG_AMT - :sql_stck_plg_val	
				WHERE FAB_CLM_MTCH_ACCNT = :sql_mtch_accnt
				RETURNING FAB_BNK_ACCNT,FAB_ALCTD_AMT,FAB_BFT_AMT
				INTO :sql_fab_bnk_accnt,:sql_fab_alctd_amt,:sql_fab_bft_amt;

				if (SQLCODE != 0)
				{
					fn_errlog( c_ServiceName, "S31765", SQLMSG, c_err_msg  );
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
					tpfree ( ( char * )ptr_fml_Obuf);
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
							
				SETNULL(sql_fab_bnk_accnt);

				EXEC SQL 
				INSERT INTO FAL_FO_ALCBFT_LOG
				(FAL_CLM_MTCH_ACCNT,
				FAL_BNK_ACCNT,
				FAL_ALCTD_AMT,
				FAL_BFT_AMT,
				FAL_TRN_DT,
				FAL_OLD_PLG_AMT,
				FAL_PLG_CHG_AMT,
				FAL_NARRATION)
				VALUES
				(:sql_mtch_accnt,
				:sql_fab_bnk_accnt,
				:sql_fab_alctd_amt,
				:sql_fab_bft_amt,
				sysdate,
				:sql_fab_plg_amt,
				-(:sql_stck_plg_val),
				'IL');

				if (SQLCODE != 0)
				{
					fn_errlog( c_ServiceName, "S31770", SQLMSG, c_err_msg  );
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
					tpfree ( ( char * )ptr_fml_Obuf);
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
				*************** Comment 2.5 ends ********************************/

				/**** Ver 2.5 Starts ******/
				/******** Commented and taken below for the Live issue ***
    		strcpy(c_narration,"IL");

    		i_returncode = fn_reduce_sam_limit_invk(c_ServiceName,
                                  		sql_mtch_accnt.arr,
                                  		sql_stck_plg_val,
                                  		c_narration,
                                  		c_err_msg);


    		if (i_returncode == -1 )
    		{
      		fn_errlog( c_ServiceName, "S31775", SQLMSG, c_err_msg  );
      		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      		tpfree ( ( char * )ptr_fml_Obuf);
      		tpfree ( ( char * )ptr_fml_Ibuf1);  ** 3.6 **
      		tpfree ( ( char * )ptr_fml_Obuf1);  ** 3.6 **
      		* fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); *
      		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    		}

				**** Issue end ***/

    		/******** Ver 2.5 Ends *****/

				/*** Uncomment for Ver 4.4 ***/
				/*** Commented for Ver 3.2 ****/
				EXEC SQL 
				INSERT INTO PML_PLG_MOD_LOG
				(PML_ORDR_NO,
				PML_STCK_CD,
				PML_ORDR_QTY,
				PML_ORDR_TM,
				PML_HAIRCUT,
				PML_ORDR_VL,
				PML_ISIN_NO,
				PML_DP_CLNT_ACCNT,
				PML_DP_ACCNT,
				PML_CLNT_MTCH_ACCNT,
				PML_PLG_REV_TYP,
				PML_MOD_TYPE,
				PML_STTS,
				PML_MOD_CNTR,
				PML_PLCD_SQNC,
				PML_BP_ID,
				PML_CHANNEL,
				PML_RMRKS)
				VALUES
				(:sql_pod_ordr_no,
				:sql_stk_stck_cd,
				:sql_qty_plg,
				sysdate,
				:sql_stk_plg_haircut,
				:sql_stck_plg_val,
				:sql_dbd_isin_nmbr,
				:sql_dbd_dp_clnt_id,
				:sql_dbd_dp_id,
				:sql_mtch_accnt,
				'I',
				:sql_pml_mod_type,
				'R',
				:sql_pml_mod_cntr,
				:sql_prs_seq,	
				:sql_pod_bp_id,
				:sql_pml_channel,
				:sql_pml_rmrks);
				
				if (SQLCODE != 0)
				{
					fn_errlog( c_ServiceName, "S31780", SQLMSG, c_err_msg  );
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /** Ver 4.6 **/
					tpfree ( ( char * )ptr_fml_Obuf);
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
				/*** Commented for Ver 3.2 ****/
				/** Uncomment end for Ver 4.4 **/
		
		/*** Added for Ver 3.2 ****/


			/** Added for Ver 4.4 **/
			BLOCK_MODEL_I:

				/******** Taken from above for Live issue fix ***/
    		strcpy(c_narration,"IL");

    		i_returncode = fn_reduce_sam_limit_invk(c_ServiceName,
                                  		sql_mtch_accnt.arr,
                                  		sql_stck_plg_val,
                                  		c_narration,
                                  		c_err_msg);


    		if (i_returncode == -1 )
    		{
      		fn_errlog( c_ServiceName, "S31785", SQLMSG, c_err_msg  );
      		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      		tpfree ( ( char * )ptr_fml_Obuf);
      		tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
      		tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /** Ver 4.6 **/
      		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    		}
        /*** Added for Ver 5.1 **/
        i_returncode = fn_get_prev_sam(c_ServiceName,
                                      sql_mtch_accnt.arr,
                                      c_err_msg);


        if (i_returncode == -1 )
        {
          fn_errlog( c_ServiceName, "S31790", SQLMSG, c_err_msg  );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpfree ( ( char * )ptr_fml_Obuf);
          tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
          tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /** Ver 4.6 **/
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
        /*** End for Ver 5.1 **/

				/*** Fix ened ***/
    /*** Added in Ver 4.6 ***/
    if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg ) == -1 )
    {
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      tpfree ( ( char * )ptr_fml_Obuf);
      fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
      tpreturn ( TPFAIL, ERR_BFR, ( char * )ptr_fml_Ibuf, 0, 0 );
    }
    /*** Ver 4.6 Ends ***/

	if(sql_dbd_plg_mode == 'B')
	{
			/*** Ver 4.4 **/
			c_bkubk_flg = 'I';

  i_err [0] = Fadd32(ptr_fml_Ibuf1,FFO_EBA_MTCH_ACT_NO, (char *)sql_mtch_accnt.arr,0);
  i_err [1] = Fadd32(ptr_fml_Ibuf1,FFO_BK_UBK_FLG, (char *)&c_bkubk_flg,0);
  i_err [2] = Fadd32(ptr_fml_Ibuf1,FFO_USR_ID, (char*)st_usr_prfl.c_user_id,0);
  i_err [3] = Fadd32(ptr_fml_Ibuf1,FFO_STCK_CD, sql_stk_stck_cd ,0);
  i_err [4] = Fadd32(ptr_fml_Ibuf1,FFO_ORD_TOT_QTY, (char *)&sql_qty_plg,0);
  i_err [5] = Fadd32(ptr_fml_Ibuf1,FFO_DPID, (char *)sql_dbd_dp_id ,0);
  i_err [6] = Fadd32(ptr_fml_Ibuf1,FFO_DP_CLNT_ID, (char *)sql_dbd_dp_clnt_id ,0);
  i_err [7] = Fadd32(ptr_fml_Ibuf1,FFO_CHANNEL, sql_pml_channel.arr,0);
  i_err [8] = Fadd32(ptr_fml_Ibuf1,FFO_SSSN_ID, (char*)&st_usr_prfl.l_session_id,0);

  for ( j=0; j < 9; j++ )
  {
    if ( i_err[ j ] == -1 )
    {
      sprintf(c_err_msg, "ERROR : At FML no :%d:",j);
      fn_errlog( c_ServiceName,"S31795",Fstrerror32(i_err[j]),c_err_msg );
      fn_userlog(c_ServiceName,c_err_msg);
      /*** tpfree((char *)ptr_fml_Ibuf); *** Commented for Ver 3.5 ***/
			tpfree ( ( char * )ptr_fml_Obuf);   /** 3.6 **/
			tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
			tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
      strcpy( c_err_msg,"Contact System Support" );
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 ); /*** Ver 3.5 **/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );	/*** Ver 3.5 ***/
    }
  }

   i_returncode = tpcall( "SFO_SAM_BKUBK",
                      (char*)ptr_fml_Ibuf1,
                      0,
                      (char**)&ptr_fml_Obuf1,
                      &l_ip_len,0);

      if( i_returncode == -1)
      {
        if ( tperrno != TPESVCFAIL )
        {
            fn_errlog ( c_ServiceName, "S31800", TPMSG,c_err_msg);
        }
        fn_errlog( c_ServiceName, "S31805", LIBMSG, c_err_msg );
        Fget32(ptr_fml_Obuf1,FFO_ERR_MSG,0,c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        tpfree ( ( char * )ptr_fml_Obuf);
        tpfree ( ( char * )ptr_fml_Ibuf1);
        tpfree ( ( char * )ptr_fml_Obuf1);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );

      }
	}	/** Ver 4.4 **/
	/** Added for Ver 4.4 **/
  /************* Commneted in Ver 4.6 ***************
	if( sql_dbd_plg_mode == 'P')
	{
		fn_userlog(c_ServiceName,"Insuder SAM Block Model.");
	  ** End for Ver 4.4 **
		c_req_conf_flg = 'R';

		fn_userlog(c_ServiceName,"Before The Force Withdrawal flag is [%c]",c_force_flag);

		i_err [0] = Fadd32(ptr_fml_Ibuf1,FFO_EBA_MTCH_ACT_NO, (char *)sql_mtch_accnt.arr,0);
  	i_err [1] = Fadd32(ptr_fml_Ibuf1,FFO_DPID, (char *)sql_dbd_dp_id ,0);
  	i_err [2] = Fadd32(ptr_fml_Ibuf1,FFO_DP_CLNT_ID, (char *)sql_dbd_dp_clnt_id ,0);
  	i_err [3] = Fadd32(ptr_fml_Ibuf1,FFO_STCK_CD, sql_stk_stck_cd ,0);
  	** i_err [4] = Fadd32(ptr_fml_Ibuf1,FFO_TIFP_QTY, (char *)&sql_qty_plg,0); **
  	i_err [4] = Fadd32(ptr_fml_Ibuf1,FFO_TIFP_QTY, (char *)&l_plg_prcs_qty,0);
  	i_err [5] = Fadd32(ptr_fml_Ibuf1,FFO_SPRD_ORD_REF, sql_pod_ordr_no.arr,0);
  	i_err [6] = Fadd32(ptr_fml_Ibuf1,FFO_OPERATION_TYP, (char *)&c_req_conf_flg,0);
  	i_err [7] = Fadd32(ptr_fml_Ibuf1,FFO_PLG_TYP, (char *)&sql_oprn_typ,0);
  	i_err [8] = Fadd32(ptr_fml_Ibuf1,FFO_EXECN_DT, (char *)vc_exec_dt.arr,0);
    i_err [9] = Fadd32(ptr_fml_Ibuf1,FFO_ISIN_NMBR ,(char *) sql_dbd_isin_nmbr,0);
    ** i_err [10] = Fadd32(ptr_fml_Ibuf1,FFO_ORDR_RFRNC ,(char *) c_ordr_rfrnc,0);			** Ver 4.4 **

  	for ( j=0; j < 10; j++ )
  	{
    	if ( i_err[ j ] == -1 )
    	{
      	sprintf(c_err_msg, "ERROR : At FML no :%d:",j);
      	fn_errlog( c_ServiceName,"S31810",Fstrerror32(i_err[j]),c_err_msg );
      	fn_userlog(c_ServiceName,c_err_msg);
      	*** tpfree((char *)ptr_fml_Ibuf); *** Commented for Ver 3.5 ***
      	strcpy( c_err_msg,"Contact System Support" );
      	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );		*** Ver 3.5 ***
				tpfree ( ( char * )ptr_fml_Obuf);   ** 3.6 **
				tpfree ( ( char * )ptr_fml_Ibuf1);  ** 3.6 **
				tpfree ( ( char * )ptr_fml_Obuf1);  ** 3.6 **
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );		*** Ver 3.5 ***
    	}
  	}

  	i_returncode = tpcall( "SFO_MRGN_PLG",
                      		(char*)ptr_fml_Ibuf1,
                      		0,
                      		(char**)&ptr_fml_Obuf1,
                      		&l_ip_len,0);

    if( i_returncode == -1)
    {
       if ( tperrno != TPESVCFAIL )
       {
           fn_errlog ( c_ServiceName, "S31815", TPMSG,c_err_msg);
       }
       fn_errlog( c_ServiceName, "S31820", LIBMSG, c_err_msg );
       Fget32(ptr_fml_Obuf1,FFO_ERR_MSG,0,c_err_msg, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
       tpfree ( ( char * )ptr_fml_Obuf);
       tpfree ( ( char * )ptr_fml_Ibuf1);
       tpfree ( ( char * )ptr_fml_Obuf1);
       tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
	}
  *************** Comment Ends Ver 4.6 ***************/
	/** End for Ver 4.4 **/


		/*** Added end for Ver 3.2 ****/

				/***	Ver 1.7 : ADDITION STARTS	***/
				strcpy(c_null_msg,"Success ");

				Fadd32(ptr_fml_Obuf,FFO_ERR_MSG,c_null_msg, 0 );
				/***  Ver 1.7 : ADDITION ENDS ***/

				/*** Ver 3.2 ***/
				tpfree ( ( char * )ptr_fml_Ibuf1);
        tpfree ( ( char * )ptr_fml_Obuf1);
				/*** Ver 3.2 ***/
				/*** tpfree( (char*)ptr_fml_Ibuf);  *** Ver 3.2 *** *** Commented for Ver 3.5 ***/

        Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, "You have successfully added amount to the Margin." , 0 ); 
				tpreturn( TPSUCCESS, 0, (char *)ptr_fml_Obuf, 0, 0 );
				
			break;
	}
	default:
	{
			strcpy(c_err_msg,"Invalid Operation Type" );
			fn_errlog ( c_ServiceName, "S31825", DEFMSG, c_err_msg);
			tpfree ( ( char * )ptr_fml_Obuf);
			tpfree ( ( char * )ptr_fml_Ibuf1);  /** 3.6 **/
		  tpfree ( ( char * )ptr_fml_Obuf1);  /** 3.6 **/
			tpreturn ( TPFAIL, ERR_BFR, ( char * )ptr_fml_Ibuf, 0, 0 );
			break;
	}
 }	/*end of switch*/

}/*end of service*/
