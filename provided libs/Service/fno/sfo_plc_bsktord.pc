/*****************************************************************************************/
/******************************************************************************************
Service Name          : sfo_plc_bsktord																										*
																										                             					*
Description           : Allows a user to place basket order in derivative                 *
																																													*
																FFO_USR_ID																								*
																FFO_SSSN_ID																								*
																FFO_XCHNG_CD																							*
																FFO_SOURCE_FLG																						*
																FFO_SPL_FLG																								*
																FFO_ORD_TYP																								*
																FFO_EBA_MTCH_ACT_NO																				*
																FFO_PRDCT_TYP																							*
																FFO_UNDRLYNG																							*
																FFO_EXPRY_DT																							*
																FFO_EXER_TYP																							*
																FFO_OPT_TYP																								*
																FFO_STRK_PRC																							*
																FFO_CTGRY_INDSTK																					*
																FFO_ORDR_FLW																							*
																FFO_LMT_MKT_SL_FLG																				*
																FFO_DSCLSD_QTY																						*
																FFO_STP_LSS_TGR																						*
																FFO_LMT_RT																								*
																FFO_ORD_TOT_QTY																						*
																FFO_ORD_VALID_DT																					*
																FFO_STP_LSS_TGR																						*
																																													*
																																													*
Output Parameters								FFO_ORDR_RFRNC																						*
                        				FFO_ERR_MSG																								*
																																													*
Log                  : 01-Sep-2014		 1.0 New Release | Bhushan Sonwane		  						*
Log                  : 02-Aug-2015     1.1 Include changes for Insider trading check |Bhupendra Malik*
										 : 18-May-2021     1.2 	Derivative_trd_restrict_CR_ISEC04_152948      *
                     : 19-Apr-2023     1.3 CR-ISEC10-179095 Add tab of buy order first    *
                                           in basket order | Prajakta Sutar               *
										 : 07-May-2023     1.4 SPIRA:1828 Core Fix	| Vipul Sharma						*
                     : 30-May-2023     1.5 SPIRA:1972 Basket Order Placement Fix          *
                                           for NRI Client | Prajakta Sutar                *
                     : 16-Jun-2023     1.6 SPIRA:3315 Basket Order Placemnet Fix          *
                                           for BPID | Prajakta Sutar                      *
******************************************************************************************/

#include <stdio.h>					/* C Header File                */
#include <stdlib.h>				  /* C Header File                */
#include <string.h>				  /* C Header File                */
#include <sqlca.h>					/* Oracle header file           */
#include <atmi.h>						/* TUXEDO Header File           */		
#include <fml32.h>					/* TUXEDO Header File           */
#include <fo.h>				
#include <fo_fml_def.h>
#include <fo_view_def.h>
#include <fn_log.h>
#include <fn_session.h>
#include <fn_tuxlib.h>
#include <fn_read_debug_lvl.h>
#include <fn_val_ord.h>


int   Z ;
#define INIT(x,y) for(Z=0;Z<y;Z++)x[Z] = 0 ;

/** Sleep Function Added in Ver 1.3 **/
int fn_fno_sleep( char     *c_ServiceName,
                  FBFR32   **ptr_fml_Ibuffer,
                  double   d_sleep_tm_msec,
                  int      i_max_call_allwd,
                  char     *c_caller_rfrnc,
                  char     *c_fwd_to_srvc,
                  char     *c_errmsg);

void SFO_PLC_BSKTORD(TPSVCINFO *rqst)
{

	FBFR32 *ptr_fml_Ibuf;
	FBFR32 *ptr_fml_Obuf;
	FBFR32 *ptr_fml_Sbuf;
	FBFR32 *ptr_fml_Rbuf;

  struct vw_usr_prfl st_usr_prfl;
  struct vw_err_msg st_err_msg;
	
	char c_ServiceName[33];
	char c_err_msg[256];
	
	int i_Fget=0;
	int i_err[40];
  int i_cnt = 0;
	int i_ch_val=0;
  int i_bufferlength=0;
  int i_actn_id = -1;
	int insider_exist = 0; /** Ver 1.1 **/
  int i_returncode=0;   /** Ver 1.1 **/
  int i_trnsctn = 0 ; /** Ver 1.3 **/
	double d_sleep_msec = 0.0; /** Ver 1.3 **/
  int i_sleep_sec = 0;  /** Ver 1.3 **/
  char  c_usr_id[50] ="\0";
	char  c_source_flag ='\0';
  char  c_spl_flg ='\0';
  char  c_prdct_typ ='\0';
  char  c_ord_typ ='\0';
  char  c_ordr_flw ='\0';
  char  c_pipe_id[2+1]="\0";
  char  c_clm_mtch_accnt[10+1]="\0";
  char  c_service_nm[30+1]="\0";
  char  c_xchng_cd[3+1]="\0";
  char  c_channel[3+1]="\0";
  char  c_expry_dt[11+1] ="\0";
  char  c_ordr_rfrnc[18+1] ="\0";
  char  c_lmt_mkt_sl_flg='\0';
  char  c_undrlyng[7]="\0"; /** ver 1.3 changed from 10 to 7 **/
  char  c_prd_typ='\0';;
  char  c_spn_flg = '\0';
  char  c_bse_spn_flg ='\0';
	char  sql_fcm_opt_typ ='\0';
  char  c_null_msg [ 10 ];
	char  c_ctgry_indstk='\0';
  char  c_exrc_typ ='\0';
	char  c_alias[9]="\0";
  char c_trdng_psswrd_flg = '\0';
  char  c_bskt_id[16] = "\0";     /** Ver 1.3 **/
  char  c_bskt_ordr_ref[17] = "\0"; /** Ver 1.3 **/
  char  c_rqst_typ = '\0';    /** Ver 1.3 **/
  char  c_insrt_tm[15] = "\0"; /** Ver 1.3 **/
 	
  long  l_sssn_id =0 ;
  long  l_stp_lss_tgr =0 ;
  long  l_lmt_rt =0 ;
	long  sql_fcm_strk_prc =0 ;
	long  int l_no_of_orders =0 ;
  long  int li_len_tobuf=0 ;
	long  l_counter=0;
	long  l_ord_tot_qty=0;
	long	l_dsclsd_qty=0;
  long  l_cvr_sltp_rt = 0;       /***  Ver 1.3 ***/
  long  l_frsh_lmt_rt = 0;       /***  Ver 1.3 ***/

	strcpy(c_ServiceName, "SFO_PLC_BSKTORD");
  INITDBGLVL(c_ServiceName);

	ptr_fml_Ibuf = (FBFR32*)rqst->data;

	MEMSET(st_usr_prfl);
	MEMSET(st_err_msg);
  MEMSET(c_err_msg);  /** Added in Ver 1.3 **/

	INIT(i_err,40);
  strcpy(c_null_msg,"\0");

  i_ch_val = Fvftos32( ptr_fml_Ibuf,
                           (char *) &st_usr_prfl,
                           "vw_usr_prfl" );
  if ( i_ch_val == -1 )
  {
    fn_errlog( c_ServiceName, "S31005", FMLMSG, c_err_msg  );
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );		/* ver 1.4 */
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );	 /* ver 1.4 */
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );	 /* ver 1.4 */
  }

	/*** Buffer Allocation ***/

	ptr_fml_Obuf = (FBFR32*)tpalloc("FML32",NULL,MIN_FML_BUF_LEN + 256);
	if (ptr_fml_Obuf == NULL) /** changed to Obuf in ver 1.3 **/
	{
		fn_errlog( c_ServiceName, "S31010", TPMSG, c_err_msg  );
		strcpy(c_err_msg,"Problem in Placing order");
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );	/* ver 1.4 */
		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );	/* ver 1.4 */
		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );	/* ver 1.4 */
	}

  /*** Initialising the string variables ***/

  INIT(c_usr_id,50);
  INIT(c_clm_mtch_accnt,11);
  INIT(c_expry_dt,12);
  INIT(c_ordr_rfrnc,19);

	i_err[0] = Fget32(ptr_fml_Ibuf,FFO_USR_ID,0,(char *)c_usr_id,0) ;
	i_err[1] = Fget32(ptr_fml_Ibuf,FFO_SSSN_ID,0,(char *)&l_sssn_id,0) ;
	i_err[2] = Fget32(ptr_fml_Ibuf,FFO_SOURCE_FLG,0,(char *)&c_source_flag,0) ;
	i_err[3] = Fget32(ptr_fml_Ibuf,FFO_SPL_FLG,0,(char *)&c_spl_flg,0) ;
	i_err[4] = Fget32(ptr_fml_Ibuf,FFO_CHANNEL,0, (char *)c_channel,0);

  for( i_Fget = 0 ; i_Fget <= 4 ; i_Fget++ ) 
  {
    if(i_err[i_Fget] == -1)
    {
      fn_userlog(c_ServiceName,"Error in Fget of :%d:",i_Fget);
      fn_errlog( c_ServiceName, "S31015", FMLMSG, c_err_msg  );
      strcpy(c_err_msg,"Problem in Placing order");
      Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, (char *)c_err_msg, 0 );
			Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Obuf, 0, 0 );
    }
  }

  /** Ver 1.3 **/
  if(c_source_flag == 'B')
  {
   if(Fget32( ptr_fml_Ibuf,FFO_RQST_TYP,0,(char *)&c_rqst_typ,0 ) == -1)
   {
    if( Ferror32 == FNOTPRES)
    {
        c_rqst_typ='\0'; /* VER TOL : TUX on LINUX -- Changed empty character assigmnet to \0 (Ravindra) */
    }
    else
    {
     fn_userlog(c_ServiceName,"Error in request type");
     fn_errlog( c_ServiceName, "S31020", FMLMSG, c_err_msg  );
     strcpy(c_err_msg,"Error in request type");
     Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, (char *)c_err_msg, 0 );
     Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
     tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Obuf, 0, 0 );
    }
   }
   if(Fget32( ptr_fml_Ibuf,FFO_SERIES,0,(char *)&c_bskt_id,0 ) == -1)
   {
    if( Ferror32 == FNOTPRES)
    {
      strcpy(c_bskt_id,"");
    }
    else
    {
     fn_userlog(c_ServiceName,"Error in getting basket id");
     fn_errlog( c_ServiceName, "S31025", FMLMSG, c_err_msg  );
     strcpy(c_err_msg,"Error in getting basket id");
     Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, (char *)c_err_msg, 0 );
     Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
     tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Obuf, 0, 0 );
    }
   }
   
   if(DEBUG_MSG_LVL_5)
   {
     fn_userlog(c_ServiceName,"FFO_USR_ID is :%s:",c_usr_id);
     fn_userlog(c_ServiceName,"FFO_SSSN_ID is :%ld:",l_sssn_id);
     fn_userlog(c_ServiceName,"FFO_SOURCE_FLG is :%c:",c_source_flag);
     fn_userlog(c_ServiceName,"FFO_SPL_FLG is :%c:",c_spl_flg);
     fn_userlog(c_ServiceName,"Channel :%s:",c_channel);
     fn_userlog(c_ServiceName,"FFO_SERIES:%s:",c_bskt_id);  
     fn_userlog(c_ServiceName,"FFO_RQST_TYP:%c:",c_rqst_typ);
     fn_userlog(c_ServiceName,"FFO_TM_STMP:%s:",c_insrt_tm);
   }
  }
  /** Ver 1.3 **/

 if(c_source_flag != 'B' && c_rqst_typ != 'R')  /** Added in Ver 1.3 **/
 {
  /**** session check *****/

  if(st_usr_prfl.l_session_id !=0)
  {
    i_ch_val = fn_chk_sssn( c_ServiceName,
                                &st_usr_prfl,
                                &st_err_msg ) ;

    if ( i_ch_val == -1 )
    {
			Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );
      Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Obuf, 0, 0 );
    }
  }


	if(c_source_flag == '1')
  {
    strcpy(c_channel, "APP") ;
  }
  else if(c_source_flag == '2')
  {
    strcpy(c_channel ,"VSA") ;
  }
  else if(c_source_flag == 'Y')       /*** For New Trade Racer ***/
  {
    strcpy(c_channel ,"NET") ;
  }
  else if(c_source_flag == 'Z')       /*** For New Trade Racer by super user ***/
  {
    strcpy(c_channel ,"CN2") ;
	}

  l_no_of_orders = Foccur32((FBFR32 *)ptr_fml_Ibuf,FFO_EBA_MTCH_ACT_NO);

  if(DEBUG_MSG_LVL_3)
	{
    fn_userlog(c_ServiceName,"FFO_REC_NO :%ld:",l_no_of_orders);
    fn_userlog(c_ServiceName,"FFO_USR_ID is :%s:",c_usr_id);
    fn_userlog(c_ServiceName,"FFO_SSSN_ID is :%ld:",l_sssn_id);
    fn_userlog(c_ServiceName,"FFO_SOURCE_FLG is :%c:",c_source_flag);
    fn_userlog(c_ServiceName,"FFO_SPL_FLG is :%c:",c_spl_flg);
		fn_userlog(c_ServiceName,"Channel :%c:",c_channel);
  }	
 
	for(i_cnt =0 ; i_cnt < l_no_of_orders; i_cnt++)
	{
		INIT(i_err,40);

  	i_err[0] 	= Fget32(ptr_fml_Ibuf,FFO_PRDCT_TYP,i_cnt,(char *)&c_prdct_typ,0) ;
  	i_err[1] 	= Fget32(ptr_fml_Ibuf,FFO_XCHNG_CD,i_cnt,(char *)c_xchng_cd,0) ;
  	i_err[2] 	= Fget32(ptr_fml_Ibuf,FFO_EBA_MTCH_ACT_NO,i_cnt,(char *)c_clm_mtch_accnt,0) ;
  	i_err[3] 	= Fget32(ptr_fml_Ibuf,FFO_LMT_MKT_SL_FLG,i_cnt,(char *)&c_lmt_mkt_sl_flg,0) ;
  	i_err[4] 	= Fget32(ptr_fml_Ibuf,FFO_ORD_TYP,i_cnt,(char *)&c_ord_typ,0) ;
  	i_err[5] 	= Fget32(ptr_fml_Ibuf,FFO_ORDR_FLW,i_cnt,(char *)&c_ordr_flw,0) ;
  	i_err[6] 	= Fget32(ptr_fml_Ibuf,FFO_EXPRY_DT,i_cnt,(char *)c_expry_dt,0) ;
  	i_err[7] 	= Fget32(ptr_fml_Ibuf,FFO_UNDRLYNG,i_cnt,(char *)c_undrlyng,0) ; 
  	i_err[8] 	= Fget32(ptr_fml_Ibuf,FFO_STRK_PRC,i_cnt,(char *)&sql_fcm_strk_prc,0) ;
  	i_err[9] 	= Fget32(ptr_fml_Ibuf,FFO_OPT_TYP,i_cnt,(char *)&sql_fcm_opt_typ,0) ;
		i_err[10] = Fget32(ptr_fml_Ibuf,FFO_LMT_RT,i_cnt,(char *)&l_lmt_rt,0) ;
		i_err[11] = Fget32(ptr_fml_Ibuf,FFO_CTGRY_INDSTK,i_cnt,(char *)&c_ctgry_indstk,0);
		i_err[12] = Fget32(ptr_fml_Ibuf,FFO_STP_LSS_TGR,i_cnt,(char *)&l_stp_lss_tgr,0);
		i_err[13] = Fget32(ptr_fml_Ibuf,FFO_EXER_TYP,i_cnt,(char *)&c_exrc_typ,0);
		i_err[14] = Fget32(ptr_fml_Ibuf,FFO_ORD_TOT_QTY,i_cnt,(char *)&l_ord_tot_qty,0);
	  
		for( i_Fget = 0 ; i_Fget <= 14 ; i_Fget++ ) 
  	{
    	if(i_err[i_Fget] == -1)
    	{
      	fn_userlog(c_ServiceName,"Error in Fget of :%d:",i_Fget);
      	fn_errlog( c_ServiceName, "S31030", FMLMSG, c_err_msg  );
      	strcpy(c_err_msg,"Problem in Placing order");
      	Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, (char *)c_err_msg, 0 );
				Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
				Fadd32( ptr_fml_Obuf,FFO_ORDR_RFRNC, c_null_msg, 0 );

     		i_ch_val = Fconcat32(ptr_fml_Obuf,ptr_fml_Ibuf);

     		if( i_ch_val == -1)
     		{
      		fn_errlog( c_ServiceName, "S31035",FMLMSG,c_err_msg);
     			Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 );
		      Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    		  Fadd32( ptr_fml_Obuf,FFO_ORDR_RFRNC, c_null_msg, 0 );
     		}

				continue;
    	}
  	}

	  if(DEBUG_MSG_LVL_3)
    {
			fn_userlog(c_ServiceName,"ORDER NO |%d|",i_cnt );
      fn_userlog(c_ServiceName,"FFO_EBA_MTCH_ACT_NO is :%s:",c_clm_mtch_accnt);
    	fn_userlog(c_ServiceName,"FFO_PRDCT_TYP is :%c:",c_prdct_typ);
    	fn_userlog(c_ServiceName,"FFO_XCHNG_CD is :%s:",c_xchng_cd);
    	fn_userlog(c_ServiceName,"FFO_UNDRLYNG is :%s:",c_undrlyng);
			fn_userlog(c_ServiceName,"FFO_EXPRY_DT is :%s:",c_expry_dt);
			fn_userlog(c_ServiceName,"FFO_LMT_MKT_SL_FLG is :%c:",c_lmt_mkt_sl_flg);
			fn_userlog(c_ServiceName,"FFO_ORDR_FLW is :%c:",c_ordr_flw);
    	fn_userlog(c_ServiceName,"FFO_STRK_PRC is :%ld:",sql_fcm_strk_prc);
    	fn_userlog(c_ServiceName,"FFO_ORD_TYP is :%c:",c_ord_typ);
    	fn_userlog(c_ServiceName,"FFO_OPT_TYP is :%c:",sql_fcm_opt_typ);
			fn_userlog(c_ServiceName,"FFO_LMT_RT is :%ld:",l_lmt_rt) ;
			fn_userlog(c_ServiceName,"FFO_STP_LSS_TGR is :%ld:",l_stp_lss_tgr);
			fn_userlog(c_ServiceName,"FFO_CTGRY_INDSTK is :%c:",c_ctgry_indstk);
			fn_userlog(c_ServiceName,"FFO_EXER_TYP is :%c:",c_exrc_typ);
			fn_userlog(c_ServiceName,"FFO_ORD_TOT_QTY is :%ld:",l_ord_tot_qty);
  	}

  	if(c_usr_id[0] == BPID)
  	{
    	if(Fget32(ptr_fml_Ibuf,FFO_ALIAS,i_cnt,(char *)c_alias,0) == -1)
    	{
			  fn_userlog(c_ServiceName,"Error in Fget of :%d:",i_Fget);
        fn_errlog( c_ServiceName, "S31040", FMLMSG, c_err_msg  );
        strcpy(c_err_msg,"Problem in Placing order");
        Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, (char *)c_err_msg, 0 );
				Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
				Fadd32( ptr_fml_Obuf,FFO_ORDR_RFRNC, c_null_msg, 0 );

        i_ch_val = Fconcat32(ptr_fml_Obuf,ptr_fml_Ibuf);

        if( i_ch_val == -1)
        {
          fn_errlog( c_ServiceName, "S31045",FMLMSG,c_err_msg);
          Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 );
          Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Obuf,FFO_ORDR_RFRNC, c_null_msg, 0 );
        }

        continue;
    	}
  	}

		EXEC SQL
					SELECT  NVL(CLM_SPAN_ALLWD,'N'),
									NVL(CLM_BSESPAN_ALLWD,'N')
					INTO    :c_spn_flg,
									:c_bse_spn_flg
					FROM    CLM_CLNT_MSTR
					WHERE   CLM_MTCH_ACCNT  = :c_clm_mtch_accnt;

		if(SQLCODE != 0)
		{
			fn_errlog( c_ServiceName, "S31050", SQLMSG, c_err_msg  );
			strcpy(c_err_msg,"Error while selecting span flag");
			Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, (char *)c_err_msg, 0 );
			Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
			Fadd32( ptr_fml_Obuf,FFO_ORDR_RFRNC, c_null_msg, 0 );

        i_ch_val = Fconcat32(ptr_fml_Obuf,ptr_fml_Ibuf);

        if( i_ch_val == -1)
        {
          fn_errlog( c_ServiceName, "S31055",FMLMSG,c_err_msg);
          Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 );
          Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Obuf,FFO_ORDR_RFRNC, c_null_msg, 0 );
        }

			continue;
		}   

		if(DEBUG_MSG_LVL_3)
		{
			fn_userlog(c_ServiceName,"NSE SPAN Allowed Flag Is :%c:",c_spn_flg);
			fn_userlog(c_ServiceName,"BSE SPAN Allowed Flag Is :%c:",c_bse_spn_flg);
			fn_userlog(c_ServiceName,"ALIAS Is :%s:",c_alias);
		}
   /** Ver 1.1 Starts **/
	/** Ver 1.2 commented as same function will be called in order placement services ****
     i_returncode = fn_chk_und_insider(c_ServiceName,
                                    st_usr_prfl,
                                    c_undrlyng,
                                    &insider_exist);
  if (i_returncode == -1)
  {
      fn_errlog( c_ServiceName, "S31060", "Error in Function fn_chk_und_insider", c_err_msg);
      Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, (char *)c_err_msg, 0 );
      Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Obuf, 0, 0 );     
   }
  if (insider_exist == 1)
  {
      fn_errlog( c_ServiceName, "B21042", DEFMSG, c_err_msg  );
      Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, (char *)c_err_msg, 0 );
      Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Obuf, 0, 0 );
   }
	****** Ver 1.1 ****/
/** Ver 1.1 Ends **/
 
		switch(c_prdct_typ)
		{
			case FUTURES:
			case OPTIONS:

			 if( (( ( c_spn_flg == 'Y' ) && strcmp(c_xchng_cd,"NFO") == 0 ) || 
							( c_bse_spn_flg == 'Y' && strcmp(c_xchng_cd,"BFO") == 0 )) )

			 {
					strcpy(c_service_nm,"SFO_SPN_PLC_ORD");
			 }
			 else if (c_prdct_typ == FUTURES)
			 {
					strcpy(c_service_nm,"SFO_FUT_PLC_ORD");
			 }
			 else
			 {
					strcpy(c_service_nm,"SFO_OPT_PLC_ORD");
			 }

			break;

			default:
				 fn_userlog(c_ServiceName,"Inside DEFAULT");
				 fn_errlog( c_ServiceName, "S31065", "Invalid product type", c_err_msg  );
				 strcpy(c_err_msg,"Invalid product type");
				 Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 );
				 Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
				 Fadd32( ptr_fml_Obuf,FFO_ORDR_RFRNC, c_null_msg, 0 );

        i_ch_val = Fconcat32(ptr_fml_Obuf,ptr_fml_Ibuf);

        if( i_ch_val == -1)
        {
          fn_errlog( c_ServiceName, "S31070",FMLMSG,c_err_msg);
          Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 );
          Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Obuf,FFO_ORDR_RFRNC, c_null_msg, 0 );
        }

				 continue;
		}
					
		if(DEBUG_MSG_LVL_3)
		{
			fn_userlog(c_ServiceName,"Before calling order rout ");
			fn_userlog(c_ServiceName,"MTCH ACNT :%s: XCH :%s: PRDCT :%c: EXPRY DT :%s: UNDRLNG :%s: STRK_PRC :%ld: option type :%c:", c_clm_mtch_accnt, c_xchng_cd, c_prdct_typ, c_expry_dt, c_undrlyng, sql_fcm_strk_prc, sql_fcm_opt_typ ); 
		}
			
		ptr_fml_Sbuf = (FBFR32*)tpalloc ( "FML32", NULL, MIN_FML_BUF_LEN );
				
		if ( ptr_fml_Sbuf == NULL )
		{
			fn_errlog( c_ServiceName, "S31075", TPMSG, c_err_msg  );
			strcpy(c_err_msg,"Problem in Placing order");
			Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 );
			Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
			Fadd32( ptr_fml_Obuf,FFO_ORDR_RFRNC, c_null_msg, 0 );

        i_ch_val = Fconcat32(ptr_fml_Obuf,ptr_fml_Ibuf);

        if( i_ch_val == -1)
        {
          fn_errlog( c_ServiceName, "S31080",FMLMSG,c_err_msg);
          Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 );
          Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Obuf,FFO_ORDR_RFRNC, c_null_msg, 0 );
        }

			continue;
		}

		ptr_fml_Rbuf = ( FBFR32 * ) tpalloc ( "FML32", NULL, MIN_FML_BUF_LEN );

		if ( ptr_fml_Rbuf == NULL )
		{
			fn_errlog( c_ServiceName, "S31085", TPMSG, c_err_msg  );
			strcpy(c_err_msg,"Problem in Placing order");
			Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 );
			Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
			Fadd32( ptr_fml_Obuf,FFO_ORDR_RFRNC, c_null_msg, 0 );

        i_ch_val = Fconcat32(ptr_fml_Obuf,ptr_fml_Ibuf);

        if( i_ch_val == -1)
        {
          fn_errlog( c_ServiceName, "S31090",FMLMSG,c_err_msg);
          Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 );
          Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Obuf,FFO_ORDR_RFRNC, c_null_msg, 0 );
        }

			continue;
		}
						
		i_ch_val = Finit32 ( ptr_fml_Sbuf, MIN_FML_BUF_LEN );
			
		if (i_ch_val == -1)
		{
			fn_errlog( c_ServiceName, "S31095", FMLMSG, c_err_msg  );
			strcpy(c_err_msg,"Problem in Placing order");
			tpfree ( ( char * ) ptr_fml_Sbuf );
			tpfree ( ( char * ) ptr_fml_Rbuf );
			Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, (char *)c_err_msg, 0 );
			Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
			Fadd32( ptr_fml_Obuf,FFO_ORDR_RFRNC, c_null_msg, 0 );

        i_ch_val = Fconcat32(ptr_fml_Obuf,ptr_fml_Ibuf);

        if( i_ch_val == -1)
        {
          fn_errlog( c_ServiceName, "S31100",FMLMSG,c_err_msg);
          Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 );
          Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Obuf,FFO_ORDR_RFRNC, c_null_msg, 0 );
        }

			continue;
		}

		i_ch_val = Finit32 ( ptr_fml_Rbuf, MIN_FML_BUF_LEN );
			
		if (i_ch_val == -1)
		{
			fn_errlog( c_ServiceName, "S31105", FMLMSG, c_err_msg  );
			strcpy(c_err_msg,"Problem in Placing order");
			tpfree ( ( char * ) ptr_fml_Sbuf );
			tpfree ( ( char * ) ptr_fml_Rbuf );
			Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, (char *)c_err_msg, 0 );
			Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
			Fadd32( ptr_fml_Obuf,FFO_ORDR_RFRNC, c_null_msg, 0 );

        i_ch_val = Fconcat32(ptr_fml_Obuf,ptr_fml_Ibuf);

        if( i_ch_val == -1)
        {
          fn_errlog( c_ServiceName, "S31110",FMLMSG,c_err_msg);
          Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 );
          Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Obuf,FFO_ORDR_RFRNC, c_null_msg, 0 );
        }

			continue;	
		}
						
		INIT(i_err,40);
				
		l_dsclsd_qty = 0;
		c_spl_flg 	 = 'N';

		i_err [ 0 ]  = Fchg32 ( ptr_fml_Sbuf, FFO_SPL_FLG,0, ( char * )&c_spl_flg, 0 );
		i_err [ 1 ]  = Fchg32 ( ptr_fml_Sbuf, FFO_EBA_MTCH_ACT_NO,0, ( char * )c_clm_mtch_accnt, 0 );
		i_err [ 2 ]  = Fchg32 ( ptr_fml_Sbuf, FFO_XCHNG_CD,0, ( char * )c_xchng_cd, 0 );
		i_err [ 3 ]  = Fchg32 ( ptr_fml_Sbuf, FFO_PRDCT_TYP,0, ( char * )&c_prdct_typ, 0 );
		i_err [ 4 ]  = Fchg32 ( ptr_fml_Sbuf, FFO_UNDRLYNG,0, ( char * )c_undrlyng, 0 );
		i_err [ 5 ]  = Fchg32 ( ptr_fml_Sbuf, FFO_EXPRY_DT,0, ( char * )c_expry_dt, 0 );
		i_err [ 6 ]  = Fchg32 ( ptr_fml_Sbuf, FFO_OPT_TYP,0, ( char * )&sql_fcm_opt_typ, 0 );
		i_err [ 7 ]  = Fchg32 ( ptr_fml_Sbuf, FFO_STRK_PRC,0, ( char * )&sql_fcm_strk_prc, 0 );
		i_err [ 8 ]  = Fchg32 ( ptr_fml_Sbuf, FFO_CTGRY_INDSTK,0, ( char * )&c_ctgry_indstk, 0 );
		i_err [ 9 ]  = Fchg32 ( ptr_fml_Sbuf, FFO_LMT_MKT_SL_FLG,0, ( char * )&c_lmt_mkt_sl_flg, 0 );
		i_err [ 10 ] = Fchg32 ( ptr_fml_Sbuf, FFO_ORDR_FLW,0, ( char * )&c_ordr_flw, 0 );
		i_err [ 11 ] = Fchg32 ( ptr_fml_Sbuf, FFO_STP_LSS_TGR,0, ( char * )&l_stp_lss_tgr, 0 );
		i_err [ 12 ] = Fchg32 ( ptr_fml_Sbuf, FFO_LMT_RT,0, ( char * )&l_lmt_rt, 0 );
		i_err [ 13 ] = Fchg32 ( ptr_fml_Sbuf, FFO_ORD_TYP,0, ( char * )&c_ord_typ, 0 );
		i_err [ 14 ] = Fchg32 ( ptr_fml_Sbuf, FFO_SVC_NAME,0, ( char * )c_service_nm, 0 );
		i_err [ 15 ] = Fchg32 ( ptr_fml_Sbuf, FFO_CHANNEL,0, ( char * )c_channel, 0 );
		i_err [ 16 ] = Fchg32 ( ptr_fml_Sbuf, FFO_DSCLSD_QTY,0, ( char * )&l_dsclsd_qty,0);
		i_err [ 17 ] = Fchg32 ( ptr_fml_Sbuf, FFO_ORD_TOT_QTY,0, ( char * )&l_ord_tot_qty,0);
		i_err [ 18 ] = Fchg32 ( ptr_fml_Sbuf, FFO_EXER_TYP,0, ( char * )&c_exrc_typ,0);
		i_err [ 19 ] = Fchg32 ( ptr_fml_Sbuf, FFO_ALIAS,0, ( char * )c_alias,0);
		i_err [ 20 ] = Fchg32 ( ptr_fml_Sbuf, FFO_USR_ID,0,( char * )c_usr_id,0);
		i_err [ 21 ] = Fchg32 ( ptr_fml_Sbuf, FFO_SSSN_ID,0,(char *)&l_sssn_id,0);

		for ( i_Fget = 0; i_Fget <= 21; i_Fget++ ) 
		{
			if ( i_err [ i_Fget ] == -1 )
			{
				fn_userlog (c_ServiceName, "Error in field |%d|", i_Fget );
				fn_errlog ( c_ServiceName,"S31115",FMLMSG, c_err_msg  );
				tpfree ( ( char * ) ptr_fml_Sbuf );
				tpfree ( ( char * ) ptr_fml_Rbuf );
				Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 );
				Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
				Fadd32( ptr_fml_Obuf,FFO_ORDR_RFRNC, c_null_msg, 0 );

        i_ch_val = Fconcat32(ptr_fml_Obuf,ptr_fml_Ibuf);

        if( i_ch_val == -1)
        {
          fn_errlog( c_ServiceName, "S31120",FMLMSG,c_err_msg);
          Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 );
          Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Obuf,FFO_ORDR_RFRNC, c_null_msg, 0 );
        }

				continue;
			}
		}

		if(tpcall("SFO_ORD_ROUT",(char*)ptr_fml_Sbuf,0,(char **)&ptr_fml_Rbuf,&li_len_tobuf,0) == -1)
		{
			if (TPCODE != TPESVCFAIL)
			{
				 fn_errlog( c_ServiceName, "S31125",TPMSG,c_err_msg);
				 fn_userlog( c_ServiceName, "TP CODE IS    |%d|",TPCODE);
			}
			else
			{
				i_ch_val = Fget32(ptr_fml_Rbuf, FFO_ERR_MSG, 0, ( char * )c_err_msg, 0);

				if (i_ch_val == -1)
				{
					fn_errlog( c_ServiceName, "S31130",FMLMSG,c_err_msg);
	
					i_ch_val = Fconcat32(ptr_fml_Obuf,ptr_fml_Sbuf);

					tpfree ( ( char * ) ptr_fml_Sbuf );
					tpfree ( ( char * ) ptr_fml_Rbuf );
					Fadd32( ptr_fml_Obuf,FFO_ERR_MSG, c_err_msg, 0 );
					Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
					Fadd32( ptr_fml_Obuf,FFO_ORDR_RFRNC, c_null_msg, 0 );
					continue;
				}
			}


			i_ch_val = Fget32(ptr_fml_Rbuf, FFO_ACTN_ID, 0, (char *)&i_actn_id, 0);

			if (i_ch_val == -1 && Ferror32 !=FNOTPRES)
			{
				fn_errlog( c_ServiceName, "S31135",FMLMSG,c_err_msg);

				i_ch_val = Fconcat32(ptr_fml_Obuf,ptr_fml_Sbuf);

				tpfree ( ( char * ) ptr_fml_Sbuf );
				tpfree ( ( char * ) ptr_fml_Rbuf );
				Fadd32( ptr_fml_Obuf,FFO_ERR_MSG, c_err_msg, 0 );
				Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
				Fadd32( ptr_fml_Obuf,FFO_ORDR_RFRNC, c_null_msg, 0 );
 				continue;
 			}
			else if( Ferror32 == FNOTPRES)
			{
				i_actn_id = -1;

				Fadd32( ptr_fml_Obuf,FFO_ERR_MSG, c_err_msg, 0 );

        fn_errlog( c_ServiceName, "S31140",FMLMSG,c_err_msg);	
        i_ch_val = Fconcat32(ptr_fml_Obuf,ptr_fml_Sbuf);

        tpfree ( ( char * ) ptr_fml_Sbuf );
        tpfree ( ( char * ) ptr_fml_Rbuf );
        Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Obuf,FFO_ORDR_RFRNC, c_null_msg, 0 );
        continue;
			}

			if(i_actn_id == 1)
			{	
				fn_userlog(c_ServiceName,"Inside Error ORDER NO |%d|",i_cnt );
				fn_errlog( c_ServiceName,"S31145","Order value very high: Use the normal Buy/Sell screen.",c_err_msg);
				strcpy(c_err_msg,"Order value very high: Use the normal Buy/Sell screen.");
			}

			fn_userlog( c_ServiceName, "ERROR Return from SFO_ORD_ROUT for record |%d| is :%s:",i_cnt,c_err_msg);

    	i_bufferlength = MIN_FML_BUF_LEN * 300 ;

    	if (Funused32(ptr_fml_Obuf) <= Fneeded32(1,i_bufferlength))
    	{
      	l_counter++;

      	ptr_fml_Obuf=(FBFR32 *)tprealloc( (char *)ptr_fml_Obuf,
       	                   (Fsizeof32(ptr_fml_Obuf)+(l_counter*MIN_FML_BUF_LEN)));

      	if (ptr_fml_Obuf == NULL)
      	{
        	fn_errlog(c_ServiceName,"S31150",TPMSG,c_err_msg);
        	Fadd32( ptr_fml_Obuf,FFO_ERR_MSG, c_err_msg, 0 );
        	Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        	tpfree ( ( char * ) ptr_fml_Sbuf );
        	tpfree ( ( char * ) ptr_fml_Rbuf );
        	tpreturn(TPFAIL,ERR_BFR, (char *)ptr_fml_Obuf, 0, 0);
      	}
    	}
		
			i_ch_val = Fconcat32(ptr_fml_Obuf,ptr_fml_Sbuf);

      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      Fadd32( ptr_fml_Obuf,FFO_ERR_MSG, c_err_msg, 0 );
			Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Obuf,FFO_ORDR_RFRNC, c_null_msg, 0 );	
			continue;
  	}

		i_ch_val = Fget32 ( ptr_fml_Rbuf, FFO_ORDR_RFRNC, 0,
                                ( char * )c_ordr_rfrnc, 0 );
    if( i_ch_val == -1 )
    {	
			fn_errlog ( c_ServiceName,"S31155",FMLMSG, c_err_msg  );

			i_ch_val = Fconcat32(ptr_fml_Obuf,ptr_fml_Sbuf);

      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      Fadd32( ptr_fml_Obuf,FFO_ERR_MSG, c_err_msg, 0 );
			Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Obuf,FFO_ORDR_RFRNC, c_null_msg, 0 );
      continue ;
    }

    if(DEBUG_MSG_LVL_3)
    {
      fn_userlog(c_ServiceName, "OUTPUT OF SFO_PLC_BSKTORD FOR SUCCESSFUL ORDER no |%d|",i_cnt );
      fn_userlog(c_ServiceName, "c_ordr_rfrnc is     |%s|", c_ordr_rfrnc);
    }

 		i_bufferlength = MIN_FML_BUF_LEN * 300  ; 

  	if (Funused32(ptr_fml_Obuf) <= Fneeded32(1,i_bufferlength))
  	{
    	l_counter++;

    	ptr_fml_Obuf=(FBFR32 *)tprealloc( (char *)ptr_fml_Obuf,
    	                    (Fsizeof32(ptr_fml_Obuf)+(l_counter*MIN_FML_BUF_LEN)));

    	if (ptr_fml_Obuf == NULL)
    	{
      	fn_errlog(c_ServiceName,"S31160",TPMSG,c_err_msg);
      	Fadd32( ptr_fml_Obuf,FFO_ERR_MSG, c_err_msg, 0 );
				Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
				tpfree ( ( char * ) ptr_fml_Sbuf );
      	tpfree ( ( char * ) ptr_fml_Rbuf );
      	tpreturn(TPFAIL,ERR_BFR, (char *)ptr_fml_Obuf, 0, 0);
    	}
  	}

		i_ch_val = Fconcat32(ptr_fml_Obuf,ptr_fml_Rbuf);

    if( i_ch_val == -1)
    {
      fn_errlog( c_ServiceName, "S31165",FMLMSG,c_err_msg);

			i_ch_val = Fconcat32(ptr_fml_Obuf,ptr_fml_Sbuf);

      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Obuf,FFO_ORDR_RFRNC, c_null_msg, 0 );
      continue ;
    }
  	
		tpfree ( ( char * ) ptr_fml_Sbuf );
    tpfree ( ( char * ) ptr_fml_Rbuf );

    strcpy(c_err_msg," Your Order Has Been Placed Successfully");
		
		Fadd32( ptr_fml_Obuf,FFO_ERR_MSG, c_err_msg, 0 );
	
		
	} /* End of for loop */
 }
 /** Ver 1.3 starts **/ 
 if(c_source_flag == 'B' && c_rqst_typ == 'R')
 {
   l_no_of_orders = Foccur32((FBFR32 *)ptr_fml_Ibuf,FFO_ORDR_RFRNC);
  
   if(DEBUG_MSG_LVL_3)
   {
    fn_userlog(c_ServiceName,"FFO_REC_NO :%ld:",l_no_of_orders);
   }
 
   if(l_no_of_orders > 0)
   {
     /** Creating time obeject **/
     EXEC SQL

        SELECT 'O'||TO_CHAR(sysdate,'ddmmyyhh24miss') 
        INTO   :c_insrt_tm 
        FROM DUAL;
    
     if (SQLCODE != 0)
     {
      fn_userlog(c_ServiceName,"Problem in creating time object");
      fn_errlog( c_ServiceName, "S31170", SQLMSG, c_err_msg);
		  Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 ); /* Ver 1.4 */
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Obuf, 0, 0 );		/* Ver 1.4  */
     }

     for(i_cnt =0 ; i_cnt < l_no_of_orders; i_cnt++)
     {
       INIT(i_err,40);

      i_err[0]  = Fget32(ptr_fml_Ibuf,FFO_PRDCT_TYP,i_cnt,(char *)&c_prdct_typ,0) ;
      i_err[1]  = Fget32(ptr_fml_Ibuf,FFO_XCHNG_CD,i_cnt,(char *)c_xchng_cd,0) ;
      i_err[2]  = Fget32(ptr_fml_Ibuf,FFO_EBA_MTCH_ACT_NO,i_cnt,(char *)c_clm_mtch_accnt,0) ;
      i_err[3]  = Fget32(ptr_fml_Ibuf,FFO_LMT_MKT_SL_FLG,i_cnt,(char *)&c_lmt_mkt_sl_flg,0) ;
      i_err[4]  = Fget32(ptr_fml_Ibuf,FFO_ORD_TYP,i_cnt,(char *)&c_ord_typ,0) ;
      i_err[5]  = Fget32(ptr_fml_Ibuf,FFO_ORDR_FLW,i_cnt,(char *)&c_ordr_flw,0) ;
      i_err[6]  = Fget32(ptr_fml_Ibuf,FFO_EXPRY_DT,i_cnt,(char *)c_expry_dt,0) ;
      i_err[7]  = Fget32(ptr_fml_Ibuf,FFO_UNDRLYNG,i_cnt,(char *)c_undrlyng,0) ;
      i_err[8]  = Fget32(ptr_fml_Ibuf,FFO_STRK_PRC,i_cnt,(char *)&sql_fcm_strk_prc,0) ;
      i_err[9]  = Fget32(ptr_fml_Ibuf,FFO_OPT_TYP,i_cnt,(char *)&sql_fcm_opt_typ,0) ;
      i_err[10] = Fget32(ptr_fml_Ibuf,FFO_LMT_RT,i_cnt,(char *)&l_lmt_rt,0) ;
      i_err[11] = Fget32(ptr_fml_Ibuf,FFO_CURR_RT,i_cnt,(char *)&l_frsh_lmt_rt,0);
      i_err[12] = Fget32(ptr_fml_Ibuf,FFO_CTGRY_INDSTK,i_cnt,(char *)&c_ctgry_indstk,0);
      i_err[13] = Fget32(ptr_fml_Ibuf,FFO_STP_LSS_TGR,i_cnt,(char *)&l_stp_lss_tgr,0);
      i_err[14] = Fget32(ptr_fml_Ibuf,FFO_EXER_TYP,i_cnt,(char *)&c_exrc_typ,0);
      i_err[15] = Fget32(ptr_fml_Ibuf,FFO_ORD_TOT_QTY,i_cnt,(char *)&l_ord_tot_qty,0);
      i_err[16] = Fget32(ptr_fml_Ibuf,FFO_ORDR_RFRNC,i_cnt,(char *)&c_bskt_ordr_ref,0); 
      
      for( i_Fget = 0 ; i_Fget <= 16 ; i_Fget++ )
      {
       if(i_err[i_Fget] == -1)
       {
         fn_userlog(c_ServiceName,"Error in Fget of :%d:",i_Fget);
         fn_errlog( c_ServiceName, "S31175", FMLMSG, c_err_msg  );
         strcpy(c_err_msg,"Problem in Placing order");
         Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, (char *)c_err_msg, 0 );
         Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
         Fadd32( ptr_fml_Ibuf,FFO_ORDR_RFRNC, c_null_msg, 0 );
				 tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Obuf, 0, 0 );/** Ver 1.4 **/
       }
      }
 
      i_trnsctn = fn_begintran( c_ServiceName, c_err_msg );

      if ( i_trnsctn == -1 )
      {
			 fn_errlog( c_ServiceName, "S31180", SQLMSG, c_err_msg  );
       Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID , (char *)&i_actn_id , 0 );
       tpfree ( ( char * ) ptr_fml_Obuf );/** Ver 1.4**/
       tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); 
      }

      EXEC SQL
      INSERT INTO FBC_FO_BSKT_CNTRCT_MRGN
        (
          FBC_USR_ID,
          FBC_CLM_MTCH_ACCNT,   /** Added in Ver 1.5 **/
          FBC_XCHNG_CD,
          FBC_PRDCT_TYP,
          FBC_INDSTK,
          FBC_UNDRLYNG,
          FBC_EXPRY_DT,
          FBC_EXER_TYP,
          FBC_OPT_TYP,
          FBC_STRK_PRC,
          FBC_ORDR_FLW,
          FBC_ORDR_TOT_QTY,
          FBC_LMT_MRKT_FLG,
          FBC_ORDR_TYPE,
          FBC_FRS_LMT_RT,
          FBC_CVR_LMT_RT,
          FBC_CVR_SLTP_RT,
          FBC_SRC_TYP,
          FBC_ORDR_RFRNC,
          FBC_BSKT_ID,
          FBC_INSRT_TM,
          FBC_ORDR_PLC_STTS
        )
        VALUES
        (
          :c_usr_id,
          :c_clm_mtch_accnt,   /** Added in Ver 1.5 **/
          :c_xchng_cd,
          :c_prdct_typ,
          :c_ctgry_indstk,
          :c_undrlyng,
          to_date(:c_expry_dt,'DD-Mon-yyyy'),
          :c_exrc_typ,
          :sql_fcm_opt_typ,
          :sql_fcm_strk_prc,
          :c_ordr_flw,
          :l_ord_tot_qty,
          :c_lmt_mkt_sl_flg,
          :c_ord_typ,
          :l_frsh_lmt_rt,
          :l_lmt_rt,
          :l_cvr_sltp_rt,
          :c_source_flag,
          :c_bskt_ordr_ref,
          :c_bskt_id,
          :c_insrt_tm,
          'I'
        );

      if ( SQLCODE != 0 )
       {
        fn_userlog(c_ServiceName,"Problem in inserting order");
        fn_errlog( c_ServiceName, "S31185", SQLMSG, c_err_msg);
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg);
				tpfree ( ( char * ) ptr_fml_Obuf );/** Ver 1.4**/
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
       }

      if(DEBUG_MSG_LVL_3)
      {
       fn_userlog(c_ServiceName,"FBC_ORDR_PLC_STTS flag set as 'I'");
      }

      if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg ) == -1 )
      {
       fn_errlog( c_ServiceName, "S31190", FMLMSG, c_err_msg  );
       fn_userlog(c_ServiceName,"FBC_ORDR_STTS IS NOT UPDATED");
       fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg);  /* Ver 1.4 */
       Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID , (char *)&i_actn_id , 0 );
       tpfree ( ( char * ) ptr_fml_Obuf );/** Ver 1.4**/
       tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); 
      }
     }
   }
   else
   {
     fn_userlog(c_ServiceName,"After sleeping");
     if(Fget32( ptr_fml_Ibuf,FFO_TM_STMP,0,(char *)&c_insrt_tm,0 ) == -1)
     {
      if( Ferror32 == FNOTPRES)
      {
        strcpy(c_insrt_tm,"");
      }
      else
      {
       fn_userlog(c_ServiceName,"Error in getting time object");
       fn_errlog( c_ServiceName, "S31195", FMLMSG, c_err_msg  );
       strcpy(c_err_msg,"Error in getting time object");
			 tpfree ( ( char * ) ptr_fml_Obuf );/** Ver 1.4**/
       Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, (char *)c_err_msg, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
       tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
     }

     if(DEBUG_MSG_LVL_3)
     {
       fn_userlog(c_ServiceName,"FFO_USR_ID is :%s:",c_usr_id);
       fn_userlog(c_ServiceName,"FFO_SOURCE_FLG is :%c:",c_source_flag);
       fn_userlog(c_ServiceName,"FFO_SERIES:%s:",c_bskt_id);  
       fn_userlog(c_ServiceName,"FFO_RQST_TYP is :%c:",c_rqst_typ);
       fn_userlog(c_ServiceName,"FFO_SSSN_ID is :%ld:",l_sssn_id);
       fn_userlog(c_ServiceName,"FFO_SPL_FLG is :%c:",c_spl_flg);
       fn_userlog(c_ServiceName,"Channel :%s:",c_channel);
       fn_userlog(c_ServiceName,"Insert Time is :%s:",c_insrt_tm); 
     } 
   }
    
   EXEC SQL
				SELECT mtch_accnt,  /** Added in Ver 1.5 **/
               exg_cd,
               prdct_typ,
               undrlyng,
               expry_dt,
               exer_typ,
               opt_typ,
               strk_prc,
               ctgry_indx,
               total_qt,
               lmt_flg,
               cvr_sltp_rt,
               frsh_lmt_rt,
               cvr_lmt_rt,
               ordr_flw,
               ordr_typ,
               ordr_refrnc
		 INTO     
               :c_clm_mtch_accnt,  /** Added in Ver 1.5 **/
							 :c_xchng_cd,
               :c_prdct_typ,
               :c_undrlyng,
               :c_expry_dt,
               :c_exrc_typ,
               :sql_fcm_opt_typ,
               :sql_fcm_strk_prc,
               :c_ctgry_indstk,
               :l_ord_tot_qty,
               :c_lmt_mkt_sl_flg,
               :l_cvr_sltp_rt,
               :l_frsh_lmt_rt,
               :l_lmt_rt,
               :c_ordr_flw,
               :c_ord_typ,
               :c_bskt_ordr_ref
      FROM (
      SELECT   FBC_CLM_MTCH_ACCNT mtch_accnt,   /** Added in Ver 1.5 **/
               FBC_XCHNG_CD exg_cd,
               FBC_PRDCT_TYP prdct_typ,
               FBC_UNDRLYNG undrlyng,
               TO_CHAR(FBC_EXPRY_DT,'DD-Mon-YYYY')expry_dt,
               FBC_EXER_TYP exer_typ,
               FBC_OPT_TYP opt_typ,
               FBC_STRK_PRC strk_prc,
               FBC_INDSTK ctgry_indx,
               nvl(FBC_ORDR_TOT_QTY,0) total_qt,
               nvl(FBC_LMT_MRKT_FLG,0)lmt_flg,
               nvl(FBC_CVR_SLTP_RT,0)cvr_sltp_rt,
               nvl(FBC_FRS_LMT_RT,0)frsh_lmt_rt,
               nvl(FBC_CVR_LMT_RT,0) cvr_lmt_rt,
               FBC_ORDR_FLW ordr_flw,
               FBC_ORDR_TYPE ordr_typ,
               nvl(FBC_ORDR_RFRNC,'NA') ordr_refrnc
      FROM     FBC_FO_BSKT_CNTRCT_MRGN
      WHERE    FBC_ORDR_PLC_STTS = 'I'
      AND      FBC_INSRT_TM = :c_insrt_tm
      AND      FBC_USR_ID   = :c_usr_id
      AND      FBC_SRC_TYP = :c_source_flag
      AND      FBC_BSKT_ID = :c_bskt_id
      ORDER BY FBC_ORDR_FLW ASC,
	           FBC_PRDCT_TYP DESC)
      WHERE ROWNUM =1;    

      if(SQLCODE != 0 && SQLCODE != NO_DATA_FOUND)
      {
        fn_userlog(c_ServiceName,"Error while getting the data for basket id :%s:",c_bskt_id);
        fn_errlog( c_ServiceName, "S31200", SQLMSG, c_err_msg);
        Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 );  /* Ver 1.4 */
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Obuf, 0, 0 ); /* Ver 1.4 */
      }
      
      if ( SQLCODE == NO_DATA_FOUND )
      {
        fn_userlog(c_ServiceName,"No data found for c_user_id :%s: ,basket_id :%s:",c_usr_id,c_bskt_id);
        fn_userlog(c_ServiceName,"Sleep function & Basket order for Buy First is successful");
				tpfree ( ( char * ) ptr_fml_Obuf );/** Ver 1.4**/	
        /** commented in ver 1.4 tpreturn(TPSUCCESS, 0, (char *)ptr_fml_Rbuf, 0 , 0 ); **/
        tpreturn(TPSUCCESS, 0, (char *)ptr_fml_Ibuf, 0 , 0 ); /** Added in Ver 1.4 **/
      }

    /** Commented in Ver 1.5 
      EXEC SQL
      SELECT UAC_CLM_MTCH_ACCNT
      INTO   :c_clm_mtch_accnt
      FROM   UAC_USR_ACCNTS
      WHERE  UAC_USR_ID=:c_usr_id;

      if(SQLCODE != 0)
      {
       fn_userlog(c_ServiceName,"Error while getting match account for user :%s:",c_usr_id);
       fn_errlog( c_ServiceName, "S31205", SQLMSG, c_err_msg);
       Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 );  * Ver 1.4 *
       tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Obuf, 0, 0 );
      }  

      if(DEBUG_MSG_LVL_3)
      {
       fn_userlog(c_ServiceName,"UAC_CLM_MTCH_ACCNT is :%s:",c_clm_mtch_accnt);
      } **/  
     
      if(c_usr_id[0] == BPID)
      {
        /** commented in ver 1.6 strcpy(c_alias,c_usr_id); **/
        /** Ver 1.6 Starts **/
        EXEC SQL
        SELECT NVL(CLM_ALIAS_NAME,'*')
    		INTO   :c_alias
    		FROM   CLM_CLNT_MSTR
    		WHERE  CLM_MTCH_ACCNT = :c_clm_mtch_accnt;
      
        if(SQLCODE != 0)
        {
         fn_userlog(c_ServiceName,"Error while getting alias for BPIDs");
         fn_errlog( c_ServiceName, "S31210", SQLMSG, c_err_msg);
         Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 );  
         tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Obuf, 0, 0 );
        }
        
        if(DEBUG_MSG_LVL_3)
        {
         fn_userlog(c_ServiceName,"CLM_ALIAS_NAME is :%s:",c_alias);
        }
        /** Ver 1.6 ends **/
      }

       ptr_fml_Sbuf = (FBFR32*)tpalloc ( "FML32", NULL, MIN_FML_BUF_LEN );

       if ( ptr_fml_Sbuf == NULL )
       {
         fn_errlog ( c_ServiceName, "S31215", TPMSG,c_err_msg );
         Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 ); /* Ver 1.4 */
         tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Obuf, 0, 0 ); /* Ver 1.4 */
         /* Commented in ver 1.4  tpreturn(TPFAIL, ERR_BFR, (char *)c_err_msg, 0, 0 ); */
       }

       ptr_fml_Rbuf = ( FBFR32 * ) tpalloc ( "FML32", NULL, MIN_FML_BUF_LEN );

       if ( ptr_fml_Rbuf == NULL )
       {
         fn_errlog ( c_ServiceName, "S31220", TPMSG,c_err_msg );
         Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 ); /* Ver 1.4 */
         tpfree ( ( char * )ptr_fml_Sbuf); /* Ver 1.4 */
         tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Obuf, 0, 0 ); /* Ver 1.4 */
        /** Commented in Ver 1.4 tpreturn(TPFAIL, ERR_BFR, (char *)c_err_msg, 0, 0 ); */
       }

       i_ch_val = Finit32 ( ptr_fml_Sbuf, MIN_FML_BUF_LEN );

       if (i_ch_val == -1)
       {
         fn_errlog ( c_ServiceName, "S31225", TPMSG,c_err_msg );
         tpfree ( ( char * ) ptr_fml_Sbuf );  /* Ver 1.4 */
         tpfree ( ( char * ) ptr_fml_Rbuf );  /* Ver 1.4 */
         Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 ); /* Ver 1.4 */
         tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Obuf, 0, 0 ); /* Ver 1.4 */
         /** commented in ver 1.4 tpreturn(TPFAIL, ERR_BFR, (char *)c_err_msg, 0, 0 );
         tpfree ( ( char * ) ptr_fml_Sbuf );
         tpfree ( ( char * ) ptr_fml_Rbuf ); **/
       }

       i_ch_val = Finit32 ( ptr_fml_Rbuf, MIN_FML_BUF_LEN );

       if (i_ch_val == -1)
       {
         fn_errlog ( c_ServiceName, "S31230", TPMSG,c_err_msg );
         tpfree ( ( char * ) ptr_fml_Sbuf );  /* Ver 1.4 */
         tpfree ( ( char * ) ptr_fml_Rbuf );  /* Ver 1.4 */
         Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 ); /* Ver 1.4 */
         tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Obuf, 0, 0 ); /* Ver 1.4 */
         /* Commented in ver 1.4 tpreturn(TPFAIL, ERR_BFR, (char *)c_err_msg, 0, 0 );
         tpfree ( ( char * ) ptr_fml_Sbuf );
         tpfree ( ( char * ) ptr_fml_Rbuf ); **/
       }


       INIT(i_err,40);

       l_dsclsd_qty = 0;
       strcpy(c_service_nm,"SFO_SPN_PLC_ORD");

       i_err [ 0 ]  = Fchg32 ( ptr_fml_Sbuf, FFO_SPL_FLG,0, ( char * )&c_spl_flg, 0 );
       i_err [ 1 ]  = Fchg32 ( ptr_fml_Sbuf, FFO_EBA_MTCH_ACT_NO,0, ( char * )c_clm_mtch_accnt, 0 );
       i_err [ 2 ]  = Fchg32 ( ptr_fml_Sbuf, FFO_XCHNG_CD,0, ( char * )c_xchng_cd, 0 );
       i_err [ 3 ]  = Fchg32 ( ptr_fml_Sbuf, FFO_PRDCT_TYP,0, ( char * )&c_prdct_typ, 0 );
       i_err [ 4 ]  = Fchg32 ( ptr_fml_Sbuf, FFO_UNDRLYNG,0, ( char * )c_undrlyng, 0 );
       i_err [ 5 ]  = Fchg32 ( ptr_fml_Sbuf, FFO_EXPRY_DT,0, ( char * )c_expry_dt, 0 );
       i_err [ 6 ]  = Fchg32 ( ptr_fml_Sbuf, FFO_OPT_TYP,0, ( char * )&sql_fcm_opt_typ, 0 );
       i_err [ 7 ]  = Fchg32 ( ptr_fml_Sbuf, FFO_STRK_PRC,0, ( char * )&sql_fcm_strk_prc, 0 );
       i_err [ 8 ]  = Fchg32 ( ptr_fml_Sbuf, FFO_CTGRY_INDSTK,0, ( char * )&c_ctgry_indstk, 0 );
       i_err [ 9 ]  = Fchg32 ( ptr_fml_Sbuf, FFO_LMT_MKT_SL_FLG,0, ( char * )&c_lmt_mkt_sl_flg, 0 );
       i_err [ 10 ] = Fchg32 ( ptr_fml_Sbuf, FFO_ORDR_FLW,0, ( char * )&c_ordr_flw, 0 );
       i_err [ 11 ] = Fchg32 ( ptr_fml_Sbuf, FFO_LMT_RT,0,( char *)&l_lmt_rt,0) ;
       i_err [ 12 ] = Fchg32 ( ptr_fml_Sbuf, FFO_CURR_RT,0,( char *)&l_frsh_lmt_rt,0);
       i_err [ 13 ] = Fchg32 ( ptr_fml_Sbuf, FFO_STP_LSS_TGR,0, ( char * )&l_cvr_sltp_rt, 0 );
       i_err [ 14 ] = Fchg32 ( ptr_fml_Sbuf, FFO_ORD_TYP,0, ( char * )&c_ord_typ, 0 );
       i_err [ 15 ] = Fchg32 ( ptr_fml_Sbuf, FFO_SVC_NAME,0, ( char * )c_service_nm, 0 );
       i_err [ 16 ] = Fchg32 ( ptr_fml_Sbuf, FFO_CHANNEL,0, ( char * )c_channel, 0 );
       i_err [ 17 ] = Fchg32 ( ptr_fml_Sbuf, FFO_DSCLSD_QTY,0, ( char * )&l_dsclsd_qty,0);
       i_err [ 18 ] = Fchg32 ( ptr_fml_Sbuf, FFO_ORD_TOT_QTY,0, ( char * )&l_ord_tot_qty,0);
       i_err [ 19 ] = Fchg32 ( ptr_fml_Sbuf, FFO_EXER_TYP,0, ( char * )&c_exrc_typ,0);
       i_err [ 20 ] = Fchg32 ( ptr_fml_Sbuf, FFO_ALIAS,0, ( char * )c_alias,0);
       i_err [ 21 ] = Fchg32 ( ptr_fml_Sbuf, FFO_USR_ID,0,( char * )c_usr_id,0);
       i_err [ 22 ] = Fchg32 ( ptr_fml_Sbuf, FFO_SSSN_ID,0,(char *)&l_sssn_id,0);
       i_err [ 23 ] = Fchg32 ( ptr_fml_Sbuf, FFO_ORDR_RFRNC,0,(char *)c_bskt_ordr_ref,0);

       for ( i_Fget = 0; i_Fget <= 23; i_Fget++ )
       {
         if ( i_err [ i_Fget ] == -1 )
         {
           fn_userlog (c_ServiceName, "Error in field |%d|", i_Fget );
           fn_errlog ( c_ServiceName,"S31235",FMLMSG, c_err_msg  );
           tpfree ( ( char * ) ptr_fml_Sbuf );
           tpfree ( ( char * ) ptr_fml_Rbuf );
           Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 );
           Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
					 tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Obuf, 0, 0 );/** Ver 1.4 **/
          }
       }

       if(DEBUG_MSG_LVL_5)
       {
         fn_userlog(c_ServiceName,"Sending data to spn_plc_ord");
         fn_userlog(c_ServiceName,"FFO_ALIAS is :%s:",c_alias) ;
         fn_userlog(c_ServiceName,"FFO_USR_ID is :%s:",c_usr_id) ;
         fn_userlog(c_ServiceName,"FFO_SSSN_ID is :%ld:",l_sssn_id) ;
         fn_userlog(c_ServiceName,"FFO_EBA_MTCH_ACT_NO is :%s:",c_clm_mtch_accnt);
         fn_userlog(c_ServiceName,"FFO_PRDCT_TYP is :%c:",c_prdct_typ);
         fn_userlog(c_ServiceName,"FFO_XCHNG_CD is :%s:",c_xchng_cd);
         fn_userlog(c_ServiceName,"FFO_UNDRLYNG is :%s:",c_undrlyng);
         fn_userlog(c_ServiceName,"FFO_EXPRY_DT is :%s:",c_expry_dt);
         fn_userlog(c_ServiceName,"FFO_LMT_MKT_SL_FLG is :%c:",c_lmt_mkt_sl_flg);
         fn_userlog(c_ServiceName,"FFO_ORDR_FLW is :%c:",c_ordr_flw);
         fn_userlog(c_ServiceName,"FFO_STRK_PRC is :%ld:",sql_fcm_strk_prc);
         fn_userlog(c_ServiceName,"FFO_ORD_TYP is :%c:",c_ord_typ);
         fn_userlog(c_ServiceName,"FFO_OPT_TYP is :%c:",sql_fcm_opt_typ);
         fn_userlog(c_ServiceName,"FFO_CTGRY_INDSTK is :%c:",c_ctgry_indstk);
         fn_userlog(c_ServiceName,"FFO_EXER_TYP is :%c:",c_exrc_typ);
         fn_userlog(c_ServiceName,"FFO_ORD_TOT_QTY is :%ld:",l_ord_tot_qty);
         fn_userlog(c_ServiceName,"FFO_LMT_RT is :%ld:",l_lmt_rt) ;
         fn_userlog(c_ServiceName,"FFO_CURR_RT is :%ld:",l_frsh_lmt_rt) ;
         fn_userlog(c_ServiceName,"FFO_STP_LSS_TGR is :%ld:",l_cvr_sltp_rt) ;
         fn_userlog(c_ServiceName,"FBC_ORDR_RFRNC is |%s|",c_bskt_ordr_ref);
       }

      i_returncode = tpcall("SFO_ORD_ROUT",(char*)ptr_fml_Sbuf,0,(char **)&ptr_fml_Rbuf,&li_len_tobuf,0);

      if (i_returncode == -1)
      {
        i_returncode = Fget32(ptr_fml_Rbuf, FFO_ERR_MSG, 0, c_err_msg, 0);
        fn_userlog(c_ServiceName,"Error log |%s|",c_err_msg);

        if (i_returncode == -1)
        {
         fn_errlog( c_ServiceName, "S31240",FMLMSG,c_err_msg);
        }
      }
      else if(i_returncode == 0)
      {
        fn_userlog(c_ServiceName,"Order Placed Successfully");
        strcpy(c_err_msg," Your Order Has Been Placed Successfully");
      }
  
      i_trnsctn = fn_begintran( c_ServiceName, c_err_msg );

      if ( i_trnsctn == -1 )
      {
        fn_errlog( c_ServiceName, "S31245", SQLMSG, c_err_msg); /* Ver 1.4 */
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID , (char *)&i_actn_id , 0 );
        tpfree ( ( char * ) ptr_fml_Sbuf );  /* Ver 1.4 */
        tpfree ( ( char * ) ptr_fml_Rbuf );  /* Ver 1.4 */
        tpfree ( ( char * ) ptr_fml_Obuf );  /* Ver 1.4 */
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); 
      }

      EXEC SQL
           UPDATE FBC_FO_BSKT_CNTRCT_MRGN
           SET    FBC_ORDR_PLC_STTS = 'C',
                  FBC_ORDR_PLC_RMRKS = :c_err_msg
           WHERE  FBC_ORDR_PLC_STTS = 'I'
           AND    FBC_USR_ID   = :c_usr_id
           AND    FBC_BSKT_ID  = :c_bskt_id
           AND    FBC_INSRT_TM = :c_insrt_tm
           AND    FBC_ORDR_RFRNC = :c_bskt_ordr_ref;

        if (SQLCODE != 0)
        {
          fn_userlog(c_ServiceName,"Problem in changin status");
          fn_errlog( c_ServiceName, "S31250", SQLMSG, c_err_msg);
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 ); /* Ver 1.4 */
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID , (char *)&i_actn_id , 0 ); /* Ver 1.4 */
          tpfree ( ( char * ) ptr_fml_Sbuf );  /* Ver 1.4 */
          tpfree ( ( char * ) ptr_fml_Rbuf );  /* Ver 1.4 */
          tpfree ( ( char * ) ptr_fml_Obuf );  /* Ver 1.4 */
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); /* Ver 1.4 */
        }

        if(DEBUG_MSG_LVL_5)
        {
          fn_userlog(c_ServiceName,"FBC_ORDR_PLC_STTS & FBC_ORDR_STTS_REMARK updated");
        }

        if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg ) == -1 )
        {
          fn_errlog( c_ServiceName, "S31255", FMLMSG, c_err_msg  );
          fn_userlog(c_ServiceName," FBC_ORDR_STTS IS NOT UPDATED");
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg);  /* Ver 1.4 */
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID , (char *)&i_actn_id , 0 );
          tpfree ( ( char * ) ptr_fml_Obuf ); /* Ver 1.4 */
          tpfree ( ( char * ) ptr_fml_Sbuf ); /* Ver 1.4 */
          tpfree ( ( char * ) ptr_fml_Rbuf ); /* Ver 1.4 */
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }

   tpfree ( ( char * ) ptr_fml_Sbuf ); 

   EXEC SQL
      SELECT FSP_BSKT_SLEEP
      INTO   :i_sleep_sec
      FROM   FSP_FO_SYSTM_PRMTR;

    if (SQLCODE != 0)
    {
      fn_userlog(c_ServiceName,"Problem in getting sleep sec from fsp table");
      fn_errlog( c_ServiceName, "S31260", SQLMSG, c_err_msg);
			i_sleep_sec = 1000000;		/* Ver 1.4 */
    }

   d_sleep_msec = (double)i_sleep_sec / 1000;
   if(DEBUG_MSG_LVL_3)
   {
     fn_userlog(c_ServiceName,"Sleep time is :%lf:",d_sleep_msec);
   } 
   if(d_sleep_msec > 0)
   {
     i_ch_val = Finit32 ( ptr_fml_Rbuf, MIN_FML_BUF_LEN );

       if (i_ch_val == -1)
       {
         fn_errlog ( c_ServiceName, "S31265", TPMSG,c_err_msg );
         tpfree ( ( char * ) ptr_fml_Rbuf ); /* Ver 1.4 */
         Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg, 0 ); /* Ver 1.4 */
         tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Obuf, 0, 0 ); /* Ver 1.4 */
         /** commented in Ver 1.4 tpreturn(TPFAIL, ERR_BFR, (char *)c_err_msg, 0, 0 );	
         tpfree ( ( char * ) ptr_fml_Sbuf );
         tpfree ( ( char * ) ptr_fml_Rbuf ); **/
       }

     i_returncode = fn_pack_vartofml ( c_ServiceName,
                                            c_err_msg,
                                            &ptr_fml_Rbuf,
                                            8,
                                            FFO_USR_ID, (char *)&c_usr_id,
                                            FFO_SERIES, (char *)&c_bskt_id,
                                            FFO_SOURCE_FLG,(char *)&c_source_flag,
                                            FFO_RQST_TYP,(char *)&c_rqst_typ,
                                            FFO_SSSN_ID, (char *)&l_sssn_id,
                                            FFO_SPL_FLG, (char *)&c_spl_flg,
                                            FFO_CHANNEL, (char *)&c_channel,
                                            FFO_TM_STMP, (char *)&c_insrt_tm);

    if(i_returncode == -1)
    {
       fn_userlog( c_ServiceName,"Error while calling fn_pack_vartofml  function.");
       fn_errlog ( c_ServiceName, "S31270", LIBMSG,c_err_msg );
       Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 ); /* Ver 1.4 */
       tpfree ( ( char * ) ptr_fml_Rbuf ); /* Ver 1.4 */
       tpfree ( ( char * ) ptr_fml_Obuf ); /* Ver 1.4 */
       /* Commented in Ver 1.4 tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); */
       tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); /** Added in Ver 1.4 **/
    }

     fn_userlog( c_ServiceName,"Calling fn_fno_sleep....");

     i_returncode =  fn_fno_sleep( c_ServiceName,
                                   &ptr_fml_Rbuf,
                                   d_sleep_msec,
                                   2,
                                   c_insrt_tm,
                                   "SFO_PLC_BSKTORD",
                                   c_err_msg);
      if(i_returncode == -1)
      {
         fn_userlog( c_ServiceName,"Error in calling sleep function.");
         fn_errlog ( c_ServiceName, "S31275", LIBMSG,c_err_msg );
         Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 ); /* Ver 1.4 */
         tpfree ( ( char * ) ptr_fml_Rbuf ); /* Ver 1.4 */
         tpfree ( ( char * ) ptr_fml_Obuf ); /* Ver 1.4 */
         tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    
      }
   }
   fn_userlog( c_ServiceName,"After Calling fn_fno_sleep....");
   tpfree ( ( char *) ptr_fml_Obuf ); /* Ver 1.4 */
   tpreturn( TPSUCCESS, 0, (char *)ptr_fml_Rbuf, 0 , 0 );
  
 }
 /** Ver 1.3 ends **/	
 /** commented in Ver 1.3 tpfree ( ( char * ) ptr_fml_Ibuf ); **/

	fn_userlog(c_ServiceName,"FNO BASKET ORDER PLACEMENT SUCCESSFULLY COMPLETED.");

	tpreturn( TPSUCCESS, 0, (char *)ptr_fml_Obuf, 0 , 0 );
}
