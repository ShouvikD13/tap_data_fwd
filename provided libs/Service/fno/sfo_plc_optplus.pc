/******************************************************************************/
/*  Program           : SFO_PLC_OPTPLUS                                       */
/*                                                                            */
/*  Input             : FFO_USR_ID                                            */
/*                      FFO_SSSN_ID                                           */
/*                      FFO_EBA_MTCH_ACT_NO                                   */
/*                      FFO_PIPE_ID                                           */
/*                      FFO_TRD_PSSWD                                         */
/*                      FFO_OPERATION_TYP                                     */
/*                      FFO_XCHNG_CD [2]                                      */
/*                      FFO_PRDCT_TYP [2]                                     */
/*                      FFO_UNDRLYNG [2]                                      */
/*                      FFO_EXPRY_DT [2]                                      */
/*                      FFO_EXER_TYP [2]                                      */
/*                      FFO_OPT_TYP  [2]                                      */
/*                      FFO_STRK_PRC [2]                                      */
/*                      FFO_CTGRY_INDSTK [2]                                  */
/*                      FFO_ORDR_FLW [2]                                      */
/*                      FFO_LMT_MKT_SL_FLG [2]                                */
/*                      FFO_ORD_TOT_QTY [2]                                   */
/*                      FFO_LMT_RT [2]                                        */
/*                      FFO_STP_LSS_TGR[2]                                    */
/*                      FFO_ORD_TYP[2]                                        */
/*                      FFO_MKT_TYP																						*/
/*                      FFO_OPNPSTN_RT                                        */
/*                      FFO_REQ_TYP                                           */
/*                                                                            */
/*                                                                            */
/*  Output            : FFO_ORDR_RFRNC [2]                                    */
/*                                                                            */
/*  Description       : This service is used to place OptionPlus order        */
/*                                                                            */
/*  Log               : 1.0     10-Sep-2013       Bhushan Sonwane             */
/*                    : 1.1     13-Nov-2013       Swati A.B                   */
/*                    : 1.2     21-Feb-2014       Bhushan Sonwane             */
/*                    : 1.3     16-Feb-2015       Anand Dhopte                */
/*                    : 1.4     23-Feb-2015       Tanmay W                    */
/*                    : 1.6     07-Aug-2015       Bhupendra Malik             */
/*                    : 1.7     17-Aug-2015       Ritesh Deolekar             */
/*										: 1.8			21-Sep-2015				Kishor Borkar								*/
/*										: 1.9			26-Nov-2015				Kishor Borkar								*/
/*                    : 2.0     23-Dec-2015       Anand Dhopte                */
/*                    : 2.1     26_Feb_2016       Kishor Borkar               */
/*                    : 2.2     10-Mar-2016       Kishor Borkar               */
/*										:	2.3			30-Jun-2016				Samip M											*/
/*                    : 2.4     08-Jul-2016       Anand Dhopte                */
/*                    : 2.5     12-Jul-2016       Navina D.                   */
/*                    : VQC     16-May-2017       Swapnil M.                  */
/*										: 2.6     05-Dec-2016				Kishor B.										*/		
/*                    : 2.7     31-Oct-2017       Anand Dhopte                */
/*                    : 2.8     12-Dec-2017       Anand Dhopte                */
/*                    : 2.9     27-Feb-2018       Mrinal Kishore              */
/*                    : 3.0     18-Jun-2018       Anand Dhopte                */
/*                    : 3.1     26-Jul-2018       Suchita Dabir               */
/*                    : 3.2     29-Nov-2018       Suchita Dabir               */
/*                    : 3.3     23-Oct-2019       Tanmay Patel                */
/*                    : 3.4     21-Oct-2020       Navina D.                   */
/*										:	3.5			02-Feb-2021				Kiran Itkar									*/
/*										:	3.6			18-May-2021				Sandip Tambe								*/
/*										:	3.7			11-Feb-2022       Naveena R    								*/
/*										:	3.8			06-Mar-2023       Ravi Malla   								*/
/******************************************************************************/
/*  1.0  -  New release                                                       */
/*  1.1  -  FNO limit Logging                                                 */
/*  1.2  -  DL changes, call via SFO_ORD_ROUT to SFO_OPT_PLC_ORD or           */
/*          SFO_SPN_PLC_ORD now returns more FMLs, Rbuf is concatenated to    */
/*          Obuf, rather than doing Fget and Fadd for every FML.              */
/*  1.3  -  Insufficient Limits - Modify Allocation changes for DL .Net       */
/*  1.4  -  Bug Fixes                                                         */
/*  1.6  -  Include changes for Insider trading check                         */
/*  1.7  -  Contract Master and Trade Quote Table Merger Changes              */
/*	1.8	 - 	Changes related to Limit_Order_Type_in_OPLUS											*/
/*	1.9	 -	Call to SFO_LMT_PRC_CAL is introduced to validate Input limit rate*/
/*  2.0  -  If condition added in case of Order Flow reversal                 */
/*  2.1  -  Cloud order changes                                               */
/*  2.2  -  Transaction Flag in Check Session IP                              */
/*	2.3	 -	Check Session IP Common Function 																	*/
/*  2.4  -  Incorrect Order Flow Issue in case of Double Order Modification   */
/*  2.5  -  Log Maintenance                                                   */
/*  VQC  -  Version Quality Control Changes                                   */
/*  2.6  -  IP Address pass to core service 																	*/
/*  2.7  -  Changes for reducing hard parsing of sql queries                  */
/*  2.8  -  FML with data type char used instead of long for storing wrapper flag*/  
/*  2.9  -  Optimization                                                      */
/*  3.0  -  Disallow clients with outstanding from taking fresh exposure      */
/*  3.1  -  Deadlock                                                          */
/*  3.2  -  FO Limit Entry                                                    */
/*  3.3  -  Ipv6 Format                                                       */
/*  3.4 -   OPLUS margin change CR-ISEC14-139243														  */
/*	3.5 -   Separate EOS for Stock and Index Underlyings in OptionPlus				*/
/*	3.6 -   Derivative_trd_restrict_CR_ISEC04_152948                  				*/
/*  3.7 -   Breeze API & Integrated Watchlist                                 */
/*  3.8 -   adding OptionPlus Error message                               */
/*  3.9 -   changing fn_lock_usr to fn_lock_fno                               */
/*  4.0 -   Margin Reporting Regulatory Changes (Nikhil Soni)                          */
/******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <atmi.h>
#include <fml32.h>
#include <sqlca.h>

/*Add header files here */
#include <fo.h>
#include <fo_fml_def.h>
#include <fo_view_def.h>
#include <fn_session.h>
#include <fn_tuxlib.h>
#include <fn_ddr.h>
#include <fn_log.h>
#include <fn_val_ord.h>
#include <fml_rout.h>
#include <fn_read_debug_lvl.h>
#include <fn_pos.h>
#include <fn_span_lib.h>

int fn_5paisa(long);
void fn_avg_price_cal(char *,long *, long *,  double *,int);

void SFO_PLC_OPTPLUS ( TPSVCINFO *rqst )
{
	char  c_ServiceName[33];
  varchar  c_err_msg[256]; /*** VQC Changed data type from char to varchar ***/
                           /** Note: also changed c_err_msg to c_err_msg.arr everywhere in code  VQC**/
  char  c_settlor_flg = '\0';
  char  c_spl_flg='\0';
  char  c_srvc_nm[33];
  char  c_pipe_id[3];

  /***    Commented in VQC
  char  c_channel[4];
  char  c_bp_id[9];
  ***/

  char  c_alias[9];
  char 	c_fno_dmn_nm [ 16 ];
  char 	c_fno_trg_nm [ 16 ];
  char 	c_fno_trg_dat [ 256 ];
  char 	c_frsh_ordr_rfrnc[19];
  char 	c_cvr_ordr_rfrnc[19];
  char 	c_narration_id[5];
  char 	c_spn_allwd_flg='\0';
  char 	c_bse_span_flag='\0';
  char 	c_op_allwd_stts='\0';
  char 	c_op_eos_flg='\0';
  char 	c_qt_trd_flg='\0';
  char 	c_sltp_trd_flg='\0';
  char 	c_dr_without_lmt_flg ='\0';
  char 	c_trdng_psswrd_flg = '\0';
  char 	c_temp_psswrd[LEN_USR_TRDNG_PSSWRD];
  char 	c_ip_address[45+1]; /** Changed from 15 to 45 in Ver 3.3 3.3 3.3 **/
  char 	c_call_source[20] = "\0";
	char 	c_insuff_flg = 'N';
  char  c_actn_flg = '\0';      /*** Ver 1.1 ***/
  char  c_lmt_allwd_flg = '\0';    /** Ver 1.8 **/
  char  c_usr_flg = '\0';      /** Ver 1.8 **/
  /*** char  c_err_msg.arr1[256] = "\0"; ** Ver 1.8 **  ***  Commented in VQC ***/
  char  c_frsh_ordr_stts = '\0';	/** Ver 1.8 **/
  char  c_cvr_ordr_stts  = '\0';	/** Ver 1.8 **/
	char  c_source_flg= '\0';  /** Ver 1.9 **/
	char  c_rqst_typ= '\0';  /** Ver 1.9 **/ 
	char  c_cvr_ordr_flw= '\0';  /** Ver 1.9 **/
  char  c_src_flg= '\0';  /** Ver 2.1 **/
  char c_txn_flg='Y';             /*** Ver 2.2 ***/
  char c_clm_clnt_lvl;              /*** VQC ***/
 
  /*** Ver 2.7 Starts ***/
  char c_exg_d_mkt_typ = 'D';
  char c_fum_opt_prd_typ = 'O';
  char c_fod_fresh_flg = 'F';
  char c_fod_cvr_flg = 'C';
  long l_fod_zero_val = 0;
  /*** Ver 2.7 Ends ***/
  varchar c_ven_id[50+1]; /*** Ver 3.7 ***/

	char c_indstk[2][2]; /*** Ver 3.5 ***/
	
  /*** int   i_err[ 20 ];
  int   i_ferr[ 20 ]; Commented in Ver 2.6 ***/

  int   i_err[ 21 ];   /** Ver 2.6 **/
  int   i_ferr[ 21 ];	 /** Ver 2.6 **/
  int   i_returncode = 0;
  int   i_trnsctn = 0;
  int   i_cnt= 0 ;
  int   i = 0 ;

  /**** Commented in VQC
  int   i_ip_len = 0;
  int   i_op_len = 0;
  int   i_ch_val = 0;
  int   i_counter = 0;
  ***/

  int insider_exist = 0;  /** Ver 1.6 **/

  long    l_temp_stp_lss_tgr = 0;
  long    l_temp_ord_lmt_rt = 0;
 /*** long    l_sssn_id_chk = 0; ** Commented in VQC ***/
  long    l_recvbuff = 0;
  
  /**** Commented in VQC
  long    l_no_of_calls = 0;
  long    l_lot_size = 0;
  long    l_mrgn_amt = 0;
  long    l_lss_amt= 0;
  ***/

  long    l_bst_bid_prc[5] = {0,0,0,0,0};
  long    l_bst_bid_qty[5] = {0,0,0,0,0};
  long    l_bst_offr_qty[5] = {0,0,0,0,0};
  long    l_bst_offr_prc[5] = {0,0,0,0,0};
  long    l_lmt_rt = 0;                                         /*** Ver 1.8 ***/
  /*** long    l_max_allw_qty = 0;                              *** Ver 1.8 ***
  long    l_stp_lss_tgr_prc = 0;                                *** Ver 1.8 *** ** Commented in VQC ***/
	long		l_ret_limit_rt	=	0;																	/*** Ver 1.9 ***/
  long    l_old_ord_qty = 0;    /*** Ver 3.0 ***/

	double d_ret_limit_rt  = 0.00;

  int i_actn_id = -1;

  /*** double d_limit_amt = 0.0;  ** Commented in VQC ***/
  double d_mrgn_amt = 0.0;
  double d_lss_amt = 0.0;
	double d_sltp_diff_prcnt = 0.0;
  double d_sltp_prcnt = 0.0;
  double d_tot_bid_qty = 0.0;
  double d_tot_offr_qty = 0.0;
  double d_avg_prc = 0.0;
  double d_balance_amt = 0.0;

  /*** ver 3.1 starts ***/
  char c_sltp_ord_rfrnc_lck[2][19];
  char c_ordr_rfrnc_lck[2][19];
  /*** ver 3.1 ends ***/

  /** Commented in VQC
  double d_diff_amt = 0.0;
  double d_temp = 0.0;
	double d_frm_diffrnc_mrgn  = 0.0;
  ***/

	double d_required_amt = 0.0;
	/*** double d_ord_tot_qty = 0.0;  ** Commented in VQC ***/

  char c_ref_rmrks[133] = "\0"; /*** Ver 3.4 ***/
  char  c_tmp_rmrks [ 133 ] = "\0";  /*** Ver 3.4 ***/

	double d_comp1_mrgn = 0.0;  /*** Ver 3.4 ***/
  double d_comp1_pl = 0.0;    /*** Ver 3.4 ***/
  double d_xchng_amt = 0.0;   /*** Ver 3.4 ***/
  double d_prem_amt = 0.0;    /*** Ver 3.4 ***/
	double d_spn_mrgn = 0.0;    /*** Ver 3.4 ***/
	double d_expr_mrgn = 0.0;   /*** Ver 3.4 ***/

  TPTRANID tranid  ; /*** Ver 1.1 ***/

  FBFR32 *ptr_fml_Ibuf;
  FBFR32 *ptr_fml_Obuf;
  FBFR32 *ptr_fml_Rbuf;
  FBFR32 *ptr_fml_Sbuf;

  EXEC SQL BEGIN DECLARE SECTION;
    struct vw_usr_prfl st_usr_prfl;
    struct vw_orderbook st_ordbook;
    
    /**** Commented in VQC
    struct vw_gt_lmt_dtls st_gt_lmt_dtls;
    struct st_pstn_actn st_pstn_action;
    ***/

    struct vw_pstn_actn ptr_st_pstn_actn;
    /*** struct st_err_msg *ptr_st_err; ** Commented in VQC ***/
    varchar c_exp_dt[ LEN_DATE ];
    varchar c_usr_usr_psswrd[50+1];

    /***** Commented in VQC
    long int li_opn_qty;
    varchar c_trd_dt[LEN_DATE];
    varchar c_trade_dt[LEN_DATE];
    varchar c_date[LEN_DATE];
    ***/

    char  c_exg_stts;
  EXEC SQL END DECLARE SECTION;

  struct vw_orderbook st_first_ordbk;

  /**** Commnented in VQC
  struct vw_orderbook st_next_ordbk;
  struct vw_orderbook st_temp_ordbook;
  ***/

  struct vw_err_msg st_err_msg;
  struct vw_contract st_cntrct; /*** Ver 3.0 ***/
  struct vw_contract st_cntrct_ins; /*** Ver 3.6 ***/

  /**** Commented in VQC
  struct vw_sequence st_s_sequence;
  struct vw_sequence st_r_sequence;
  struct vw_spdordbk st_spd_ordbk;
  ***/

  ptr_fml_Ibuf = (FBFR32 *)rqst->data;
  strcpy(c_ServiceName, rqst->name);
  INITDBGLVL(c_ServiceName);

  MEMSET(st_first_ordbk);
  
  /**** Commented in VQC
  MEMSET(st_next_ordbk);
  MEMSET(st_temp_ordbook);
  ****/

  MEMSET(st_usr_prfl);
  MEMSET(st_ordbook);
 /***  MEMSET(st_pstn_action);   ** Commented in VQC ***/
  MEMSET(c_temp_psswrd);  
  MEMSET(c_usr_usr_psswrd);
	MEMSET(st_err_msg);					/** Ver 2.3 **/
  MEMSET(st_cntrct);          /*** Ver 3.0 ***/
  MEMSET(st_cntrct_ins);          /*** Ver 3.6 ***/

  /*** ver 3.1 starts ***/
  MEMSET(c_sltp_ord_rfrnc_lck);
  MEMSET(c_ordr_rfrnc_lck);
  /*** ver 3.1 ends ***/

	MEMSET(c_ven_id); /*** Ver 3.7 ***/

  i_returncode = Fvftos32( ptr_fml_Ibuf,
                           (char *) &st_usr_prfl,
                           "vw_usr_prfl" );
  if ( i_returncode == -1 )
  {
    fn_errlog( c_ServiceName, "S31005", FMLMSG, c_err_msg.arr  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  if(DEBUG_MSG_LVL_3) /*** Ver 2.5 ***/
  {
    fn_userlog( c_ServiceName, "User id       :%s:",
                                  st_usr_prfl.c_user_id );
    fn_userlog( c_ServiceName, "Session id    :%ld:",
                                  st_usr_prfl.l_session_id );
    fn_userlog( c_ServiceName, "Match Account :%s:",
                                  st_usr_prfl.c_cln_mtch_accnt );
    fn_userlog( c_ServiceName, "Pipe id :%s:",
                                  st_usr_prfl.c_pipe_id );
  }

  ptr_fml_Sbuf = (FBFR32 *)tpalloc( "FML32", NULL, MIN_FML_BUF_LEN*3 );
  if ( ptr_fml_Sbuf == NULL )
  {
    fn_errlog( c_ServiceName, "S31010", TPMSG, c_err_msg.arr  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  i_returncode = Fvstof32( ptr_fml_Sbuf, (char *) &st_usr_prfl,
                             FUPDATE, "vw_usr_prfl" );
  if ( i_returncode == -1 )
  {
    fn_errlog( c_ServiceName, "S31015", FMLMSG, c_err_msg.arr  );
    tpfree ( ( char * ) ptr_fml_Sbuf );  /*** Added in VQC ***/ 
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
  ptr_fml_Rbuf = (FBFR32 *)tpalloc( "FML32", NULL, MIN_FML_BUF_LEN*3 );

  if ( ptr_fml_Rbuf == NULL )
  {
    fn_errlog( c_ServiceName, "S31020", TPMSG, c_err_msg.arr  );
    tpfree ( ( char * ) ptr_fml_Sbuf );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }


  ptr_fml_Obuf = (FBFR32 *)tpalloc( "FML32", NULL, MIN_FML_BUF_LEN*3 );

  if ( ptr_fml_Obuf == NULL )
  {
    fn_errlog( c_ServiceName, "S31025", TPMSG, c_err_msg.arr  );
    tpfree ( ( char * ) ptr_fml_Sbuf );
    tpfree ( ( char * ) ptr_fml_Rbuf );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  /**** session check *****/

	/*** Commented for Ver 2.3 ***
  if (st_usr_prfl.l_session_id !=0)
  {
    i_returncode = fn_chk_sssn( c_ServiceName,
                                &st_usr_prfl,
                                &st_err_msg ) ;

    if ( i_returncode == -1 )
    {
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );
			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); *** Ver 1.3 ***
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); *** Ver 1.3 ***
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
  }
	*** Ver 2.3 ***/

	/*** Commented and moved below for Ver 2.3 ***
  i_trnsctn = fn_begintran( c_ServiceName, c_err_msg.arr );

  if ( i_trnsctn == -1 )
  {
    fn_errlog( c_ServiceName, "S31030", LIBMSG , c_err_msg.arr );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); *** Ver 1.3 ***
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); *** Ver 1.3 ***
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  i_returncode = fn_lock_usr( c_ServiceName, st_usr_prfl.c_cln_mtch_accnt );

  if ( i_returncode == -1 )
  {
    fn_errlog( c_ServiceName, "S31035", LIBMSG , c_err_msg.arr );
		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); *** Ver 1.3 ***
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); *** Ver 1.3 ***
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
	*** Ver 2.3 ***/

  i_err[0]= Fget32(ptr_fml_Ibuf, FFO_XCHNG_CD,0,
                                    (char *)st_ordbook.c_xchng_cd, 0);
  i_ferr [ 0 ] = Ferror32;

  i_err[1]= Fget32(ptr_fml_Ibuf, FFO_PRDCT_TYP,0,
                                    (char *)&st_ordbook.c_prd_typ, 0);
  i_ferr [ 1 ] = Ferror32;

  i_err[2]= Fget32(ptr_fml_Ibuf, FFO_UNDRLYNG,0,
                                    (char *)st_ordbook.c_undrlyng, 0);
  i_ferr [ 2 ] = Ferror32;

  i_err[3]= Fget32(ptr_fml_Ibuf, FFO_EXPRY_DT,0,
                                    (char *)c_exp_dt.arr, 0);
  i_ferr [ 3 ] = Ferror32;

  i_err[4]= Fget32(ptr_fml_Ibuf, FFO_EXER_TYP,0,
                                    (char *)&st_ordbook.c_exrc_typ, 0);
  i_ferr [ 4 ] = Ferror32;

  i_err[5]= Fget32(ptr_fml_Ibuf, FFO_OPT_TYP,0,
                                    (char *)&st_ordbook.c_opt_typ, 0);
  i_ferr [ 5 ] = Ferror32;

  i_err[6]= Fget32(ptr_fml_Ibuf, FFO_STRK_PRC,0,
                                    (char *)&st_ordbook.l_strike_prc, 0);
  i_ferr [ 6 ] = Ferror32;

  i_err[7]= Fget32(ptr_fml_Ibuf, FFO_CTGRY_INDSTK,0,
                                    (char *)&st_ordbook.c_ctgry_indstk, 0);
  i_ferr [ 7 ] = Ferror32;

  i_err[8]= Fget32(ptr_fml_Ibuf, FFO_ORDR_FLW,0,
                                    (char *)&st_ordbook.c_ordr_flw, 0);
  i_ferr [ 8 ] = Ferror32;

  i_err[9]= Fget32(ptr_fml_Ibuf, FFO_LMT_MKT_SL_FLG,0,
                                    (char *)&st_ordbook.c_slm_flg, 0);
  i_ferr [ 9 ] = Ferror32;

  i_err[10]= Fget32(ptr_fml_Ibuf, FFO_ORD_TOT_QTY,0,
                                    (char *)&st_ordbook.l_ord_tot_qty, 0);
  i_ferr [ 10 ] = Ferror32;

  i_err[11]= Fget32(ptr_fml_Ibuf, FFO_LMT_RT,0,
                                    (char *)&st_ordbook.l_ord_lmt_rt, 0);
  i_ferr [ 11 ] = Ferror32;

  i_err[12]= Fget32(ptr_fml_Ibuf, FFO_CHANNEL,0,
                                    (char *)st_ordbook.c_channel, 0);
  i_ferr [ 12 ] = Ferror32;

  i_err[13]= Fget32(ptr_fml_Ibuf, FFO_STP_LSS_TGR,0,
                                     (char *)&st_ordbook.l_stp_lss_tgr, 0);
  i_ferr [13] = Ferror32;

  i_err[ 14 ] = Fget32(ptr_fml_Ibuf, FFO_ORD_TYP ,0,
                                     (char *)&st_ordbook.c_ord_typ,0);
  i_ferr [14 ] = Ferror32;
  i_err[ 15 ] = Fget32(ptr_fml_Ibuf, FFO_TRD_PSSWD,0,
                                     (char *)c_usr_usr_psswrd.arr,0);
  i_ferr [ 15 ] = Ferror32;

  for(i=0; i < 16; i++)
  {
    if ( (i_err[ i ] == -1 ) && i_ferr[15] != FNOTPRES  )
    {
      fn_errlog( c_ServiceName, "S31040",
      Fstrerror32(i_ferr[i]),c_err_msg.arr);
	/***		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); *** Commented in VQC ***/
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
  }

  i_err[ 16 ] = Fget32(ptr_fml_Ibuf, FFO_MKT_TYP ,0,
                                     (char *)&st_ordbook.c_mrkt_typ,0);                         /*** Ver 1.8 ***/
  i_ferr [ 16 ] = Ferror32;

  if ( (i_err[ 16 ] == -1 ) && i_ferr[16] != FNOTPRES || st_ordbook.c_mrkt_typ == '\0' ) /* VER TOL : TUX on LINUX -- Changed NULL to \0 (Ravindra) */
  {
    if(i_ferr[16] != FNOTPRES || st_ordbook.c_mrkt_typ == '\0' ) /* VER TOL : TUX on LINUX -- Changed NULL to \0 (Ravindra) */
    {
      st_ordbook.c_mrkt_typ = 'M';
    }
    else
    {
      fn_userlog( c_ServiceName, "Exchange code :%d %d :",i_err[ i ],i);
      fn_errlog( c_ServiceName, "S31045",
      Fstrerror32(i_ferr[i]),c_err_msg.arr);
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
   /***   fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  *** Commented in VQC ***/
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
  }

  /*** Ver 3.7 starts ***/
    MEMSET(c_ven_id);
    i_err[20]  = Fget32(ptr_fml_Ibuf,FFO_USER_CODE,0,(char *)c_ven_id.arr,0);
    i_ferr [20] = Ferror32;

    if ( i_err[0] == -1 )
    {
      if ( Ferror32 != FNOTPRES )
      {
        fn_errlog( c_ServiceName, "S31050", Fstrerror32(i_ferr[i]),c_err_msg.arr);
        tpfree ( ( char * ) ptr_fml_Sbuf );
        tpfree ( ( char * ) ptr_fml_Rbuf );
        tpfree ( ( char * ) ptr_fml_Obuf );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
      else if( Ferror32 == FNOTPRES )
      {
        strcpy(c_ven_id.arr,"");
      }
    }
   SETLEN(c_ven_id);
   fn_userlog( c_ServiceName, "Vendor id = ESP_ID  :%s:",c_ven_id.arr);

  /*** Ver 3.7 ends ***/

  if(st_ordbook.c_mrkt_typ == 'L')
  {
    i_err[ 17 ] = Fget32(ptr_fml_Ibuf, FFO_OPNPSTN_RT ,0,
                                      (char *)&l_lmt_rt,0);                                       /*** Ver 1.8 ***/
    i_ferr [ 17 ] = Ferror32;

    if ( i_err[ 17 ] == -1 )
    {
      fn_userlog( c_ServiceName, "Exchange code :%d %d :",i_err[ i ],i);
      fn_errlog( c_ServiceName, "S31055",
      Fstrerror32(i_ferr[i]),c_err_msg.arr);
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
   /***   fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  *** Commented in VQC ***/
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
  }

  i_err[ 18 ] = Fget32(ptr_fml_Ibuf, FFO_REQ_TYP ,0,
                                     (char *)&st_ordbook.c_req_typ,0);                         /*** Ver 1.8 ***/
  i_ferr [ 18 ] = Ferror32;

  if ( (i_err[ 18 ] == -1 ) && i_ferr[18] != FNOTPRES || st_ordbook.c_req_typ == '\0' ) /* VER TOL : TUX on LINUX -- Changed NULL to \0 (Ravindra) */
  {
    if(i_ferr[18] != FNOTPRES || st_ordbook.c_req_typ == '\0' ) /* VER TOL : TUX on LINUX -- Changed NULL to \0 (Ravindra) */
    {
      st_ordbook.c_req_typ= 'P';
    }
    else
    {
      fn_userlog( c_ServiceName, "Exchange code :%d %d :",i_err[ i ],i);
      fn_errlog( c_ServiceName, "S31060",
      Fstrerror32(i_ferr[i]),c_err_msg.arr);
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
    /***   fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );   *** Commented in VQC ***/
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
  }

  /*** Ver 2.1 Starts Here ***/
  i_err[ 19 ] = Fget32(ptr_fml_Ibuf, FFO_STATUS_FLG ,0,
                                     (char *)&c_src_flg,0);      
  i_ferr [ 19 ] = Ferror32;

  if ( (i_err[ 19 ] == -1 ) && i_ferr[19] != FNOTPRES )
  {
      fn_userlog( c_ServiceName, "Exchange code :%d %d :",i_err[ i ],i);
      fn_errlog( c_ServiceName, "S31065",
      Fstrerror32(i_ferr[i]),c_err_msg.arr);
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
   /***   fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  *** Commented in VQC ***/
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
  else if (c_src_flg == '\0') /* VER TOL : TUX on LINUX -- Changed NULL to \0 (Ravindra) */
  {
    c_src_flg = 'O';
  }

	if(DEBUG_MSG_LVL_1) /*** Ver 2.5 ***/
  {
    fn_userlog( c_ServiceName, "After getting source flag....:%c:",c_src_flg);
	}

  /*** Ver 2.1 Ends Here ***/

  if(DEBUG_MSG_LVL_3)			/** if() added in Ver 1.8 **/	/*** Ver 2.5 ***/
  {
  	fn_userlog( c_ServiceName, "fresh limit rate :%ld:",l_lmt_rt);  /*** Ver 2.5 ***/
	}

  if(DEBUG_MSG_LVL_1) 
  {
    fn_userlog( c_ServiceName, "Fresh Order Flow Is :%c:",st_ordbook.c_ordr_flw); /*** Ver 2.4 ***/
  }

  /*** Commented in Ver 2.4 *** For double order modification cover order flow was passed from front end instead of fresh order flow, so we asked front end to pass proper flow i.e. fresh order flow ***

  ** Ver 1.8 starts ** ** Revert the order flow for modification because validations for modification depends on
                             Fresh order flow. **

	if(DEBUG_MSG_LVL_1) *** Ver 2.5 ***
  {
    fn_userlog( c_ServiceName, "st_ordbook.c_ordr_flw********************************:%c:",st_ordbook.c_ordr_flw);
  }

  if(strcmp(st_ordbook.c_channel,"WEB") == 0) *** Ver 2.0 ***
  {
   if(st_ordbook.c_req_typ == 'M' && st_ordbook.c_ordr_flw == 'B')
   {
    st_ordbook.c_ordr_flw = 'S';
   }
   else if(st_ordbook.c_req_typ == 'M' && st_ordbook.c_ordr_flw == 'S')
   {
    st_ordbook.c_ordr_flw = 'B';
   }
  }

  ** Ver 1.8 ends **

  *********************/

  if(st_usr_prfl.c_user_id[0] == BPID)
  {
    if(Fget32(ptr_fml_Ibuf,FFO_ALIAS,0,(char *)c_alias,0) == -1)
    {
      fn_errlog( c_ServiceName, "S31070", FMLMSG, c_err_msg.arr  );
	/***		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  *** Commented in VQC ***/
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
  }


	/*** Ver 3.7 starts***/
	if ( st_ordbook.c_req_typ == 'P' && (st_ordbook.c_ctgry_indstk != 'I' || st_ordbook.c_ctgry_indstk != 'S' ) )
	{
		SETLEN(c_exp_dt);

	  if(DEBUG_MSG_LVL_4)
		{	
    fn_userlog( c_ServiceName, "Exchange code :%s:",
                              st_ordbook.c_xchng_cd );
    fn_userlog( c_ServiceName, "Product Type  :%c:",
                                st_ordbook.c_prd_typ );
    fn_userlog( c_ServiceName, "Underlyng     :%s:",
                                st_ordbook.c_undrlyng );
    fn_userlog( c_ServiceName, "Expiry date   :%s:",
                                st_ordbook.c_expry_dt);
    fn_userlog( c_ServiceName, "Excercise Type:%c:",
                               st_ordbook.c_exrc_typ );
    fn_userlog( c_ServiceName, "Option type   :%c:",
                               st_ordbook.c_opt_typ );
    fn_userlog( c_ServiceName, "Strike price  :%ld:",
                               st_ordbook.l_strike_prc );
    fn_userlog( c_ServiceName, "Category      :%c:",
                               st_ordbook.c_ctgry_indstk );
		}	

		 EXEC SQL
      SELECT FTQ_INDSTK
      INTO  :st_ordbook.c_ctgry_indstk
      FROM  FTQ_FO_TRD_QT
      WHERE FTQ_XCHNG_CD  =:st_ordbook.c_xchng_cd
      AND   FTQ_PRDCT_TYP = DECODE(:st_ordbook.c_prd_typ,'P','F','U','F','I','O',:st_ordbook.c_prd_typ)
      AND   FTQ_UNDRLYNG  =:st_ordbook.c_undrlyng
      AND   FTQ_OPT_TYP   =:st_ordbook.c_opt_typ
      AND   FTQ_STRK_PRC  =:st_ordbook.l_strike_prc
      AND   FTQ_EXPRY_DT  =:c_exp_dt;
			
			if (SQLCODE != 0)
			{
				fn_errlog( c_ServiceName, "S31075", SQLMSG,c_err_msg.arr  );
    		tpfree ( ( char * ) ptr_fml_Sbuf );     
    		tpfree ( ( char * ) ptr_fml_Rbuf );     
    		tpfree ( ( char * ) ptr_fml_Obuf );     
    		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    		Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); 
    		Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); 
    		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
	}
	/*** Ver 3.7 ends ***/

    /*** Ver 1.6 Starts ***/
	strcpy( st_cntrct_ins.c_xchng_cd, st_ordbook.c_xchng_cd );  /** Ver 3.6 **/
  st_cntrct_ins.c_prd_typ = st_ordbook.c_prd_typ;             /** Ver 3.6 **/
  strcpy( st_cntrct_ins.c_undrlyng , st_ordbook.c_undrlyng  ); /** Ver 3.6 **/
  strcpy( st_cntrct_ins.c_expry_dt,  st_ordbook.c_expry_dt );  /** Ver 3.6 **/
  st_cntrct_ins.c_exrc_typ        = st_ordbook.c_exrc_typ;     /** Ver 3.6 **/
  st_cntrct_ins.c_opt_typ         = st_ordbook.c_opt_typ;      /** Ver 3.6 **/
  st_cntrct_ins.l_strike_prc      = st_ordbook.l_strike_prc;   /** Ver 3.6 **/
  st_cntrct_ins.c_ctgry_indstk    = st_ordbook.c_ctgry_indstk;  /** Ver 3.6 **/

 i_returncode = fn_chk_und_insider(c_ServiceName,
                                    st_usr_prfl,
                                    /*st_ordbook.c_undrlyng, ** Ver 3.6 comment **/
                                    st_cntrct_ins,					/** Ver 3.6 **/
                                    &insider_exist);
  if (i_returncode == -1)
  {
      fn_errlog( c_ServiceName, "S31080", "Error in Function fn_chk_und_insider", c_err_msg.arr);
   /***   fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );   *** Commented in VQC ***/
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

	
  if (insider_exist == 1)
  {
      fn_errlog( c_ServiceName, "B91164", DEFMSG, c_err_msg.arr  );	/** Ver 3.6 B21042 changed to B91164 **/
    /***  fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  *** Commented in VQC ***/
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

/*** Ver 1.6 Ends ***/


  SETLEN(c_exp_dt);

  strcpy ( st_ordbook.c_expry_dt, ( char * ) c_exp_dt.arr );

 if(DEBUG_MSG_LVL_1) 	/*** Ver 2.5 ***/
 {
    fn_userlog( c_ServiceName, "Match Accnt :%s: Req Tpe :%c:",st_usr_prfl.c_cln_mtch_accnt,st_ordbook.c_req_typ);
 }

  if(DEBUG_MSG_LVL_1) 	/*** Ver 2.5 ***/
  {
    fn_userlog( c_ServiceName, "Exchange code :%s:",
                              st_ordbook.c_xchng_cd );
    fn_userlog( c_ServiceName, "Product Type  :%c:",
                                st_ordbook.c_prd_typ );
    fn_userlog( c_ServiceName, "Underlyng     :%s:",
                                st_ordbook.c_undrlyng );
    fn_userlog( c_ServiceName, "Expiry date   :%s:",
                                st_ordbook.c_expry_dt);
    fn_userlog( c_ServiceName, "Excercise Type:%c:",
                               st_ordbook.c_exrc_typ );
    fn_userlog( c_ServiceName, "Option type   :%c:",
                               st_ordbook.c_opt_typ );
    fn_userlog( c_ServiceName, "Strike price  :%ld:",
                               st_ordbook.l_strike_prc );
    fn_userlog( c_ServiceName, "Category      :%c:",
                               st_ordbook.c_ctgry_indstk );
    fn_userlog( c_ServiceName, "Order flow B/S:%c:",
                               st_ordbook.c_ordr_flw );
    fn_userlog( c_ServiceName, "Lmt/Mkt/StpLss:%c:",
                               st_ordbook.c_slm_flg );
    fn_userlog( c_ServiceName, "Order Qty     :%ld:",
                               st_ordbook.l_ord_tot_qty );
		fn_userlog( c_ServiceName, "SLTP rate    :%ld:",	
																st_ordbook.l_stp_lss_tgr );
    fn_userlog( c_ServiceName, "Limit rate    :%ld:",
                               st_ordbook.l_ord_lmt_rt );
    fn_userlog( c_ServiceName, "CHANNEL   :%s:",
                                st_ordbook.c_channel);
    fn_userlog( c_ServiceName, "ALIAS   :%s:",
                                c_alias);
    fn_userlog( c_ServiceName, "Market Type   :%c:",                              /**** Ver 1.8 ****/
                                st_ordbook.c_mrkt_typ);
    fn_userlog( c_ServiceName, "Fresh Limit Rate :%ld:",                          /**** Ver 1.8 ****/
                                l_lmt_rt);
    /*** fn_userlog( c_ServiceName, "Request Type :%c:",                               **** Ver 1.8 ****
                               st_ordbook.c_req_typ); *** Ver 2.5 ***/
  }
  st_ordbook.l_dsclsd_qty = 0 ;
  c_spl_flg = 'N';

  /**Call function for trading limit check **/
  i_returncode = fn_chk_trdng_limit(c_ServiceName,
                                    st_ordbook.l_ord_tot_qty,
                                    st_ordbook.l_strike_prc,
                                    &c_trdng_psswrd_flg,
                                    &st_usr_prfl,
                                    &st_err_msg );
  if ( i_returncode == -1 )
  {
    fn_errlog( c_ServiceName, "S31085", LIBMSG, c_err_msg.arr );
	/*fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); 			Commented In VQC	***/
    tpfree ( ( char * ) ptr_fml_Sbuf );       /** Added in VQC ***/
    tpfree ( ( char * ) ptr_fml_Rbuf );       /** Added in VQC ***/
    tpfree ( ( char * ) ptr_fml_Obuf );       /** Added in VQC ***/
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  if(DEBUG_MSG_LVL_3)
  {
   fn_userlog( c_ServiceName, "c_trdng_psswrd_flg:%c:", c_trdng_psswrd_flg );
  }

  SETLEN( c_usr_usr_psswrd );
  if ( c_trdng_psswrd_flg == YES )
  {
    strcpy( c_temp_psswrd, (char *)c_usr_usr_psswrd.arr );
  }

  i_returncode =  fn_check_user_ip ( c_ServiceName,
                                      &st_usr_prfl ,
                                      c_temp_psswrd,
                                      c_trdng_psswrd_flg,
                                      c_ip_address,
                                      c_txn_flg,                   /*** Ver 2.2 ***/
                                      &st_err_msg );

  if ( i_returncode == -1 )
  {
    fn_errlog( c_ServiceName, "S31090", LIBMSG, c_err_msg.arr );
		/*** fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  *** Commented in VQC ***/
    fn_userlog(c_ServiceName,"error message :%s:",st_err_msg.c_err_msg);
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );

    if ( c_trdng_psswrd_flg ==  'Y' )
    {
      i_actn_id = 1;
    }
    else
    {
      i_actn_id = -1;
    }

    tpfree ( ( char * ) ptr_fml_Sbuf );       /** Added in VQC ***/
    tpfree ( ( char * ) ptr_fml_Rbuf );       /** Added in VQC ***/
    tpfree ( ( char * ) ptr_fml_Obuf );       /** Added in VQC ***/
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  if(DEBUG_MSG_LVL_3)
  {
    fn_userlog(c_ServiceName,"ip address:%s:",c_ip_address);
  }

	/*** Added from above for Ver 2.3 ***/
  i_trnsctn = fn_begintran( c_ServiceName, c_err_msg.arr );

  if ( i_trnsctn == -1 )
  {
    fn_errlog( c_ServiceName, "S31095", LIBMSG , c_err_msg.arr );
    tpfree ( ( char * ) ptr_fml_Sbuf );       /** Added in VQC ***/
    tpfree ( ( char * ) ptr_fml_Rbuf );       /** Added in VQC ***/
    tpfree ( ( char * ) ptr_fml_Obuf );       /** Added in VQC ***/
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  /*** ver 3.1 starts ***/

  if(st_ordbook.c_req_typ == 'M' || st_ordbook.c_req_typ == 'C' )
  {
 	     i_err[0]= Fget32(ptr_fml_Ibuf, FFO_ORDR_RFRNC,0, (char *)&c_frsh_ordr_rfrnc, 0);             
     	 i_ferr [ 0 ] = Ferror32;

	     i_err[1]= Fget32(ptr_fml_Ibuf, FFO_ORDR_RFRNC,1,(char *)&c_cvr_ordr_rfrnc, 0);
	     i_ferr [ 1 ] = Ferror32;

       for(i=0; i < 2; i++)
       {
         if ( (i_err[ i ] == -1 ) )
         {
            fn_errlog( c_ServiceName, "S31100",Fstrerror32(i_ferr[i]),c_err_msg.arr);
            tpfree ( ( char * ) ptr_fml_Sbuf );
            tpfree ( ( char * ) ptr_fml_Rbuf );
            tpfree ( ( char * ) ptr_fml_Obuf ); 
            fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
            Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
            Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
            Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
           }        
       }
       EXEC    SQL
       SELECT  FOD_ORDR_RFRNC,
               FOD_SLTP_ORDR_RFRNC,
							 FOD_INDSTK  /*** Ver 3.5 ***/
       INTO    :c_ordr_rfrnc_lck,
               :c_sltp_ord_rfrnc_lck,
							 :c_indstk  /*** Ver 3.5 ***/ 
       FROM    FOD_FO_ORDR_DTLS
       WHERE   FOD_ORDR_RFRNC in ( :c_frsh_ordr_rfrnc,:c_cvr_ordr_rfrnc )
       FOR     UPDATE OF FOD_ORDR_RFRNC;
       if (SQLCODE != 0 ) 
       {
        if (SQLCODE == -54)
        {
             fn_userlog( c_ServiceName, "Resource busy and failed to acquire lock" );
        }
            fn_errlog( c_ServiceName, "S31105",SQLMSG,c_err_msg.arr);
            tpfree ( ( char * ) ptr_fml_Sbuf );
            tpfree ( ( char * ) ptr_fml_Rbuf );
            tpfree ( ( char * ) ptr_fml_Obuf );
            fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
            Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
            Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
            Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
       else
        {
            fn_userlog( c_ServiceName, "Sucessfully acquired FOR UPDATE lock on :%s: and :%s:",c_frsh_ordr_rfrnc,c_cvr_ordr_rfrnc );
        }
				st_ordbook.c_ctgry_indstk = c_indstk[0][0];  /*** Ver 3.5 ***/
				fn_userlog( c_ServiceName, "Navina:%c:%c:%c:%c:",c_indstk[0][0],c_indstk[0][1],c_indstk[1][0],c_indstk[1][1]);	/*** Ver 3.5 ***/
		
  }
  /*** ver 3.1 ends ***/
  		/* i_returncode = fn_lock_usr( c_ServiceName, st_usr_prfl.c_cln_mtch_accnt ); commented in 3.9 */
  		i_returncode = fn_lock_fno( c_ServiceName, st_usr_prfl.c_cln_mtch_accnt ); /* Added in 3.9 */

		 if ( i_returncode == -1 )
		 {
 		    fn_errlog( c_ServiceName, "S31110", LIBMSG , c_err_msg.arr );
    		tpfree ( ( char * ) ptr_fml_Sbuf );       /** Added in VQC ***/
    		tpfree ( ( char * ) ptr_fml_Rbuf );       /** Added in VQC ***/
    		tpfree ( ( char * ) ptr_fml_Obuf );       /** Added in VQC ***/
    		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    		Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
    		Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
    		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		 }
	/*** Ver 2.3 ***/

  /*** Select User Current Pipe ID ******/
	/*** Commented in Ver 2.9
  EXEC SQL
      SELECT  PCM_CRNT_PIPE_ID
      INTO    :st_usr_prfl.c_pipe_id
      FROM    PCM_PIPE_CLM_MAP
      WHERE   PCM_CLM_MTCH_ACCNT  = :st_usr_prfl.c_cln_mtch_accnt
      AND     PCM_XCHNG_CD        = :st_ordbook.c_xchng_cd ;

  if( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
  {
    fn_errlog( c_ServiceName, "S31115", SQLMSG,c_err_msg.arr  );
    fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    tpfree ( ( char * ) ptr_fml_Sbuf );       ** Added in VQC ***
    tpfree ( ( char * ) ptr_fml_Rbuf );       ** Added in VQC ***
    tpfree ( ( char * ) ptr_fml_Obuf );       ** Added in VQC ***
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); *** Ver 1.3 ***
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); *** Ver 1.3 ***
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }


  ********Check whether trading on SLTP is allowed******

  *** Below query column names changed to upper case in Ver 2.7 ***

  EXEC SQL
      SELECT  MTM_OP_ALLWD_STTS,
              MTM_OP_EOS_FLG
      INTO    :c_op_allwd_stts,
              :c_op_eos_flg
      FROM    MTM_APPLN_STTS
      WHERE   MTM_XCHNG_CD =  :st_ordbook.c_xchng_cd
      AND     MTM_PIPE_ID  =  :st_usr_prfl.c_pipe_id;
	Comment Ends for Ver 2.9 ***/

	fn_userlog( c_ServiceName, "CR-ISEC14-144377 Index/Stock :%c:",  st_ordbook.c_ctgry_indstk );   /*** Added in Ver 3.5 ***/

	/**** Added in Ver 2.9 ****/
	EXEC SQL

        SELECT PCM_CRNT_PIPE_ID,
               /*** MTM_OP_ALLWD_STTS,
               MTM_OP_EOS_FLG	Commented in Ver 3.5 ***/
							 DECODE( :st_ordbook.c_ctgry_indstk,'I',MTM_OP_ALLWD_STTS,'S',MTM_OP_ALLWD_STTS_S,'N' ),	/*** Ver 3.5 ***/
							 DECODE( :st_ordbook.c_ctgry_indstk,'I',MTM_OP_EOS_FLG,'S',MTM_OP_EOS_FLG_S,'N' )					/*** Ver 3.5 ***/
        INTO   :st_usr_prfl.c_pipe_id,
               :c_op_allwd_stts,
               :c_op_eos_flg
        FROM    PCM_PIPE_CLM_MAP,
                MTM_APPLN_STTS
        WHERE   PCM_CLM_MTCH_ACCNT  =:st_usr_prfl.c_cln_mtch_accnt
        AND     PCM_XCHNG_CD =:st_ordbook.c_xchng_cd
        AND     MTM_XCHNG_CD = :st_ordbook.c_xchng_cd
        AND     MTM_PIPE_ID = PCM_CRNT_PIPE_ID;
 /**** Add ended for Ver 2.9 ****/
 if( SQLCODE != 0 )
  {
    fn_errlog( c_ServiceName, "S31120", SQLMSG,c_err_msg.arr  );
		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    tpfree ( ( char * ) ptr_fml_Sbuf );       /** Added in VQC ***/
    tpfree ( ( char * ) ptr_fml_Rbuf );       /** Added in VQC ***/
    tpfree ( ( char * ) ptr_fml_Obuf );       /** Added in VQC ***/
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  if (c_op_allwd_stts == 'N' )
  {
    fn_errlog( c_ServiceName, "B35019",DEFMSG,c_err_msg.arr);
		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    tpfree ( ( char * ) ptr_fml_Sbuf );       /** Added in VQC ***/
    tpfree ( ( char * ) ptr_fml_Rbuf );       /** Added in VQC ***/
    tpfree ( ( char * ) ptr_fml_Obuf );       /** Added in VQC ***/
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  if(c_op_eos_flg =='Y')
  {
    fn_errlog( c_ServiceName, "B35020",DEFMSG,c_err_msg.arr);
		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    tpfree ( ( char * ) ptr_fml_Sbuf );       /** Added in VQC ***/
    tpfree ( ( char * ) ptr_fml_Rbuf );       /** Added in VQC ***/
    tpfree ( ( char * ) ptr_fml_Obuf );       /** Added in VQC ***/
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  /*** Column names changed to upper case in below query in Ver 2.7 ***/

  EXEC SQL
     SELECT /** to_char( exg_nxt_trd_dt, 'DD-Mon-YYYY' ),
            to_char( exg_nxt_trd_dt, 'YYYYMMDD' ),   ** commented in VQC **/
            EXG_CRRNT_STTS
     INTO   /** :c_trd_dt,
            :c_date,   ** commented in VQC **/
            :c_exg_stts
     FROM   EXG_XCHNG_MSTR
     WHERE  EXG_XCHNG_CD = :st_ordbook.c_xchng_cd
     /*** AND    EXG_MKT_TYP  = 'D';  Commented in Ver 2.7 ***/
     AND    EXG_MKT_TYP  = :c_exg_d_mkt_typ;  /*** Ver 2.7 bind variable used instead of hard coded value ***/

  if ( SQLCODE != 0 )
  {
     fn_errlog( c_ServiceName, "S31125",SQLMSG,c_err_msg.arr);
		 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
     tpfree ( ( char * ) ptr_fml_Sbuf );       /** Added in VQC ***/
     tpfree ( ( char * ) ptr_fml_Rbuf );       /** Added in VQC ***/
     tpfree ( ( char * ) ptr_fml_Obuf );       /** Added in VQC ***/
     Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		 Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
     Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
     Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
     tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  /*** Commented in VQC ***
  SETNULL ( c_trd_dt );
  SETNULL ( c_date );
  ***/

  if( c_exg_stts != EXCHANGE_OPEN )
  {
    fn_errlog( c_ServiceName, "S31130","OptionPlus with Stop Loss Limit Margin orders can be placed only when the Exchange is open",c_err_msg.arr);
    strcpy(c_err_msg.arr,"OptionPlus with Stop Loss Limit Margin orders can be placed only when the Exchange is open");
		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    tpfree ( ( char * ) ptr_fml_Sbuf );       /** Added in VQC ***/
    tpfree ( ( char * ) ptr_fml_Rbuf );       /** Added in VQC ***/
    tpfree ( ( char * ) ptr_fml_Obuf );       /** Added in VQC ***/
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

    if( st_ordbook.c_req_typ == 'P')                                            /*** if() added in Ver 1.8 ***/
    {

			/*** Ver 1.9 Starts ***/
			c_source_flg = 'P'; /*** Ver 1.9 Call from Placement ***/
			c_rqst_typ  = 'S';   /*** Ver 1.9 Call from Placement ***/

		  if(DEBUG_MSG_LVL_1) /*** Ver 2.5 ***/
			{
				fn_userlog( c_ServiceName, "st_ordbook.c_ordr_flw.................:%c:",st_ordbook.c_ordr_flw);
			}

			if(st_ordbook.c_ordr_flw == 'B')
			{
				c_cvr_ordr_flw='S';
			}
			else
			{
				c_cvr_ordr_flw='B';
			}

		  if(DEBUG_MSG_LVL_3) /*** Ver 2.5 ***/
			{
				fn_userlog( c_ServiceName, "c_cvr_ordr_flw.................:%c:",c_cvr_ordr_flw);
			}

			i_returncode  = fn_call_svc_fml ( c_ServiceName,
																					 c_err_msg.arr,
																					 "SFO_LMT_PRC_CAL",
																					 0,
																					 13,
																					 1,
																					 FFO_USR_ID                 , (char *)st_usr_prfl.c_user_id,
																					 FFO_SSSN_ID                , (char *)&st_usr_prfl.l_session_id,
																					 FFO_XCHNG_CD               , (char *)st_ordbook.c_xchng_cd,
																					 FFO_ORDR_FLW               , (char *)&c_cvr_ordr_flw,
																					 FFO_UNDRLYNG               , (char *)st_ordbook.c_undrlyng,
																					 FFO_EBA_MTCH_ACT_NO        , (char *)st_usr_prfl.c_cln_mtch_accnt,
																					 FFO_RQST_TYP               , (char *)&c_rqst_typ ,
																					 FFO_PRDCT_TYP              , (char *)&st_ordbook.c_prd_typ,
																					 FFO_OPT_TYP                , (char *)&st_ordbook.c_opt_typ,
																					 FFO_STRK_PRC               , (char *)&st_ordbook.l_strike_prc,
																					 FFO_STP_LSS_TGR            , (char *)&st_ordbook.l_stp_lss_tgr,
																					 FFO_EXPRY_DT               , (char *)c_exp_dt.arr,
																					 FFO_SOURCE_FLG             , (char *)&c_source_flg ,
																					 FFO_LMT_RT                 , (char *)&l_ret_limit_rt ,NULL
																				);

		if (i_returncode != 0)
		{
				fn_errlog( c_ServiceName, "S31135", "Error while calling SFO_LMT_PRC_CAL", c_err_msg.arr);
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
				tpfree ( ( char * ) ptr_fml_Sbuf );
				tpfree ( ( char * ) ptr_fml_Rbuf );
				tpfree ( ( char * ) ptr_fml_Obuf );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
				Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}

	  if(DEBUG_MSG_LVL_1) /*** Ver 2.5 ***/
		{
			fn_userlog( c_ServiceName, "l_ret_limit_rt.................:%ld:",l_ret_limit_rt);
		}
		if(st_ordbook.l_ord_lmt_rt != l_ret_limit_rt)
		{
				fn_errlog( c_ServiceName, "S31140", "Incorrect Limit Rate received", c_err_msg.arr);
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
				tpfree ( ( char * ) ptr_fml_Sbuf );
				tpfree ( ( char * ) ptr_fml_Rbuf );
				tpfree ( ( char * ) ptr_fml_Obuf );
				d_ret_limit_rt=l_ret_limit_rt;
				fn_userlog( c_ServiceName, "d_ret_limit_rt :%lf: l_ret_limit_rt :%ld:",d_ret_limit_rt,l_ret_limit_rt);
				sprintf(c_err_msg.arr,"Incorrect Limit Rate received. Actual Rate: %.2lf",d_ret_limit_rt/100);/*Added in Ver 3.8 */
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
				Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
		/*** Ver 1.9 Ends ***/
    
		/******check whether underlying is enabled for trading ***/

  		EXEC SQL
    		SELECT NVL(FUM_QT_TRDNG_FLG,'Q'),
           		 NVL(FUM_SLTP_FP_TRDNG_FLG,'Q')
    		INTO   :c_qt_trd_flg,
           		 :c_sltp_trd_flg
    		FROM   FUM_FO_UNDRLYNG_MSTR
    		WHERE  FUM_XCHNG_CD= :st_ordbook.c_xchng_cd
    		/*** AND    FUM_PRDCT_TYP = 'O'  *** Commented in Ver 2.7 ***/
        AND    FUM_PRDCT_TYP = :c_fum_opt_prd_typ  /*** Ver 2.7 bind variable used instead of hard coded value ***/
    		AND    FUM_UNDRLYNG = :st_ordbook.c_undrlyng
    		AND    FUM_CTGRY_INDSTK = :st_ordbook.c_ctgry_indstk;

  		if ( SQLCODE  !=  0 && SQLCODE != NO_DATA_FOUND)
  		{
     		fn_errlog( c_ServiceName, "S31145",SQLMSG,c_err_msg.arr);
		 		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        tpfree ( ( char * ) ptr_fml_Sbuf );       /** Added in VQC ***/
        tpfree ( ( char * ) ptr_fml_Rbuf );       /** Added in VQC ***/
        tpfree ( ( char * ) ptr_fml_Obuf );       /** Added in VQC ***/
     		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		 		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
     		Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); 
     		Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); 
     		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  		}

  		if( c_qt_trd_flg != 'T' || c_sltp_trd_flg != 'T' || SQLCODE == NO_DATA_FOUND )
  		{
    		fn_errlog( c_ServiceName, "S31150","This Underlying is currently disabled",c_err_msg.arr);
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    		strcpy(c_err_msg.arr,"This Underlying is currently disabled");
    		tpfree ( ( char * ) ptr_fml_Sbuf );
    		tpfree ( ( char * ) ptr_fml_Rbuf );
    		tpfree ( ( char * ) ptr_fml_Obuf );
    		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
				Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    		Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
    		Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
    		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  		}

      /**** Check whether contract is enabled ***/
  		c_qt_trd_flg = '\0';
  		c_sltp_trd_flg = '\0';

			/*** Commented in Ver 1.7 and same column selected in Below ftq fetch ***

  		EXEC SQL
    		SELECT nvl(FCM_QT_TRDNG_FLG,'Q'),
        		   nvl(FCM_SLTP_FP_QT_TRDNG_FLG,'Q')
      	INTO   :c_qt_trd_flg,
        	     :c_sltp_trd_flg
      	FROM   FCM_FO_CNTRCT_MSTR
      	WHERE  FCM_XCHNG_CD = :st_ordbook.c_xchng_cd
      	AND    FCM_PRDCT_TYP = 'O'
      	AND    FCM_INDSTK = :st_ordbook.c_ctgry_indstk
      	AND    FCM_UNDRLYNG = :st_ordbook.c_undrlyng
      	AND    FCM_EXPRY_DT = :st_ordbook.c_expry_dt
      	AND    FCM_EXER_TYP = :st_ordbook.c_exrc_typ
      	AND    FCM_OPT_TYP  = :st_ordbook.c_opt_typ
      	AND    FCM_STRK_PRC = :st_ordbook.l_strike_prc;

			

  		if ( SQLCODE  !=  0 && SQLCODE != NO_DATA_FOUND)
  		{
     		fn_errlog( c_ServiceName, "S31155",SQLMSG,c_err_msg.arr);
		 		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
     		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		 		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
     		Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); *** Ver 1.3 ***
     		Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); *** Ver 1.3 ***
     		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  		}

  		if( c_qt_trd_flg != 'T' || c_sltp_trd_flg != 'T' ||  SQLCODE == NO_DATA_FOUND )
  		{
     		fn_errlog( c_ServiceName, "S31160","This Contract is currently disabled",c_err_msg.arr);
		 		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
     		strcpy(c_err_msg.arr,"This Contract is currently disabled");
     		tpfree ( ( char * ) ptr_fml_Sbuf );
     		tpfree ( ( char * ) ptr_fml_Rbuf );
     		tpfree ( ( char * ) ptr_fml_Obuf );
     		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		 		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
     		Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); *** Ver 1.3 ***
     		Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); *** Ver 1.3 ***
     		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  		}

  		if( (st_ordbook.l_ord_lmt_rt <=0) || (st_ordbook.l_stp_lss_tgr <= 0) )
  		{
    		fn_errlog( c_ServiceName, "S31165","Limit rate or SLTP cannot be less than or equal to Zero.",c_err_msg.arr);
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    		strcpy(c_err_msg.arr,"Limit rate or SLTP cannot be less than or equal to Zero.");
    		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
				Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    		Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); *** Ver 1.3 ***
    		Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); *** Ver 1.3 ***
    		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  		}
	

      *** Ver 1.8 starts ***
      EXEC SQL
        SELECT  NVL(FUM_SLTPFP_LMT_ALLWD_FLG,'N')
          INTO  :c_lmt_allwd_flg
          FROM  FUM_FO_UNDRLYNG_MSTR
        WHERE  FUM_UNDRLYNG = :st_ordbook.c_undrlyng
        AND  FUM_XCHNG_CD = :st_ordbook.c_xchng_cd
        AND  FUM_PRDCT_TYP = decode(:st_ordbook.c_prd_typ,'U','F','I','O','P','F',:st_ordbook.c_prd_typ);;

        if ( SQLCODE  !=  0 && SQLCODE != NO_DATA_FOUND)
        {
          fn_errlog( c_ServiceName, "S31170",SQLMSG,c_err_msg.arr);
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }

      if(st_ordbook.c_mrkt_typ == 'L' && c_lmt_allwd_flg == 'N')
      {
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
       fn_errlog( c_ServiceName,"S31175","Only Market orders are allowed in this stock. Please enter market as order type to  place your order.",c_err_msg.arr);
       strcpy(c_err_msg.arr,"Only Market orders are allowed in this stock. Please enter market as order type to place your order .");
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
      *** Ver 1.8 Ends ***

			Ver 1.7 Comment Ends 	***/
		}

    /***** Moved query here in VQC ************/

    EXEC SQL
        SELECT  NVL(CLM_SPAN_ALLWD,'N'),
                NVL(CLM_BSESPAN_ALLWD,'N'),
                CLM_CLNT_LVL                    /*** Added in VQC ****/
        INTO    :c_spn_allwd_flg,
                :c_bse_span_flag,
                :c_clm_clnt_lvl                 /*** Added in VQC ****/
        FROM    CLM_CLNT_MSTR
        WHERE   CLM_MTCH_ACCNT  = :st_usr_prfl.c_cln_mtch_accnt;

    if ( SQLCODE  !=  0 )
    {
      fn_errlog( c_ServiceName, "S31180",SQLMSG,c_err_msg.arr);
      fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
      tpfree ( ( char * ) ptr_fml_Sbuf );       /** Added in VQC ***/
      tpfree ( ( char * ) ptr_fml_Rbuf );       /** Added in VQC ***/
      tpfree ( ( char * ) ptr_fml_Obuf );       /** Added in VQC ***/
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
  /*** Ver 3.0 Starts ***/

  if ( st_ordbook.c_req_typ == 'P' )
  {

   st_cntrct.c_prd_typ = st_ordbook.c_prd_typ;

    i_returncode = fn_disallow_frsh_expsre(c_ServiceName,
                             st_usr_prfl.c_cln_mtch_accnt,
                             c_spn_allwd_flg,
                             st_ordbook.c_ordr_flw,
                             st_ordbook.l_ord_tot_qty,
                             l_old_ord_qty,
                             &st_cntrct,
                             &st_err_msg );
     if (i_returncode == -1 || i_returncode == -2)
     {
      fn_errlog( c_ServiceName, "S31185", "Error in Function fn_disallow_frsh_expsre", c_err_msg.arr);
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
      fn_aborttran( c_ServiceName, i_trnsctn, st_err_msg.c_err_msg );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG,  st_err_msg.c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     }
  }
  /*** Ver 3.0 Ends ***/

  if( st_ordbook.c_req_typ == 'P' || st_ordbook.c_req_typ == 'M')           /** if() added in Ver 1.8 **/
  {
		/***	Ver 1.7 Starts			***/

   /*** Column names in below query changed to upper case in Ver 2.7 ***/

		EXEC SQL
      SELECT  NVL(FTQ_BST1_BID_PRC,0),
              NVL(FTQ_BST1_BID_QTY,0),
              NVL(FTQ_BST2_BID_PRC,0),
              NVL(FTQ_BST2_BID_QTY,0),
              NVL(FTQ_BST3_BID_PRC,0),
              NVL(FTQ_BST3_BID_QTY,0),
              NVL(FTQ_BST4_BID_PRC,0),
              NVL(FTQ_BST4_BID_QTY,0),
              NVL(FTQ_BST5_BID_PRC,0),
              NVL(FTQ_BST5_BID_QTY,0),
              NVL(FTQ_BST1_OFFR_PRC,0),
              NVL(FTQ_BST1_OFFR_QTY,0),
              NVL(FTQ_BST2_OFFR_PRC,0),
              NVL(FTQ_BST2_OFFR_QTY,0),
              NVL(FTQ_BST3_OFFR_PRC,0),
              NVL(FTQ_BST3_OFFR_QTY,0),
              NVL(FTQ_BST4_OFFR_PRC,0),
              NVL(FTQ_BST4_OFFR_QTY,0),
              NVL(FTQ_BST5_OFFR_PRC,0),
              NVL(FTQ_BST5_OFFR_QTY,0),
							NVL(FTQ_QT_TRDNG_FLG,'Q'),                 /*** Added in Ver 1.7 ***/
              NVL(FTQ_SLTP_FP_QT_TRDNG_FLG,'Q')          /*** Added in Ver 1.7 ***/
       INTO   :l_bst_bid_prc[0],
              :l_bst_bid_qty[0],
              :l_bst_bid_prc[1],
              :l_bst_bid_qty[1],
              :l_bst_bid_prc[2],
              :l_bst_bid_qty[2],
              :l_bst_bid_prc[3],
              :l_bst_bid_qty[3],
              :l_bst_bid_prc[4],
              :l_bst_bid_qty[4],
              :l_bst_offr_prc[0],
              :l_bst_offr_qty[0],
              :l_bst_offr_prc[1],
              :l_bst_offr_qty[1],
              :l_bst_offr_prc[2],
							:l_bst_offr_qty[2],
              :l_bst_offr_prc[3],
              :l_bst_offr_qty[3],
              :l_bst_offr_prc[4],
              :l_bst_offr_qty[4],
							:c_qt_trd_flg,                             /*** Added in Ver 1.7 ***/
              :c_sltp_trd_flg                            /*** Added in Ver 1.7 ***/
       FROM   FTQ_FO_TRD_QT
       WHERE  FTQ_XCHNG_CD  = :st_ordbook.c_xchng_cd
       /*** AND    FTQ_PRDCT_TYP = 'O' *** Commented in Ver 2.7 ***/
       AND    FTQ_PRDCT_TYP = :c_fum_opt_prd_typ /*** Ver 2.7 bind variable used instead of hard coded values ***/ 
       AND    FTQ_UNDRLYNG  = :st_ordbook.c_undrlyng
       AND    FTQ_EXPRY_DT  = :st_ordbook.c_expry_dt
       AND    FTQ_EXER_TYP  = :st_ordbook.c_exrc_typ
       AND    FTQ_OPT_TYP   = :st_ordbook.c_opt_typ
       AND    FTQ_STRK_PRC  = :st_ordbook.l_strike_prc;

    if ( SQLCODE  !=  0 )
    {
      fn_errlog( c_ServiceName, "S31190",SQLMSG,c_err_msg.arr);
      fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
      tpfree ( ( char * ) ptr_fml_Sbuf );       /** Added in VQC ***/
      tpfree ( ( char * ) ptr_fml_Rbuf );       /** Added in VQC ***/
      tpfree ( ( char * ) ptr_fml_Obuf );       /** Added in VQC ***/
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

		if( st_ordbook.c_req_typ == 'P')
		{

			if( c_qt_trd_flg != 'T' || c_sltp_trd_flg != 'T' ||  SQLCODE == NO_DATA_FOUND )
      {
        fn_errlog( c_ServiceName, "S31195","This Contract is currently disabled",c_err_msg.arr);
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        strcpy(c_err_msg.arr,"This Contract is currently disabled");
        tpfree ( ( char * ) ptr_fml_Sbuf );
        tpfree ( ( char * ) ptr_fml_Rbuf );
        tpfree ( ( char * ) ptr_fml_Obuf );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); 
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

      if( (st_ordbook.l_ord_lmt_rt <=0) || (st_ordbook.l_stp_lss_tgr <= 0) )
      {
        fn_errlog( c_ServiceName, "S31200","Limit rate or SLTP cannot be less than or equal to Zero.",c_err_msg.arr);
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        tpfree ( ( char * ) ptr_fml_Sbuf );       /** Added in VQC ***/
        tpfree ( ( char * ) ptr_fml_Rbuf );       /** Added in VQC ***/
        tpfree ( ( char * ) ptr_fml_Obuf );       /** Added in VQC ***/
        strcpy(c_err_msg.arr,"Limit rate or SLTP cannot be less than or equal to Zero.");
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); 
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); 
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

			 EXEC SQL
        SELECT  NVL(FUM_SLTPFP_LMT_ALLWD_FLG,'N')
          INTO  :c_lmt_allwd_flg
          FROM  FUM_FO_UNDRLYNG_MSTR
        WHERE  FUM_UNDRLYNG = :st_ordbook.c_undrlyng
        AND  FUM_XCHNG_CD = :st_ordbook.c_xchng_cd
        AND  FUM_PRDCT_TYP = decode(:st_ordbook.c_prd_typ,'U','F','I','O','P','F',:st_ordbook.c_prd_typ);;

        if ( SQLCODE  !=  0 && SQLCODE != NO_DATA_FOUND)
        {
          fn_errlog( c_ServiceName, "S31205",SQLMSG,c_err_msg.arr);
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
          tpfree ( ( char * ) ptr_fml_Sbuf );       /** Added in VQC ***/
          tpfree ( ( char * ) ptr_fml_Rbuf );       /** Added in VQC ***/
          tpfree ( ( char * ) ptr_fml_Obuf );       /** Added in VQC ***/
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }

      if(st_ordbook.c_mrkt_typ == 'L' && c_lmt_allwd_flg == 'N')
      {
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    		fn_errlog( c_ServiceName,"S31210","Only Market orders are allowed in this stock. Please enter market as order type to  place your order.",c_err_msg.arr);
       strcpy(c_err_msg.arr,"Only Market orders are allowed in this stock. Please enter market as order type to place your order .");
        tpfree ( ( char * ) ptr_fml_Sbuf );       /** Added in VQC ***/
        tpfree ( ( char * ) ptr_fml_Rbuf );       /** Added in VQC ***/
        tpfree ( ( char * ) ptr_fml_Obuf );       /** Added in VQC ***/
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

		}
		
		/***	Ver 1.7 Ends	***/

  		/*** Ver 1.8 ** Starts ***/
  	if ( st_ordbook.c_mrkt_typ == 'L' )
  	{
    	if ( st_ordbook.c_ordr_flw == SELL )        /*** Cover Order Flow Buy ***/
    	{
      	/** Stop loss triger price and limit price of cover Buy order shall be more than the limit price of cover order **/
      	/** for fresh sell order **/
      	if(st_ordbook.l_stp_lss_tgr < l_lmt_rt)
      	{
        	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        	fn_errlog( c_ServiceName, "S31215","Stop loss trigger price and limit price of cover order must be greater than limit  rate of fresh SELL order.",c_err_msg.arr);
        	strcpy(c_err_msg.arr,"Stop loss trigger price and limit price of cover order must be greater than limit rate of fresh SELL order.");
          tpfree ( ( char * ) ptr_fml_Sbuf );       /** Added in VQC ***/
          tpfree ( ( char * ) ptr_fml_Rbuf );       /** Added in VQC ***/
          tpfree ( ( char * ) ptr_fml_Obuf );       /** Added in VQC ***/
        	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        	Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
        	Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
        	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      	}
    	}

    	if ( st_ordbook.c_ordr_flw == BUY  )      /*** Cover Order Flow Sell ***/
    	{
      	/** Stop loss triger price and limit price of cover Sell order shall be less than  the limit price of Fresh order **/
      	/** for fresh Buy order **/
      	if(st_ordbook.l_stp_lss_tgr > l_lmt_rt)
      	{
        	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        	fn_errlog( c_ServiceName, "S31220","Stop loss trigger price and limit price of cover Sell order must be Less than limit rate of fresh BUY order.",c_err_msg.arr);
        	strcpy(c_err_msg.arr,"Stop loss trigger price and limit price of cover Sell order must be Less than limit rate of fresh BUY order.");
          tpfree ( ( char * ) ptr_fml_Sbuf );       /** Added in VQC ***/
          tpfree ( ( char * ) ptr_fml_Rbuf );       /** Added in VQC ***/
          tpfree ( ( char * ) ptr_fml_Obuf );       /** Added in VQC ***/
        	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        	Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
        	Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
        	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      	}
    	}
  	}
  	/*** Ver 1.8 ** Ends ***/

		/***	Ver 1.7 To avoid multiple DB hits on same table , qurey moved upwards  

  	**** Check order placement will be allowed only to the extent of first 5 bids/offer qty **

  	EXEC SQL
     	SELECT  NVL(ftq_bst1_bid_prc,0),
      	      NVL(ftq_bst1_bid_qty,0),
             	NVL(ftq_bst2_bid_prc,0),
             	NVL(ftq_bst2_bid_qty,0),
             	NVL(ftq_bst3_bid_prc,0),
             	NVL(ftq_bst3_bid_qty,0),
             	NVL(ftq_bst4_bid_prc,0),
             	NVL(ftq_bst4_bid_qty,0),
             	NVL(ftq_bst5_bid_prc,0),
             	NVL(ftq_bst5_bid_qty,0),
             	NVL(ftq_bst1_offr_prc,0),
             	NVL(ftq_bst1_offr_qty,0),
             	NVL(ftq_bst2_offr_prc,0),
             	NVL(ftq_bst2_offr_qty,0),
             	NVL(ftq_bst3_offr_prc,0),
             	NVL(ftq_bst3_offr_qty,0),
             	NVL(ftq_bst4_offr_prc,0),
             	NVL(ftq_bst4_offr_qty,0),
             	NVL(ftq_bst5_offr_prc,0),
             	NVL(ftq_bst5_offr_qty,0)
       INTO   :l_bst_bid_prc[0],
              :l_bst_bid_qty[0],
              :l_bst_bid_prc[1],
              :l_bst_bid_qty[1],
              :l_bst_bid_prc[2],
              :l_bst_bid_qty[2],
              :l_bst_bid_prc[3],
              :l_bst_bid_qty[3],
              :l_bst_bid_prc[4],
              :l_bst_bid_qty[4],
              :l_bst_offr_prc[0],
              :l_bst_offr_qty[0],
              :l_bst_offr_prc[1],
              :l_bst_offr_qty[1],
              :l_bst_offr_prc[2],
              :l_bst_offr_qty[2],
              :l_bst_offr_prc[3],
              :l_bst_offr_qty[3],
              :l_bst_offr_prc[4],
              :l_bst_offr_qty[4]
       FROM   ftq_fo_trd_qt
       WHERE  ftq_xchng_cd  = :st_ordbook.c_xchng_cd
       AND    ftq_prdct_typ = 'O'
       AND    ftq_undrlyng  = :st_ordbook.c_undrlyng
       AND    ftq_expry_dt  = :st_ordbook.c_expry_dt
       AND    ftq_exer_typ  = :st_ordbook.c_exrc_typ
       AND    ftq_opt_typ   = :st_ordbook.c_opt_typ
       AND    ftq_strk_prc  = :st_ordbook.l_strike_prc;

  	if ( SQLCODE  !=  0 )
  	{
     	fn_errlog( c_ServiceName, "S31225",SQLMSG,c_err_msg.arr);
		 	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
     	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		 	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
     	Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); *** Ver 1.3 ***
     	Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); *** Ver 1.3 ***
     	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	}

		Commented in Ver 1.7	***/

  	d_tot_bid_qty = l_bst_bid_qty[0] +
                  	l_bst_bid_qty[1] +
                  	l_bst_bid_qty[2] +
                  	l_bst_bid_qty[3] +
                  	l_bst_bid_qty[4];

  	d_tot_offr_qty = l_bst_offr_qty[0] +
                   	 l_bst_offr_qty[1] +
                     l_bst_offr_qty[2] +
                   	 l_bst_offr_qty[3] +
                   	 l_bst_offr_qty[4];



  	if(DEBUG_MSG_LVL_1) 	/*** Ver 2.5 ***/
  	{
    	fn_userlog( c_ServiceName, "d_tot_bid_qty :%lf:",d_tot_bid_qty);
    	fn_userlog( c_ServiceName, "d_tot_offr_qty :%lf:",d_tot_offr_qty);
  	}

  	/***** Fetching sltp % diff *****/
  	EXEC SQL
       	SELECT NVL(FMM_SLTP_DIFF_PRCNT,0),
             	 NVL(FMM_SLTP_PRCNT,0)
       	INTO   :d_sltp_diff_prcnt,
               :d_sltp_prcnt
       	FROM   FMM_FO_MRGN_MSTR
       /***	WHERE  FMM_PRDCT_TYP='O'  *** Commented in Ver 2.7 ***/
        WHERE  FMM_PRDCT_TYP= :c_fum_opt_prd_typ   /*** Ver 2.7 bind variable used instead of hard coded value ***/
       	AND    FMM_UNDRLYNG = :st_ordbook.c_undrlyng
       	AND    FMM_XCHNG_CD = :st_ordbook.c_xchng_cd
       	AND    FMM_UNDRLYNG_BSKT_ID =(SELECT  FCB_UNDRLYNG_BSKT_ID
                                     	FROM    FCB_FO_CLN_BSKT_ALLTD
                                     	WHERE   FCB_CLN_LVL = :c_clm_clnt_lvl); /** Added in VQC **/
                                                           /*** (SELECT CLM_CLNT_LVL
                                                           	FROM    CLM_CLNT_MSTR
                                                           	WHERE   CLM_MTCH_ACCNT = :st_usr_prfl.c_cln_mtch_accnt));
                                                            *** Commented in VQC ***/ 
  	if ( SQLCODE  !=  0 )
  	{
     	fn_errlog( c_ServiceName, "S31230",SQLMSG,c_err_msg.arr);
     	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
      tpfree ( ( char * ) ptr_fml_Sbuf );       /** Added in VQC ***/
      tpfree ( ( char * ) ptr_fml_Rbuf );       /** Added in VQC ***/
      tpfree ( ( char * ) ptr_fml_Obuf );       /** Added in VQC ***/
     	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
     	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
     	Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
     	Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
     	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
	}

  /***** Commented this query and moved above in VQC *******

  	EXEC SQL
       	SELECT  NVL(CLM_SPAN_ALLWD,'N'),
               	NVL(CLM_BSESPAN_ALLWD,'N')
       	INTO    :c_spn_allwd_flg,
               	:c_bse_span_flag
       	FROM    CLM_CLNT_MSTR
       	WHERE   CLM_MTCH_ACCNT  = :st_usr_prfl.c_cln_mtch_accnt;

  	if ( SQLCODE  !=  0 )
  	{
    	fn_errlog( c_ServiceName, "S31235",SQLMSG,c_err_msg.arr);
			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    	Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); *** Ver 1.3 ***
    	Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); *** Ver 1.3 ***
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	}

    ********************* VQC **************************************/

  	if(DEBUG_MSG_LVL_3)
  	{
   	 	fn_userlog(c_ServiceName,"NSE SPAN ALLWD FLAG IS :%c:",c_spn_allwd_flg);
			fn_userlog(c_ServiceName,"BSE SPAN ALLWD FLAG IS :%c:",c_bse_span_flag);
  	}

  if( st_ordbook.c_req_typ == 'P' || st_ordbook.c_req_typ == 'M')           /** if() added in Ver 1.8 **/
  {
  	strcpy ( ptr_st_pstn_actn.c_cln_mtch_accnt,st_usr_prfl.c_cln_mtch_accnt);
  	strcpy ( ptr_st_pstn_actn.c_xchng_cd, st_ordbook.c_xchng_cd );
    /*** Commented in VQC
  	strcpy ( st_pstn_action.c_cln_mtch_accnt,st_usr_prfl.c_cln_mtch_accnt);
  	strcpy ( st_pstn_action.c_xchng_cd, st_ordbook.c_xchng_cd );
    ******/
  	l_temp_ord_lmt_rt = st_ordbook.l_ord_lmt_rt;
  	l_temp_stp_lss_tgr = st_ordbook.l_stp_lss_tgr;
  	st_ordbook.l_mdfctn_cntr = 1;

    /********* Commeting VQC Starts here as value d_diff_amt calculated is not used  *************

  	if (st_ordbook.c_ordr_flw == 'S') ** for cover ordr flw buy **
  	{
    	d_diff_amt =  st_ordbook.l_ord_lmt_rt - st_ordbook.l_stp_lss_tgr;
  	}
  	else if(st_ordbook.c_ordr_flw == 'B')
  	{
    	d_diff_amt = st_ordbook.l_stp_lss_tgr - st_ordbook.l_ord_lmt_rt;
  	}

  	if(DEBUG_MSG_LVL_3)
  	{
   		fn_userlog(c_ServiceName,"SLTP & Limit value difference :%lf:",d_diff_amt);
  	}

    ********** VQC Commentng Ends here***************/

  	/*Check if the limit price and the trigger price of the cover order are in multiples of 5 paise*/

   	if( (fn_5paisa(st_ordbook.l_ord_lmt_rt)!= 0) &&
         	(fn_5paisa(st_ordbook.l_stp_lss_tgr)!= 0))
   	{
     	fn_errlog( c_ServiceName, "S31240","limit price and the trigger price of the cover order must be in multiples of paise ",c_err_msg.arr);
     	strcpy(c_err_msg.arr,"limit price and the trigger price of the cover order must be in multiples of paise ");
		 	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
     	tpfree ( ( char * ) ptr_fml_Sbuf );
     	tpfree ( ( char * ) ptr_fml_Rbuf );
     	tpfree ( ( char * ) ptr_fml_Obuf );
     	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		 	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
     	Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
     	Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
     	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
   	}
	}
    /********* For Loop Begins *********************/

   if( st_ordbook.c_req_typ == 'P')                                            /*** if() added in Ver 1.8 ***/
   {
   	for( i_cnt=0; i_cnt < 2; i_cnt++)
   	{
    	if(i_cnt == 0 )
    	{
				if(st_ordbook.c_mrkt_typ == 'L')
        {
          st_ordbook.c_slm_flg = st_ordbook.c_mrkt_typ;
        }
        else
        {
          st_ordbook.c_slm_flg = 'M';
        }	
      	st_ordbook.l_stp_lss_tgr = 0;
      	st_first_ordbk.l_ord_tot_qty = st_ordbook.l_ord_tot_qty;
      	strcpy(st_first_ordbk.c_xchng_cd ,st_ordbook.c_xchng_cd);
      	st_first_ordbk.c_prd_typ = st_ordbook.c_prd_typ;
      	strcpy(st_first_ordbk.c_undrlyng ,st_ordbook.c_undrlyng);
      	strcpy(st_first_ordbk.c_expry_dt ,st_ordbook.c_expry_dt);
      	st_first_ordbk.c_exrc_typ = st_ordbook.c_exrc_typ;
      	st_first_ordbk.c_opt_typ = st_ordbook.c_opt_typ;
      	st_first_ordbk.l_strike_prc = st_ordbook.l_strike_prc;

      	/******* Calculating weighted avg price *******/
				if(st_ordbook.c_mrkt_typ == 'M')												/**  if added in Ver 1.8 **/
				{ 
      		if(st_ordbook.c_ordr_flw == 'S' )
      		{
   					fn_avg_price_cal(c_ServiceName,l_bst_bid_qty,l_bst_bid_prc,&d_avg_prc,st_ordbook.l_ord_tot_qty); 

          /*** ver 3.2 starts ***/
          /*** For Fresh sell order, the weighted average price should not be greater than the *
             * SLTP of cover Buy order ***/
          if(DEBUG_MSG_LVL_0)
          {
			        fn_userlog( c_ServiceName," THE l_temp_stp_lss_tgr is :%ld: and d_avg_prc is :%lf:",l_temp_stp_lss_tgr,d_avg_prc);
	        }

          if( (double)l_temp_stp_lss_tgr < d_avg_prc )
          {
		         fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
		         fn_errlog( c_ServiceName, "B22009",DEFMSG,c_err_msg.arr);
             tpfree ( ( char * ) ptr_fml_Sbuf );
             tpfree ( ( char * ) ptr_fml_Rbuf );
             tpfree ( ( char * ) ptr_fml_Obuf );
	      	   Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		         Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
		         Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
		         Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); 
		         tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          }
          /*** ver 3.2 ends ***/
 
      		}
      		else if (st_ordbook.c_ordr_flw == 'B')
      		{
        		fn_avg_price_cal(c_ServiceName,l_bst_offr_qty,l_bst_offr_prc,&d_avg_prc,st_ordbook.l_ord_tot_qty);

           /*** ver 3.2 starts ***/
           /*** For Fresh buy order, the weighted average price should not be less than the *
              * SLTP of cover sell order ***/

            if(DEBUG_MSG_LVL_0)
            {
      			     fn_userlog( c_ServiceName," THE l_temp_stp_lss_tgr is :%ld: and d_avg_prc is :%lf:",l_temp_stp_lss_tgr,d_avg_prc);
	          }
            if( (double)l_temp_stp_lss_tgr > d_avg_prc )
            {
				        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
				        fn_errlog( c_ServiceName, "B22010",DEFMSG,c_err_msg.arr );
                tpfree ( ( char * ) ptr_fml_Sbuf );
                tpfree ( ( char * ) ptr_fml_Rbuf );
                tpfree ( ( char * ) ptr_fml_Obuf );
				        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
				        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
				        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
				        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); 
				        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }
            /*** ver 3.2 ends ***/

      		}
      		st_ordbook.l_ord_lmt_rt = 0;
      		l_lmt_rt= (long) d_avg_prc;
				}
				else
				{
				  d_avg_prc = (double) l_lmt_rt;
      		st_ordbook.l_ord_lmt_rt = (long) d_avg_prc;

				  if(DEBUG_MSG_LVL_1) /*** Ver 2.5 ***/
					{
      			fn_userlog( c_ServiceName,"d_avg_prc:%lf:",d_avg_prc);
      			fn_userlog( c_ServiceName,"l_lmt_rt:%ld:",l_lmt_rt);
					}
				}

				/*** Commented in Ver 1.8 ****
      	d_mrgn_amt= ((st_ordbook.l_ord_tot_qty * d_avg_prc *d_sltp_prcnt)/100);

  			EXEC SQL
   				SELECT nvl(FRM_DIFFRNC_MRGN,0) 
   				INTO   :d_frm_diffrnc_mrgn
   				FROM   FRM_FO_RANGE_MSTR
   				WHERE  FRM_XCHNG_CD = :st_ordbook.c_xchng_cd 
	 				AND    FRM_UNDRLYNG = :st_ordbook.c_undrlyng 
	 				AND 	 FRM_ORDR_FLOW = :st_ordbook.c_ordr_flw
					AND    FRM_FROM_RANGE <= :l_temp_stp_lss_tgr
        	AND    :l_temp_stp_lss_tgr   < FRM_TO_RANGE;
 
  			if ( SQLCODE  !=  0  && SQLCODE != NO_DATA_FOUND)
  			{
    			fn_errlog( c_ServiceName, "S31245",SQLMSG,c_err_msg.arr);
					fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
					Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        	Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); *** Ver 1.3 ***
        	Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); *** Ver 1.3 ***
    			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  			}
				else if ( SQLCODE == NO_DATA_FOUND )
      	{
					fn_userlog(c_ServiceName,"Entered SLTP is OutOff Range");
        	fn_errlog( c_ServiceName, "S31250","Order Not Allowed to Place : SLTP OutOff Range.",c_err_msg.arr);
        	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        	Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); *** Ver 1.3 ***
        	Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); *** Ver 1.3 ***
        	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     	  }
	  		
					fn_userlog(c_ServiceName,"d_frm_diffrnc_mrgn :%lf:",d_frm_diffrnc_mrgn);
				if( st_ordbook.c_ordr_flw == 'B' )  
				{
					if( d_frm_diffrnc_mrgn < 100 && d_frm_diffrnc_mrgn != -1 )
					{
						fn_userlog(c_ServiceName,"Inside frm mrgn < 100 check");
						d_lss_amt = st_ordbook.l_ord_tot_qty * (d_avg_prc - st_ordbook.l_ord_lmt_rt);
      		}
					else if ( d_frm_diffrnc_mrgn == 100 )
					{
						fn_userlog(c_ServiceName,"Inside frm mrgn = 100 check");
				 		d_lss_amt = st_ordbook.l_ord_tot_qty * d_avg_prc;
					}
					else if( d_frm_diffrnc_mrgn == -1 )
					{
						fn_userlog(c_ServiceName,"Entered SLTP is OutOff Range"); 
				  	fn_errlog( c_ServiceName, "S31255","Please Enter SLTP in Proper Range",c_err_msg.arr);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          	Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); *** Ver 1.3 ***
          	Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); *** Ver 1.3 ***
        		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );	
					}
				}			
				else 
				{
					fn_userlog(c_ServiceName,"Inside  ordr_flw sell.");
      		d_lss_amt = st_ordbook.l_ord_tot_qty * (d_avg_prc - st_ordbook.l_ord_lmt_rt ) * -1;
				}

      	d_mrgn_amt = (long long)d_mrgn_amt;
      	d_lss_amt = (long long) d_lss_amt;
					Comment Ends in Ver 1.8	*********************/

      	if(DEBUG_MSG_LVL_3)
      	{
       /*** 	fn_userlog( c_ServiceName, "d_lss_amt = :%lf:",d_lss_amt);		***** Commented in Ver 1.8 ***
        	fn_userlog(c_ServiceName,"d_mrgn_amt :%lf:",d_mrgn_amt); ***/
        	fn_userlog(c_ServiceName,"st_ordbook.l_ord_tot_qty :%d:",st_ordbook.l_ord_tot_qty);
        	fn_userlog(c_ServiceName,"d_sltp_prcnt is :%lf:",d_sltp_prcnt);
       	  fn_userlog( c_ServiceName, "st_ordbook.l_ord_tot_qty = :%ld:",st_ordbook.l_ord_tot_qty);
        	fn_userlog( c_ServiceName, "d_avg_prc = :%lf:",d_avg_prc);
        	fn_userlog( c_ServiceName, "st_ordbook.l_ord_lmt_rt = :%ld:",st_ordbook.l_ord_lmt_rt);
      	}

      	/*** st_ordbook.l_ord_lmt_rt = 0; *** Commented in Ver 1.8 ***/
   		
			  if(DEBUG_MSG_LVL_3)
   			{
    			fn_userlog( c_ServiceName, "st_ordbook.c_ordr_flw :%c:",st_ordbook.c_ordr_flw);
    			fn_userlog( c_ServiceName, "st_ordbook.l_ord_tot_qty :%ld:",st_ordbook.l_ord_tot_qty);
    			fn_userlog( c_ServiceName, "d_tot_bid_qty:%lf:",d_tot_bid_qty);
    			fn_userlog( c_ServiceName, "d_tot_offr_qty:%lf:",d_tot_offr_qty);
     /***	fn_userlog( c_ServiceName, "d_ord_tot_qty:%lf:",d_ord_tot_qty);   ** Commented in VQC ***/
   			}

   	/*** d_ord_tot_qty = st_ordbook.l_ord_tot_qty;  ** Commented in VQC ***/

				if(st_ordbook.c_mrkt_typ == 'M')
        {
   				if((st_ordbook.c_ordr_flw == 'S' && st_ordbook.l_ord_tot_qty > d_tot_bid_qty ) ||
       			 (st_ordbook.c_ordr_flw == 'B' && st_ordbook.l_ord_tot_qty > d_tot_offr_qty))
   				{
    			 fn_errlog( c_ServiceName, "S31260","Order Quantity is greater than total quantity of best 5 bids/offers",c_err_msg.arr);
    			 strcpy(c_err_msg.arr,"Order Quantity is greater than total quantity of best 5 bids/offers");
    			 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    			 tpfree ( ( char * ) ptr_fml_Sbuf );
    			 tpfree ( ( char * ) ptr_fml_Rbuf );
    			 tpfree ( ( char * ) ptr_fml_Obuf );
    			 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    			 Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    			 Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
    			 Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
    			 tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
   				}
				}
	 		}
   		else
   		{
      	st_ordbook.c_slm_flg='S';
      	st_ordbook.c_ordr_flw =(st_ordbook.c_ordr_flw == 'B'?'S':(st_ordbook.c_ordr_flw == 'S'?'B':'\0')); /* VER TOL : TUX on LINUX-- Changed empty character with \0 (Ravindra) */
      	st_ordbook.l_ord_lmt_rt = l_temp_ord_lmt_rt;
      	st_ordbook.l_stp_lss_tgr =  l_temp_stp_lss_tgr;

				if(DEBUG_MSG_LVL_3) /*** Ver 2.5 ***/
				{
      		fn_userlog( c_ServiceName, "Cover Order Flow :%c:",st_ordbook.c_ordr_flw);
				}
   		}

	 	/**** if(DEBUG_MSG_LVL_3)
	 	{
			fn_userlog( c_ServiceName, "st_ordbook.c_ordr_flw :%c:",st_ordbook.c_ordr_flw);
			fn_userlog( c_ServiceName, "st_ordbook.l_ord_tot_qty :%ld:",st_ordbook.l_ord_tot_qty);
			fn_userlog( c_ServiceName, "d_tot_bid_qty:%lf:",d_tot_bid_qty);
			fn_userlog( c_ServiceName, "d_tot_offr_qty:%lf:",d_tot_offr_qty);
			fn_userlog( c_ServiceName, "d_ord_tot_qty:%lf:",d_ord_tot_qty);
	 	}

	 	d_ord_tot_qty = st_ordbook.l_ord_tot_qty;
   
	 	if((st_ordbook.c_ordr_flw == 'S' && st_ordbook.l_ord_tot_qty > d_tot_bid_qty ) ||
    	   (st_ordbook.c_ordr_flw == 'B' && st_ordbook.l_ord_tot_qty > d_tot_offr_qty))
   	{
    	fn_errlog( c_ServiceName, "S31265","Order Quantity is greater than total quantity of best 5 bids/offers",c_err_msg.arr);
    	strcpy(c_err_msg.arr,"Order Quantity is greater than total quantity of best 5 bids/offers");
			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    	tpfree ( ( char * ) ptr_fml_Sbuf );
    	tpfree ( ( char * ) ptr_fml_Rbuf );
    	tpfree ( ( char * ) ptr_fml_Obuf );
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
	 		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
   	}
***/

   if ( (c_spn_allwd_flg == 'Y' && strcmp(st_ordbook.c_xchng_cd,"NFO")==0) ||
        ( c_bse_span_flag == 'Y' && strcmp(st_ordbook.c_xchng_cd,"BFO")==0 ))
   {
    strcpy(c_srvc_nm,"SFO_SPN_PLC_ORD");
   }
   else
   {
    strcpy(c_srvc_nm,"SFO_OPT_PLC_ORD");
   }

   i_err[0] = Fchg32 ( ptr_fml_Sbuf, FFO_XCHNG_CD, 0,
                                     (char *)st_ordbook.c_xchng_cd, 0);
   i_ferr [ 0 ] = Ferror32;

   i_err[1] = Fchg32 ( ptr_fml_Sbuf, FFO_PRDCT_TYP, 0,
                                    (char *)&st_ordbook.c_prd_typ, 0);
   i_ferr [ 1 ] = Ferror32;

   i_err[2] = Fchg32 ( ptr_fml_Sbuf, FFO_UNDRLYNG, 0,
                                    (char *)st_ordbook.c_undrlyng, 0);
   i_ferr [ 2 ] = Ferror32;

   i_err[3] = Fchg32 ( ptr_fml_Sbuf, FFO_EXPRY_DT, 0,
                                     (char *)c_exp_dt.arr, 0);
   i_ferr [ 3 ] = Ferror32;

   i_err[4] = Fchg32 ( ptr_fml_Sbuf, FFO_EXER_TYP, 0,
                                     (char *)&st_ordbook.c_exrc_typ, 0);
   i_ferr [ 4 ] = Ferror32;

   i_err[5] = Fchg32 ( ptr_fml_Sbuf, FFO_OPT_TYP, 0,
                                     (char *)&st_ordbook.c_opt_typ, 0);
   i_ferr [ 5 ] = Ferror32;

   i_err[6] = Fchg32 ( ptr_fml_Sbuf, FFO_STRK_PRC, 0,
                                     (char *)&st_ordbook.l_strike_prc, 0);
   i_ferr [ 6 ] = Ferror32;

   i_err[7] = Fchg32 ( ptr_fml_Sbuf, FFO_CTGRY_INDSTK, 0,
                                     (char *)&st_ordbook.c_ctgry_indstk, 0);
   i_ferr [ 7 ] = Ferror32;

   i_err[8] = Fchg32 ( ptr_fml_Sbuf, FFO_ORDR_FLW, 0,
                                     (char *)&st_ordbook.c_ordr_flw, 0);
   i_ferr [ 8 ] = Ferror32;

   i_err[9] = Fchg32 ( ptr_fml_Sbuf, FFO_LMT_MKT_SL_FLG, 0,
                                     (char *)&st_ordbook.c_slm_flg, 0);
   i_ferr [ 9 ] = Ferror32;

   i_err[10] = Fchg32 ( ptr_fml_Sbuf, FFO_ORD_TYP, 0,
                                     (char *)&st_ordbook.c_ord_typ, 0);
   i_ferr [ 10 ] = Ferror32;

   i_err[11] = Fchg32 ( ptr_fml_Sbuf, FFO_ORD_TOT_QTY, 0,
                                     (char *)&st_ordbook.l_ord_tot_qty, 0);
   i_ferr [ 11 ] = Ferror32;

   i_err[12] = Fchg32 ( ptr_fml_Sbuf, FFO_LMT_RT, 0,
                                     (char *)&st_ordbook.l_ord_lmt_rt, 0);
   i_ferr [ 12 ] = Ferror32;

   i_err[13] = Fchg32 ( ptr_fml_Sbuf, FFO_DSCLSD_QTY, 0,
                                     (char *)&st_ordbook.l_dsclsd_qty, 0);
   i_ferr [ 13 ] = Ferror32;
   i_err[14] = Fchg32 ( ptr_fml_Sbuf, FFO_STP_LSS_TGR, 0,
                                     (char *)&st_ordbook.l_stp_lss_tgr, 0);
   i_ferr [ 14 ] = Ferror32;

   i_err[15] = Fchg32 ( ptr_fml_Sbuf, FFO_CHANNEL, 0,
                                     (char *)st_ordbook.c_channel, 0);
   i_ferr [ 15 ] = Ferror32;

   i_err[16] = Fchg32 ( ptr_fml_Sbuf, FFO_ALIAS, 0,
                                     (char *)c_alias, 0);
   i_ferr [ 16 ] = Ferror32;

   i_err[17] = Fchg32 ( ptr_fml_Sbuf, FFO_SPL_FLG, 0,
                                     (char *)&c_spl_flg, 0);
   i_ferr [ 17 ] = Ferror32;

   i_err[18] = Fchg32 ( ptr_fml_Sbuf, FFO_SVC_NAME, 0,
                                     (char *)c_srvc_nm, 0);
   i_ferr [ 18 ] = Ferror32;

   i_err[19] = Fchg32 ( ptr_fml_Sbuf, FFO_STATUS_FLG, 0,
                                     (char *)&c_src_flg, 0);            /*** Ver 2.1 ***/
   i_ferr [ 19 ] = Ferror32;

   i_err[20] = Fchg32 ( ptr_fml_Sbuf, FFO_OI_INDCTR, 0, (char *)c_ip_address, 0);                    /*** Ver 2.6 ***/
   i_ferr [ 20 ] = Ferror32;

   /** for(i=0; i < 19; i++) Commented in Ver 2.1 ***/
   for(i=0; i < 21; i++)   /*** Changed from 20 to 21 in Ver 2.6 ***/
   {
     if ( (i_err[ i ] == -1 ) )
     {
       fn_userlog(c_ServiceName,"count :%d:",i);
       fn_errlog( c_ServiceName, "S31270",
                             Fstrerror32(i_ferr[i]),c_err_msg.arr);
			 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
       tpfree ( ( char * ) ptr_fml_Sbuf );
       tpfree ( ( char * ) ptr_fml_Rbuf );
       tpfree ( ( char * ) ptr_fml_Obuf );
       Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
			 Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
       Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
       tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     }
   }

   i_err[0]= Fget32(ptr_fml_Ibuf, FFO_SETTLOR,i_cnt,
                                       (char *)st_ordbook.c_settlor, 0);
   i_ferr [ 0 ] = Ferror32;

   if (( i_err[0] == -1 ) && ( i_ferr[0] != FNOTPRES ))
   {
     fn_errlog( c_ServiceName, "S31275", Fstrerror32(i_ferr[0]),c_err_msg.arr);
	 	 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
     tpfree ( ( char * ) ptr_fml_Sbuf );
     tpfree ( ( char * ) ptr_fml_Rbuf );
     tpfree ( ( char * ) ptr_fml_Obuf );
     Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		 Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
     Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
     Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
     tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
   }
   else if ( i_ferr[0] == FNOTPRES )
   {
     c_settlor_flg = NO;
   }
   else
   {
     c_settlor_flg = YES;
     i_returncode = Fchg32 ( ptr_fml_Sbuf, FFO_SETTLOR, 0,
                                 (char *)st_ordbook.c_settlor, 0);
     if ( i_returncode == -1 )
     {
       fn_errlog( c_ServiceName, "S31280",FMLMSG,c_err_msg.arr);
			 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
       tpfree ( ( char * ) ptr_fml_Sbuf );
       tpfree ( ( char * ) ptr_fml_Rbuf );
       tpfree ( ( char * ) ptr_fml_Obuf );
       Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
			 Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
       Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
       tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     }
   }

    MEMSET(c_call_source);
    strcpy(c_call_source,"PLC_OPTPLUS");
    i_returncode = Fchg32 ( ptr_fml_Sbuf, FFO_ACTION1, 0, (char *)c_call_source, 0);
    if ( i_returncode == -1 )
    {
      fn_errlog( c_ServiceName, "S31285",FMLMSG,c_err_msg.arr);
			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

		/*** Ver 3.7 starts ***/
    i_returncode = Fchg32 ( ptr_fml_Sbuf, FFO_USER_CODE, 0, (char *)c_ven_id.arr, 0);
    if ( i_returncode == -1 )
    {
      fn_errlog( c_ServiceName, "S31290",FMLMSG,c_err_msg.arr);
      fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
		/*** Ver 3.7 ends ***/

    i_returncode = tpcall("SFO_ORD_ROUT", (char *)ptr_fml_Sbuf, 0,
                      (char **)&ptr_fml_Rbuf, &l_recvbuff, 0);

      if (i_returncode == -1)
      {
        if (TPCODE != TPESVCFAIL)
        {
          fn_errlog( c_ServiceName, "S31295",TPMSG,c_err_msg.arr);
					fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
          fn_userlog( c_ServiceName, "TP CODE IS    |%d|",TPCODE);
        }
        else
        {
          i_returncode = Fget32(ptr_fml_Rbuf, FFO_ERR_MSG, 0, c_err_msg.arr, 0);

          if (i_returncode == -1)
          {
            fn_errlog( c_ServiceName, "S31300",FMLMSG,c_err_msg.arr);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
            tpfree ( ( char * ) ptr_fml_Sbuf );
            tpfree ( ( char * ) ptr_fml_Rbuf );
            tpfree ( ( char * ) ptr_fml_Obuf );
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
            Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
            Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
            Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/ 
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          }
        }
				
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        tpfree ( ( char * ) ptr_fml_Sbuf );
        tpfree ( ( char * ) ptr_fml_Rbuf );
        tpfree ( ( char * ) ptr_fml_Obuf );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

    i_returncode= Fget32(ptr_fml_Rbuf, FFO_ORDR_RFRNC,0,
                                    (char *)st_ordbook.c_ordr_rfrnc, 0);

    if (i_returncode == -1)
    {
      fn_errlog( c_ServiceName, "S31305",FMLMSG,c_err_msg.arr);
			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

    i_returncode= Fget32(ptr_fml_Rbuf, FFO_PIPE_ID,0,
                                    (char *)c_pipe_id, 0);

    if (i_returncode == -1)
		{
      fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );			/***	Added In VQC	***/
      tpfree ( ( char * ) ptr_fml_Sbuf ); /*** Added in Ver VQC ***/
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

		/*** Commented in Ver 1.2 ** Starts ***

    i_returncode = Fadd32 ( ptr_fml_Obuf, FFO_ORDR_RFRNC,
                                    ( char *)st_ordbook.c_ordr_rfrnc, 0 );
    if( i_returncode == -1)
    {
      fn_errlog( c_ServiceName, "S31310",FMLMSG,c_err_msg.arr);
			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

     *** Commented in Ver 1.2 ** Ends ***/

    /*** Ver 1.2 *** Starts ***/

    i_returncode = Fconcat32(ptr_fml_Obuf,ptr_fml_Rbuf);

    if( i_returncode == -1)
    {
      fn_errlog( c_ServiceName, "S31315",FMLMSG,c_err_msg.arr);
      fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

     /*** Ver 1.2 *** Ends ***/

    i_err[0] = 0 ;
    i_ferr[0] = 0 ;

    if(i_cnt == 0)
    {
      strcpy(c_frsh_ordr_rfrnc,st_ordbook.c_ordr_rfrnc);
    }
    else if ( i_cnt == 1)
    {
      strcpy(c_cvr_ordr_rfrnc,st_ordbook.c_ordr_rfrnc);
    }
    if ( Finit32 ( ptr_fml_Rbuf,
                  ( FLDLEN32 ) Fsizeof32 ( ptr_fml_Rbuf ) ) == -1 )
    {
       fn_errlog( c_ServiceName, "S31320",FMLMSG,c_err_msg.arr);
			 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
       tpfree ( ( char * ) ptr_fml_Sbuf );
       tpfree ( ( char * ) ptr_fml_Rbuf );
       tpfree ( ( char * ) ptr_fml_Obuf );
       Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
			 Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
       Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
       tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

    if(DEBUG_MSG_LVL_3) 	/*** Ver 2.5 ***/
    {
      fn_userlog(c_ServiceName,"Printing Values for Instance:%d:",i_cnt);
    }

   } /***end of for loop ***/

    /** Ver 1.8 starts from here **/
    EXEC SQL
       UPDATE  FOD_FO_ORDR_DTLS
          SET  FOD_SLTP_ORDR_RFRNC = :c_cvr_ordr_rfrnc,
       /***    FOD_FC_FLAG = 'F'   *** Commented in Ver 2.7 ***/
               FOD_FC_FLAG = :c_fod_fresh_flg  /*** Ver 2.7 bind variable used instead of hard coded values ***/ 
        WHERE  FOD_ORDR_RFRNC = :c_frsh_ordr_rfrnc;

      if( SQLCODE != 0 )
      {
        fn_errlog( c_ServiceName, "S31325", SQLMSG,c_err_msg.arr  );
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        tpfree ( ( char * ) ptr_fml_Sbuf );     /*** Added in VQC ***/
        tpfree ( ( char * ) ptr_fml_Rbuf );     /*** Added in VQC ***/
        tpfree ( ( char * ) ptr_fml_Obuf );     /*** Added in VQC ***/
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

      EXEC SQL
        UPDATE  FOD_FO_ORDR_DTLS
           SET  FOD_SLTP_ORDR_RFRNC = :c_frsh_ordr_rfrnc,
        /***    FOD_FC_FLAG = 'C',
                FOD_AMT_BLCKD = 0 ,  
                FOD_LSS_AMT_BLCKD = 0   *** Commented in Ver 2.7 ***/
                FOD_FC_FLAG = :c_fod_cvr_flg ,      /*** Ver 2.7 bind variable used instead of hard coded value ***/ 
                FOD_AMT_BLCKD = :l_fod_zero_val ,   /*** Ver 2.7 bind variable used instead of hard coded value ***/
                FOD_LSS_AMT_BLCKD = :l_fod_zero_val, /*** Ver 2.7 bind variable used instead of hard coded value ***/
								FOD_SLTP_MRGN     = :l_fod_zero_val,        /*** Ver 3.4 ***/
                FOD_SLTP_PL       = :l_fod_zero_val,        /*** Ver 3.4 ***/
                FOD_SLTP_SEBI_MRGN= :l_fod_zero_val,        /*** Ver 3.4 ***/
                FOD_OPLUS_PREMIUM= :l_fod_zero_val,        /*** Ver 3.4 ***/
                FOD_SPAN_MRGN= :l_fod_zero_val,        /*** Ver 3.4 ***/
                FOD_EXPR_MRGN= :l_fod_zero_val         /*** Ver 3.4 ***/								
         WHERE  FOD_ORDR_RFRNC = :c_cvr_ordr_rfrnc;

      if( SQLCODE != 0 )
      {
        fn_errlog( c_ServiceName, "S31330", SQLMSG,c_err_msg.arr  );
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        tpfree ( ( char * ) ptr_fml_Sbuf );     /*** Added in VQC ***/
        tpfree ( ( char * ) ptr_fml_Rbuf );     /*** Added in VQC ***/
        tpfree ( ( char * ) ptr_fml_Obuf );     /*** Added in VQC ***/
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

    /**Call function for margin calcluation **/
		
	  if(DEBUG_MSG_LVL_3)			/** if() added in Ver 1.8 **/
  	{	
      fn_userlog( c_ServiceName, "c_frsh_ordr_rfrnc= :%s:",c_frsh_ordr_rfrnc);
      fn_userlog( c_ServiceName, "l_lmt_rt= :%ld:",l_lmt_rt);
      fn_userlog( c_ServiceName, "st_ordbook.l_ord_lmt_rt= :%ld:",st_ordbook.l_ord_lmt_rt);
      fn_userlog( c_ServiceName, "d_mrgn_amt= :%lf:",d_mrgn_amt);
      fn_userlog( c_ServiceName, "d_lss_amt= :%lf:",d_lss_amt);
		}

     i_returncode = fn_cal_mrgn_sltp_op ( c_ServiceName,
              														c_frsh_ordr_rfrnc,
              														l_lmt_rt,
              														st_ordbook.l_ord_lmt_rt,
              														&d_mrgn_amt,
              														&d_lss_amt,
			                                    c_ref_rmrks,  /*** Ver 3.4 ***/
																					&d_comp1_mrgn,/*** Ver 3.4 ***/
																					&d_comp1_pl,  /*** Ver 3.4 ***/
																					&d_xchng_amt, /*** Ver 3.4 ***/
																					&d_prem_amt,	/*** Ver 3.4 ***/
																					&d_spn_mrgn,	/*** Ver 3.4 ***/
																					&d_expr_mrgn,	/*** Ver 3.4 ***/
              														'U',
              														c_err_msg.arr
            														); 
    if ( i_returncode == -1 )
    {
      fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
      fn_errlog( c_ServiceName, "S31335", LIBMSG, c_err_msg.arr );
      tpfree ( ( char * ) ptr_fml_Sbuf );     /*** Added in VQC ***/
      tpfree ( ( char * ) ptr_fml_Rbuf );     /*** Added in VQC ***/
      tpfree ( ( char * ) ptr_fml_Obuf );     /*** Added in VQC ***/
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
		else if( i_returncode == -2 )
    {
      fn_userlog(c_ServiceName,"Entered SLTP is OutOff Range");
      fn_errlog( c_ServiceName, "S31340","Please Enter SLTP in Proper Range",c_err_msg.arr);
      tpfree ( ( char * ) ptr_fml_Sbuf );     /*** Added in VQC ***/
      tpfree ( ( char * ) ptr_fml_Rbuf );     /*** Added in VQC ***/
      tpfree ( ( char * ) ptr_fml_Obuf );     /*** Added in VQC ***/ 
			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
    d_mrgn_amt = (long long)d_mrgn_amt;
    d_lss_amt  = (long long)d_lss_amt;

    if(DEBUG_MSG_LVL_1) 	/*** Ver 2.5 ***/
    {
      fn_userlog( c_ServiceName, "d_lss_amt = :%lf:",d_lss_amt);
      fn_userlog( c_ServiceName, "d_mrgn_amt :%lf:",d_mrgn_amt);
    }
      /** Ver 1.8 Ends here **/
  sprintf(ptr_st_pstn_actn.c_ref_rmrks,"%s-%ld",c_frsh_ordr_rfrnc,st_ordbook.l_mdfctn_cntr);

  strcpy( c_narration_id , ON_ORDER_PLACEMENT);
  c_dr_without_lmt_flg = DEBIT_WHEN_LIMIT;
  d_required_amt = 0;
  c_insuff_flg = 'N' ;

  if( d_mrgn_amt != 0 )
  {
    if( d_mrgn_amt !=0 )
    i_returncode = fn_upd_limits( c_ServiceName,
                                    &ptr_st_pstn_actn,
                                    &st_err_msg,
                                    c_narration_id,
                                    c_dr_without_lmt_flg,
                                    d_mrgn_amt * -1,
                                    &d_balance_amt);

    if ( i_returncode != 0 )
    {
      switch ( i_returncode )
      {
        case  INSUFFICIENT_LIMITS :
          fn_userlog(c_ServiceName," Inside INSUFFICIENT_LIMITS.");
          fn_errlog( c_ServiceName, "S31345", LIBMSG, c_err_msg.arr  );
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
          strcpy(c_err_msg.arr,st_err_msg.c_err_msg);
          tpfree ( ( char * ) ptr_fml_Obuf );

          c_insuff_flg = 'Y';
          strcpy(c_err_msg.arr,strtok(c_err_msg.arr,"|"));
          d_required_amt = atof(strtok(NULL,"|"));

          d_required_amt = d_required_amt + (d_lss_amt / 100 );

          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
          Fadd32( ptr_fml_Ibuf,FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);

          strcpy(c_err_msg.arr,strtok(c_err_msg.arr,"<"));

          sprintf(c_err_msg.arr,"%s < %0.2lf >",c_err_msg.arr,d_required_amt);

          if(DEBUG_MSG_LVL_3)
          {
           fn_userlog(c_ServiceName,"d_lss_amt :%lf:",d_lss_amt);
           fn_userlog(c_ServiceName,"d_required_amt :%lf:",d_required_amt);
          }

          /*** Ver 1.1 Starts ***/

          c_actn_flg = 'P';

          strcpy ( st_ordbook.c_cln_mtch_accnt,st_usr_prfl.c_cln_mtch_accnt);

          i_trnsctn = fn_begintran( c_ServiceName, c_err_msg.arr );
          if ( i_trnsctn == -1 )
          {
            fn_errlog( c_ServiceName, "S31350",LIBMSG,c_err_msg.arr);
            tpfree ( ( char * ) ptr_fml_Sbuf );     /*** Added in VQC ***/
            tpfree ( ( char * ) ptr_fml_Rbuf );     /*** Added in VQC ***/
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
            Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&i_actn_id, 0 );
            Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
            Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          }


          i_returncode =  fn_ins_ffl_log_tbl  (  c_ServiceName,
                                                 st_ordbook,
                                                 c_err_msg.arr,
                                                 d_required_amt,
                                                 c_actn_flg
                                                );
          if ( i_returncode != 0 )
          {
            fn_errlog( c_ServiceName, "S31355", LIBMSG, c_err_msg.arr  );
            fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
            tpfree ( ( char * ) ptr_fml_Sbuf );     /*** Added in VQC ***/
            tpfree ( ( char * ) ptr_fml_Rbuf );     /*** Added in VQC ***/
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
            Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID , (char *)&i_actn_id , 0 );
            Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
            Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );

          }

          if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg.arr ) == -1 )
          {
            fn_errlog( c_ServiceName, "S31360",LIBMSG,c_err_msg.arr);
            tpfree ( ( char * ) ptr_fml_Sbuf );     /*** Added in VQC ***/
            tpfree ( ( char * ) ptr_fml_Rbuf );     /*** Added in VQC ***/
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
            Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&i_actn_id, 0 );
            Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
            Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          }

          /*** Ver 1.1  Ends   ***/

      
          tpfree ( ( char * ) ptr_fml_Sbuf );     /*** Added in VQC ***/
          tpfree ( ( char * ) ptr_fml_Rbuf );     /*** Added in VQC ***/
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );

        default:
          fn_errlog( c_ServiceName, "S31365", LIBMSG, c_err_msg.arr  );
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
          tpfree ( ( char * ) ptr_fml_Sbuf );     /*** Added in VQC ***/
          tpfree ( ( char * ) ptr_fml_Rbuf );     /*** Added in VQC ***/
          tpfree ( ( char * ) ptr_fml_Obuf );
          strcpy(c_err_msg.arr,st_err_msg.c_err_msg);
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
    }
  }

  strcpy( c_narration_id , ON_ORDER_PLACEMENT);
  c_dr_without_lmt_flg = DEBIT_WHEN_LIMIT;

  if( d_lss_amt != 0)
  {

		 /*** Ver 3.4 started ***/
			MEMSET(c_tmp_rmrks);
			strcpy ( c_tmp_rmrks, ptr_st_pstn_actn.c_ref_rmrks );
			/** Ver 3.8 Starts added for debug **/
 			if(DEBUG_MSG_LVL_0)
			{
				fn_userlog( c_ServiceName, "Length of remarks before is :%d: Temp Remarks is :%d: Ref Remarks is :%d:",strlen(ptr_st_pstn_actn.c_ref_rmrks),strlen(c_tmp_rmrks),strlen(c_ref_rmrks));
			}
			/** Ver 3.8 Ends added for debug**/
			sprintf(ptr_st_pstn_actn.c_ref_rmrks,"%s%s",c_ref_rmrks,c_tmp_rmrks);
			/*** Ver 3.4 ends ***/
			/** Ver 3.8 Starts added for debug**/
			if(DEBUG_MSG_LVL_0)
			{
				fn_userlog( c_ServiceName, "Length of remarks after is :%d:",strlen(ptr_st_pstn_actn.c_ref_rmrks));
			}
			/** Ver 3.8 Ends added for debug**/

      i_returncode = fn_upd_limits( c_ServiceName,
                                      &ptr_st_pstn_actn,
                                      &st_err_msg,
                                      c_narration_id,
                                      c_dr_without_lmt_flg,
                                      d_lss_amt * -1,
                                      &d_balance_amt);

      if ( i_returncode != 0 )
       {
          switch ( i_returncode )
          {
            case  INSUFFICIENT_LIMITS :
              fn_userlog(c_ServiceName," Inside INSUFFICIENT_LIMITS.");
              fn_errlog( c_ServiceName, "S31370", LIBMSG, c_err_msg.arr  );
              fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
              strcpy(c_err_msg.arr,st_err_msg.c_err_msg);
              tpfree ( ( char * ) ptr_fml_Obuf );

              c_insuff_flg = 'Y';
              strcpy(c_err_msg.arr,strtok(c_err_msg.arr,"|"));
              d_required_amt = atof(strtok(NULL,"|"));

              if(DEBUG_MSG_LVL_5)
              {
               fn_userlog(c_ServiceName,"d_required_amt :%lf:",d_required_amt);
              }

              Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
              Fadd32( ptr_fml_Ibuf,FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);

              /*** Ver 1.1 Starts ***/

              c_actn_flg = 'P';

              strcpy ( st_ordbook.c_cln_mtch_accnt,st_usr_prfl.c_cln_mtch_accnt);   /** Ver 1.4 **/

              i_trnsctn = fn_begintran( c_ServiceName, c_err_msg.arr );
              if ( i_trnsctn == -1 )
              {
                fn_errlog( c_ServiceName, "S31375",LIBMSG,c_err_msg.arr);
                tpfree ( ( char * ) ptr_fml_Sbuf );     /*** Added in VQC ***/
                tpfree ( ( char * ) ptr_fml_Rbuf );     /*** Added in VQC ***/
                Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
                Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&i_actn_id, 0 );
                Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
                Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
                tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
              }

              i_returncode =  fn_ins_ffl_log_tbl  (  c_ServiceName,
                                                     st_ordbook,
                                                     c_err_msg.arr,
                                                     d_required_amt,
                                                     c_actn_flg
                                                  );
              if ( i_returncode != 0 )
              {
                fn_errlog( c_ServiceName, "S31380", LIBMSG, c_err_msg.arr  );
                fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
                tpfree ( ( char * ) ptr_fml_Sbuf );     /*** Added in VQC ***/
                tpfree ( ( char * ) ptr_fml_Rbuf );     /*** Added in VQC ***/
                Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
                Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID , (char *)&i_actn_id , 0 );
                Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
                Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
                tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );

              }

              if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg.arr ) == -1 )
              {
                fn_errlog( c_ServiceName, "S31385",LIBMSG,c_err_msg.arr);
                tpfree ( ( char * ) ptr_fml_Sbuf );     /*** Added in VQC ***/
                tpfree ( ( char * ) ptr_fml_Rbuf );     /*** Added in VQC ***/
                Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
                Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&i_actn_id, 0 );
                Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
                Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
                tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
              }

              /*** Ver 1.1  Ends   ***/

              tpfree ( ( char * ) ptr_fml_Sbuf );     /*** Added in VQC ***/
              tpfree ( ( char * ) ptr_fml_Rbuf );     /*** Added in VQC ***/
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
              Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );

           default:
              fn_errlog( c_ServiceName, "S31390", LIBMSG, c_err_msg.arr  );
              fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
              tpfree ( ( char * ) ptr_fml_Obuf );
              tpfree ( ( char * ) ptr_fml_Sbuf );     /*** Added in VQC ***/
              tpfree ( ( char * ) ptr_fml_Rbuf );     /*** Added in VQC ***/
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
              Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
              Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
              Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          }
      }
			strcpy ( ptr_st_pstn_actn.c_ref_rmrks, c_tmp_rmrks);    /**** Ver 3.4 ***/
      MEMSET(c_tmp_rmrks);																		/**** Ver 3.4 ***/
  }

  EXEC SQL
       UPDATE FOD_FO_ORDR_DTLS
       SET    FOD_LMT_RT = :d_avg_prc,
            /***  FOD_SLTP_ORDR_RFRNC = :c_cvr_ordr_rfrnc, Commented in Ver 1.8 ***/
              FOD_AMT_BLCKD = :d_mrgn_amt,
              FOD_LSS_AMT_BLCKD = :d_lss_amt,
              FOD_SLTP_MRGN = :d_comp1_mrgn,/*** Ver 3.4 ***/
              FOD_SLTP_PL   = :d_comp1_pl,  /*** Ver 3.4 ***/
              FOD_SLTP_SEBI_MRGN = :d_xchng_amt, /*** Ver 3.4 ***/
							FOD_OPLUS_PREMIUM  = :d_prem_amt,	 /*** Ver 3.4 ***/
							FOD_SPAN_MRGN = :d_spn_mrgn,			 /*** Ver 3.4 ***/
							FOD_EXPR_MRGN = :d_expr_mrgn			 /*** Ver 3.4 ***/
            /***  FOD_FC_FLAG = 'F' Commented in Ver 1.8 ***/
       WHERE  FOD_ORDR_RFRNC = :c_frsh_ordr_rfrnc;


  if( SQLCODE != 0 )
  {
    fn_errlog( c_ServiceName, "S31395", SQLMSG,c_err_msg.arr  );
    fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    tpfree ( ( char * ) ptr_fml_Obuf );     /*** Added in VQC ***/
    tpfree ( ( char * ) ptr_fml_Sbuf );     /*** Added in VQC ***/
    tpfree ( ( char * ) ptr_fml_Rbuf );     /*** Added in VQC ***/
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  EXEC SQL
   UPDATE FXB_FO_XCHNG_BOOK
   SET    FXB_LMT_RT = :d_avg_prc
   WHERE  FXB_ORDR_RFRNC  = :c_frsh_ordr_rfrnc;

  if( SQLCODE != 0 )
  {
    fn_errlog( c_ServiceName, "S31400", SQLMSG,c_err_msg.arr  );
    fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    tpfree ( ( char * ) ptr_fml_Obuf );     /*** Added in VQC ***/
    tpfree ( ( char * ) ptr_fml_Sbuf );     /*** Added in VQC ***/
    tpfree ( ( char * ) ptr_fml_Rbuf );     /*** Added in VQC ***/
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  /*** Commented in VQC ******
  EXEC SQL
   UPDATE FOD_FO_ORDR_DTLS
 **  SET   FOD_SLTP_ORDR_RFRNC = :c_frsh_ordr_rfrnc, Commented in Ver 1.8 **
      SET FOD_AMT_BLCKD = 0 ,
          FOD_LSS_AMT_BLCKD = 0
       **  FOD_FC_FLAG = 'C' Commented in Ver 1.8 **
   WHERE  FOD_ORDR_RFRNC = :c_cvr_ordr_rfrnc;

  if( SQLCODE != 0 )
  {
    fn_errlog( c_ServiceName, "S31405", SQLMSG,c_err_msg.arr  );
    fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); *** Ver 1.3 ***
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); *** Ver 1.3 ***
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
  **********/
 }

/*** Ver 1.8 Starts from Here ***/
    if(st_ordbook.c_req_typ == 'M')
    {
      c_usr_flg = 'W';

      /** commented in ver 3.1
      i_err[0]= Fget32(ptr_fml_Ibuf, FFO_ORDR_RFRNC,0,
                                     (char *)&c_frsh_ordr_rfrnc, 0);
      i_ferr [ 0 ] = Ferror32;

      i_err[1]= Fget32(ptr_fml_Ibuf, FFO_ORDR_RFRNC,1,
                                     (char *)&c_cvr_ordr_rfrnc, 0);
      i_ferr [ 1 ] = Ferror32;
      ** comment ends ***/

  		if(DEBUG_MSG_LVL_1)			/** if() added in Ver 1.8 ***/ 	/*** Ver 2.5 ***/
  		{
      	fn_userlog( c_ServiceName, "c_frsh_ordr_rfrnc :%s:",c_frsh_ordr_rfrnc);
      	fn_userlog( c_ServiceName, "c_cvr_ordr_rfrnc:%s:",c_cvr_ordr_rfrnc);
			}
	
      EXEC SQL
           SELECT FOD_ORDR_STTS
             INTO :c_frsh_ordr_stts
             FROM FOD_FO_ORDR_DTLS
            WHERE FOD_ORDR_RFRNC=:c_frsh_ordr_rfrnc;

      if( SQLCODE != 0 )
      {
        fn_errlog( c_ServiceName, "S31410", SQLMSG,c_err_msg.arr  );
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        tpfree ( ( char * ) ptr_fml_Obuf );     /*** Added in VQC ***/
        tpfree ( ( char * ) ptr_fml_Sbuf );     /*** Added in VQC ***/
        tpfree ( ( char * ) ptr_fml_Rbuf );     /*** Added in VQC ***/
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

      EXEC SQL
           SELECT FOD_ORDR_STTS
             INTO :c_cvr_ordr_stts
             FROM FOD_FO_ORDR_DTLS
            WHERE FOD_ORDR_RFRNC=:c_cvr_ordr_rfrnc;

      if( SQLCODE != 0 )
      {
        fn_errlog( c_ServiceName, "S31415", SQLMSG,c_err_msg.arr  );
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        tpfree ( ( char * ) ptr_fml_Obuf );     /*** Added in VQC ***/
        tpfree ( ( char * ) ptr_fml_Sbuf );     /*** Added in VQC ***/
        tpfree ( ( char * ) ptr_fml_Rbuf );     /*** Added in VQC ***/
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

      if(c_frsh_ordr_stts == 'O' && c_cvr_ordr_stts == 'O')
      {
			
        /**** Commented in VQC ********
	
				EXEC SQL
					SELECT FUM_CTGRY_INDSTK 
					INTO	 :st_ordbook.c_ctgry_indstk
					FROM	 FUM_FO_UNDRLYNG_MSTR
					WHERE	 FUM_UNDRLYNG = :st_ordbook.c_undrlyng
					AND    FUM_XCHNG_CD= :st_ordbook.c_xchng_cd
					AND    FUM_PRDCT_TYP = 'O';
				
				if ( SQLCODE  !=  0 )
				{
					fn_errlog( c_ServiceName, "S31420",SQLMSG,c_err_msg.arr);
					fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
					Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
					Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); 
					Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); 
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
		
       ************* in VQC ***********/
	
				EXEC SQL
						SELECT NVL(FUM_QT_TRDNG_FLG,'Q'),
									 NVL(FUM_SLTP_FP_TRDNG_FLG,'Q')
						INTO   :c_qt_trd_flg,
									 :c_sltp_trd_flg
						FROM   FUM_FO_UNDRLYNG_MSTR
						WHERE  FUM_XCHNG_CD= :st_ordbook.c_xchng_cd
				/***		AND    FUM_PRDCT_TYP = 'O'  Commented in Ver 2.7 ***/
            AND    FUM_PRDCT_TYP = :c_fum_opt_prd_typ  /*** Ver 2.7 bind variable used instead of hard coded value ***/ 
						AND    FUM_UNDRLYNG = :st_ordbook.c_undrlyng;
      /***	AND    FUM_CTGRY_INDSTK = :st_ordbook.c_ctgry_indstk;    ** Commentd in VQC ***/

				if ( SQLCODE  !=  0 && SQLCODE != NO_DATA_FOUND)
				{
					fn_errlog( c_ServiceName, "S31425",SQLMSG,c_err_msg.arr);
					fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
          tpfree ( ( char * ) ptr_fml_Obuf );     /*** Added in VQC ***/
          tpfree ( ( char * ) ptr_fml_Sbuf );     /*** Added in VQC ***/
          tpfree ( ( char * ) ptr_fml_Rbuf );     /*** Added in VQC ***/
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
					Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
					Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); 
					Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); 
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}

				if(DEBUG_MSG_LVL_3) /*** Ver 2.5 ***/
				{
					fn_userlog( c_ServiceName, "c_qt_trd_flg....111111111:%c:",c_qt_trd_flg);
					fn_userlog( c_ServiceName, "c_sltp_trd_flg....111111111:%c:",c_sltp_trd_flg);
				}

  		if( c_qt_trd_flg != 'T' || c_sltp_trd_flg != 'T' || SQLCODE == NO_DATA_FOUND )
  		{
    	  fn_errlog( c_ServiceName, "S31430","You are only allowed to cancel this OptionPLUS order. Since this contract is currently disabled for trading so placement/modification of orders is not allowed in this contract.",c_err_msg.arr);
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
          strcpy(c_err_msg.arr,"You are only allowed to cancel this OptionPLUS order. Since this contract is currently disabled for trading so placement/modification of orders is not allowed in this contract.");
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
					tpfree ( ( char * ) ptr_fml_Sbuf );
          tpfree ( ( char * ) ptr_fml_Rbuf );
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  		}

      /**** Check whether contract is enabled ***/
  		c_qt_trd_flg = '\0';
  		c_sltp_trd_flg = '\0';

			/***	Commented In Ver 1.7

  		EXEC SQL
    		SELECT nvl(FCM_QT_TRDNG_FLG,'Q'),
        		   nvl(FCM_SLTP_FP_QT_TRDNG_FLG,'Q')
      	INTO   :c_qt_trd_flg,
        	     :c_sltp_trd_flg
      	FROM   FCM_FO_CNTRCT_MSTR
      	WHERE  FCM_XCHNG_CD = :st_ordbook.c_xchng_cd
      	AND    FCM_PRDCT_TYP = 'O'
      	AND    FCM_INDSTK = :st_ordbook.c_ctgry_indstk
      	AND    FCM_UNDRLYNG = :st_ordbook.c_undrlyng
      	AND    FCM_EXPRY_DT = :st_ordbook.c_expry_dt
      	AND    FCM_EXER_TYP = :st_ordbook.c_exrc_typ
      	AND    FCM_OPT_TYP  = :st_ordbook.c_opt_typ
      	AND    FCM_STRK_PRC = :st_ordbook.l_strike_prc;

			*********************************************************/
			
			EXEC SQL																						/***  Added In Ver 1.7  ***/
				SELECT	NVL(FTQ_QT_TRDNG_FLG,'Q'),
								NVL(FTQ_SLTP_FP_QT_TRDNG_FLG,'Q')
        INTO   :c_qt_trd_flg,
               :c_sltp_trd_flg
        FROM   FTQ_FO_TRD_QT
        WHERE  FTQ_XCHNG_CD = :st_ordbook.c_xchng_cd
      /***  AND    FTQ_PRDCT_TYP = 'O'  Commented in Ver 2.7 ***/
        AND    FTQ_PRDCT_TYP = :c_fum_opt_prd_typ  /*** Ver 2.7 bind variable used instead of host variable ***/
      /***  AND    FTQ_INDSTK = :st_ordbook.c_ctgry_indstk     *** Commented in VQC ***/
        AND    FTQ_UNDRLYNG = :st_ordbook.c_undrlyng
        AND    FTQ_EXPRY_DT = :st_ordbook.c_expry_dt
        AND    FTQ_EXER_TYP = :st_ordbook.c_exrc_typ
        AND    FTQ_OPT_TYP  = :st_ordbook.c_opt_typ
        AND    FTQ_STRK_PRC = :st_ordbook.l_strike_prc;	

  		if ( SQLCODE  !=  0 && SQLCODE != NO_DATA_FOUND)
  		{
     		fn_errlog( c_ServiceName, "S31435",SQLMSG,c_err_msg.arr);
		 		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        tpfree ( ( char * ) ptr_fml_Obuf );     /*** Added in VQC ***/
        tpfree ( ( char * ) ptr_fml_Sbuf );     /*** Added in VQC ***/
        tpfree ( ( char * ) ptr_fml_Rbuf );     /*** Added in VQC ***/
     		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		 		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
     		Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
     		Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
     		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  		}

        if( c_qt_trd_flg != 'T' || c_sltp_trd_flg != 'T' ||  SQLCODE == NO_DATA_FOUND )
        {
          fn_errlog( c_ServiceName, "S31440","You are only allowed to cancel this OptionPLUS order. Since this contract is currently disabled for trading so placement/modification of orders is not allowed in this contract.",c_err_msg.arr);
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
          strcpy(c_err_msg.arr,"You are only allowed to cancel this OptionPLUS order. Since this contract is currently disabled for trading so placement/modification of orders is not allowed in this contract.");
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
					tpfree ( ( char * ) ptr_fml_Sbuf );
          tpfree ( ( char * ) ptr_fml_Rbuf );
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
			}
      for(i=0; i < 2; i++)
      {
        if ( (i_err[ i ] == -1 ) )
        {
          fn_errlog( c_ServiceName, "S31445",
          Fstrerror32(i_ferr[i]),c_err_msg.arr);
          tpfree ( ( char * ) ptr_fml_Sbuf );
          tpfree ( ( char * ) ptr_fml_Rbuf );
          tpfree ( ( char * ) ptr_fml_Obuf );
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      }
    	/*** Start of 'for' loop for modification ***/
      for( i_cnt=0; i_cnt < 2; i_cnt++)
      {
        if( i_cnt == 0 )
        {
          st_ordbook.c_slm_flg = st_ordbook.c_mrkt_typ;
          st_ordbook.l_ord_lmt_rt = l_lmt_rt;
          st_first_ordbk.l_ord_tot_qty = st_ordbook.l_ord_tot_qty;
          strcpy(st_first_ordbk.c_xchng_cd ,st_ordbook.c_xchng_cd);
          st_first_ordbk.c_prd_typ = st_ordbook.c_prd_typ;
          strcpy(st_first_ordbk.c_undrlyng ,st_ordbook.c_undrlyng);
          strcpy(st_first_ordbk.c_expry_dt ,st_ordbook.c_expry_dt);
          st_first_ordbk.c_exrc_typ = st_ordbook.c_exrc_typ;
          st_first_ordbk.c_opt_typ = st_ordbook.c_opt_typ;
          st_first_ordbk.l_strike_prc = st_ordbook.l_strike_prc;
          st_ordbook.l_stp_lss_tgr = 0;
        }
        else
        {
          st_ordbook.c_slm_flg='S';
          st_ordbook.c_ordr_flw =(st_ordbook.c_ordr_flw == 'B'?'S':(st_ordbook.c_ordr_flw == 'S'?'B':'\0')); /* VER TOL : TUX on LINUX -- Changed empty character with \0 (Ravindra) */
          st_ordbook.l_ord_lmt_rt = l_temp_ord_lmt_rt;
          st_ordbook.l_stp_lss_tgr =  l_temp_stp_lss_tgr;

				  if(DEBUG_MSG_LVL_1) /*** Ver 2.5 ***/
					{
						fn_userlog( c_ServiceName, "Cover Order Flow :%c:",st_ordbook.c_ordr_flw);
					}
        }

        if ( (c_spn_allwd_flg == 'Y' && strcmp(st_ordbook.c_xchng_cd,"NFO")==0) ||
             ( c_bse_span_flag == 'Y' && strcmp(st_ordbook.c_xchng_cd,"BFO")==0 ))
        {
          strcpy(c_srvc_nm,"SFO_SPN_MOD_ORD");
        }
        else
        {
          strcpy(c_srvc_nm,"SFO_PLCMOD_OPT");
        }

        i_err[0] = Fchg32 ( ptr_fml_Sbuf, FFO_XCHNG_CD, 0,
                                  (char *)st_ordbook.c_xchng_cd, 0);
        i_ferr [ 0 ] = Ferror32;

        i_err[1] = Fchg32 ( ptr_fml_Sbuf, FFO_USR_ID, 0,
                                 (char *)&st_usr_prfl.c_user_id, 0);
        i_ferr [ 1 ] = Ferror32;

        i_err[2] = Fchg32 ( ptr_fml_Sbuf, FFO_SSSN_ID, 0,
                                 (char *)&st_usr_prfl.l_session_id, 0);
        i_ferr [ 2 ] = Ferror32;

        i_err[3] = Fchg32 ( ptr_fml_Sbuf, FFO_EBA_MTCH_ACT_NO, 0,
                                  (char *)&st_usr_prfl.c_cln_mtch_accnt, 0);
        i_ferr [ 3 ] = Ferror32;

        i_err[4] = Fchg32 ( ptr_fml_Sbuf, FFO_ORD_TOT_QTY, 0,
                                  (char *)&st_ordbook.l_ord_tot_qty, 0);
        i_ferr [ 4 ] = Ferror32;

        i_err[5] = Fchg32 ( ptr_fml_Sbuf, FFO_LMT_RT, 0,
                                  (char *)&st_ordbook.l_ord_lmt_rt, 0);
        i_ferr [ 5 ] = Ferror32;

        i_err[6] = Fchg32 ( ptr_fml_Sbuf, FFO_ORDR_RFRNC, 0,
                                  (char *)&st_ordbook.c_ordr_rfrnc, 0);
        i_ferr [ 6 ] = Ferror32;
        if(i_cnt == 0)
        {
          i_err[7] = Fchg32 ( ptr_fml_Sbuf, FFO_STP_LSS_TGR, 0,
                                    (char *)&st_ordbook.l_stp_lss_tgr, 0);
          i_ferr [ 7 ] = Ferror32;
        }
        else
        {
          i_err[7] = Fchg32 ( ptr_fml_Sbuf, FFO_STP_LSS_TGR, 0,
                                  (char *)&st_ordbook.l_stp_lss_tgr, 0);
          i_ferr [ 7 ] = Ferror32;
        }
        i_err[8] = Fchg32 ( ptr_fml_Sbuf, FFO_ORDR_FLW, 0,
                                  (char *)&st_ordbook.c_ordr_flw, 0);
        i_ferr [ 8 ] = Ferror32;

        i_err[9] = Fchg32 ( ptr_fml_Sbuf, FFO_LMT_MKT_SL_FLG, 0,
                                  (char *)&st_ordbook.c_slm_flg, 0);
        i_ferr [ 9 ] = Ferror32;

        i_err[10] = Fchg32 ( ptr_fml_Sbuf, FFO_ORD_TYP, 0,
                                  (char *)&st_ordbook.c_ord_typ, 0);
        i_ferr [ 10 ] = Ferror32;

        i_err[11] = Fchg32 ( ptr_fml_Sbuf, FFO_DSCLSD_QTY, 0,
                                  (char *)&st_ordbook.l_dsclsd_qty, 0);
        i_ferr [ 11 ] = Ferror32;

        i_err[12] = Fchg32 ( ptr_fml_Sbuf, FFO_PIPE_ID, 0,
                                  (char *)&st_usr_prfl.c_pipe_id, 0);
        i_ferr [ 12 ] = Ferror32;

        i_err[13] = Fchg32 ( ptr_fml_Sbuf, FFO_SVC_NAME, 0,
                                      (char *)c_srvc_nm, 0);
        i_ferr [ 13 ] = Ferror32;
        i_err[14] = Fchg32(ptr_fml_Sbuf, FFO_TRD_PSSWD,0,
                                     (char *)c_temp_psswrd,0);
        i_ferr [ 14 ] = Ferror32;
        if(i_cnt == 0)
        {
          i_err[15] = Fchg32 ( ptr_fml_Sbuf,FFO_ORDR_RFRNC , 0,
                                  (char *)&c_frsh_ordr_rfrnc, 0);
          i_ferr [ 15 ] = Ferror32;
        }
        else
        {
          i_err[15] = Fchg32 ( ptr_fml_Sbuf, FFO_ORDR_RFRNC, 0,
                                  (char *)&c_cvr_ordr_rfrnc, 0);
          i_ferr [ 15 ] = Ferror32;
        }
        
        /*** Commented in Ver 2.8 as data-type of FML used is long and variable data-type is char ***
        i_err[16] = Fchg32 ( ptr_fml_Sbuf,FFO_USR_FLG, 0,
                               (char *)&c_usr_flg, 0);
        ***/
   
        i_err[16] = Fchg32 ( ptr_fml_Sbuf,FFO_CLSR_TYP, 0,
                               (char *)&c_usr_flg, 0);   /*** Ver 2.8 ***/
        i_ferr [ 16 ] = Ferror32;

        i_err[17] = Fchg32 ( ptr_fml_Sbuf, FFO_ALIAS, 0,
                                     (char *)c_alias, 0);
        i_ferr [ 17 ] = Ferror32;

   			i_err[18] = Fchg32 ( ptr_fml_Sbuf, FFO_OI_INDCTR, 0, (char *)c_ip_address, 0);                    /*** Ver 2.6 ***/
   			i_ferr [ 18 ] = Ferror32;

        /** for(i=0; i < 17; i++)   Ver 1.8 ***/
        for(i=0; i < 19; i++)   /*** Changed from 18 to 19 in Ver 2.6 ***/
        {
          if ( (i_err[ i ] == -1 ) )
          {
            fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
            fn_userlog(c_ServiceName,"count :%d:",i);
            fn_errlog( c_ServiceName, "S31450",
            Fstrerror32(i_ferr[i]),c_err_msg.arr);
            tpfree ( ( char * ) ptr_fml_Sbuf );
            tpfree ( ( char * ) ptr_fml_Rbuf );
            tpfree ( ( char * ) ptr_fml_Obuf );
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
            Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
            Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
            Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          }
        }

        i_returncode = tpcall("SFO_ORD_ROUT", (char *)ptr_fml_Sbuf, 0,
                              (char **)&ptr_fml_Rbuf, &l_recvbuff, 0);

        if (i_returncode == -1)
        {
          if (TPCODE != TPESVCFAIL)
          {
            fn_errlog( c_ServiceName, "S31455",TPMSG,c_err_msg.arr);
            fn_userlog( c_ServiceName, "TP CODE IS    |%d|",TPCODE);
          }
          else
          {
            i_returncode = Fget32(ptr_fml_Rbuf, FFO_ERR_MSG, 0, c_err_msg.arr, 0);

            if (i_returncode == -1)
            {
              fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
              fn_errlog( c_ServiceName, "S31460",FMLMSG,c_err_msg.arr);
              tpfree ( ( char * ) ptr_fml_Sbuf );
              tpfree ( ( char * ) ptr_fml_Rbuf );
              tpfree ( ( char * ) ptr_fml_Obuf );
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
              Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
              Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
              Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }

            i_returncode = Fget32(ptr_fml_Rbuf, FFO_BAL_AMT, 0, (char *)&d_required_amt, 0);

            if (i_returncode == -1)
            {
              fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
              fn_errlog( c_ServiceName, "S31465",FMLMSG,c_err_msg.arr);
              tpfree ( ( char * ) ptr_fml_Sbuf );
              tpfree ( ( char * ) ptr_fml_Rbuf );
              tpfree ( ( char * ) ptr_fml_Obuf );
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
              Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
              Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
              Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }

            i_returncode = Fget32(ptr_fml_Rbuf, FFO_MOD_CAN_FLG, 0, &c_insuff_flg, 0);


            if (i_returncode == -1)
            {
              fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
              fn_errlog( c_ServiceName, "S31470",FMLMSG,c_err_msg.arr);
              tpfree ( ( char * ) ptr_fml_Sbuf );
              tpfree ( ( char * ) ptr_fml_Rbuf );
              tpfree ( ( char * ) ptr_fml_Obuf );
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
              Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
              Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
              Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }
          }

        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        tpfree ( ( char * ) ptr_fml_Sbuf );
        tpfree ( ( char * ) ptr_fml_Rbuf );
        tpfree ( ( char * ) ptr_fml_Obuf );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

    }/*** End of for loop ***/
  /********************Ver 3.7 Starts Here  **************************/     
      i_actn_id = 0;

  /********************Ver Successfull message on api **************************/
  strcpy(c_err_msg.arr,"The order has been modified Successfully ");
  Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
  Fadd32( ptr_fml_Obuf, FFO_ACTN_ID, (char *)&i_actn_id, 0 );
  /********************Ver 3.7 Ends Here  **************************/
 
  }

  if(st_ordbook.c_req_typ == 'C')
  {
    c_usr_flg = 'W';

    /*** commented in ver 3.1 **

    i_err[0]= Fget32(ptr_fml_Ibuf, FFO_ORDR_RFRNC,0,
                                  (char *)&c_frsh_ordr_rfrnc, 0);
    i_ferr [ 0 ] = Ferror32;

    i_err[1]= Fget32(ptr_fml_Ibuf, FFO_ORDR_RFRNC,1,
                                  (char *)&c_cvr_ordr_rfrnc, 0);
    i_ferr [ 1 ] = Ferror32;

 		if(DEBUG_MSG_LVL_1)	*** Ver 2.5 ***
 		{
     	fn_userlog( c_ServiceName, "c_frsh_ordr_rfrnc :%s:",c_frsh_ordr_rfrnc);
     	fn_userlog( c_ServiceName, "c_cvr_ordr_rfrnc:%s:",c_cvr_ordr_rfrnc);
		}

    for(i=0; i < 2; i++)
    {
      if ( (i_err[ i ] == -1 ) && i_ferr[15] != FNOTPRES  )
      {
        fn_errlog( c_ServiceName, "S31475",
        Fstrerror32(i_ferr[i]),c_err_msg.arr);
        tpfree ( ( char * ) ptr_fml_Sbuf );
        tpfree ( ( char * ) ptr_fml_Rbuf );
        tpfree ( ( char * ) ptr_fml_Obuf );
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
    }
    *** ver 3.1 ends ***/

  /*** Start of 'for' loop for Cancellation ***/
    for( i_cnt=0; i_cnt < 2; i_cnt++)
    {

      if( i_cnt == 0 )
      {
        strcpy(st_first_ordbk.c_xchng_cd ,st_ordbook.c_xchng_cd);
      }
      else
      {
        st_ordbook.c_slm_flg='S';
        st_ordbook.c_ordr_flw =(st_ordbook.c_ordr_flw == 'B'?'S':(st_ordbook.c_ordr_flw == 'S'?'B':'\0')); /* VER TOL : TUX on LINUX-- Changed empty character with \0 (Ravindra) */
        st_ordbook.l_ord_lmt_rt = l_temp_ord_lmt_rt;
        st_ordbook.l_stp_lss_tgr =  l_temp_stp_lss_tgr;

			  if(DEBUG_MSG_LVL_3) /*** Ver 2.5 ***/
				{
					fn_userlog( c_ServiceName, "Cover Order Flow :%c:",st_ordbook.c_ordr_flw);
				}
      }

      if ( (c_spn_allwd_flg == 'Y' && strcmp(st_ordbook.c_xchng_cd,"NFO")==0) ||
           ( c_bse_span_flag == 'Y' && strcmp(st_ordbook.c_xchng_cd,"BFO")==0 ))
      {
        strcpy(c_srvc_nm,"SFO_SPN_CANCEL");
      }
      else
      {
        strcpy(c_srvc_nm,"SFO_CANCEL_OPT");
      }

      i_err[0] = Fchg32 ( ptr_fml_Sbuf, FFO_XCHNG_CD, 0,
                             (char *)st_ordbook.c_xchng_cd, 0);
      i_ferr [ 0 ] = Ferror32;

      i_err[1] = Fchg32 ( ptr_fml_Sbuf, FFO_USR_ID, 0,
                             (char *)&st_usr_prfl.c_user_id, 0);
      i_ferr [ 1 ] = Ferror32;

      i_err[2] = Fchg32 ( ptr_fml_Sbuf, FFO_SSSN_ID, 0,
                             (char *)&st_usr_prfl.l_session_id, 0);
      i_ferr [ 2 ] = Ferror32;

      i_err[3] = Fchg32 ( ptr_fml_Sbuf, FFO_EBA_MTCH_ACT_NO, 0,
                              (char *)&st_usr_prfl.c_cln_mtch_accnt, 0);
      i_ferr [ 3 ] = Ferror32;

      i_err[4] = Fchg32 ( ptr_fml_Sbuf, FFO_PIPE_ID, 0,
                              (char *)&st_usr_prfl.c_pipe_id, 0);
      i_ferr [ 4 ] = Ferror32;
      i_err[5] = Fchg32 ( ptr_fml_Sbuf, FFO_SVC_NAME, 0,
                              (char *)c_srvc_nm, 0);
    	i_ferr [ 5 ] = Ferror32;

      if(i_cnt == 0)
      {
        i_err[6] = Fchg32 ( ptr_fml_Sbuf,FFO_ORDR_RFRNC , 0,
                              (char *)&c_frsh_ordr_rfrnc, 0);
        i_ferr [ 6 ] = Ferror32;
      }
      else
      {
        i_err[6] = Fchg32 ( ptr_fml_Sbuf, FFO_ORDR_RFRNC, 0,
                              (char *)&c_cvr_ordr_rfrnc, 0);
        i_ferr [ 6 ] = Ferror32;
      }

      /*** Commented in Ver 2.8 as data-type of FML used is long and variable data-type is char ***
      i_err[7] = Fchg32 ( ptr_fml_Sbuf,FFO_USR_FLG, 0,
                            (char *)&c_usr_flg, 0);
      ***/
  
      i_err[7] = Fchg32 ( ptr_fml_Sbuf,FFO_CLSR_TYP, 0,
                            (char *)&c_usr_flg, 0);   /*** Ver 2.8 ***/
      i_ferr [ 7 ] = Ferror32;

      i_err[8] = Fchg32 ( ptr_fml_Sbuf, FFO_ALIAS, 0,
                                     (char *)c_alias, 0);
      i_ferr [ 8 ] = Ferror32;

   		i_err[9] = Fchg32 ( ptr_fml_Sbuf, FFO_OI_INDCTR, 0, (char *)c_ip_address, 0);                    /*** Ver 2.6 ***/
   		i_ferr [ 9 ] = Ferror32;
	
      /** for(i=0; i < 8; i++)      *** Ver 1.8 ***/
      for(i=0; i < 10; i++)     /*** Changed from 9 to 10 in Ver 2.6 ***/
      {
        if ( (i_err[ i ] == -1 ) )
        {
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
          fn_userlog(c_ServiceName,"count :%d:",i);
          fn_errlog( c_ServiceName, "S31480",
          Fstrerror32(i_ferr[i]),c_err_msg.arr);
          tpfree ( ( char * ) ptr_fml_Sbuf );
          tpfree ( ( char * ) ptr_fml_Rbuf );
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      }

     i_returncode = tpcall("SFO_ORD_ROUT", (char *)ptr_fml_Sbuf, 0,
                   (char **)&ptr_fml_Rbuf, &l_recvbuff, 0);


     if (i_returncode == -1)
     {
       if (TPCODE != TPESVCFAIL)
       {
         fn_errlog( c_ServiceName, "S31485",TPMSG,c_err_msg.arr);
         fn_userlog( c_ServiceName, "TP CODE IS    |%d|",TPCODE);
       }
       else
       {
         i_returncode = Fget32(ptr_fml_Rbuf, FFO_ERR_MSG, 0, c_err_msg.arr, 0);

         if (i_returncode == -1)
         {
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
          fn_errlog( c_ServiceName, "S31490",FMLMSG,c_err_msg.arr);
          tpfree ( ( char * ) ptr_fml_Sbuf );
          tpfree ( ( char * ) ptr_fml_Rbuf );
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
         }
       }

       fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
       tpfree ( ( char * ) ptr_fml_Sbuf );
       tpfree ( ( char * ) ptr_fml_Rbuf );
       tpfree ( ( char * ) ptr_fml_Obuf );
       Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
       Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
       tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     }
   }  /*** End of for loop ***/
 }
  /*** Ver 1.8 Ends Here ***/
  tpfree ( ( char * ) ptr_fml_Rbuf );
  tpfree ( ( char * ) ptr_fml_Sbuf );


  if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg.arr ) == -1 )
  {
    tpfree ( ( char * ) ptr_fml_Obuf );
    fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 1.3 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 1.3 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  /*** Ver 4.0 : starts here ***/
  i_returncode = 0;

  i_returncode = fn_upd_mrgn_reporting( st_usr_prfl.c_cln_mtch_accnt,
                                        st_ordbook.c_xchng_cd,
                                        c_ServiceName,
                                        c_err_msg.arr);

  if ( i_returncode != 0 )
  {
    fn_errlog(c_ServiceName, "S31495", FMLMSG , c_err_msg.arr);
    fn_userlog(c_ServiceName,"Pls check, Nikhil Error while calling function fn_upd_mrgn_reporting..");
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
  /*** Ver 4.0 : Ends here ***/

  /********************************************************/
  /****Changes for Tux4 Triggers***************************/
  /********************************************************/


  /* To post the Trigger in Tux3 Domain Call the service SFO_FOS_TRG */

  strcpy ( c_fno_dmn_nm, "FNO" );
  strcpy ( c_fno_trg_nm, "TRG_LOOK_TAB" );
  strcpy ( c_fno_trg_dat, "TRG_LOOK_TAB" );

  i_returncode = fn_call_svc_fml ( c_ServiceName,
                                   c_err_msg.arr,
                                   "SFO_FOS_TRG",
                                   0,
                                   4,
                                   0,
                                   FFO_DMN_NM, (char *)c_fno_dmn_nm,
                                   FFO_TRG_NM, (char *)c_fno_trg_nm,
                                   FFO_ABT_TRG_DATA, (char *)c_fno_trg_dat,
                                   FFO_ABT_FILTER, (char *)c_pipe_id);

  if ( i_returncode != SUCC_BFR )
  {
    fn_errlog( c_ServiceName, "S31500", LIBMSG, c_err_msg.arr  );
  }

  /********************************************************/
  /****Changes for Tux4 Triggers ends**********************/
  /********************************************************/

	i_actn_id = 0;
	Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
  
  tpreturn( TPSUCCESS, 0, (char *)ptr_fml_Obuf, 0 , 0 );

}

/***********Function for 5 paisa check**************/
int fn_5paisa(long l_temp)
{
  if((l_temp%5) != 0)
    return -1;
  return 0;
}
