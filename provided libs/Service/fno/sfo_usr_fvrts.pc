/************************************************************************************************************/
/*	Program	    			:	SFO_USR_FVRTS                                         															*/
/*                                                                            															*/
/*  Input             : FFO_USR_ID                                            															*/
/*                      FFO_SSSN_ID                                           															*/
/*                      FFO_XCHNG_CD                                          															*/
/*                      FFO_PRDCT_TYP                                         															*/
/*                      FFO_UNDRLYNG                                          															*/
/*                      FFO_EXPRY_DT                                          															*/
/*                      FFO_EXER_TYP                                          															*/
/*                      FFO_OPT_TYP                                           															*/
/*                      FFO_STRK_PRC                                          															*/
/*                      FFO_RQST_TYP                                          															*/
/*                      FFO_MIN_LOT_QTY                                       															*/
/*                      FFO_CTGRY_INDSTK                                      															*/
/*                                                                            															*/
/*  Output            : Success/FFO_ERR_MSG                                   															*/
/*                                                                            															*/
/*  Description       : To add or delete from the user favourite              															*/
/*                      Contract List                                         															*/
/*                                                                            															*/
/*  Log               : 1.0   20-Sep-2001  S. Swaminathan                                            				*/
/*                    : 1.1   19-Dec-2007   Sushil Sharma - AIX Migration     															*/
/*                    : 1.2   28-Aug-2014   Sachin Birje  - view to FML Change															*/
/*                    : 1.3   12-Aug-2015   Sachin Birje  - Stock code Change 															*/
/*                    : 1.4   14-Dec-2015		Kishor Borkar - Colud Order Changes															*/
/*                    : 1.5   14-Jul-2016   Sachin Birje  - Valid contract check														*/
/*                    : 1.6   22-Jul-2016   Sachin Birje  - FP favourite not allowed changes								*/
/*										:	VQC		29-Jun-2016		Swapnil More	-	VQC changes																			*/
/*                    : 1.7   14-Sep-2016   Kishor Borkar - Cloud order changes(FFC_INSRT_DT column added) 	*/
/*                    : 1.9   18-Oct-2016   Swapnil More  - Cloud Order changes for other front ends      	*/
/*										:	2.0		04-Jan-2016		Kishor Borkar	-	Colud Order Changes for core products						*/
/*										:	2.1		27-Apr-2021		Kiran Itkar		- Basket Order changes														*/
/*                    : 2.2   26-Nov-2021   Mahesh R      - Minor Changes of Buisness Message               */
/*                    : 2.3   05-Apr-2022   Suchita D     - CR-ISEC10-160824 changes                        */
/*                    : 2.4   10-Apr-2022   Shlok Ghan    - Basket Copy Paste                               */
/*                    : 2.5   27-May-2022   Naveena R.    - CR-ISEC14-166852 Introduction of Add to         */
/*                                                          My Favourite Box in FO Home page                */
/*                    : 2.6   18-Oct-2022   Prajakta S    - Spira IN:349 Increasing basket name             */ 
/*                    : 2.7   07-Nov-2022   Mahesh Shinde - Spira IN:456 get FML bug 												*/
/*                    : 2.8   21-Nov-2022   Prajakta S    - Spira IN:545 modify contract of futureplus SLTP */
/*                                                          and optionplus in basket with Market order type */
/*                    : 2.9   22-Nov-2022   Prajakta S    - CR-ISEC10-178410-CR-Place order through         */
/*                                                           upload excel in basket order                   */
/*										: 3.0   20-Dec-2022		Ravindra P    - Spira 497 : MIS report for strategy builder     */
/*                    : 3.1   17-Mar-2023   Prajakta S    - Spira 1486: Adding contract in Basket changed to 30 */
/*                    : 3.2   17-Mar-2023   Prajakta S    - CR-ISEC10-182478 Place F&O orders via upload    */
/*                                                          csv in basket order phase 2                     */
/************************************************************************************************************/
/*  1.0   - New release                                                       															*/
/*	VQC		-	Version Quality Control Changes																																	*/
/*  1.9   - Limit Order Allowed Validation introduced for other front ends while adding cloud order to  		*/
/*          SLTP FP & OP                                                     																*/
/************************************************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <atmi.h>
#include <fml32.h>
#include <sqlca.h>
#include <fo_fml_def.h>
/** #include <fo_view_def.h> ** Ver 1.2 **/
#include <fo_view_def.h>    /** Ver 1.2 **/
#include <fo.h>
#include <fn_tuxlib.h>
#include <fn_log.h>             /*  Ver 1.1 : Added 	*/
#include <fn_session.h>         /*  Ver 1.1 : Added 	*/
#include <fn_read_debug_lvl.h>  /*  Ver 1.1 : Added   */

void SFO_USR_FVRTS( TPSVCINFO *rqst )
{
	int i_err[18];											/** changes from 9 to 13 in Ver 1.4 **/	/*** changes from 13 to 16 in Ver 2.1 ***/ /*** changed from 16 to 18 in Ver 2.1 ***/				
	int i_ferr[18];											/** changes from 9 to 13 in Ver 1.4 **/	/*** changes from 13 to 16 in Ver 2.1 ***/ /*** changed from 16 to 18 in Ver 2.1 ***/
	int i_cnt						= 0 ;						/** Initilized to 0 in VQC **/
	int i_reccount			= 0 ;						/** Initilized to 0 in VQC **/
	int i_tot_recs			= 0 ; 					/** Initilized to 0 in VQC **/
	int i_returncode		= 0 ; 					/** Initilized to 0 in VQC **/
	int i_record_exists = 0 ; 					/** Initilized to 0 in VQC **/
	int i_trnsctn				= 0 ;						/** Initilized to 0 in VQC **/
  int l_ordr_qty      = 0 ;           /*** Ver 1.4 ***/
  int i_valid_cntrct  = 0 ;     			/*** Ver 1.5 ***/
	int i_count					= 0 ;
  int i_fail_flag     = 0 ;           /*** Ver 3.2 ***/
	
	char c_rqst_typ='\0';
	char c_ServiceName[33];
	varchar c_err_msg[256];				/**** VQC Changed datatype from char[] to varchar ***/
  varchar c_err_msg1[1024] ;  /** Added in Ver 3.2 **/
/*char c_msg[256];					***** Commentd in VQC as it is unused ****/
  char c_scd_prcs_flg;
  char c_source_flg					=	'\0';   			/*** Ver 1.4 ***/
  char c_lmt_mktsl_flg			=	'\0'; 				/*** Ver 1.4 ***/
	char c_lmt_allwd_flg			=	'N' ;  				/*** Ver 1.4 ***/
	char c_ffc_ordr_rfrnc[17]	=	"\0";					/*** Ver 1.4 ***/
  char c_fum_sltp_alwd_flg  = '\0';         /*** Ver 1.9 ***/
  char c_ftq_sltp_alwd_flg  = '\0';         /*** Ver 1.9 ***/
	char c_ftq_qt_trdng_flg 	= '\0';         /*** Ver 2.0 ***/
	char c_ftq_fp_qt_trdng_flg= '\0';         /*** Ver 2.0 ***/
	char c_fum_qt_trdng_flg   = '\0';         /*** Ver 2.0 ***/
  char c_fum_fp_trdng_flg   = '\0';         /*** Ver 2.0 ***/
  char c_fail_flag          = 'N';          /*** Ver 3.2 ***/

	char  c_bskt_name[21]="\0";       /***  Ver 2.1 ***/     /*** ver 2.6 changed from 15 to 21 ***/
  char  c_bskt_id[15] ="\0";        /***  Ver 2.1 ***/
  char  c_crtd_dt[ LEN_DATE ];      /***  Ver 2.1 ***/
	char  c_fbl_bskt_id[10] = "\0";		/***  Ver 2.1 ***/
	char  c_bskt_ordr_ref[17]="\0";		/***  Ver 2.1 ***/
	char  c_ordr_flw = '\0';          /***  Ver 2.1 ***/  
  char  c_basket_name[] = "\0";     /***  Ver 2.6 ***/ 
	char  c_opr_typ = '\0';           /*** Added in VER 3.0 : To separate basket created from strategy builder ***/

  long l_cvr_sltp_rt = 0.0;       /***  Ver 2.1 ***/
  double d_frs_lmt_rt = 0.0;        /***  Ver 2.1 ***/
  long l_cvr_lmt_rt = 0.0;        /***  Ver 2.1 ***/
	int i_ch_val=0;	/*** Ver 2.1 ***/
	char c_ordr_typ = '\0';						/*** Ver 2.1 ***/
  double d_cvr_sltp_diff		=	 0.0; 				/*** Ver 1.4 ***/
  long l_frs_lmt_rt = 0;
  char c_error_msg[256];      /*** Ver 2.9 ***/ 

	EXEC SQL BEGIN DECLARE SECTION;
/**	long li_sssn_id;  Commented in VQC and used st_usr_prfl.l_session_id instead ***/
	  long li_count      = 0;     /** Initilized to 0 in VQC **/	
		long li_max_cntrct = 0; 		/** Initilized to 0 in VQC **/
		long l_lot_sz 		 = 0; 		/** Initilized to 0 in VQC **/
    long sql_fum_freeze_qty = 0;     /** Ver 2.9 **/
    char c_ctgry_indx  = '\0';       /** Ver 2.9 **/
    char sql_source_flag = 'B';      /** Ver 3.2 **/
		struct vw_contract st_cntrct;
		struct vw_usr_prfl st_usr_prfl;
		struct vw_err_msg st_err_msg;
		varchar sql_ffc_usr_id[8+1];
		char sql_ffc_xchng_cd[3+1];
	EXEC SQL END DECLARE SECTION;
  
  MEMSET(c_err_msg1); /** Added in Ver 3.2 **/

	FBFR32 *ptr_fml_Ibuf;
  FBFR32 *ptr_fml_Obuf;    /*** Added in Ver 3.2 ***/
	ptr_fml_Ibuf	=	(FBFR32 *)rqst->data;

	strcpy( c_ServiceName, rqst->name );
	INITDBGLVL(c_ServiceName);            /*  Ver 1.1 : Added   */

  ptr_fml_Obuf = NULL;    /** Added in Ver 3.2 ***/


	i_err[0] 		= Fget32( ptr_fml_Ibuf, FFO_USR_ID, 0, (char *)sql_ffc_usr_id.arr, 0 ); 
	i_ferr [0] 	= Ferror32;

/*i_err[1] 		= Fget32( ptr_fml_Ibuf, FFO_SSSN_ID, 0, (char *)&li_sssn_id, 0 ); *** VQC **/ 
	i_err[1]		= Fget32( ptr_fml_Ibuf, FFO_SSSN_ID, 0, (char *)&st_usr_prfl.l_session_id, 0); /** added in vQC **/
	i_ferr [1] 	= Ferror32;
	
	i_err[2] 		= Fget32( ptr_fml_Ibuf, FFO_RQST_TYP, 0,  (char *)&c_rqst_typ, 0 ); 
	i_ferr [2] 	= Ferror32;
	
	i_err[3] 		= Fget32( ptr_fml_Ibuf, FFO_XCHNG_CD, 0, (char *)sql_ffc_xchng_cd, 0 ); 
	i_ferr [3] 	= Ferror32;

  for ( i_cnt=0; i_cnt < 4; i_cnt++ ) 
  {
    if ( i_err[ i_cnt ] == -1 )
    {
      fn_errlog( c_ServiceName, "S31005", Fstrerror32(i_ferr[i_cnt]),
                                          c_err_msg.arr  );		/** VQC changed from c_err_msg to c_err_msg.arr **/
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  /** VQC changed from c_err_msg to c_err_msg.arr **/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
  }
	/*** Ver 1.4 Starts ***/
  i_err[4] = Fget32( ptr_fml_Ibuf, FFO_SOURCE_FLG, 0,
                     (char *)&c_source_flg, 0 );
  i_ferr [4] = Ferror32;

	if ( i_err[ 4 ] == -1 )
	{
    if( Ferror32 == FNOTPRES)
    {
      c_source_flg='F';
    }
    else
    {
		  fn_errlog( c_ServiceName, "S31010", Fstrerror32(i_ferr[i_cnt]), 
                                         c_err_msg.arr  );   /** VQC changed from c_err_msg to c_err_msg.arr **/
		  Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  /** VQC changed from c_err_msg to c_err_msg.arr **/
		  tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
	}
	if( DEBUG_MSG_LVL_3 )
	{
    fn_userlog( c_ServiceName, "c_source_flg..........2:%c:", c_source_flg);
	}
  /*** Ver 1.4 Ends ***/

	/**** Added in Ver 2.1 ****/
  if(c_source_flg == 'B')
  {

		/** Added in VER 3.0 : To accept additional FML for distinguishing startegy builder orders **/

    if(Fget32( ptr_fml_Ibuf,FFO_OPERATION_TYP,0,(char *)&c_opr_typ,0 ) == -1)
    {
      if( Ferror32 != FNOTPRES )
      {
        fn_errlog( c_ServiceName, "S22222", LIBMSG, c_err_msg.arr  );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
    }
		if( DEBUG_MSG_LVL_0 )
			fn_userlog( c_ServiceName, " VER 3.0 : Operation type flag is :%c:", c_opr_typ);

    /** VER 3.0 ends here **/

		if(c_rqst_typ == 'G' || c_rqst_typ == 'N' ||  c_rqst_typ =='P' ||  c_rqst_typ =='Q' || c_rqst_typ == 'U')
                                                                                       /*** Ver 2.9 added new request type U ***/  
		{
			if(Fget32( ptr_fml_Ibuf,FFO_SYMBOL,0,(char *)c_bskt_name,0 ) == -1)
    	{
      	fn_errlog( c_ServiceName, "S22222", LIBMSG, c_err_msg.arr  );
      	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    	}
		}
		if( c_rqst_typ == 'N' || c_rqst_typ == 'M' ||  c_rqst_typ =='P' ||  c_rqst_typ =='Q' || c_rqst_typ =='H' || c_rqst_typ =='Z'
         || c_rqst_typ == 'U') /***ver 2.3***/ /*** Ver 2.9 added new request type U ***/
		{
			if(Fget32( ptr_fml_Ibuf,FFO_SERIES,0,(char *)c_bskt_id,0 ) == -1)
    	{
      	fn_errlog( c_ServiceName, "S22222", LIBMSG, c_err_msg.arr  );
      	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    	}
		}
  }
		if( DEBUG_MSG_LVL_3 )
		{
			fn_userlog( c_ServiceName, "c_source_flg:%c:",c_source_flg);
			fn_userlog( c_ServiceName, "c_rqst_typ:%c:",c_rqst_typ);
			fn_userlog( c_ServiceName, "c_bskt_name:%s:",c_bskt_name);
			fn_userlog( c_ServiceName, "c_bskt_id:%s:",c_bskt_id);
		}
  /*** Ended Ver 2.1 ****/

	i_tot_recs = Foccur32( (FBFR32 *)ptr_fml_Ibuf, FFO_XCHNG_CD );
	SETLEN( sql_ffc_usr_id );

	if( DEBUG_MSG_LVL_3 ) {          /*  Ver 1.1 : Debug level Change  */
		fn_userlog( c_ServiceName, "sql_ffc_usr_id:%s:", sql_ffc_usr_id.arr );
/**	fn_userlog( c_ServiceName, "li_sssn_id:%ld:", li_sssn_id ); 							  Commented in VQC ***/
		fn_userlog( c_ServiceName, "li_sssn_id:%ld:", st_usr_prfl.l_session_id );  /*** Added in VQC ***/
		fn_userlog( c_ServiceName, "c_rqst_typ:%c:", c_rqst_typ );
		fn_userlog( c_ServiceName, "i_tot_recs:%d:", i_tot_recs );
	}

	/** if ( li_sssn_id != 0 ) **  				Commented in  VQC **/
	if (st_usr_prfl.l_session_id != 0)		 /** Added in VQC **/
	{

		strcpy( st_usr_prfl.c_user_id, (char *)sql_ffc_usr_id.arr );
/**	st_usr_prfl.l_session_id = li_sssn_id;  											*** Commented in VQC ***/
		strcpy( st_usr_prfl.c_cln_mtch_accnt, "*" );
   
		st_usr_prfl.l_usr_flg = 0;												/*** Added in VQC (session issue) ***/
		
		i_returncode = fn_chk_sssn( c_ServiceName, &st_usr_prfl, 
																						   &st_err_msg );

		if ( i_returncode == -1 )
		{
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
	}

	if ( c_rqst_typ == ADD  && c_source_flg != 'C' && c_source_flg != 'B')  /** c_source_flg added in ver 2.0 **/ /*** 'B' added in Ver 2.1 ***/
	{
		li_count=0;
		EXEC SQL
			SELECT 	count(*)
			INTO		:li_count
			FROM		ffc_fo_fvrt_cntrct_lst
			WHERE		ffc_usr_id		=	:sql_ffc_usr_id 
			AND			ffc_xchng_cd 	=	:sql_ffc_xchng_cd
			AND			ffc_rqst_typ	= :c_source_flg;			/** Ver 1.4 **/
	
		if ( ( SQLCODE != 0 ) && ( SQLCODE != NO_DATA_FOUND ) )
		{
			fn_errlog( c_ServiceName, "S31015", SQLMSG, c_err_msg.arr  );  /** VQC changed from c_err_msg to c_err_msg.arr **/
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  /** VQC changed from c_err_msg to c_err_msg.arr **/
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}

		li_max_cntrct=0;
		EXEC SQL
			SELECT 	FSP_MAX_CNTRCT_FVRT_LST
			INTO		:li_max_cntrct
			FROM 		FSP_FO_SYSTM_PRMTR;

		if ( SQLCODE != 0 )
		{
			fn_errlog( c_ServiceName, "S31020", SQLMSG, c_err_msg.arr  ); /** VQC changed from c_err_msg to c_err_msg.arr **/
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  /** VQC changed from c_err_msg to c_err_msg.arr **/
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}

		if ( ( li_count + i_tot_recs ) > li_max_cntrct )
		{
			strcpy( c_err_msg.arr, "Exceeding the Limit to add to Favourite List" );  /** VQC changed from c_err_msg to c_err_msg.arr **/
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  /** VQC changed from c_err_msg to c_err_msg.arr **/
			fn_errlog( c_ServiceName, "S31025", "Exceeding the Limit to add to Favourite List", c_err_msg.arr  );  /** VQC changed from c_err_msg to c_err_msg.arr **/
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
	}
	/*** KIRAN ****/
	if( DEBUG_MSG_LVL_3 )
	{
		fn_userlog(c_ServiceName, "sql_ffc_usr_id :%s:",sql_ffc_usr_id.arr);
		fn_userlog(c_ServiceName, "sql_ffc_xchng_cd :%s:",sql_ffc_xchng_cd);
		fn_userlog(c_ServiceName, "c_bskt_id :%s:",c_bskt_id);
	}

	if (( c_rqst_typ == 'H'|| c_rqst_typ == 'U') && c_source_flg == 'B' )  /*** Ver 2.9 added new request type U ***/
	{
		 li_count=0;
			EXEC SQL
 				SELECT 	count(1)
 				INTO		:li_count
 				FROM   	FBC_FO_BSKT_CNTRCT_LST
 				WHERE		FBC_USR_ID		= :sql_ffc_usr_id
 				AND			FBC_XCHNG_CD	= :sql_ffc_xchng_cd
 				AND			FBC_BSKT_ID		= :c_bskt_id;

			if ( SQLCODE != 0 )
	    {
      	fn_errlog( c_ServiceName, "S31030", SQLMSG, c_err_msg.arr  ); 
      	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    	}
		
		li_max_cntrct=0;
    EXEC SQL
      SELECT  FSP_MAX_BSKT_CNTRCT_LST 
      INTO    :li_max_cntrct
      FROM    FSP_FO_SYSTM_PRMTR;

    if ( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31035", SQLMSG, c_err_msg.arr  ); 
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
		if( DEBUG_MSG_LVL_3 )
		{	
			fn_userlog( c_ServiceName, "li_count :%ld:",li_count);
			fn_userlog( c_ServiceName, "li_max_cntrct :%ld:",li_max_cntrct);
		}
    
    /*** Ver 2.9 starts (checks contracts present in excel) ***/
    if(c_rqst_typ == 'U')
    {
      li_count += i_tot_recs;
    }
    if(c_rqst_typ == 'U')
    {
      if (  li_count >  li_max_cntrct )  /*** Added in Ver 2.9 ***/
      {
       {
        sprintf( c_err_msg.arr, "Can not add more than %ld items in a basket",li_max_cntrct); /** Ver 3.1 Changed from 50 to 30 **/
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        /*commented in ver 3.1 fn_errlog( c_ServiceName, "S31040", "Can not add more than 50 items in a basket", c_err_msg.arr  ); */
        fn_errlog( c_ServiceName, "S31045", "Can not add more items in a basket", c_err_msg.arr  );
                                                                            /** Added in Ver 3.1  **/
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
       }   
      }
    }
    else
    { /*** Ver 2.9 ends  ***/ 
	  	if (  li_count  >= li_max_cntrct )
      {
       sprintf( c_err_msg.arr, "Can not add more than %ld items in a basket",li_max_cntrct); /*** Ver 2.9 changed from 20 to 50 ***/
                                                                                           /** Ver 3.1 Changed from 50 to 30 **/
       Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
       /*commented in ver 3.1 fn_errlog( c_ServiceName, "S31050", "Can not add more than 30 items in a basket", c_err_msg.arr  );
                                                *** Ver 2.9 changed from 20 to 50 ***/
       fn_errlog( c_ServiceName, "S31055", "Can not add more items in a basket", c_err_msg.arr  );
                                                                            /** Added in Ver 3.1  **/
       tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
    }
	}
	if ( c_rqst_typ == 'G'  && c_source_flg == 'B' )
	{
		if( DEBUG_MSG_LVL_3 )
		{
			fn_userlog( c_ServiceName, "sql_ffc_usr_id :%s:",sql_ffc_usr_id.arr);
			fn_userlog( c_ServiceName, "Inside c_rqst_typ == G && c_source_flg == B");
		}

		EXEC SQL
			SELECT count(rowid)
      INTO    :li_count
      from    FBL_FO_BSKT_LST
      WHERE  	FBL_USR_ID = :sql_ffc_usr_id; 

		if ( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31060", SQLMSG, c_err_msg.arr  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

    li_max_cntrct=0;
    EXEC SQL
      SELECT  FSP_MAX_BSKT_CNTRCT_LST
      INTO    :li_max_cntrct
      FROM    FSP_FO_SYSTM_PRMTR;

    if ( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31065", SQLMSG, c_err_msg.arr  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

		if( DEBUG_MSG_LVL_3 )
		{
    	fn_userlog( c_ServiceName, "li_count :%ld:",li_count);
    	fn_userlog( c_ServiceName, "li_max_cntrct :%ld:",li_max_cntrct);
		}

    if (  li_count  >= li_max_cntrct )
    {
      strcpy( c_err_msg.arr, "Can not add more than 20 baskets" );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
      fn_errlog( c_ServiceName, "S31070", "Can not add more than 20 baskets", c_err_msg.arr  );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}

    /*** ver 2.6 starts ***/
    if(strlen(c_bskt_name) > 20)
     {
       strncpy(c_basket_name, c_bskt_name,20);
       strcpy(c_bskt_name, c_basket_name);
       fn_userlog( c_ServiceName, "c_bskt_name:%s:",c_bskt_name);
     }
       
    /*** ver 2.6 ends ***/ 	
	}

	i_trnsctn = fn_begintran( c_ServiceName, c_err_msg.arr );  /** VQC changed from c_err_msg to c_err_msg.arr **/

	if ( i_trnsctn == -1 )
	{
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  /** VQC changed from c_err_msg to c_err_msg.arr **/
		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}
    
	if( DEBUG_MSG_LVL_3 )
	{
		fn_userlog ( c_ServiceName,"Suchita c_source_flg :%c: c_rqst_typ :%c:",c_source_flg,c_rqst_typ);
	}

	/** Added in Ver 3.2 **/
	if(c_source_flg == 'B' && c_rqst_typ == 'U')
	{
  	ptr_fml_Obuf = (FBFR32 *)tpalloc( "FML32", NULL, MIN_FML_BUF_LEN * 200); 
	}
	/** end Ver 3.2 **/

	/*** Added in Ver 2.1 ***/
	/*** Request type 'G' for adding basket ***/
	if(c_source_flg == 'B' && c_rqst_typ == 'G')
  {
		i_count = 0;

		/*** Check for repitation of basket ***/
    EXEC SQL
      SELECT  count(rowid)
      INTO    :i_count
      from    FBL_FO_BSKT_LST
      WHERE		FBL_BSKT_NAME = :c_bskt_name
			AND			FBL_USR_ID		=	:sql_ffc_usr_id;

		if ( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31075", SQLMSG, c_err_msg.arr  );
      fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );   
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

		MEMSET(c_fbl_bskt_id);
		if( DEBUG_MSG_LVL_3 )
		{
    	fn_userlog(c_ServiceName,"***inside Basket create sequence............................***");
		}	

		if( i_count == 1 )
		{
			fn_userlog(c_ServiceName,"*** :%s: Basket name already exists ***",
                                    sql_ffc_usr_id.arr );
          fn_errlog( c_ServiceName, "S31080", "Basket name already exists.", c_err_msg.arr  ); 
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  
          MEMSET(c_err_msg.arr);  
          sprintf(c_err_msg.arr,"Basket name already exists."); 
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 ); 
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
		else if( i_count == 0 )
		{

			/*** Added in VER 3.0 : Baskets created through startegy builder will have basket id starting with S ***/
      if ( c_opr_typ == 'S')
      {
        EXEC SQL
        SELECT 'S'||LPAD(TO_CHAR(EXG_NXT_TRD_DT,'MMDD'),4,'0')||LPAD(TO_CHAR(GET_BSKTLST_SEQ.NEXTVAL),4,'0')
        INTO   :c_fbl_bskt_id
        FROM   EXG_XCHNG_MSTR
        WHERE  EXG_XCHNG_CD  = 'NFO';
      }
      /*** VER 3.0 ends here ***/		
			else
			{
				EXEC SQL
        	SELECT 'B'||LPAD(TO_CHAR(EXG_NXT_TRD_DT,'MMDD'),4,'0')||LPAD(TO_CHAR(GET_BSKTLST_SEQ.NEXTVAL),4,'0')
        	INTO   :c_fbl_bskt_id
        	FROM   EXG_XCHNG_MSTR
 	       	WHERE  EXG_XCHNG_CD  = 'NFO';
			}	

      if ( ( SQLCODE != 0 ) && ( SQLCODE != NO_DATA_FOUND ) )
      {
        fn_errlog( c_ServiceName, "S31085", SQLMSG, c_err_msg.arr  );  
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );     
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

			if( DEBUG_MSG_LVL_0 )
      	fn_userlog( c_ServiceName, " VER 3.0 : Basket ID generated is :%s:", c_fbl_bskt_id);

			EXEC SQL
			INSERT INTO FBL_FO_BSKT_LST
			(
				FBL_BSKT_NAME,
				FBL_BSKT_ID,
				FBL_CRTD_DT,
				FBL_USR_ID,
				FBL_XCHNG_CD
			)
			Values
			(
				:c_bskt_name,
				:c_fbl_bskt_id,	
				sysdate,
				:sql_ffc_usr_id,
				:sql_ffc_xchng_cd
			);

			if ( SQLCODE != 0 )
    	{
      	fn_errlog( c_ServiceName, "S31090", SQLMSG, c_err_msg.arr  );  /** VQC changed from c_err_msg to c_err_msg.arr **/
      	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  /** VQC changed from c_err_msg to c_err_msg.arr **/
      	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );     /** VQC changed from c_err_msg to c_err_msg.arr **/
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    	}			
  
			i_ch_val = fn_pack_vartofml ( c_ServiceName,
																	c_err_msg.arr,
																	&ptr_fml_Ibuf,
																	1,
																	FFO_SERIES, 			(char *)c_fbl_bskt_id
																); 	

			if ( i_ch_val != 0 )
			{
				fn_errlog( c_ServiceName, "S31095", SQLMSG, c_err_msg.arr  ); 
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );    
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
		}
	}
	else if (c_source_flg == 'B' && c_rqst_typ == 'N')
	{
		if( DEBUG_MSG_LVL_3 )
		{
			fn_userlog( c_ServiceName, "sql_ffc_usr_id:%s:", sql_ffc_usr_id.arr );
			fn_userlog( c_ServiceName, "c_bskt_name:%s:", c_bskt_name );
			fn_userlog( c_ServiceName, "sql_ffc_xchng_cd:%s:", sql_ffc_xchng_cd );
			fn_userlog( c_ServiceName, "c_bskt_id:%s:", c_bskt_id );
		}

    /*** ver 2.3 starts ***/

    i_count = 0;

    EXEC SQL
      SELECT  count(rowid)
      INTO    :i_count
      from    FBL_FO_BSKT_LST
      WHERE   FBL_BSKT_NAME = :c_bskt_name
      AND     FBL_USR_ID    = :sql_ffc_usr_id;

    if ( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31100", SQLMSG, c_err_msg.arr  );
      fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

     if(i_count == 0)
     {
	   	EXEC SQL
		    	UPDATE FBL_FO_BSKT_LST
				  SET FBL_BSKT_NAME   	= :c_bskt_name,
          FBL_CRTD_DT = sysdate                  /*** 2.6 ***/
			    WHERE FBL_USR_ID     = :sql_ffc_usr_id 
				  AND FBL_XCHNG_CD		= :sql_ffc_xchng_cd
				  AND FBL_BSKT_ID		=	:c_bskt_id;

      if ( SQLCODE != 0 )
      {
        fn_errlog( c_ServiceName, "S31105", SQLMSG, c_err_msg.arr  ) ;  /** VQC changed from c_err_msg to c_err_msg.arr **/
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  /** VQC changed from c_err_msg to c_err_msg.arr **/
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );   /** VQC changed from c_err_msg to c_err_msg.arr **/
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
		 }
     else
     {
        fn_userlog(c_ServiceName,"*** :%s: Basket name already exists ***",
                                    sql_ffc_usr_id.arr );
        fn_errlog( c_ServiceName, "S31110", "Basket name already exists.", c_err_msg.arr  );
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        MEMSET(c_err_msg.arr);
        sprintf(c_err_msg.arr,"Basket name already exists.");
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     
      }
    /*** ver 2.3 ends ***/
	}
	/**** Ended Ver 2.1 ***/
	else 
	{
		for ( i_reccount = 0; i_reccount < i_tot_recs; i_reccount++ )
		{
    fn_userlog(c_ServiceName,"Contract Number %d",i_reccount+1); /** Added in Ver 3.2 **/
    i_fail_flag = 0;  /** Added in Ver 3.2 **/
	  i_err[0] = Fget32( ptr_fml_Ibuf, FFO_XCHNG_CD, i_reccount, 
										 (char *)st_cntrct.c_xchng_cd, 0 );
	  i_ferr [0] = Ferror32;

		i_err[1] = Fget32( ptr_fml_Ibuf, FFO_PRDCT_TYP, i_reccount, 
											 (char *)&st_cntrct.c_prd_typ, 0 );
		i_ferr [1] = Ferror32;

		i_err[2] = Fget32( ptr_fml_Ibuf, FFO_UNDRLYNG, i_reccount, 
 	 		                 (char *)st_cntrct.c_undrlyng, 0 );
		i_ferr [2] = Ferror32;

		i_err[3] = Fget32( ptr_fml_Ibuf, FFO_EXPRY_DT, i_reccount, 
   		                 (char *)st_cntrct.c_expry_dt, 0 );
		i_ferr [3] = Ferror32;

		i_err[4] = Fget32( ptr_fml_Ibuf, FFO_EXER_TYP, i_reccount, 
   		                 (char *)&st_cntrct.c_exrc_typ, 0 );
		i_ferr [4] = Ferror32;

		i_err[5] = Fget32( ptr_fml_Ibuf, FFO_OPT_TYP, i_reccount, 
   		                 (char *)&st_cntrct.c_opt_typ, 0 );
		i_ferr [5] = Ferror32;

		i_err[6] = Fget32( ptr_fml_Ibuf, FFO_STRK_PRC, i_reccount, 
   		                 (char *)&st_cntrct.l_strike_prc, 0 );
		i_ferr [6] = Ferror32;

		if ( !(c_source_flg == 'B' && c_rqst_typ == 'Q') )	/*** Added in ver 2.1 ***/
		{
		      	i_err[7] = Fget32( ptr_fml_Ibuf, FFO_MIN_LOT_QTY, i_reccount, 
   		                 (char *)&l_lot_sz, 0 );
		      	i_ferr [7] = Ferror32;

	      		i_err[8] = Fget32( ptr_fml_Ibuf, FFO_CTGRY_INDSTK, i_reccount, 
   			                 (char *)&st_cntrct.c_ctgry_indstk, 0 );
		      	i_ferr [8] = Ferror32;
		}
	
		/*** Added in Ver 2.1 ***/	
		if ( i_err[ 7 ] == -1 )
  	{
    	if( Ferror32 == FNOTPRES)
    	{
      	l_lot_sz=0;
    	}
    	else
    	{
      	fn_errlog( c_ServiceName, "S31115", Fstrerror32(i_ferr[i_cnt]),
        	                                 c_err_msg.arr  );  
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); 
      	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  
				if(c_source_flg == 'B' && c_rqst_typ == 'U')
				{
					tpfree ( ( char * ) ptr_fml_Obuf ); /** Added in Ver 3.2 **/
				}
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    	}
  	}
		if ( i_err[ 8 ] == -1 )
		{
			if( Ferror32 == FNOTPRES)
			{
				st_cntrct.c_ctgry_indstk='\0';
			}
			else
      {
        fn_errlog( c_ServiceName, "S31120", Fstrerror32(i_ferr[i_cnt]),
                                           c_err_msg.arr  );
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
				if(c_source_flg == 'B' && c_rqst_typ == 'U')
				{
					tpfree ( ( char * ) ptr_fml_Obuf ); /** Added in Ver 3.2 **/
				}
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
    }
		/*** Ended Ver 2.1 ***/

		/*for ( i_cnt=0; i_cnt < 9; i_cnt++ ) Commented in Ver 2.7*/

		for ( i_cnt=0; i_cnt < 7; i_cnt++ ) /*** Ver 2.7 FML on 7 and 8 position already checked above for specific condition ***/
		{
      if( !(c_source_flg == 'B' && c_rqst_typ == 'P') )
      {
      if ( i_err[ i_cnt ] == -1 )
      {
        fn_errlog( c_ServiceName, "S31125", Fstrerror32(i_ferr[i_cnt]),
                                            c_err_msg.arr  );  /** VQC changed from c_err_msg to c_err_msg.arr **/
        fn_userlog(c_ServiceName,"Unable to fget :%d:", i_cnt );
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  /** VQC changed from c_err_msg to c_err_msg.arr **/
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  /** VQC changed from c_err_msg to c_err_msg.arr **/
				if(c_source_flg == 'B' && c_rqst_typ == 'U')
				{
					tpfree ( ( char * ) ptr_fml_Obuf ); /** Added in Ver 3.2 **/
				}
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
     }
		}
      /*** Ver 1.4 Starts ***/

    c_lmt_mktsl_flg ='\0';
    d_cvr_sltp_diff=0.0;
    l_ordr_qty = 0;

		if((c_source_flg == 'C' && c_rqst_typ != DELETE) || (c_source_flg == 'B' &&
                         (c_rqst_typ == 'H' || c_rqst_typ == 'M' || c_rqst_typ == 'Z' || c_rqst_typ == 'U')))
                            	/*** or condition added in Ver 2.1 ***/   /*** ver 2.3 ***/ /*** Ver 2.9 added new request type 'U'***/
		{
    	i_err[9] = Fget32( ptr_fml_Ibuf, FFO_ORD_TOT_QTY, i_reccount,
      	                 (char *)&l_ordr_qty, 0 );
    	i_ferr [9] = Ferror32;

    	i_err[10] = Fget32( ptr_fml_Ibuf, FFO_LMT_MKT_SL_FLG , i_reccount,
      	                 (char *)&c_lmt_mktsl_flg, 0 );
    	i_ferr [10] = Ferror32;

			if((st_cntrct.c_prd_typ == 'U' || st_cntrct.c_prd_typ == 'I') && (c_source_flg != 'B' && c_rqst_typ != 'H'))			/*** if condition added in Ver 2.0 ***/	/*** and condition added in Ver 2.1 ****/
			{
    		i_err[11] = Fget32( ptr_fml_Ibuf, FFO_INTRST_RT, i_reccount,
      		                 (char *)&d_cvr_sltp_diff, 0 );
    		i_ferr [11] = Ferror32;
			
				for ( i_cnt=9; i_cnt < 12; i_cnt++ )
				{
  				if ( i_err[ i_cnt ] == -1 )
  				{
    				fn_errlog( c_ServiceName, "S31130", Fstrerror32(i_ferr[i_cnt]),
          		                              c_err_msg.arr  );  /** VQC changed from c_err_msg to c_err_msg.arr **/
    				fn_userlog(c_ServiceName,"Unable to fget :%d:", i_cnt );
    				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr);  /** VQC changed from c_err_msg to c_err_msg.arr **/
    				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );   /** VQC changed from c_err_msg to c_err_msg.arr **/
						if(c_source_flg == 'B' && c_rqst_typ == 'U')
						{
							tpfree ( ( char * ) ptr_fml_Obuf ); /** Added in Ver 3.2 **/
						}
    				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  				}
				}
			}
			/**** Added in Ver 2.1 ****/
      else if(c_source_flg == 'B' && (c_rqst_typ == 'H' || c_rqst_typ == 'M' || c_rqst_typ == 'Z' || c_rqst_typ == 'U' ) )
                        /*** ver 2.3 ***/  /*** Ver 2.9 added new request type 'U'***/
      {
				i_err[11] = Fget32( ptr_fml_Ibuf, FFO_CVR_BRKG, i_reccount,
                           (char *)&l_cvr_sltp_rt, 0 );
        i_ferr [11] = Ferror32;
				
				i_err[12] = Fget32( ptr_fml_Ibuf, FFO_CURR_RT, i_reccount,
                           (char *)&l_frs_lmt_rt, 0 );
        i_ferr [12] = Ferror32;

				i_err[13] = Fget32( ptr_fml_Ibuf, FFO_LMT_RT, i_reccount,
                           (char *)&l_cvr_lmt_rt, 0  );
        i_ferr [13] = Ferror32;

				i_err[14] = Fget32( ptr_fml_Ibuf, FFO_ORDR_FLW,  i_reccount,
                           (char *)&c_ordr_flw, 0 );
        i_ferr [14] = Ferror32;		

				i_err[15] = Fget32( ptr_fml_Ibuf, FFO_SERIES,  i_reccount,
                           (char *)c_bskt_id, 0 );
        i_ferr [15] = Ferror32;

				i_err[16] = Fget32( ptr_fml_Ibuf, FFO_ORD_TYP,  i_reccount,
                           (char *)&c_ordr_typ, 0 );
        i_ferr [16] = Ferror32;


				for ( i_cnt=9; i_cnt < 17; i_cnt++ )
        {
          if ( i_err[ i_cnt ] == -1 )
          {
            fn_errlog( c_ServiceName, "S31135", Fstrerror32(i_ferr[i_cnt]),
                                            c_err_msg.arr  );  /** VQC changed from c_err_msg to c_err_msg.arr **/
            fn_userlog(c_ServiceName,"Unable to fget :%d:", i_cnt );
            fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr);  /** VQC changed from c_err_msg to c_err_msg.arr **/
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );   /** VQC changed from c_err_msg to c_err_msg.arr **/
						if(c_source_flg == 'B' && c_rqst_typ == 'U')
						{
							tpfree ( ( char * ) ptr_fml_Obuf ); /** Added in Ver 3.2 **/
						}
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          }
        }
        
				if( DEBUG_MSG_LVL_3 )
				{	
        	fn_userlog(c_ServiceName,"SUCHITA l_frs_lmt_rt :%ld:",l_frs_lmt_rt);
        	fn_userlog(c_ServiceName,"SUCHITA l_cvr_lmt_rt :%ld:",l_cvr_lmt_rt);
				}
      }
			/*** Ended Ver 2.1 ***/
			else /*** Ver 2.0 Starts ***/
			{		
      	for ( i_cnt=9; i_cnt < 11; i_cnt++ )
      	{
        	if ( i_err[ i_cnt ] == -1 )
        	{
          	fn_errlog( c_ServiceName, "S31140", Fstrerror32(i_ferr[i_cnt]), c_err_msg.arr  ); 
          	fn_userlog(c_ServiceName,"Unable to fget :%d:", i_cnt );
          	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr); 
          	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 ); 
          	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        	}
      	}
			}	/*** Ver 2.0 Ends ***/
		}

		i_cnt = 0;		/***** Ver 2.7 Reset to 0 to avoid error checking with wrong position ****/

		if((c_source_flg == 'C' && c_rqst_typ != ADD) || (c_source_flg == 'B' && (c_rqst_typ == 'Q' || c_rqst_typ == 'M' ) ))	/*** or condition added in Ver 2.1 ***/
		{
			if(c_source_flg == 'C')
			{
				/**** Commented in Ver 2.7 *********
				i_err[12] = Fget32( ptr_fml_Ibuf,FFO_ORDR_RFRNC, i_reccount,  
        	                 (char *)c_ffc_ordr_rfrnc, 0 );
      	i_ferr [12] = Ferror32;
				**************************************************/
				/**** Added  in Ver 2.7 Hard code 12 replaced with i_cnt as with above conditions FML position changes *********/

				i_err[i_cnt] = Fget32( ptr_fml_Ibuf,FFO_ORDR_RFRNC, i_reccount,  
        	                 (char *)c_ffc_ordr_rfrnc, 0 );
      	i_ferr [i_cnt] = Ferror32;

        if ( i_err[ i_cnt ] == -1 )
        {
          fn_errlog( c_ServiceName, "S31145", Fstrerror32(i_ferr[i_cnt]),
                                          c_err_msg.arr  );  /** VQC changed from c_err_msg to c_err_msg.arr **/
          fn_userlog(c_ServiceName,"Unable to fget :%d:", i_cnt );
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  /** VQC changed from c_err_msg to c_err_msg.arr **/
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );   /** VQC changed from c_err_msg to c_err_msg.arr **/
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }		
        fn_userlog(c_ServiceName,"After get order ref no..........:%s:", c_ffc_ordr_rfrnc);
			}
			/*** Added in Ver 2.1 ***/
			else if(c_source_flg == 'B')
			{
				/**** Commented in Ver 2.7 *********
				i_err[12] = Fget32( ptr_fml_Ibuf,FFO_ORDR_RFRNC, i_reccount,
                           (char *)c_bskt_ordr_ref, 0);
				**************************************************/

				/**** Added  in Ver 2.7 Hard code 12 replaced with i_cnt as with above conditions FML position changes *********/

				i_err[i_cnt] = Fget32( ptr_fml_Ibuf,FFO_ORDR_RFRNC, i_reccount,
                           (char *)c_bskt_ordr_ref, 0);
				i_ferr [i_cnt] = Ferror32;

				if ( i_err[ i_cnt ] == -1 )
        {
          fn_errlog( c_ServiceName, "S31150", Fstrerror32(i_ferr[i_cnt]),
                                          c_err_msg.arr  );  /** VQC changed from c_err_msg to c_err_msg.arr **/
          fn_userlog(c_ServiceName,"Unable to fget :%d:", i_cnt );
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  /** VQC changed from c_err_msg to c_err_msg.arr **/
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );   /** VQC changed from c_err_msg to c_err_msg.arr **/
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
				if( DEBUG_MSG_LVL_3 )
				{
        	fn_userlog(c_ServiceName,"After get basket order ref no..........:%s:",c_bskt_ordr_ref);
				}
			}
			/*** Ended Ver 2.1 ***/	
		}
	 	/*** Ver 1.4 Ends ***/

		/*SETLEN( sql_ffc_expry_dt );*/

     /*** Ver 2.9 Starts  Adding MIN_LOT_QT & CTGRY_INDX while request type is U***/
 
 
   if(c_source_flg == 'B' && c_rqst_typ == 'U')
   {
     if( DEBUG_MSG_LVL_3 )
    {
      fn_userlog( c_ServiceName, "exchange :%s:",st_cntrct.c_xchng_cd  );
      fn_userlog( c_ServiceName, "underlying :%s:",st_cntrct.c_undrlyng  );
      fn_userlog( c_ServiceName, "prdct_typ :%c:",st_cntrct.c_prd_typ);
      fn_userlog( c_ServiceName, "opt_typ :%c:",st_cntrct.c_opt_typ  );
      fn_userlog( c_ServiceName, "strike_price :%ld:",st_cntrct.l_strike_prc  );
      fn_userlog( c_ServiceName, "expiry_date :%s:",st_cntrct.c_expry_dt  );
    }

      if(st_cntrct.c_prd_typ == 'F')
      {
       sprintf(c_error_msg,"FUTURE-%s-%s",st_cntrct.c_undrlyng,st_cntrct.c_expry_dt);
      }
      else if(st_cntrct.c_prd_typ == 'P')
      {
       sprintf(c_error_msg,"FUTUREPLUS-%s-%s",st_cntrct.c_undrlyng,st_cntrct.c_expry_dt);
      }
      else if(st_cntrct.c_prd_typ == 'O')
      {
       sprintf(c_error_msg,"OPTION-%s-%s-%ld-%c",st_cntrct.c_undrlyng,st_cntrct.c_expry_dt,st_cntrct.l_strike_prc/100,st_cntrct.c_opt_typ);
      }
      else
      {
       MEMSET(c_err_msg.arr);
       sprintf(c_error_msg,"%s-%s-%ld-%c",st_cntrct.c_undrlyng,st_cntrct.c_expry_dt,st_cntrct.l_strike_prc/100,st_cntrct.c_opt_typ);
       /** commented in Ver 3.2 fn_errlog( c_ServiceName, "S31155", "Incorrect product type $",c_err_msg.arr); 
       sprintf(c_err_msg.arr,"Row %i |%s| Incorrect product type",i_reccount+2,c_error_msg); **/
       fn_userlog( c_ServiceName, "c_err_msg.arr :%s:",c_err_msg.arr  );
       /** Ver 3.2 Starts **/
       i_fail_flag++;
       if(i_fail_flag > 7)
       {
         fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
         Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg1.arr, 0 );
         i_fail_flag = 1;
         MEMSET(c_err_msg1.arr);
       }
       else if(i_fail_flag == 1)
       {
         sprintf(c_err_msg.arr,"Row %i | %s$Incorrect product type",i_reccount+2,c_error_msg);
         strcat(c_err_msg1.arr,c_err_msg.arr);
         fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
       }
       else if(i_fail_flag > 1 && i_fail_flag < 7)
       {
         sprintf(c_err_msg.arr,",Incorrect product type");
         strcat(c_err_msg1.arr,c_err_msg.arr);
         fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
       }  
       /** Ver 3.2 ends **/ 
       /** commented in ver 3.2 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
       tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); **/       
      }
    }

    if(c_source_flg == 'B' && c_rqst_typ == 'U')
    {
        EXEC SQL
        SELECT NVL(FTQ_MIN_LOT_QTY,0),
               FTQ_INDSTK
        INTO :l_lot_sz,
             :c_ctgry_indx
        FROM FTQ_FO_TRD_QT
        WHERE  FTQ_XCHNG_CD = :st_cntrct.c_xchng_cd
        AND FTQ_UNDRLYNG = :st_cntrct.c_undrlyng
        AND FTQ_PRDCT_TYP = DECODE(:st_cntrct.c_prd_typ,'P','F',:st_cntrct.c_prd_typ)
        AND FTQ_OPT_TYP = :st_cntrct.c_opt_typ
        AND FTQ_STRK_PRC = :st_cntrct.l_strike_prc
        AND FTQ_EXPRY_DT = :st_cntrct.c_expry_dt;

        if(SQLCODE != 0)
        {
          /** commented in ver 3.2 fn_errlog( c_ServiceName, "S31160", SQLMSG, c_err_msg.arr); **/
          /** commented in ver 3.2 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); **/
          MEMSET(c_err_msg.arr);
          /** commented in ver 3.2 sprintf(c_err_msg.arr,"Row %i |%s| Invalid contract ",i_reccount+2,c_error_msg); **/
          /** Ver 3.2 starts **/
          i_fail_flag++;
          if(i_fail_flag > 7)
          {
            fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
            Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg1.arr, 0 );
            i_fail_flag = 1;
            MEMSET(c_err_msg1.arr);
          }
          else if(i_fail_flag == 1)
          {
            sprintf(c_err_msg.arr,"Row %i | %s$Invalid contract",i_reccount+2,c_error_msg);
            strcat(c_err_msg1.arr,c_err_msg.arr);
            fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
          }
          else if(i_fail_flag > 1 && i_fail_flag < 7)
          {
            sprintf(c_err_msg.arr,",Invalid contract");
            strcat(c_err_msg1.arr,c_err_msg.arr);
            fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
          }
          Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg1.arr, 0 );
          MEMSET(c_err_msg1.arr);
          c_fail_flag = 'Y';
          continue;
          /** Ver 3.2 ends **/
          /** commented in ver 3.2 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); **/        
        }
        if ( Fadd32 (ptr_fml_Ibuf,FFO_MIN_LOT_QTY,(char *)&l_lot_sz,0) ==  -1)
        {
            fn_errlog( c_ServiceName, "S31165", FMLMSG,c_err_msg.arr  );
            fn_userlog(c_ServiceName,"Unable to fget FFO_MIN_LOT_QTY");
            fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr);
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
        if ( Fadd32 (ptr_fml_Ibuf,FFO_CTGRY_INDSTK,(char *)&c_ctgry_indx,0) ==  -1)
        {
            fn_errlog( c_ServiceName, "S31170", FMLMSG,c_err_msg.arr  );
            fn_userlog(c_ServiceName,"Unable to fget FFO_CTGRY_INDSTK");
            fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr);
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }

         st_cntrct.c_ctgry_indstk=c_ctgry_indx;

				if (c_ordr_flw != 'B'  && c_ordr_flw != 'S')  
				{
					/** commented in ver 3.2 fn_errlog( c_ServiceName, "S31175", DEFMSG, c_err_msg.arr); **/
          /** commented in ver 3.2 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); **/
          MEMSET(c_err_msg.arr);
          /** commented in ver 3.2 sprintf(c_err_msg.arr,"Row %i |%s| Invalid order flow ",i_reccount+2,c_error_msg); **/
          /** Ver 3.2 starts **/
          i_fail_flag++;
          if(i_fail_flag > 7)
          {
           fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
           Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg1.arr, 0 );
           i_fail_flag = 1;
           MEMSET(c_err_msg1.arr);
          }
          else if(i_fail_flag == 1)
          {
            sprintf(c_err_msg.arr,"Row %i | %s$Invalid order flow",i_reccount+2,c_error_msg);
            strcat(c_err_msg1.arr,c_err_msg.arr);
            fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
          }
          else if(i_fail_flag > 1 && i_fail_flag < 7)
          {
            sprintf(c_err_msg.arr,",Invalid order flow");
            strcat(c_err_msg1.arr,c_err_msg.arr);
            fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
          }
          /** Ver 3.2 ends **/
          /** commented in ver 3.2 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); **/         
				}

    }
       /*** Ver 2.9 ends ***/
   
    /*** Ver 1.3 Starts here ******/
    c_scd_prcs_flg ='Y';
    EXEC SQL
      SELECT  NVL(SCD_PRCS_FLG,'N')
      INTO    :c_scd_prcs_flg
      FROM    SCD_STOCK_CHNG_DTLS
      WHERE   SCD_OLD_STK_CD = :st_cntrct.c_undrlyng;

    if(SQLCODE != 0 && SQLCODE != NO_DATA_FOUND)
    {
			/** Ver 2.9 starts ***/
      if(c_source_flg == 'B' && c_rqst_typ == 'U')
      {
         /** commented in ver 3.2 fn_errlog( c_ServiceName, "S31180", SQLMSG, c_err_msg.arr); **/
         /** commented in ver 3.2 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); **/
         MEMSET(c_err_msg.arr);
         /** commented in ver 3.2 sprintf(c_err_msg.arr,"Row %i |%s| Invalid Underlying ",i_reccount+2,c_error_msg); **/
         /** Ver 3.2 starts **/
         i_fail_flag++;
         if(i_fail_flag > 7)
         {
           fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
           Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg1.arr, 0 );
           i_fail_flag = 1;
           MEMSET(c_err_msg1.arr);
         }
         else if(i_fail_flag == 1)
         {
           sprintf(c_err_msg.arr,"Row %i | %s$Invalid Underlying",i_reccount+2,c_error_msg);
           strcat(c_err_msg1.arr,c_err_msg.arr);
           fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
         }
         else if(i_fail_flag > 1 && i_fail_flag < 7)
         {
           sprintf(c_err_msg.arr,",Invalid Underlying");
           strcat(c_err_msg1.arr,c_err_msg.arr);
           fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
         }
         /** Ver 3.2 ends **/
         /** commented in ver 3.2 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
         tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); **/        
      }
       else
       { /** Ver 2.9 ends ***/
      	fn_errlog( c_ServiceName, "S31185", SQLMSG, c_err_msg.arr  );  /** VQC changed from c_err_msg to c_err_msg.arr **/
      	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  /** VQC changed from c_err_msg to c_err_msg.arr **/
      	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );    /** VQC changed from c_err_msg to c_err_msg.arr **/
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
    }

    if(c_scd_prcs_flg != 'Y')
    {
			/** Ver 2.9 starts ***/
      if(c_source_flg == 'B' && c_rqst_typ == 'U')
      {
         fn_errlog( c_ServiceName, "S31190", SQLMSG, c_err_msg.arr);
         /** commented in ver 3.2 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); **/
         MEMSET(c_err_msg.arr);
         /** commented in ver 3.2 sprintf(c_err_msg.arr,"Row %i |%s| This stock is not available for updation currently ",i_reccount+2,c_error_msg); **/
         /** Ver 3.2 starts **/
         i_fail_flag++;
         if(i_fail_flag > 7)
         {
           fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
           Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg1.arr, 0 );
           i_fail_flag = 1;
           MEMSET(c_err_msg1.arr);
         }
         else if(i_fail_flag == 1)
         {
           sprintf(c_err_msg.arr,"Row %i | %s$This stock is not available for updation currently",i_reccount+2,c_error_msg);
           strcat(c_err_msg1.arr,c_err_msg.arr);
           fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
         }
         else if(i_fail_flag > 1 && i_fail_flag < 7)
         {
           sprintf(c_err_msg.arr,",This stock is not available for updation currently");
           strcat(c_err_msg1.arr,c_err_msg.arr);
           fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
         }
         /** Ver 3.2 ends **/
         /** commented in ver 3.2 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
         tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); **/        
      }
       else
       { /** Ver 2.9 ends ***/
      	fn_errlog( c_ServiceName, "S31195", " ", c_err_msg.arr  ) ;  /** VQC changed from c_err_msg to c_err_msg.arr **/
      	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  /** VQC changed from c_err_msg to c_err_msg.arr **/
      	MEMSET(c_err_msg.arr);  /** VQC changed from c_err_msg to c_err_msg.arr **/
      	sprintf(c_err_msg.arr,"This stock is not available for updation currently. Please try after some time");
      	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  /** VQC changed from c_err_msg to c_err_msg.arr **/
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
    } 
    /*** Ver 1.3 Ends here *****/
		if( DEBUG_MSG_LVL_3 )
		{
    	fn_userlog ( c_ServiceName,"Suchita c_source_flg :%c: c_rqst_typ :%c:",c_source_flg,c_rqst_typ);
		}
		if ( c_rqst_typ == ADD || c_rqst_typ == 'H' || c_rqst_typ == 'Z'|| c_rqst_typ == 'U')	
                             	/*** or condition is added in Ver 2.1 ***/ /*** ver 2.3 ***/ /*** Ver 2.9 U request type is added ***/
		{
      i_record_exists = 0;
 
      if(c_source_flg == 'C' || c_source_flg == 'B')				/** if() added in Ver 1.4 **/	/*** or condition is added in Ver 2.1 ***/
			{
        
      	/******** Ver 1.9 Starts ************/

        EXEC SQL
          SELECT nvl(FUM_SLTPFP_LMT_ALLWD_FLG,'N'),
                 nvl(FUM_SLTP_FP_TRDNG_FLG, 'N'),
								 nvl(FUM_QT_TRDNG_FLG,'N'),						/** Ver 2.0 **/
								 nvl(FUM_FP_TRDNG_FLG,'N')						/** Ver 2.0 **/
          INTO  :c_lmt_allwd_flg,
                :c_fum_sltp_alwd_flg,
								:c_fum_qt_trdng_flg,									/** Ver 2.0 **/
								:c_fum_fp_trdng_flg										/** Ver 2.0 **/
          FROM  FUM_FO_UNDRLYNG_MSTR
          WHERE FUM_XCHNG_CD    = :st_cntrct.c_xchng_cd
          AND   FUM_UNDRLYNG    = :st_cntrct.c_undrlyng
          AND   FUM_PRDCT_TYP   =	decode(:st_cntrct.c_prd_typ,'U','F','I','O','P','F',:st_cntrct.c_prd_typ); /** Added core products in Ver 2.0 **/ 

        if(SQLCODE != 0)
       	{		/*** Ver 2.9 Added ***/
          if(c_source_flg == 'B' && c_rqst_typ == 'U')
          {
            /** commented in ver 3.2 fn_errlog( c_ServiceName, "S31200", SQLMSG, c_err_msg.arr); **/
            /** commented in ver 3.2 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); **/
            MEMSET(c_err_msg.arr);
            /** commented in ver 3.2 sprintf(c_err_msg.arr,"Row %i |%s| Invalid Contract ",i_reccount+2,c_error_msg); **/
            /** Ver 3.2 starts **/
            i_fail_flag++;
            if(i_fail_flag > 7)
            {
              fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
              Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg1.arr, 0 );
              i_fail_flag = 1;
              MEMSET(c_err_msg1.arr);
            }
            else if(i_fail_flag == 1)
            {
              sprintf(c_err_msg.arr,"Row %i | %s$Invalid Contract",i_reccount+2,c_error_msg);
              strcat(c_err_msg1.arr,c_err_msg.arr);
              fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
            }
            else if(i_fail_flag > 1 && i_fail_flag < 7)
            {
              sprintf(c_err_msg.arr,",Invalid Contract");
              strcat(c_err_msg1.arr,c_err_msg.arr);
              fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
            }
            /** Ver 3.2 ends **/         
            /** commented in ver 3.2 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); **/           
          }
          else
          {	/*** Ver 2.9 End ***/
          fn_errlog( c_ServiceName, "S31205", SQLMSG, c_err_msg.arr);
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr);
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); 
          }
        }

			if( DEBUG_MSG_LVL_3 )
			{
      	fn_userlog(c_ServiceName,"c_fum_sltp_alwd_flg:%c:,st_cntrct.c_prd_typ:%c:", c_fum_sltp_alwd_flg,st_cntrct.c_prd_typ);
			}

        if( (c_fum_sltp_alwd_flg != 'T') && (st_cntrct.c_prd_typ == 'U' || st_cntrct.c_prd_typ == 'I')) /*** SLTP FP/OP Underlying Level Flag Checked ***/ /*** st_cntrct.c_prd_typ added in Ver 2.0 ***/
        {
          fn_errlog( c_ServiceName, "S31210", " Underlying Is Not Enabled For This Product.",c_err_msg.arr);
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr);
          MEMSET(c_err_msg.arr);
          sprintf(c_err_msg.arr,"Underlying Is Not Enabled For This Product"); 
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); 
         }
				/*** Ver 2.0 Starts ***/
			
				if((c_fum_qt_trdng_flg != 'T') && (st_cntrct.c_prd_typ == 'F' || st_cntrct.c_prd_typ == 'O'))
				{
          /** Ver 2.9 starts ***/
          if(c_source_flg == 'B' && c_rqst_typ == 'U')
          {
            /** commented in ver 3.2 fn_errlog( c_ServiceName, "S31215", SQLMSG, c_err_msg.arr); **/
            /** commented in ver 3.2 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); **/
            MEMSET(c_err_msg.arr);
            /** commented in ver 3.2 sprintf(c_err_msg.arr,"Row %i |%s| Contract is not enabled for trading ",i_reccount+2,c_error_msg); **/
            /** Ver 3.2 starts **/
            i_fail_flag++;
            if(i_fail_flag > 7)
            {
              fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
              Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg1.arr, 0 );
              i_fail_flag = 1;
              MEMSET(c_err_msg1.arr);
            }
            else if(i_fail_flag == 1)
            {
              sprintf(c_err_msg.arr,"Row %i | %s$Contract is not enabled for trading",i_reccount+2,c_error_msg);
              strcat(c_err_msg1.arr,c_err_msg.arr);
              fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
            }
            else if(i_fail_flag > 1 && i_fail_flag < 7)
            {
              sprintf(c_err_msg.arr,",Contract is not enabled for trading");
              strcat(c_err_msg1.arr,c_err_msg.arr);
              fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
            }
            /** Ver 3.2 ends **/          
            /** commented in ver 3.2 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); **/           
          }
          else
          { /** Ver 2.9 ends ***/
          fn_errlog( c_ServiceName, "S31220", "Underlying Is Not Enabled For This Product.",c_err_msg.arr);
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr);
          MEMSET(c_err_msg.arr);
          sprintf(c_err_msg.arr,"Underlying Is Not Enabled For This Product."); 
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );  
          }
				}
				
				if(c_fum_fp_trdng_flg != 'T' && st_cntrct.c_prd_typ == 'P')
				{
          /** Ver 2.9 starts ***/
        	if(c_source_flg == 'B' && c_rqst_typ == 'U')
          {
            /** commented in ver 3.2 fn_errlog( c_ServiceName, "S31225", SQLMSG, c_err_msg.arr); **/
            /** commented in ver 3.2 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); **/
            MEMSET(c_err_msg.arr);
            /** commented in ver 3.2 sprintf(c_err_msg.arr,"Row %i |%s| Contract is not enabled for trading ",i_reccount+2,c_error_msg); **/
            /** Ver 3.2 starts **/
            i_fail_flag++;
            if(i_fail_flag > 7)
            {
              fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
              Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg1.arr, 0 );
              i_fail_flag = 1;
              MEMSET(c_err_msg1.arr);
            }
            else if(i_fail_flag == 1)
            {
              sprintf(c_err_msg.arr,"Row %i | %s$Contract is not enabled for trading",i_reccount+2,c_error_msg);
              strcat(c_err_msg1.arr,c_err_msg.arr);
              fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
            }
            else if(i_fail_flag > 1 && i_fail_flag < 7)
            {
              sprintf(c_err_msg.arr,",Contract is not enabled for trading");
              strcat(c_err_msg1.arr,c_err_msg.arr);
              fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
            }
            /** Ver 3.2 ends **/          
            /** commented in ver 3.2 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); **/           
          }
          else
          { /** Ver 2.9 ends **/
          fn_errlog( c_ServiceName, "S31230", "Underlying Is Not Enabled For This Product.",c_err_msg.arr);
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr);
          MEMSET(c_err_msg.arr);
          sprintf(c_err_msg.arr,"Underlying Is Not Enabled For This Product."); 
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); 
          }
				}
				/*** Ver 2.0 Ends ***/
        if(c_lmt_allwd_flg == 'N' && c_lmt_mktsl_flg == 'L' && (st_cntrct.c_prd_typ=='U' || st_cntrct.c_prd_typ=='I')) /** Product type hadled in Ver 2.0 **/
        {
          fn_errlog( c_ServiceName, "S31235", "Limit orders are not allowed in this contract.", c_err_msg.arr);
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr);
          MEMSET(c_err_msg.arr);
          sprintf(c_err_msg.arr,"Limit orders are not allowed in this contract."); 
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }

      	/******* Ver 1.9 Ends *****************/
			
       /**** Ver 1.5 Starts here *******/
       i_valid_cntrct=0;
       /*** Ver 2.9 Starts  ***/
        if( DEBUG_MSG_LVL_3 )
        {
         fn_userlog( c_ServiceName, "exchange :%s:",st_cntrct.c_xchng_cd  );
         fn_userlog( c_ServiceName, "underlying :%s:",st_cntrct.c_undrlyng  );
         fn_userlog( c_ServiceName, "prdct_typ :%c:",st_cntrct.c_prd_typ);
         fn_userlog( c_ServiceName, "opt_typ :%c:",st_cntrct.c_opt_typ  );
         fn_userlog( c_ServiceName, "strike_price :%ld:",st_cntrct.l_strike_prc  );
         fn_userlog( c_ServiceName, "expiry_date :%s:",st_cntrct.c_expry_dt  );
        }
        /*** Ver 2.9 ends ***/       

       EXEC SQL
          SELECT /** count(1)	 Commented in ver 1.9 **/
                 1,                                      /*** Added in Ver 1.9 ***/
                 NVL(FTQ_SLTP_FP_QT_TRDNG_FLG, 'Q'),     /*** Added in Ver 1.9 ***/								 		
								 NVL(FTQ_QT_TRDNG_FLG,'Q'),							 /*** Added in Ver 2.0 ***/
								 NVL(FTQ_FP_QT_TRDNG_FLG,'Q') 					 /*** Added in Ver 2.0 ***/
          INTO :i_valid_cntrct,
                 :c_ftq_sltp_alwd_flg,                   /*** Added in Ver 1.9 ***/
								 :c_ftq_qt_trdng_flg,										 /*** Added in Ver 2.0 ***/
								 :c_ftq_fp_qt_trdng_flg 								 /*** Added in Ver 2.0 ***/					
             FROM FTQ_FO_TRD_QT
           WHERE FTQ_XCHNG_CD =:st_cntrct.c_xchng_cd
             AND FTQ_PRDCT_TYP =DECODE(:st_cntrct.c_prd_typ,'I','O','U','F','P','F',:st_cntrct.c_prd_typ)
             AND FTQ_UNDRLYNG =:st_cntrct.c_undrlyng
             AND FTQ_EXPRY_DT =to_date( :st_cntrct.c_expry_dt, 'DD-Mon-yyyy')
             AND FTQ_EXER_TYP =:st_cntrct.c_exrc_typ
             AND FTQ_OPT_TYP  =:st_cntrct.c_opt_typ
             AND FTQ_STRK_PRC =:st_cntrct.l_strike_prc;

        if (  SQLCODE != 0 )
        {
          /** Ver 2.9 starts ***/
          if(c_source_flg == 'B' && c_rqst_typ == 'U')
          {
            /** commented in ver 3.2 fn_errlog( c_ServiceName, "S31240", SQLMSG, c_err_msg.arr); **/
            /** commented in ver 3.2 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); **/
            MEMSET(c_err_msg.arr);
            /** commented in ver 3.2 sprintf(c_err_msg.arr,"Row %i |%s| Contract is invalid ",i_reccount+2,c_error_msg); **/
            /** Ver 3.2 starts **/
            i_fail_flag++;
            if(i_fail_flag > 7)
            {
              fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
              Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg1.arr, 0 );
              i_fail_flag = 1;
              MEMSET(c_err_msg1.arr);
            }
            else if(i_fail_flag == 1)
            {
              sprintf(c_err_msg.arr,"Row %i | %s$Contract is invalid",i_reccount+2,c_error_msg);
              strcat(c_err_msg1.arr,c_err_msg.arr);
              fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
            }
            else if(i_fail_flag > 1 && i_fail_flag < 7)
            {
              sprintf(c_err_msg.arr,",Contract is invalid");
              strcat(c_err_msg1.arr,c_err_msg.arr);
              fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
            }
            /** Ver 3.2 ends **/
            /** commented in ver 3.2 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); **/           
          }
          else
          { /** Ver 2.9 ends **/
          fn_errlog( c_ServiceName, "S31245", SQLMSG, c_err_msg.arr);  /** VQC changed from c_err_msg to c_err_msg.arr **/
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr);  /** VQC changed from c_err_msg to c_err_msg.arr **/
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  /** VQC changed from c_err_msg to c_err_msg.arr **/
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); 
          }
        }

				if( (c_ftq_sltp_alwd_flg != 'T') && (st_cntrct.c_prd_typ == 'U' || st_cntrct.c_prd_typ == 'I')) /*** Added in Ver 1.9 ***/ /*** st_cntrct.c_prd_typ added in Ver 2.0 ***/
        {
          if(st_cntrct.c_prd_typ == 'U')
          {
            fn_errlog( c_ServiceName, "S31250", "This contract is not enabled for SLTP FP", c_err_msg.arr);
            MEMSET(c_err_msg.arr);
            sprintf(c_err_msg.arr,"This contract is not enabled for SLTP FP");
          }

          else if(st_cntrct.c_prd_typ == 'I')
          {
            fn_errlog( c_ServiceName, "S31255", "This contract is not enabled for SLTP OP", c_err_msg.arr);
            MEMSET(c_err_msg.arr);
            sprintf(c_err_msg.arr,"This contract is not enabled for SLTP OP");
          }

          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr);
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }

				/**** Ver 2.0 Starts Here ****/
        if((c_ftq_qt_trdng_flg != 'T') && (st_cntrct.c_prd_typ == 'F' || st_cntrct.c_prd_typ == 'O')) 
        {
          if(st_cntrct.c_prd_typ == 'F')
          {
            /** Ver 2.9 starts ***/
            if(c_source_flg == 'B' && c_rqst_typ == 'U')
            {
             /** commented in ver 3.2 fn_errlog( c_ServiceName, "S31260", SQLMSG, c_err_msg.arr); **/
             MEMSET(c_err_msg.arr);
             /** commented in ver 3.2 sprintf(c_err_msg.arr,"Row %i |%s| This contract is not enabled for Future ",i_reccount+2,c_error_msg); **/
            }
            else
            { /** Ver 2.9 ends **/ 
             fn_errlog( c_ServiceName, "S31265", "This contract is not enabled for Future", c_err_msg.arr);
             MEMSET(c_err_msg.arr);
             sprintf(c_err_msg.arr,"This contract is not enabled for Future");
            }
         }
          else if(st_cntrct.c_prd_typ == 'O')
          {
            /** Ver 2.9 starts ***/
             if(c_source_flg == 'B' && c_rqst_typ == 'U')
             {
               /** commented in ver 3.2 fn_errlog( c_ServiceName, "S31270", SQLMSG, c_err_msg.arr); **/
               MEMSET(c_err_msg.arr);
               /** commented in ver 3.2 sprintf(c_err_msg.arr,"Row %i |%s| This contract is not enabled for Option ",i_reccount+2,c_error_msg); **/
             }
             else
             { /** Ver 2.9 ends **/ 
                fn_errlog( c_ServiceName, "S31275", "This contract is not enabled for Option", c_err_msg.arr);
                MEMSET(c_err_msg.arr);
                sprintf(c_err_msg.arr,"This contract is not enabled for Option");
              }
            }
          /** Ver 3.2 starts **/
         if(c_source_flg == 'B' && c_rqst_typ == 'U')
         {
          i_fail_flag++;
          if(i_fail_flag > 7)
          {
           fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
           Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg1.arr, 0 );
           i_fail_flag = 1;
           MEMSET(c_err_msg1.arr);
          }
          else if(i_fail_flag == 1)
          {
            sprintf(c_err_msg.arr,"Row %i | %s$This contract is not enabled for trading",i_reccount+2,c_error_msg);
            strcat(c_err_msg1.arr,c_err_msg.arr);
            fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
          }
          else if(i_fail_flag > 1 && i_fail_flag < 7)
          {
            sprintf(c_err_msg.arr,",This contract is not enabled for trading");
            strcat(c_err_msg1.arr,c_err_msg.arr);
            fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
          }
			   }
         else
         { /** Ver 3.2 ends **/
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr);
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
         }	
       }

				if(c_ftq_fp_qt_trdng_flg != 'T' && st_cntrct.c_prd_typ == 'P')
				{
          /** Ver 2.9 starts ***/
          if(c_source_flg == 'B' && c_rqst_typ == 'U')
          {
            /** commented in ver 3.2 fn_errlog( c_ServiceName, "S31280", SQLMSG, c_err_msg.arr); **/
            /** commented in ver 3.2 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); **/
            MEMSET(c_err_msg.arr);
            /** commented in ver 3.2 sprintf(c_err_msg.arr,"Row %i |%s| This contract is not enabled for FuturePLUS ",i_reccount+2,c_error_msg); **/
            /** Ver 3.2 starts **/
            i_fail_flag++;
            if(i_fail_flag > 7)
            {
              fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
              Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg1.arr, 0 );
              i_fail_flag = 1;
              MEMSET(c_err_msg1.arr);
            }
            else if(i_fail_flag == 1)
            {
              sprintf(c_err_msg.arr,"Row %i | %s$This contract is not enabled for FuturePLUS",i_reccount+2,c_error_msg);
              strcat(c_err_msg1.arr,c_err_msg.arr);
              fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
            }
            else if(i_fail_flag > 1 && i_fail_flag < 7)
            {
              sprintf(c_err_msg.arr,",This contract is not enabled for FuturePLUS");
              strcat(c_err_msg1.arr,c_err_msg.arr);
              fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
            }
            /** Ver 3.2 ends **/
            /** commented in ver 3.2 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); **/           
          }
          else
          { /** Ver 2.9 ends **/
            fn_errlog( c_ServiceName, "S31285", "This contract is not enabled for FuturePLUS", c_err_msg.arr);
            MEMSET(c_err_msg.arr);
            sprintf(c_err_msg.arr,"This contract is not enabled for FuturePLUS"); 
            fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr);
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); 
          }
				}
				/**** Ver 2.0 Ends Here ****/

        if( i_valid_cntrct == 0 )
        {
          /** Ver 2.9 starts ***/
          if(c_source_flg == 'B' && c_rqst_typ == 'U')
          {
            /** commented in ver 3.2 fn_errlog( c_ServiceName, "S31290", SQLMSG, c_err_msg.arr); **/
            /** commented in ver 3.2 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); **/
            MEMSET(c_err_msg.arr);
            /** commented in ver 3.2 sprintf(c_err_msg.arr,"Row %i |%s| Invalid Combination of contract, pls check and try again ",i_reccount+2,c_error_msg); **/
            /** Ver 3.2 starts **/
            i_fail_flag++;
            if(i_fail_flag > 7)
            {
              fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
              Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg1.arr, 0 );
              i_fail_flag = 1;
              MEMSET(c_err_msg1.arr);
            }
            else if(i_fail_flag == 1)
            {
              sprintf(c_err_msg.arr,"Row %i | %s$Invalid Combination of contract",i_reccount+2,c_error_msg);
              strcat(c_err_msg1.arr,c_err_msg.arr);
              fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
            }
            else if(i_fail_flag > 1 && i_fail_flag < 7)
            {
              sprintf(c_err_msg.arr,",Invalid Combination of contract");
              strcat(c_err_msg1.arr,c_err_msg.arr);
              fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
            }
            /** Ver 3.2 ends **/           
            /** commented in ver 3.2 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); **/           
          }
          else
          { /** Ver 2.9 ends **/
            fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  /** VQC changed from c_err_msg to c_err_msg.arr **/
            MEMSET(c_err_msg.arr);  /** VQC changed from c_err_msg to c_err_msg.arr **/
            strcpy(c_err_msg.arr,"Invalid Combination of contract, pls check and try again.");
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  /** VQC changed from c_err_msg to c_err_msg.arr **/
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          } 
         }
        /***** Ver 1.5 Ends Here ***************/
 
       /*** Ver 2.9 Starts Quantity Check and Limit Price Check ***/
         if( DEBUG_MSG_LVL_3 )
         {
          fn_userlog( c_ServiceName, "l_cvr_lmt_rt:%ld: ",l_cvr_lmt_rt );
          fn_userlog( c_ServiceName, "sql_fum_freeze_qty:%ld:",sql_fum_freeze_qty  );
          fn_userlog( c_ServiceName, "l_lot_sz:%ld:",l_lot_sz  );
          fn_userlog( c_ServiceName, "l_ordr_qty:%ld:",l_ordr_qty  );
         }
      if(c_source_flg == 'B' && c_rqst_typ == 'U')
      {
        if((c_lmt_mktsl_flg == 'M' && l_cvr_lmt_rt != 0)||(c_lmt_mktsl_flg == 'L' && l_cvr_lmt_rt <= 0))
                                                                         /** Market flag is added in Ver 3.2 **/
        {
          /** commented in ver 3.2 fn_errlog( c_ServiceName, "S31295", DEFMSG, c_err_msg.arr); **/
          /** commented in ver 3.2 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); **/
          MEMSET(c_err_msg.arr);
          /** commented in ver 3.2 sprintf(c_err_msg.arr,"Row %i |%s| Please enter positive limit rate ",i_reccount+2,c_error_msg );*/
          /** Ver 3.2 starts **/
          i_fail_flag++;
          if(i_fail_flag > 7)
          {
           fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
           Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg1.arr, 0 );
           i_fail_flag = 1;
           MEMSET(c_err_msg1.arr);
          }
          else if(i_fail_flag == 1)
          {
            sprintf(c_err_msg.arr,"Row %i | %s$Please enter positive limit rate",i_reccount+2,c_error_msg);
            strcat(c_err_msg1.arr,c_err_msg.arr);
            fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
          }
          else if(i_fail_flag > 1 && i_fail_flag < 7)
          {
            sprintf(c_err_msg.arr,",Please enter positive limit rate");
            strcat(c_err_msg1.arr,c_err_msg.arr);
            fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
          }
          /** Ver 3.2 ends **/       
          /** commented in ver 3.2 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); **/         
        }

        EXEC SQL
        SELECT FUM_FREEZE_QTY
        INTO   :sql_fum_freeze_qty
        FROM   FUM_FO_UNDRLYNG_MSTR
        WHERE  FUM_XCHNG_CD   = :st_cntrct.c_xchng_cd 
        AND    FUM_PRDCT_TYP  = decode(:st_cntrct.c_prd_typ,'U','F','I','O','P','F',:st_cntrct.c_prd_typ)
        AND    FUM_UNDRLYNG   = :st_cntrct.c_undrlyng;

        if ( SQLCODE != 0 )
       {
        /** commented in ver 3.2 fn_errlog( c_ServiceName, "S31300", SQLMSG, c_err_msg.arr ); **/
        /** commented in ver 3.2 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); **/
        MEMSET(c_err_msg.arr);
        /** Commented in ver 3.2 sprintf(c_err_msg.arr,"Row %i |%s| Maximum qty per order for stock allowed by the exchange is %ld $",i_reccount+2,c_error_msg,sql_fum_freeze_qty ); **/
        /** Ver 3.2 starts **/
        i_fail_flag++;
        if(i_fail_flag > 7)
        {
          fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
          Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg1.arr, 0 );
          i_fail_flag = 1;
          MEMSET(c_err_msg1.arr);
        }
        else if(i_fail_flag == 1)
        {
          sprintf(c_err_msg.arr,"Row %i | %s$Invalid Contract",i_reccount+2,c_error_msg);
          strcat(c_err_msg1.arr,c_err_msg.arr);
          fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
        }
        else if(i_fail_flag > 1 && i_fail_flag < 7)
        {
          sprintf(c_err_msg.arr,",Invalid Contract");
          strcat(c_err_msg1.arr,c_err_msg.arr);
          fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
        }
        /** Ver 3.2 ends **/      
        /** commented in ver 3.2 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); **/       
       }
       
       if( l_ordr_qty  > sql_fum_freeze_qty && sql_fum_freeze_qty != 0 )
       {
        /** commented in ver 3.2 fn_errlog( c_ServiceName, "S31305",DEFMSG,c_err_msg.arr ); **/
        /** commented in ver 3.2 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); **/
        MEMSET(c_err_msg.arr);
        /** commented in ver 3.2 sprintf(c_err_msg.arr,"Row %i |%s| Maximum qty per order for this stock allowed by the exchange is %ld ",i_reccount+2,c_error_msg,sql_fum_freeze_qty ); **/
        /** Ver 3.2 starts **/
        i_fail_flag++;
        if(i_fail_flag > 7)
        {
          fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
          Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg1.arr, 0 );
          i_fail_flag = 1;
          MEMSET(c_err_msg1.arr);
        }
        else if(i_fail_flag == 1)
        {
          sprintf(c_err_msg.arr,"Row %i | %s$Maximum qty per order for this stock allowed by the exchange is %ld",i_reccount+2,c_error_msg,sql_fum_freeze_qty);
          strcat(c_err_msg1.arr,c_err_msg.arr);
          fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
        }
        else if(i_fail_flag > 1 && i_fail_flag < 7)
        {
          sprintf(c_err_msg.arr,",Maximum qty per order for this stock allowed by the exchange is %ld",sql_fum_freeze_qty);
          strcat(c_err_msg1.arr,c_err_msg.arr);
          fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
        }
        /** Ver 3.2 ends **/
        /** commented in ver 3.2 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); **/       
       }
       if ( l_ordr_qty % l_lot_sz != 0 )
       { 
          /** commented in ver 3.2 fn_errlog( c_ServiceName, "S31310", DEFMSG, c_err_msg.arr); **/
          /** commented in ver 3.2 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); **/
          MEMSET(c_err_msg.arr);
          /** commented in ver 3.2 sprintf(c_err_msg.arr,"Row %i |%s| Please enter quantity in multiples of %ld ",i_reccount+2,c_error_msg,l_lot_sz ); **/
          /*Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg.arr, 0 ); * Ver 3.2 */
          /** Ver 3.2 starts **/
          i_fail_flag++;
          if(i_fail_flag > 7)
          {
           fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
           Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg1.arr, 0 );
           i_fail_flag = 1;
           MEMSET(c_err_msg1.arr);
          }
          else if(i_fail_flag == 1)
          {
            sprintf(c_err_msg.arr,"Row %i | %s$Please enter quantity in multiples of %ld",i_reccount+2,c_error_msg,l_lot_sz ); 
            strcat(c_err_msg1.arr,c_err_msg.arr);
            fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
          }
          else if(i_fail_flag > 1 && i_fail_flag < 7)
          {
            sprintf(c_err_msg.arr,",Please enter quantity in multiples of %ld",l_lot_sz ); 
            strcat(c_err_msg1.arr,c_err_msg.arr);
            fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
          }
          /** Ver 3.2 ends **/         
          /** commented in ver 3.2 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); **/         
       }

        if ( l_ordr_qty <= 0)
        {
          /** commented in ver 3.2 fn_errlog( c_ServiceName, "S31315", DEFMSG, c_err_msg.arr); **/
          /** commented in ver 3.2 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); **/
          MEMSET(c_err_msg.arr);
          /** commented in ver 3.2 sprintf(c_err_msg.arr,"Row %i |%s| Please enter positive quantity ",i_reccount+2,c_error_msg ); **/
          /*Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg.arr, 0 ); * Ver 3.2 */
          /** Ver 3.2 starts **/
          i_fail_flag++;
          if(i_fail_flag > 7)
          {
           fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
           Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg1.arr, 0 );
           i_fail_flag = 1;
           MEMSET(c_err_msg1.arr);
          }
          else if(i_fail_flag == 1)
          {
            sprintf(c_err_msg.arr,"Row %i | %s$Please enter positive quantity",i_reccount+2,c_error_msg); 
            strcat(c_err_msg1.arr,c_err_msg.arr);
            fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
          }
          else if(i_fail_flag > 1 && i_fail_flag < 7)
          {
            sprintf(c_err_msg.arr,",Please enter positive quantity"); 
            strcat(c_err_msg1.arr,c_err_msg.arr);
            fn_userlog(c_ServiceName, "i_fail_flag = %d, %s",i_fail_flag,c_err_msg1.arr);
          }
          /** Ver 3.2 ends **/         
          /** commented in ver 3.2 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); **/         
        }
     
        
        /*** if(c_lmt_mktsl_flg != 'M' && c_lmt_mktsl_flg != 'L')
        {
          fn_errlog( c_ServiceName, "S31320", DEFMSG, c_err_msg.arr);
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
          MEMSET(c_err_msg.arr);
          sprintf(c_err_msg.arr,"Row %i |%s| Please enter correct order type ", i_reccount+2 ,c_error_msg );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        } ***/  
      
       }
       /*** Ver 2.9 ends ***/     

			if(c_source_flg == 'B')		/*** if condition added in Ver 2.1 ***/
			{
				EXEC SQL
             SELECT 1
             INTO :i_record_exists
             FROM
             FBC_FO_BSKT_CNTRCT_LST
             WHERE FBC_USR_ID    =  :sql_ffc_usr_id
             AND FBC_XCHNG_CD     =  :st_cntrct.c_xchng_cd
             AND FBC_PRDCT_TYP    =  :st_cntrct.c_prd_typ
             AND FBC_UNDRLYNG     =  :st_cntrct.c_undrlyng
             AND FBC_EXPRY_DT     =  to_date( :st_cntrct.c_expry_dt, 'DD-Mon-yyyy')
             AND FBC_EXER_TYP     =  :st_cntrct.c_exrc_typ
             AND FBC_OPT_TYP      =  :st_cntrct.c_opt_typ
             AND FBC_STRK_PRC     =  :st_cntrct.l_strike_prc
             AND FBC_LOT_SZ       =  :l_lot_sz
             AND FBC_INDSTK       =  :st_cntrct.c_ctgry_indstk
             AND FBC_ORDR_TOT_QTY =  :l_ordr_qty
             AND FBC_LMT_MRKT_FLG =  :c_lmt_mktsl_flg
             AND FBC_CVR_SLTP_RT	=  :l_cvr_sltp_rt
             AND FBC_SRC_TYP      =  :c_source_flg
             AND    FBC_BSKT_ID    = :c_bskt_id; /** suchita **/
			}
			else
			{
        EXEC SQL
             SELECT 1
             INTO :i_record_exists
             FROM
             FFC_FO_FVRT_CNTRCT_LST
             WHERE FFC_USR_ID 		=  :sql_ffc_usr_id
             AND FFC_XCHNG_CD 		=  :st_cntrct.c_xchng_cd
             AND FFC_PRDCT_TYP		=  :st_cntrct.c_prd_typ
             AND FFC_UNDRLYNG 		=  :st_cntrct.c_undrlyng
             AND FFC_EXPRY_DT 		=  to_date( :st_cntrct.c_expry_dt, 'DD-Mon-yyyy')
             AND FFC_EXER_TYP 		=  :st_cntrct.c_exrc_typ
             AND FFC_OPT_TYP  		=  :st_cntrct.c_opt_typ
             AND FFC_STRK_PRC 		=  :st_cntrct.l_strike_prc
             AND FFC_LOT_SZ   		=  :l_lot_sz
             AND FFC_INDSTK   		=  :st_cntrct.c_ctgry_indstk
						 AND FFC_ORDR_QTY			=	 :l_ordr_qty									
		         AND FFC_LMT_MRKT_FLG =	 :c_lmt_mktsl_flg						
          	 AND FFC_CVR_SLTP_DIFF=	 :d_cvr_sltp_diff
          	 AND FFC_RQST_TYP			=	 :c_source_flg;           
			}
			
				if( DEBUG_MSG_LVL_3 )
				{
					fn_userlog(c_ServiceName,"i_record_exists:%d:",i_record_exists);
				} 
			}
			else
			{

        /***** Ver 1.6 Starts Here *****/
       if( st_cntrct.c_prd_typ == 'P' )
       {
          fn_errlog( c_ServiceName, "S31325", "Invalid Combination of contract, pls check and try again.", c_err_msg.arr  );
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr);  /** VQC changed from c_err_msg to c_err_msg.arr **/
          MEMSET(c_err_msg.arr); /** VQC changed from c_err_msg to c_err_msg.arr **/
          sprintf(c_err_msg.arr,"Invalid Combination of contract, pls check and try again.");
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  /** VQC changed from c_err_msg to c_err_msg.arr **/
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
       }
       /***** Ver 1.6 Ends Here *******/
			if(c_source_flg != 'B') /*** ver 2.4 ***/
      {
      	EXEC SQL
        	   SELECT 1
          	 INTO :i_record_exists
             FROM 
             FFC_FO_FVRT_CNTRCT_LST
             WHERE FFC_USR_ID =  :sql_ffc_usr_id
       	 	   AND FFC_XCHNG_CD =  :st_cntrct.c_xchng_cd
       	 	   AND FFC_PRDCT_TYP=  :st_cntrct.c_prd_typ
       	 	   AND FFC_UNDRLYNG =  :st_cntrct.c_undrlyng
       	 	   AND FFC_EXPRY_DT =  to_date( :st_cntrct.c_expry_dt, 'DD-Mon-yyyy')
       	 	   AND FFC_EXER_TYP =	 :st_cntrct.c_exrc_typ
       	 	   AND FFC_OPT_TYP  =  :st_cntrct.c_opt_typ
       	 	   AND FFC_STRK_PRC =  :st_cntrct.l_strike_prc
       	 	   AND FFC_LOT_SZ 	=  :l_lot_sz
       	 	   AND FFC_INDSTK   =  :st_cntrct.c_ctgry_indstk
						 And FFC_RQST_TYP	=	 :c_source_flg;									/** Ver 1.4 **/
			}
			if(c_source_flg != 'B') /*** ver 2.4 ***/
      {
      	if ( ( SQLCODE != 0 ) && ( SQLCODE != NO_DATA_FOUND ) )
      	{
       	 fn_errlog( c_ServiceName, "S31330", SQLMSG, c_err_msg.arr  );  /** VQC changed from c_err_msg to c_err_msg.arr **/
       	 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  /** VQC changed from c_err_msg to c_err_msg.arr **/
       	 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  /** VQC changed from c_err_msg to c_err_msg.arr **/
       	 tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      	}
			}
  	}    
      if ( i_record_exists == 1 )
      {
			 if(c_source_flg != 'B')   /** ver 2.4 **/
       {	
				if( c_source_flg == 'C' )
				{
          fn_userlog(c_ServiceName,"*** :%s: Cloud record already exists ***",
                                    sql_ffc_usr_id.arr );
      		fn_errlog( c_ServiceName, "S31335", "Cloud record already exists.", c_err_msg.arr  );  /** VQC changed from c_err_msg to c_err_msg.arr **/
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  /** VQC changed from c_err_msg to c_err_msg.arr **/
      		MEMSET(c_err_msg.arr);  /** VQC changed from c_err_msg to c_err_msg.arr **/
      		sprintf(c_err_msg.arr,"Cloud record already exists.");  /** VQC changed from c_err_msg to c_err_msg.arr **/
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  /** VQC changed from c_err_msg to c_err_msg.arr **/
      		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
				 /** ver 2.4 ** else if(c_source_flg == 'B' )	*** Added in Ver 2.1 ***
				{
					fn_userlog(c_ServiceName,"*** :%s: Basket record already exists ***",
                                    sql_ffc_usr_id.arr );
          fn_errlog( c_ServiceName, "S31340", "Basket record already exists.", c_err_msg.arr  );  
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
          MEMSET(c_err_msg.arr);  
          sprintf(c_err_msg.arr,"Basket record already exists.");  
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );		
				}	**/
				else
				{
		      fn_userlog(c_ServiceName,"*** :%s: Fvrt record already exists ***",
                                    sql_ffc_usr_id.arr );
					/*** continue;  **** commented in Ver 2.5 ***/
          /*** Ver 2.5 start ***/
          fn_errlog( c_ServiceName, "S31345", "Fav record already exists.", c_err_msg.arr  );  /** VQC changed from c_err_msg to c_err_msg.arr **/
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  /** VQC changed from c_err_msg to c_err_msg.arr **/
          MEMSET(c_err_msg.arr);  /** VQC changed from c_err_msg to c_err_msg.arr **/
          sprintf(c_err_msg.arr,"Already added");  /** VQC changed from c_err_msg to c_err_msg.arr **/
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  /** VQC changed from c_err_msg to c_err_msg.arr **/
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          /*** Ver 2.5 ends ***/					
				}
			 } 
      }
			
		if( c_source_flg == 'C' )
		{
       MEMSET(c_ffc_ordr_rfrnc);
  		          fn_userlog(c_ServiceName,"***inside create sequence..................................  ***"); 
			EXEC SQL
        SELECT TO_CHAR(EXG_NXT_TRD_DT,'YYYYMMDD')||LPAD(TO_CHAR(GET_CLOUD_SEQ.NEXTVAL),8,'0')
        INTO   :c_ffc_ordr_rfrnc
        FROM   EXG_XCHNG_MSTR
				WHERE  EXG_XCHNG_CD  = 'NFO'; /**** No need to change the query for BFO ... Same to be refered ***/ 

      if ( ( SQLCODE != 0 ) && ( SQLCODE != NO_DATA_FOUND ) )
      {
        fn_errlog( c_ServiceName, "S31350", SQLMSG, c_err_msg.arr  );  /** VQC changed from c_err_msg to c_err_msg.arr **/
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  /** VQC changed from c_err_msg to c_err_msg.arr **/
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );     /** VQC changed from c_err_msg to c_err_msg.arr **/
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      } 
		}
		else if (c_source_flg == 'B' )		/*** Ver 2.1 ***/
		{
			MEMSET(c_bskt_ordr_ref);
                fn_userlog(c_ServiceName,"***inside Basket create sequence..................................  ***");
			EXEC SQL
        SELECT 'B'||LPAD(TO_CHAR(EXG_NXT_TRD_DT,'YYYYMMDD'),8,'0')||LPAD(TO_CHAR(GET_BSKTORDR_SEQ.NEXTVAL),7,'0')
        INTO   :c_bskt_ordr_ref
        FROM   EXG_XCHNG_MSTR
        WHERE  EXG_XCHNG_CD  = 'NFO';

			if ( ( SQLCODE != 0 ) && ( SQLCODE != NO_DATA_FOUND ) )
      {
        fn_errlog( c_ServiceName, "S31355", SQLMSG, c_err_msg.arr  );  
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );     
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

			if( DEBUG_MSG_LVL_3 )
			{
				fn_userlog(c_ServiceName,"c_bskt_ordr_ref:%s:",c_bskt_ordr_ref);
			}
		}

		if(c_source_flg == 'B' )		/*** Added in Ver 2.1 ***/
		{
			if( DEBUG_MSG_LVL_3 )
			{
				fn_userlog(c_ServiceName,"***inside Basket Insert statement ***");
			}
			EXEC SQL
				INSERT INTO FBC_FO_BSKT_CNTRCT_LST
				(
					FBC_USR_ID,
					FBC_XCHNG_CD,
					FBC_PRDCT_TYP,
					FBC_INDSTK,
					FBC_UNDRLYNG,
					FBC_EXPRY_DT,
					FBC_EXER_TYP,
					FBC_OPT_TYP,
					FBC_STRK_PRC,
					FBC_LOT_SZ,
					FBC_ORDR_FLW,
					FBC_ORDR_TOT_QTY,
					FBC_LMT_MRKT_FLG,
					FBC_ORDR_TYPE,
					FBC_FRS_LMT_RT,
					FBC_CVR_LMT_RT,
					FBC_CVR_SLTP_RT,
					FBC_SRC_TYP,
					FBC_ORDR_RFRNC,
					FBC_INSRT_DT,
					FBC_BSKT_ID,
          FBC_SOURCE_FLG   /** Added in Ver 3.2 upload excel identifier **/
				)
				VALUES
				(
					:sql_ffc_usr_id,
          :st_cntrct.c_xchng_cd,
          :st_cntrct.c_prd_typ,
	  			:st_cntrct.c_ctgry_indstk,
          :st_cntrct.c_undrlyng,
          to_date( :st_cntrct.c_expry_dt, 'DD-Mon-yyyy' ),
          :st_cntrct.c_exrc_typ,
          :st_cntrct.c_opt_typ,
          :st_cntrct.l_strike_prc,
          :l_lot_sz,
          :c_ordr_flw,
          :l_ordr_qty,                      
          :c_lmt_mktsl_flg,
					:c_ordr_typ,
          :l_frs_lmt_rt,
	  			:l_cvr_lmt_rt,
	  			:l_cvr_sltp_rt,
          :c_source_flg,                    
          :c_bskt_ordr_ref,           
          systimestamp, /** sysdate changed to systimestamp in Ver 3.2 **/ 
	  			:c_bskt_id,
          DECODE(:c_rqst_typ,'U','U',:sql_source_flag)  /** Added in Ver 3.2 upload excel identifier **/
				);

       /*** ver 2.6 Starts ***/

      EXEC SQL
          UPDATE FBL_FO_BSKT_LST
          SET FBL_CRTD_DT = sysdate
          WHERE FBL_USR_ID     = :sql_ffc_usr_id
          AND FBL_XCHNG_CD    = :sql_ffc_xchng_cd
          AND FBL_BSKT_ID   = :c_bskt_id;

      /*** ver 2.6 Ends ***/
	
		}		/*** Ended Ver 2.1 ***/ 
		else
		{	
			EXEC SQL
				INSERT INTO ffc_fo_fvrt_cntrct_lst
				( 
					FFC_USR_ID,
       	 	FFC_XCHNG_CD,
       	 	FFC_PRDCT_TYP,
       	 	FFC_UNDRLYNG,
       	 	FFC_EXPRY_DT,
       	 	FFC_EXER_TYP,
       	 	FFC_OPT_TYP,
       	 	FFC_STRK_PRC,
       	 	FFC_LOT_SZ,
       	 	FFC_INDSTK,
					FFC_ORDR_QTY,											/** Ver 1.4 **/
					FFC_LMT_MRKT_FLG,									/** Ver 1.4 **/
					FFC_CVR_SLTP_DIFF,								/** Ver 1.4 **/	
					FFC_RQST_TYP,											/** Ver 1.4 **/
					FFC_ORDR_RFRNC,										/** Ver 1.4 **/
          FFC_INSRT_DT                      /** Ver 1.7 **/				
				)
				VALUES
				(
					:sql_ffc_usr_id,
					:st_cntrct.c_xchng_cd,
					:st_cntrct.c_prd_typ,
					:st_cntrct.c_undrlyng,
					to_date( :st_cntrct.c_expry_dt, 'DD-Mon-yyyy' ),
					:st_cntrct.c_exrc_typ,
					:st_cntrct.c_opt_typ,
					:st_cntrct.l_strike_prc,
					:l_lot_sz,
					:st_cntrct.c_ctgry_indstk,
					:l_ordr_qty,											/** Ver 1.4 **/
					:c_lmt_mktsl_flg,									/** Ver 1.4 **/
					:d_cvr_sltp_diff,									/** Ver 1.4 **/
					:c_source_flg,										/** Ver 1.4 **/
					:c_ffc_ordr_rfrnc,								/** Ver 1.4 **/
          sysdate                           /** Ver 1.7 **/
				);
			}
				if ( SQLCODE != 0 )
				{
					fn_errlog( c_ServiceName, "S31360", SQLMSG, c_err_msg.arr  );  /** VQC changed from c_err_msg to c_err_msg.arr **/
					fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  /** VQC changed from c_err_msg to c_err_msg.arr **/
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );     /** VQC changed from c_err_msg to c_err_msg.arr **/
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
		}
		else if ( c_rqst_typ == DELETE || c_rqst_typ == 'Q' || c_rqst_typ == 'P' )		/*** or condition added in Ver 2.1 ***/
		{
			if( DEBUG_MSG_LVL_3 )
			{
      	fn_userlog(c_ServiceName,"I am inside Delete request type ");
    		fn_userlog ( c_ServiceName,"Suchita c_source_flg :%c: c_rqst_typ :%c:",c_source_flg,c_rqst_typ);
        fn_userlog( c_ServiceName,"Suchita sql_ffc_usr_id :%s: c_bskt_id :%s: c_bskt_ordr_ref :%s: ",sql_ffc_usr_id.arr,c_bskt_id,c_bskt_ordr_ref);
			}

			if( c_source_flg == 'C' )			/*** if() added in Ver 1.4 ***/
			{
      	EXEC SQL
        	DELETE ffc_fo_fvrt_cntrct_lst
        	WHERE ffc_ordr_rfrnc= :c_ffc_ordr_rfrnc;
			}
			/*** Ver 2.1 starts ***/
			else if(c_source_flg == 'B' && c_rqst_typ == 'Q')
			{
				EXEC SQL
					DELETE FBC_FO_BSKT_CNTRCT_LST
					WHERE	 FBC_USR_ID			= :sql_ffc_usr_id
					AND    FBC_BSKT_ID		= :c_bskt_id 
					AND		 FBC_ORDR_RFRNC = :c_bskt_ordr_ref;

         /*** ver 2.6 Starts ***/

      EXEC SQL
          UPDATE FBL_FO_BSKT_LST
          SET FBL_CRTD_DT = sysdate
          WHERE FBL_USR_ID     = :sql_ffc_usr_id
          AND FBL_XCHNG_CD    = :sql_ffc_xchng_cd
          AND FBL_BSKT_ID   = :c_bskt_id;

      /*** ver 2.6 Ends ***/

			}
			else if(c_source_flg == 'B' && c_rqst_typ == 'P')
			{

				EXEC SQL
					DELETE FROM FBC_FO_BSKT_CNTRCT_LST
					WHERE	 FBC_USR_ID			= :sql_ffc_usr_id
					AND		 FBC_BSKT_ID		= :c_bskt_id;

				if ( ( SQLCODE != 0 ) && ( SQLCODE != NO_DATA_FOUND ) )
				{
					fn_errlog( c_ServiceName, "S31365", SQLMSG, c_err_msg.arr  ) ;  
					fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); 
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );   
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}

				EXEC SQL
					DELETE FROM FBL_FO_BSKT_LST
					WHERE  FBL_USR_ID	 = :sql_ffc_usr_id
					AND		 FBL_BSKT_ID = :c_bskt_id;

        if ( ( SQLCODE != 0 ) && ( SQLCODE != NO_DATA_FOUND ) )
        {
          fn_errlog( c_ServiceName, "S31370", SQLMSG, c_err_msg.arr  ) ;
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
			}
			/*** Ver 2.1 ends ***/
			else
			{
				EXEC SQL
					DELETE ffc_fo_fvrt_cntrct_lst
					WHERE		ffc_usr_id		=	:sql_ffc_usr_id
					AND			ffc_xchng_cd 	=	:st_cntrct.c_xchng_cd
					AND			ffc_prdct_typ	=	:st_cntrct.c_prd_typ
					AND			ffc_undrlyng	=	:st_cntrct.c_undrlyng
					AND			ffc_expry_dt	=	to_date(:st_cntrct.c_expry_dt, 'DD-Mon-yyyy' )
					AND 		ffc_exer_typ 	=	:st_cntrct.c_exrc_typ
					AND 		ffc_opt_typ 	=	:st_cntrct.c_opt_typ
					AND 		ffc_strk_prc 	=	:st_cntrct.l_strike_prc
					AND 		ffc_lot_sz 		=	:l_lot_sz
					AND			ffc_rqst_typ  = :c_source_flg;					/** Ver 1.4 **/
			}

			if ( ( SQLCODE != 0 ) && ( SQLCODE != NO_DATA_FOUND ) )
			{
				fn_errlog( c_ServiceName, "S31375", SQLMSG, c_err_msg.arr  ) ;  /** VQC changed from c_err_msg to c_err_msg.arr **/
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  /** VQC changed from c_err_msg to c_err_msg.arr **/
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );   /** VQC changed from c_err_msg to c_err_msg.arr **/
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
		}	/*** Ver 1.4 Starts ***/
		else if(c_rqst_typ == MODIFY && (c_source_flg == 'C' || c_source_flg == 'B') )	/*** OR condition added in Ver 2.1 ***/
		{
			if( DEBUG_MSG_LVL_3 )
			{
      	fn_userlog( c_ServiceName, "c_lmt_mktsl_flg...................:%c:",c_lmt_mktsl_flg);
			}
      i_record_exists = 0;

			if (c_source_flg == 'C' ) /*** if condition added in Ver 2.1 ***/
			{
      EXEC SQL
           SELECT 1
           INTO :i_record_exists
           FROM
           FFC_FO_FVRT_CNTRCT_LST
           WHERE FFC_USR_ID     =  :sql_ffc_usr_id
           AND FFC_XCHNG_CD     =  :st_cntrct.c_xchng_cd
           AND FFC_PRDCT_TYP    =  :st_cntrct.c_prd_typ
           AND FFC_UNDRLYNG     =  :st_cntrct.c_undrlyng
           AND FFC_EXPRY_DT     =  to_date( :st_cntrct.c_expry_dt, 'DD-Mon-yyyy')
           AND FFC_EXER_TYP     =  :st_cntrct.c_exrc_typ
           AND FFC_OPT_TYP      =  :st_cntrct.c_opt_typ
           AND FFC_STRK_PRC     =  :st_cntrct.l_strike_prc
           AND FFC_LOT_SZ       =  :l_lot_sz
           AND FFC_INDSTK       =  :st_cntrct.c_ctgry_indstk
           AND FFC_ORDR_QTY     =  :l_ordr_qty
           AND FFC_LMT_MRKT_FLG =  :c_lmt_mktsl_flg
           AND FFC_CVR_SLTP_DIFF=  :d_cvr_sltp_diff
           AND FFC_RQST_TYP     =  :c_source_flg;

      if ( ( SQLCODE != 0 ) && ( SQLCODE != NO_DATA_FOUND ) )
      {
        fn_errlog( c_ServiceName, "S31380", SQLMSG, c_err_msg.arr  );  /** VQC changed from c_err_msg to c_err_msg.arr **/
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  /** VQC changed from c_err_msg to c_err_msg.arr **/
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );     /** VQC changed from c_err_msg to c_err_msg.arr **/
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

      if ( i_record_exists == 1 )
      {
          fn_userlog(c_ServiceName,"*** :%s: Cloud record already exists ***",
                                    sql_ffc_usr_id.arr );
          fn_errlog( c_ServiceName, "S31385", "Cloud record already exists.", c_err_msg.arr  );  /** VQC changed from c_err_msg to c_err_msg.arr **/
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  /** VQC changed from c_err_msg to c_err_msg.arr **/
          MEMSET(c_err_msg.arr);  /** VQC changed from c_err_msg to c_err_msg.arr **/
          sprintf(c_err_msg.arr,"Cloud record already exists."); /** VQC changed from c_err_msg to c_err_msg.arr **/
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  /** VQC changed from c_err_msg to c_err_msg.arr **/
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }


			if(c_lmt_mktsl_flg == 'L' && (st_cntrct.c_prd_typ=='U' || st_cntrct.c_prd_typ=='I')) /** Product type handled in Ver 2.0 ***/
			{
				EXEC SQL
				SELECT nvl(FUM_SLTPFP_LMT_ALLWD_FLG,'N') 
					INTO :c_lmt_allwd_flg
					FROM FFC_FO_FVRT_CNTRCT_LST,FUM_FO_UNDRLYNG_MSTR 
				 WHERE FFC_USR_ID     = :sql_ffc_usr_id
           AND FFC_XCHNG_CD   = :st_cntrct.c_xchng_cd
           AND FFC_PRDCT_TYP  = :st_cntrct.c_prd_typ
           AND FFC_UNDRLYNG   = :st_cntrct.c_undrlyng
           AND FFC_EXPRY_DT   = to_date( :st_cntrct.c_expry_dt, 'DD-Mon-yyyy' )
           AND FFC_EXER_TYP   = :st_cntrct.c_exrc_typ
           AND FFC_OPT_TYP    = :st_cntrct.c_opt_typ
           AND FFC_STRK_PRC   = :st_cntrct.l_strike_prc
           AND FFC_LOT_SZ     = :l_lot_sz
           AND FFC_INDSTK     = :st_cntrct.c_ctgry_indstk
           AND FFC_RQST_TYP  = :c_source_flg
					 AND FFC_ORDR_RFRNC = :c_ffc_ordr_rfrnc 
					 AND FUM_XCHNG_CD=FFC_XCHNG_CD 
					 AND FUM_UNDRLYNG=FFC_UNDRLYNG 
					 AND FUM_PRDCT_TYP=decode(FFC_PRDCT_TYP,'U','F','I','O','P','F',FFC_PRDCT_TYP);  /*** Handling for 'P' in Ver 2.0 ***/

        if ( SQLCODE != 0 )
        {
          fn_errlog( c_ServiceName, "S31390", SQLMSG, c_err_msg.arr  );  /** VQC changed from c_err_msg to c_err_msg.arr **/
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  /** VQC changed from c_err_msg to c_err_msg.arr **/
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  /** VQC changed from c_err_msg to c_err_msg.arr **/
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }

        if(c_lmt_allwd_flg == 'N')
        {
          fn_userlog( c_ServiceName, "Limit order is not allowed for this contract.");
          fn_errlog( c_ServiceName, "S31395", "Limit order is not allowed for this contract.", c_err_msg.arr  );  /** VQC changed from c_err_msg to c_err_msg.arr **/
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  /** VQC changed from c_err_msg to c_err_msg.arr **/
          MEMSET(c_err_msg.arr);  /** VQC changed from c_err_msg to c_err_msg.arr **/
          sprintf(c_err_msg.arr,"Limit order is not allowed for this contract.");  /** VQC changed from c_err_msg to c_err_msg.arr **/
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  /** VQC changed from c_err_msg to c_err_msg.arr **/
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
			}
      EXEC SQL
        UPDATE ffc_fo_fvrt_cntrct_lst
           SET FFC_ORDR_QTY   	= :l_ordr_qty,
               FFC_LMT_MRKT_FLG = :c_lmt_mktsl_flg,
               FFC_CVR_SLTP_DIFF= :d_cvr_sltp_diff
				 WHERE FFC_USR_ID     = :sql_ffc_usr_id 
           AND FFC_XCHNG_CD		= :st_cntrct.c_xchng_cd 
           AND FFC_PRDCT_TYP	=	:st_cntrct.c_prd_typ 
           AND FFC_UNDRLYNG		=	:st_cntrct.c_undrlyng 
           AND FFC_EXPRY_DT		=	to_date( :st_cntrct.c_expry_dt, 'DD-Mon-yyyy' ) 
           AND FFC_EXER_TYP		= :st_cntrct.c_exrc_typ 
           AND FFC_OPT_TYP		= :st_cntrct.c_opt_typ	 
           AND FFC_STRK_PRC		=	:st_cntrct.l_strike_prc 
           AND FFC_LOT_SZ			=	:l_lot_sz 
           AND FFC_INDSTK			= :st_cntrct.c_ctgry_indstk
					 AND FFC_ORDR_RFRNC	= :c_ffc_ordr_rfrnc
           AND FFC_RQST_TYP   = :c_source_flg;      
			
        if ( SQLCODE != 0 )
        {
          fn_errlog( c_ServiceName, "S31400", SQLMSG, c_err_msg.arr  ) ;  /** VQC changed from c_err_msg to c_err_msg.arr **/
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  /** VQC changed from c_err_msg to c_err_msg.arr **/
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );   /** VQC changed from c_err_msg to c_err_msg.arr **/
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
			}
			
			else	if (c_source_flg == 'B' ) /*** if loop added in Ver 2.1 ***/
			{
				if( DEBUG_MSG_LVL_3 )
				{
         	fn_userlog( c_ServiceName,"Suchita sql_ffc_usr_id :%s: st_cntrct.c_xchng_cd :%s: st_cntrct.c_prd_typ :%c: st_cntrct.c_undrlyng :%s:"
																	,sql_ffc_usr_id.arr,st_cntrct.c_xchng_cd,st_cntrct.c_prd_typ,st_cntrct.c_undrlyng);
         	fn_userlog( c_ServiceName,"Suchita st_cntrct.c_expry_dt :%s: st_cntrct.c_exrc_typ :%c: st_cntrct.c_opt_typ :%c: st_cntrct.l_strike_prc :%ld:",st_cntrct.c_expry_dt,st_cntrct.c_exrc_typ,st_cntrct.c_opt_typ,st_cntrct.l_strike_prc);
        fn_userlog( c_ServiceName,"Suchita l_ordr_qty :%ld: c_lmt_mktsl_flg :%c: c_ordr_typ :%c: d_frs_lmt_rt :%lf: l_cvr_lmt_rt :%ld"
																,l_ordr_qty,c_lmt_mktsl_flg,c_ordr_typ,d_frs_lmt_rt,l_cvr_lmt_rt);
        fn_userlog( c_ServiceName,"Suchita l_cvr_sltp_rt :%ld: c_source_flg :%c: c_ordr_flw :%c: c_bskt_ordr_ref :%s: c_bskt_id :%s:"
																,l_cvr_sltp_rt,c_source_flg,c_ordr_flw,c_bskt_ordr_ref,c_bskt_id);
 				}
 
         rtrim(st_cntrct.c_expry_dt);
         rtrim(c_bskt_ordr_ref);
         rtrim(c_bskt_id);

 
			   EXEC SQL
           SELECT 1
           INTO :i_record_exists
           FROM
           FBC_FO_BSKT_CNTRCT_LST
           WHERE FBC_USR_ID     =  :sql_ffc_usr_id
           AND FBC_XCHNG_CD     =  :st_cntrct.c_xchng_cd
           AND FBC_PRDCT_TYP    =  :st_cntrct.c_prd_typ
           AND FBC_UNDRLYNG     =  :st_cntrct.c_undrlyng
           AND FBC_EXPRY_DT     =  to_date( :st_cntrct.c_expry_dt, 'DD-Mon-yyyy')
           AND FBC_EXER_TYP     =  :st_cntrct.c_exrc_typ
           AND FBC_OPT_TYP      =  :st_cntrct.c_opt_typ
           AND FBC_STRK_PRC     =  :st_cntrct.l_strike_prc
					 AND FBC_ORDR_RFRNC		=	 :c_bskt_ordr_ref
					 AND FBC_BSKT_ID			=	 :c_bskt_id
           AND FBC_ORDR_TOT_QTY =  :l_ordr_qty
           AND FBC_LMT_MRKT_FLG =  :c_lmt_mktsl_flg
           AND FBC_FRS_LMT_RT             =        :d_frs_lmt_rt
           AND FBC_CVR_LMT_RT             =        :l_cvr_lmt_rt
           AND FBC_CVR_SLTP_RT    =        :l_cvr_sltp_rt
           AND FBC_SRC_TYP      =  :c_source_flg
           AND FBC_ORDR_FLW     =  :c_ordr_flw
           AND FBC_ORDR_TYPE    =  :c_ordr_typ;
           

      if ( ( SQLCODE != 0 ) && ( SQLCODE != NO_DATA_FOUND ) )
      {
        fn_errlog( c_ServiceName, "S31405", SQLMSG, c_err_msg.arr  );  
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );    
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

      if ( i_record_exists == 1 )
      {
          fn_userlog(c_ServiceName,"*** :%s: Basket record already exists ***",
                                    sql_ffc_usr_id.arr );
          fn_errlog( c_ServiceName, "S31410", "Basket record already exists.", c_err_msg.arr  ); 
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); 
          MEMSET(c_err_msg.arr); 
          sprintf(c_err_msg.arr,"Basket record already exists.");
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

			EXEC SQL
        UPDATE FBC_FO_BSKT_CNTRCT_LST
           SET FBC_ORDR_TOT_QTY =  :l_ordr_qty,
               FBC_LMT_MRKT_FLG =  :c_lmt_mktsl_flg,
							 FBC_ORDR_TYPE		=  :c_ordr_typ,
							 FBC_FRS_LMT_RT		=	 :l_frs_lmt_rt,
							 FBC_CVR_LMT_RT		=	 :l_cvr_lmt_rt,
               /*** DECODE(:c_lmt_mktsl_flg,'M',0,:l_cvr_sltp_rt), Commented in Ver 2.8 ***/
               FBC_CVR_SLTP_RT  =  :l_cvr_sltp_rt,  /*** Ver 2.8 SLTP will be as per input for FPSLTP and OPSLTP ***/ 
               FBC_INSRT_DT = sysdate       /*** ver 2.6 ***/
				 WHERE FBC_USR_ID     = :sql_ffc_usr_id 
           AND FBC_XCHNG_CD		= :st_cntrct.c_xchng_cd 
           AND FBC_PRDCT_TYP	=	:st_cntrct.c_prd_typ 
           AND FBC_UNDRLYNG		=	:st_cntrct.c_undrlyng 
           AND FBC_EXPRY_DT		=	to_date( :st_cntrct.c_expry_dt, 'DD-Mon-yyyy' ) 
           AND FBC_EXER_TYP		= :st_cntrct.c_exrc_typ 
           AND FBC_OPT_TYP		= :st_cntrct.c_opt_typ	 
           AND FBC_STRK_PRC		=	:st_cntrct.l_strike_prc 
					 AND FBC_ORDR_FLW   =	:c_ordr_flw
					 AND FBC_ORDR_RFRNC	= :c_bskt_ordr_ref
					 AND FBC_BSKT_ID		=	:c_bskt_id
           AND FBC_SRC_TYP    = :c_source_flg;      
			
        /*** commented in ver 2.2 if ( SQLCODE != 0 )
        {
	        fn_errlog( c_ServiceName, "S31415", SQLMSG, c_err_msg.arr  ) ;  
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); 
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 ); 
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        } ***/
        /***  Ver 2.2 Starts Here ***/
        if ( SQLCODE != 0 )
        {
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr);
          fn_errlog( c_ServiceName, "B14022", DEFMSG, c_err_msg.arr );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );

        }
        /***  Ver 2.2 Ends Here ***/

          /*** ver 2.6 Starts ***/

      EXEC SQL
          UPDATE FBL_FO_BSKT_LST
          SET FBL_CRTD_DT = sysdate
          WHERE FBL_USR_ID     = :sql_ffc_usr_id
          AND FBL_XCHNG_CD    = :sql_ffc_xchng_cd
          AND FBL_BSKT_ID   = :c_bskt_id;

      /*** ver 2.6 Ends ***/
 
			} /*** Ver 2.1 ***/
		}/*** Ver 1.4 Ends ***/	
		else
		{
			fn_errlog( c_ServiceName, "S31420", "Invalid Flag", c_err_msg.arr  );  /** VQC changed from c_err_msg to c_err_msg.arr **/
			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); /** VQC changed from c_err_msg to c_err_msg.arr **/
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  /** VQC changed from c_err_msg to c_err_msg.arr **/
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
    /** Ver 3.2 starts **/
    if(c_source_flg == 'B' && c_rqst_typ == 'U')
    {
      fn_userlog(c_ServiceName,"Before checking all check flag c_fail_flag = %c",c_fail_flag);
      if(i_fail_flag > 0 && i_fail_flag < 7)
      {
       fn_userlog(c_ServiceName," All Errors are in c_err_msg is |%s|",c_err_msg.arr);
       fn_userlog(c_ServiceName," All Errors are in c_err_msg1 is |%s|",c_err_msg1.arr);
       strcpy(c_err_msg.arr,c_err_msg1.arr);
       Fadd32(ptr_fml_Obuf,FFO_ERR_MSG, c_err_msg1.arr, 0 );
       MEMSET(c_err_msg.arr);
       MEMSET(c_err_msg1.arr);
      }
      if(i_fail_flag > 0 && c_fail_flag == 'N')
      {
        fn_userlog(c_ServiceName, "Total records checked %d ",i_reccount+1);
        c_fail_flag = 'Y';
      }
    }
     /** Ver 3.2 ends **/
	 }
   /** Ver 3.2 starts **/
   if(c_source_flg == 'B' && c_rqst_typ == 'U' && c_fail_flag == 'Y')
   {
     fn_userlog(c_ServiceName, "Total records are %d",i_reccount);
     fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
     tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Obuf,0,0);
   }
   /** Ver 3.2 ends **/
  }

	if(c_source_flg == 'B' && c_rqst_typ == 'U')
	{
  	tpfree ( ( char * ) ptr_fml_Obuf ); /** Added in Ver 3.2 **/
	}

	if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg.arr ) == -1 )  /** VQC changed from c_err_msg to c_err_msg.arr **/
	{
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  /** VQC changed from c_err_msg to c_err_msg.arr **/
		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}
   tpreturn( TPSUCCESS, SUCC_BFR, (char *)ptr_fml_Ibuf, 0L, 0 );
}
