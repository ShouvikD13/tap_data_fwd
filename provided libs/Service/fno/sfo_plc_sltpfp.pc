/******************************************************************************/
/*  Program						: SFO_PLC_SLTPFP																				*/	
/*																																						*/
/*  Input             : FFO_USR_ID                                            */
/*                      FFO_SSSN_ID                                           */
/*                      FFO_EBA_MTCH_ACT_NO                                   */
/*                      FFO_PIPE_ID                                           */
/*                      FFO_TRD_PSSWD                                         */
/*                      FFO_OPERATION_TYP                                     */
/*                      FFO_XCHNG_CD [2]                                      */
/*                      FFO_PRDCT_TYP [2]                                     */
/*                      FFO_UNDRLYNG [2]                                      */
/*                      FFO_EXPRY_DT [2]                                      */
/*                      FFO_EXER_TYP [2]                                      */
/*                      FFO_OPT_TYP  [2]                                      */
/*                      FFO_STRK_PRC [2]                                      */
/*                      FFO_CTGRY_INDSTK [2]                                  */
/*                      FFO_ORDR_FLW [2]                                      */
/*                      FFO_LMT_MKT_SL_FLG [2]                                */
/*                      FFO_ORD_TOT_QTY [2]                                   */
/*                      FFO_LMT_RT [2]                                        */
/*											FFO_STP_LSS_TGR[2]                                    */
/*											FFO_ORD_TYP[2]																				*/				
/*										  FFO_MKT_TYP																						*/
/*  									  FFO_OPNPSTN_RT							                          */ 
/*                      FFO_REQ_TYP                                           */
/*																																						*/
/*  Output            : FFO_ORDR_RFRNC [2]                                    */
/*                                                                            */
/*  Description       : This service is used to place SLTP order					    */
/*                                                                            */
/*  Log               : 1.0 		07-Dec-2012 			Vishnu Nair 		            */
/*                    : 1.1     11-Jul-2013       Navina D.                   */
/*                    : 1.2     15-Jul-2013       Sachin Birje.               */
/*                    : 1.3     01-Aug-2013       Bhushan Sonwane             */
/*                    : 1.4     06-Nov-2013       Swati A.B                   */
/*                    : 1.5     30-Oct-2013       Bhushan Sonwane             */
/*                    : 1.6     20-Dec-2013       Bhushan Sonwane             */
/*                    : 1.8     13-Jan-2014       Navina D./ Bhushan          */
/*                    : 2.0     24-Jul-2014       Navina D.                   */
/*                    : 2.2     16-Feb-2015       Anand Dhopte                */
/*                    : 2.3     23-Feb-2015       Tanmay W./ Sonu Jalap       */
/*                    : 2.4     15-Jun-2015       Navina D.                   */
/*                    : 2.5		  24-Jul-2015       Kishor B.                   */
/*                    : 2.6     06-Aug-2015       Ritesh D.                   */
/*                    : 2.7     07-Aug-2015       Bhupendra Malik             */
/*										: 2.9     03-Nov-2015       Navina D.                   */
/*										: 3.0			26-Nov-2015				Kishor B.										*/
/*                    : 3.1     18-Dec-2015       Anand Dhopte                */
/*                    : 3.3     25-Feb-2015       Kishor B.                   */
/*                    : 3.4     16-Mar-2016       Kishor B.                   */
/*										: 3.5			30-Jun-2016				Samip M.										*/
/*                    : 3.6     08-Jul-2016       Anand Dhopte                */
/*										: 3.7			12-Jul-2016				Kishor B.										*/
/*										: 3.8			05-Dec-2016				Kishor B.										*/
/*                    : 3.9     27-Mar-2017       Bhupendra Malik             */
/*                    : 4.0     28-Far-2017       Bhupendra Malik             */
/*                    : VQC     14-Jun-2017       Swapnil More                */
/*                    : 4.1     31-Oct-2017       Anand Dhopte                */
/*                    : 4.2     12-Dec-2017       Anand Dhopte                */
/*                    : 4.4     25-Jul-2018       Suchita Dabir               */
/*                    : 4.3     15-Jun-2018       Anand Dhopte                */
/*                    : 4.5     10-Oct-2018       Mrinal KIshore              */
/*                    : 4.6     27-Nov-2018       Suchita Dabir               */
/*                    : 4.7     23-Oct-2019       Tanmay Patel                */
/*										: 4.8     02-Mar-2020       Navina D.                   */
/*										: 4.9			02-Feb-2021				Kiran Itkar									*/
/*										: 5.0			18-May-2021				Sandip Tambe								*/
/*										: 5.1		  19-Feb-2022	      Naveena            					*/
/*										: 5.2     09-Mar-2023       Vipul Shamra								*/
/******************************************************************************/
/*  1.0  -  New release                                                       */
/*  1.1  -  FuturePLUS SLTP product type validation.                          */ 
/*  1.2  -  Modify Allocation Screen display on Insufficient Limit            */
/*  1.3  -  Pipe ID and Action ID Changes for RIA                             */
/*  1.4  -  FNO limit Logging (Swati A.B)                                     */
/*  1.5  -  DLRevamp changes, call via SFO_ORD_ROUT to SFO_FUT_PLC_ORD or     */
/*          SFO_SPN_PLC_ORD now returns more FMLs, Rbuf is concatenated to    */
/*          Obuf, rather than doing Fget and Fadd for every FML.              */ 
/*  1.6  -  SLTP and Limit Price validation Changes for IPhone and            */
/*					Restrict NRI Customer to Place FuturePLUS SLTP Order							*/
/*  1.8  -  Max qty allowed change for NIFTY in SLTP FP product               */
/*  2.0  -  Enabling SLTP FP for NRI clients.                                 */
/*  2.2  -  Insufficient Limits - Modify Allocation changes for DL .Net       */
/*  2.3  -  Insert match account into FFL / Insert logs for fn_avg_price      */
/*  2.4  -  Fix for avg price (error of money being credited to match a/c)    */
/*	2.5  -  Changes related to CR_ISEC14_64402 Limit_Order_Type_in_FP_SLTP    */
/*  2.6  -  Contract Master and Trade Quote Table Merger Changes              */
/*  2.7  -  Include changes for Insider trading check                         */
/*	2.9  -  Error message changed for fpsltp                                  */
/*	3.0	 -	Call to SFO_LMT_PRC_CAL is introduced to validate Input limit rate*/
/*  3.1  -  If condition added in case of Order Flow reversal                 */
/*  3.3  -  Cloud order changes                                               */
/*  3.4  -  Transaction Flag in Check Session IP                              */
/*	3.5	 -	Check Session IP Common Function																	*/
/*  3.6  -  Incorrect Order Flow Issue in case of Double Order Modification   */
/*	3.7	 -	Log Maintenance																										*/
/*	3.8	 -	IP address pass to core service																		*/
/*  3.9  -  Core Fix                                                          */
/*  4.0  -  Optimization                                                      */
/*  VQC  -  Version Quality Control.                                          */
/*  4.1  -  Changes for reducing hard parsing of sql queries                  */
/*  4.2  -  FML with data type char used instead of long for storing wrapper flag*/       
/*  4.3  -  Disallow clients with outstanding from taking fresh exposure      */
/*  4.4  -  Deadlock handling                                                 */ 
/*  4.5  -  Error Log Over-written issue                                      */ 
/*  4.6  -  FO Limit Entry                                                    */ 
/*  4.7  -  Ipv6 Format                                                       */
/*  4.8  -  FPSL margin change CR-ISEC14-133200                               */
/*	4.9	 -	Separate EOS for Stock and Index Underlyings in FPSL							*/
/*	5.0	 -	Derivative Trading restriction CR CR_ISEC04_152948  							*/
/*  5.1  -  Breeze API & Integrated Watchlist                                 */
/*  5.2  -  changing fn_lock_usr to fn_lock_fno(Ravi) & Putting message before calling to fn_upd_limits	 (Vipul)*/ 
/*  5.3  -  Margin Reporting Regulatory Changes (Nikhil Soni)                  */
/******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <atmi.h>
#include <fml32.h>
#include <sqlca.h>

/*Add header files here */
#include <fo.h>
#include <fo_fml_def.h>
#include <fo_view_def.h> 
#include <fn_session.h>
#include <fn_tuxlib.h>
#include <fn_ddr.h>
#include <fn_log.h> 
#include <fn_val_ord.h> 
#include <fml_rout.h> 
#include <fn_read_debug_lvl.h>
#include <fn_pos.h>
#include <fn_span_lib.h> 


int fn_5paisa(long);
void fn_round2(double*);
/** void fn_avg_price(long *, long *,  double *,int);** commented in Ver 2.3 **/
void fn_avg_price(char*, long *, long *,  double *,int); /** Ver 2.3 **/

void SFO_PLC_SLTPFP ( TPSVCINFO *rqst )
{
  char 	c_ServiceName[33];
  varchar 	c_err_msg[256]; /*** VQC Changed datatype to varchar fom char ***/
                            /** Note: also changed c_err_msg to c_err_msg.arr everywhere in code in VQC **/
	char	c_settlor_flg = '\0';
	char	c_spl_flg='\0';
  char 	c_srvc_nm[33];
  char 	c_pipe_id[3];
  /*** char 	c_channel[4];
  char 	c_bp_id[9];  *** Commented in VQC ***/
  char 	c_alias[9];
  char c_fno_dmn_nm [ 16 ];
  char c_fno_trg_nm [ 16 ];
  char c_fno_trg_dat [ 256 ];
	char c_frsh_ordr_rfrnc[19];
	char c_cvr_ordr_rfrnc[19];
	char c_narration_id[5];
	char c_spn_allwd_flg='\0';	
	char c_bse_span_flag='\0';				
	char c_sltp_stts='\0';
	char c_sltp_eos_flg='\0';
  char c_qt_trd_flg='\0';
	char c_sltp_trd_flg='\0';
	char c_dr_without_lmt_flg ='\0';
  char c_trdng_psswrd_flg = '\0';
	char c_temp_psswrd[LEN_USR_TRDNG_PSSWRD];
	char c_ip_address[45+1]; /** Changed from 15 to 45 in Ver 4.7 **/
	char c_call_source[20] = "\0";	/*** Ver 1.1 ***/
  char c_insuff_flg = 'N';  /* Ver 1.2 */
  char c_actn_flg = '\0';      /*** Ver 1.4 ***/
	char c_lmt_allwd_flg = '\0';    /** 2.5 **/
	char c_usr_flg = '\0';			/** 2.5 **/
	/**** char  c_err_msg1[256] = "\0"; ** 2.5 **  **** Commented in VQC ***/
	varchar	c_err_msg1[256] ;			/*** Ver 4.5 ***/
	char  c_source_flg= '\0';  /** Ver 3.0 **/
  char  c_rqst_typ= '\0';  /** Ver 3.0 **/
  char  c_cvr_ordr_flw= '\0';  /** Ver 3.0 **/	
  char  c_src_flg ='\0';      /*** Ver 3.3 ***/
  char c_txn_flg='Y';             /*** Ver 3.4 ***/
  char c_clm_clnt_lvl = '\0';     /*** Added in VQC ***/
	char c_ref_rmrks[100] = "\0"; /*** Ver 4.8 ***/
	char	c_tmp_rmrks [ 100 ] = "\0";	 /*** Ver 4.8 ***/
	
	double d_comp1_mrgn = 0.0;	/*** Ver 4.8 ***/
	double d_comp1_pl = 0.0;		/*** Ver 4.8 ***/
	double d_xchng_amt = 0.0;		/*** Ver 4.8 ***/

  /*** Ver 4.1 Starts ***/
  char c_exg_d_mkt_typ = 'D';  
  char c_fum_fut_prd_typ = 'F';

  char c_fod_cvr_flg = 'C';
  long l_fod_zero_val = 0;
  /*** Ver 4.1 Ends ***/
	
  /*** ver 4.4 starts ***/
  char c_sltp_ord_rfrnc_lck[2][19];
  char c_ordr_rfrnc_lck[2][19];
  /*** ver 4.4 ends ***/
	char c_indstk[2][2]; /*** Ver 4.9 ***/
	/** int		i_err[ 20 ]; 		
	int		i_ferr[ 20 ]; Commented in Ver 3.8 ***/ 

  int   i_err[ 21 ];		/*** Ver 3.8 ***/
  int   i_ferr[ 21 ];   /*** Ver 3.8 ***/
	int		i_returncode = 0;
  int 	i_trnsctn = 0;
  int 	i_cnt= 0 ;
	int		i = 0 ;

  /*** Commented in VQC
	int		i_ip_len = 0;
	int		i_op_len = 0;
	int		i_ch_val = 0;
	int   i_counter = 0;
  ****/
 
  int   i_flg = 0;
  int   i_cal_on_wrst_prc = 0;  /*** Ver 1.8 ***/
  int   insider_exist = 0;        /** Ver 2.7 **/		
	long		l_temp_stp_lss_tgr = 0;
	long 		l_temp_ord_lmt_rt = 0;
 /*** 	long		l_sssn_id_chk = 0; *** Commented in VQC ***/
	long    l_recvbuff = 0;

  /*** Commented in VQC ***
	long    l_no_of_calls = 0; 
	long    l_lot_size = 0;
	long		l_mrgn_amt = 0;
	long		l_lss_amt= 0;
  ***/

	long		l_bst_bid_prc[5] = {0,0,0,0,0};
	long 		l_bst_bid_qty[5] = {0,0,0,0,0};
	long 		l_bst_offr_qty[5] = {0,0,0,0,0};
	long		l_bst_offr_prc[5] = {0,0,0,0,0};
	long    l_lmt_rt = 0;																					/*** Ver 2.5 ***/
	long 		l_max_allw_qty = 0;																		/*** Ver 2.5 ***/
	/*** long    l_stp_lss_tgr_prc = 0;													   *** Ver 2.5 ***  *** Commentd in VQC ***/	
	long    l_ret_limit_rt  = 0;                                  /*** Ver 3.0 ***/
  long    l_old_ord_qty = 0;                                    /*** Ver 4.3 ***/
 
	int i_actn_id = -1;   

	/*** double d_limit_amt = 0.0; **** Commented in VQC ***/ 
	double d_mrgn_amt = 0.0;
	double d_lss_amt = 0.0;
	double d_sltp_diff_prcnt = 0.0;
	double d_sltp_prcnt = 0.0;
	double d_tot_bid_qty = 0.0;
	double d_tot_offr_qty = 0.0; 
	double d_avg_prc = 0.0;
	double d_balance_amt = 0.0;	
	double d_diff_amt = 0.0;	
	/*** double d_temp = 0.0;   **** Commented in VQC ***/	
  double d_required_amt = 0.0;  /* Ver 1.2 */

  double d_temp_diff_amt = 0.0;     /*** Added in VQC ***/

	varchar c_ven_id[50+1];	/*** Ver 5.1 ***/

  TPTRANID tranid  ; /*** Ver 1.4 ***/

	FBFR32 *ptr_fml_Ibuf;
  FBFR32 *ptr_fml_Obuf;
  FBFR32 *ptr_fml_Rbuf;
  FBFR32 *ptr_fml_Sbuf;

  EXEC SQL BEGIN DECLARE SECTION;
	  struct vw_usr_prfl st_usr_prfl;
  	struct vw_orderbook st_ordbook;
    
    /*** Commented in VQC ***
		struct vw_gt_lmt_dtls st_gt_lmt_dtls;
		struct st_pstn_actn st_pstn_action;
    ***/

    struct vw_pstn_actn ptr_st_pstn_actn;	 
		/*** struct st_err_msg *ptr_st_err;  *** Commented in VQC ***/
		varchar c_exp_dt[ LEN_DATE ];
    varchar c_usr_usr_psswrd[50+1];

    /*** Commented in VQC
		long int li_opn_qty;
    varchar c_trd_dt[LEN_DATE];
		varchar c_trade_dt[LEN_DATE];
    varchar c_date[LEN_DATE];
    ***/

		char	c_exg_stts;
  EXEC SQL END DECLARE SECTION;

  /*** Commented in VQC 
  struct vw_orderbook st_first_ordbk;
  struct vw_orderbook st_next_ordbk;
	struct vw_orderbook st_temp_ordbook;
  ******/
 
  struct vw_err_msg st_err_msg;
  struct vw_contract st_cntrct; /*** Ver 4.3 ***/
  struct vw_contract st_cntrct_insdr; /*** Ver 5.0 ***/
 
  /*** Commented in VQC 
  struct vw_sequence st_s_sequence;
  struct vw_sequence st_r_sequence;
  struct vw_spdordbk st_spd_ordbk;
  ***/

  ptr_fml_Ibuf = (FBFR32 *)rqst->data;
  strcpy(c_ServiceName, rqst->name);
	INITDBGLVL(c_ServiceName);

  /*** Commented in VQC
  MEMSET(st_first_ordbk);  
	MEMSET(st_next_ordbk);   
	MEMSET(st_temp_ordbook);
  ***/
 
	MEMSET(st_usr_prfl);
	MEMSET(st_ordbook);
  MEMSET(st_cntrct);    /*** Ver 4.3 ***/ 
  MEMSET(st_cntrct_insdr);    /*** Ver 5.0 ***/ 
 /***	MEMSET(st_pstn_action); *** Commented in VQC ***/
  
  /*** ver 4.4 starts ***/
  MEMSET(c_sltp_ord_rfrnc_lck);
  MEMSET(c_ordr_rfrnc_lck);
  /*** ver 4.4 ends ***/
  
  MEMSET(c_temp_psswrd);  /** Ver 1.2 **/
  MEMSET(c_usr_usr_psswrd); /** Ver 1.2 **/	
	MEMSET(c_err_msg1);			/*** Ver 4.5 ***/

	MEMSET(c_ven_id); /*** Ver 5.1 ***/

	i_returncode = Fvftos32( ptr_fml_Ibuf,
                           (char *) &st_usr_prfl,
                           "vw_usr_prfl" );

  if ( i_returncode == -1 )
  {
    fn_errlog( c_ServiceName, "S31005", FMLMSG, c_err_msg.arr  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
	  tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  /** if(DEBUG_MSG_LVL_5) Commented in Ver 3.7 ***/
  if(DEBUG_MSG_LVL_1)  /** Ver 3.7 **/
  {
    fn_userlog( c_ServiceName, "User id       :%s:",
                                  st_usr_prfl.c_user_id );
    fn_userlog( c_ServiceName, "Session id    :%ld:",
                                  st_usr_prfl.l_session_id );
    fn_userlog( c_ServiceName, "Match Account :%s:",
                                  st_usr_prfl.c_cln_mtch_accnt );
    fn_userlog( c_ServiceName, "Pipe id :%s:",
                                  st_usr_prfl.c_pipe_id );
  }

 	ptr_fml_Sbuf = (FBFR32 *)tpalloc( "FML32", NULL, MIN_FML_BUF_LEN*3 );
 	if ( ptr_fml_Sbuf == NULL )
 	{
   	fn_errlog( c_ServiceName, "S31010", TPMSG, c_err_msg.arr  );
   	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );  
		Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/ 
   	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
 	}
	
 	i_returncode = Fvstof32( ptr_fml_Sbuf, (char *) &st_usr_prfl,
                             FUPDATE, "vw_usr_prfl" ); 
 	
	if ( i_returncode == -1 )
 	{
		tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
   	fn_errlog( c_ServiceName, "S31015", FMLMSG, c_err_msg.arr  );
   	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );     
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/ 
		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
 	}
 	ptr_fml_Rbuf = (FBFR32 *)tpalloc( "FML32", NULL, MIN_FML_BUF_LEN*3 );

 	if ( ptr_fml_Rbuf == NULL )
 	{
   	fn_errlog( c_ServiceName, "S31020", TPMSG, c_err_msg.arr  );
 		tpfree ( ( char * ) ptr_fml_Sbuf );
   	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );   
   	Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
 	}


 	ptr_fml_Obuf = (FBFR32 *)tpalloc( "FML32", NULL, MIN_FML_BUF_LEN*3 );

 	if ( ptr_fml_Obuf == NULL )
 	{
   	fn_errlog( c_ServiceName, "S31025", TPMSG, c_err_msg.arr  );
 		tpfree ( ( char * ) ptr_fml_Sbuf );
 		tpfree ( ( char * ) ptr_fml_Rbuf );
   	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );    
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
 	}

  /**** session check *****/

	/*** Commented for Ver 3.5 ***
	if (st_usr_prfl.l_session_id !=0)  
 	{
   	i_returncode = fn_chk_sssn( c_ServiceName,
 	                              &st_usr_prfl,
   	                            &st_err_msg ) ;

 		if ( i_returncode == -1 )
 		{
   		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );
			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      *** Ver 1.3 ***
 	    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); *** Ver 2.2 ***
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); *** Ver 2.2 ***
	  	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
 		}
 	}
	*** Ver 3.5 ***/

	/*** Commented and moved to below for Ver 3.5 ****
  i_trnsctn = fn_begintran( c_ServiceName, c_err_msg );
  if ( i_trnsctn == -1 )
  {
    fn_errlog( c_ServiceName, "S31030", LIBMSG , c_err_msg );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      *** Ver 1.3 ***
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); *** Ver 2.2 ***
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); *** Ver 2.2 ***
	  tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
	
  i_returncode = fn_lock_usr( c_ServiceName, st_usr_prfl.c_cln_mtch_accnt );
  if ( i_returncode == -1 )
  {
    fn_errlog( c_ServiceName, "S31035", LIBMSG , c_err_msg );
    fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      *** Ver 1.3 ***
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); *** Ver 2.2 ***
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); *** Ver 2.2 ***
	  tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
	****** Ver 3.5 ***/

 	i_err[0]= Fget32(ptr_fml_Ibuf, FFO_XCHNG_CD,0,
                										(char *)st_ordbook.c_xchng_cd, 0);
 	i_ferr [ 0 ] = Ferror32;

 	i_err[1]= Fget32(ptr_fml_Ibuf, FFO_PRDCT_TYP,0,
                										(char *)&st_ordbook.c_prd_typ, 0);
 	i_ferr [ 1 ] = Ferror32;

 	i_err[2]= Fget32(ptr_fml_Ibuf, FFO_UNDRLYNG,0,
                										(char *)st_ordbook.c_undrlyng, 0);
 	i_ferr [ 2 ] = Ferror32;

 	i_err[3]= Fget32(ptr_fml_Ibuf, FFO_EXPRY_DT,0,
                										(char *)c_exp_dt.arr, 0);
 	i_ferr [ 3 ] = Ferror32;

 	i_err[4]= Fget32(ptr_fml_Ibuf, FFO_EXER_TYP,0,
                										(char *)&st_ordbook.c_exrc_typ, 0);
 	i_ferr [ 4 ] = Ferror32;

 	i_err[5]= Fget32(ptr_fml_Ibuf, FFO_OPT_TYP,0,
                										(char *)&st_ordbook.c_opt_typ, 0);
 	i_ferr [ 5 ] = Ferror32;

 	i_err[6]= Fget32(ptr_fml_Ibuf, FFO_STRK_PRC,0,
                										(char *)&st_ordbook.l_strike_prc, 0);
 	i_ferr [ 6 ] = Ferror32;

 	i_err[7]= Fget32(ptr_fml_Ibuf, FFO_CTGRY_INDSTK,0,
                										(char *)&st_ordbook.c_ctgry_indstk, 0);
 	i_ferr [ 7 ] = Ferror32;

 	i_err[8]= Fget32(ptr_fml_Ibuf, FFO_ORDR_FLW,0,
                										(char *)&st_ordbook.c_ordr_flw, 0);
 	i_ferr [ 8 ] = Ferror32;

 	i_err[9]= Fget32(ptr_fml_Ibuf, FFO_LMT_MKT_SL_FLG,0,
                										(char *)&st_ordbook.c_slm_flg, 0);
 	i_ferr [ 9 ] = Ferror32;

 	i_err[10]= Fget32(ptr_fml_Ibuf, FFO_ORD_TOT_QTY,0,
                										(char *)&st_ordbook.l_ord_tot_qty, 0);
 	i_ferr [ 10 ] = Ferror32;

 	i_err[11]= Fget32(ptr_fml_Ibuf, FFO_LMT_RT,0,
                 										(char *)&st_ordbook.l_ord_lmt_rt, 0);
 	i_ferr [ 11 ] = Ferror32;

 	i_err[12]= Fget32(ptr_fml_Ibuf, FFO_CHANNEL,0,
                										(char *)st_ordbook.c_channel, 0); 
 	i_ferr [ 12 ] = Ferror32;
		
 	i_err[13]= Fget32(ptr_fml_Ibuf, FFO_STP_LSS_TGR,0,
                                     (char *)&st_ordbook.l_stp_lss_tgr, 0);
  i_ferr [13] = Ferror32;
			
	i_err[ 14 ] = Fget32(ptr_fml_Ibuf, FFO_ORD_TYP ,0,
                                     (char *)&st_ordbook.c_ord_typ,0);
 	i_ferr [14 ] = Ferror32;
	i_err[ 15 ] = Fget32(ptr_fml_Ibuf, FFO_TRD_PSSWD,0,
																		 (char *)c_usr_usr_psswrd.arr,0);
	i_ferr [ 15 ] = Ferror32;

 	for(i=0; i < 16; i++) 
 	{
 		if ( (i_err[ i ] == -1 ) && i_ferr[15] != FNOTPRES )
		{
      fn_userlog( c_ServiceName, "Exchange code :%d %d :",i_err[ i ],i);
			fn_errlog( c_ServiceName, "S31040",
      Fstrerror32(i_ferr[i]),c_err_msg.arr);
 			tpfree ( ( char * ) ptr_fml_Sbuf );
 			tpfree ( ( char * ) ptr_fml_Rbuf );
 			tpfree ( ( char * ) ptr_fml_Obuf );
			/** fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); Commented in Ver 3.9 **/
 			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		  Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
 		  Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
	}

	i_err[ 16 ] = Fget32(ptr_fml_Ibuf, FFO_MKT_TYP ,0,
                                     (char *)&st_ordbook.c_mrkt_typ,0);                         /*** Ver 2.5 ***/
  i_ferr [ 16 ] = Ferror32;

  if ( (i_err[ 16 ] == -1 ) && i_ferr[16] != FNOTPRES || st_ordbook.c_mrkt_typ == '\0' ) /* VER TOL : TUX on LINUX -- Changed NULL to \0 (Ravindra) */
  {
	if(i_ferr[16] != FNOTPRES || st_ordbook.c_mrkt_typ == '\0') /* VER TOL : TUX on LINUX -- Changed NULL to \0 (Ravindra) */
		{
			st_ordbook.c_mrkt_typ = 'M';
		}
		else
		{
     	fn_userlog( c_ServiceName, "Exchange code :%d %d :",i_err[ i ],i);
     	fn_errlog( c_ServiceName, "S31045",
     	Fstrerror32(i_ferr[i]),c_err_msg.arr);
   	  tpfree ( ( char * ) ptr_fml_Sbuf );
     	tpfree ( ( char * ) ptr_fml_Rbuf );
     	tpfree ( ( char * ) ptr_fml_Obuf );
     	/**fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); Commented in Ver 3.9 **/
     	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
     	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
   	}	
	}
  if(st_ordbook.c_mrkt_typ == 'L')
  {
    i_err[ 17 ] = Fget32(ptr_fml_Ibuf, FFO_OPNPSTN_RT ,0,
                                      (char *)&l_lmt_rt,0);                                       /*** Ver 2.5 ***/
    i_ferr [ 17 ] = Ferror32;
		
		if ( i_err[ 17 ] == -1 )
		{
			fn_userlog( c_ServiceName, "Exchange code :%d %d :",i_err[ i ],i);
      fn_errlog( c_ServiceName, "S31050",
      Fstrerror32(i_ferr[i]),c_err_msg.arr);
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
      /**fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); Commented in Ver 3.9 **/
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
	}
  i_err[ 18 ] = Fget32(ptr_fml_Ibuf, FFO_REQ_TYP ,0,
                                     (char *)&st_ordbook.c_req_typ,0);                         /*** Ver 2.5 ***/
  i_ferr [ 18 ] = Ferror32;
		
	if ( (i_err[ 18 ] == -1 ) && i_ferr[18] != FNOTPRES || st_ordbook.c_req_typ == '\0') /* VER TOL : TUX on LINUX -- Changed NULL to \0 (Ravindra) */
  {
   	if(i_ferr[18] != FNOTPRES || st_ordbook.c_req_typ == '\0') /* VER TOL : TUX on LINUX -- Changed NULL to \0 (Ravindra) */
   	{
     	st_ordbook.c_req_typ= 'P';
   	}
   	else
   	{
     	fn_userlog( c_ServiceName, "Exchange code :%d %d :",i_err[ i ],i);
     	fn_errlog( c_ServiceName, "S31055",
     	Fstrerror32(i_ferr[i]),c_err_msg.arr);
     	tpfree ( ( char * ) ptr_fml_Sbuf );
     	tpfree ( ( char * ) ptr_fml_Rbuf );
     	tpfree ( ( char * ) ptr_fml_Obuf );
     	/**fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); Commented in Ver 3.9 **/
     	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
     	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
     	Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
   	}
  }

  i_err[ 19 ] = Fget32(ptr_fml_Ibuf, FFO_STATUS_FLG,0,
                                     (char *)&c_src_flg,0);      /** Ver 3.3 **/
  i_ferr [ 19 ] = Ferror32;

  if ( (i_err[ 19 ] == -1 ) && i_ferr[19] != FNOTPRES)
  {
      fn_userlog( c_ServiceName, "Exchange code :%d %d :",i_err[ i ],i);
      fn_errlog( c_ServiceName, "S31060",
      Fstrerror32(i_ferr[i]),c_err_msg.arr);
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
      /**fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); Commented in Ver 3.9 **/
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
  else if (c_src_flg == '\0') /* VER TOL : TUX on LINUX -- Changed NULL to \0 (Ravindra) */
  {
    c_src_flg = 'O';
  }

  if(DEBUG_MSG_LVL_3)  /** Ver 3.7 **/
  {
  	fn_userlog( c_ServiceName, "After get source flag.....:%c:",c_src_flg);
	
		fn_userlog( c_ServiceName, "fresh limit rate :%ld:",l_lmt_rt); /** %lf changed to %ld in Ver 3.9 **/
	}

	/*** Ver 5.1 starts ***/
    MEMSET(c_ven_id);
    i_err[20]  = Fget32(ptr_fml_Ibuf,FFO_USER_CODE,0,(char *)c_ven_id.arr,0);
    i_ferr [20] = Ferror32;

    if ( i_err[0] == -1 )
    {
      if ( Ferror32 != FNOTPRES )
      {
     		fn_errlog( c_ServiceName, "S31065", Fstrerror32(i_ferr[i]),c_err_msg.arr);
        tpfree ( ( char * ) ptr_fml_Sbuf );
        tpfree ( ( char * ) ptr_fml_Rbuf );
        tpfree ( ( char * ) ptr_fml_Obuf );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); 
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
      else if( Ferror32 == FNOTPRES )
      {
        strcpy(c_ven_id.arr,"");
      }
    }
		SETLEN(c_ven_id);
	/*** Ver 5.1 ends ***/

   if(DEBUG_MSG_LVL_1)
   {
     fn_userlog( c_ServiceName, " Fresh Order Flow Is :%c:",st_ordbook.c_ordr_flw); /*** Ver 3.6 ***/
   }

  /*** Commented in Ver 3.6 *** For double order modification cover order flow was passed from front end instead of fresh order flow, so we asked front end to pass proper flow i.e. fresh order flow ***

  if(strcmp(st_ordbook.c_channel,"WEB") == 0)   *** Ver 3.1 ***
  { 
	** Ver 2.5 starts ** ** Revert the order flow for modification because validations for modification depends on 
														 Fresh order flow. **                                              
  	if(st_ordbook.c_req_typ == 'M' && st_ordbook.c_ordr_flw == 'B')
	  {
		 st_ordbook.c_ordr_flw = 'S';
	  }
	  else if(st_ordbook.c_req_typ == 'M' && st_ordbook.c_ordr_flw == 'S')
	  {
		 st_ordbook.c_ordr_flw = 'B';
	  } 
	** Ver 2.5 ends ** 
  } 

  *********************/

	if(st_usr_prfl.c_user_id[0] == BPID)
 	{
   	if(Fget32(ptr_fml_Ibuf,FFO_ALIAS,0,(char *)c_alias,0) == -1)
   	{
     	fn_errlog( c_ServiceName, "S31070", FMLMSG, c_err_msg.arr  );
 			tpfree ( ( char * ) ptr_fml_Sbuf );
 			tpfree ( ( char * ) ptr_fml_Rbuf );
			tpfree ( ( char * ) ptr_fml_Obuf );
			/**fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); Commented in Ver 3.9 **/
 			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
 	    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
   	}
	}

	SETLEN(c_exp_dt);

	strcpy ( st_ordbook.c_expry_dt, ( char * ) c_exp_dt.arr );

	if(DEBUG_MSG_LVL_5)
	{
		fn_userlog( c_ServiceName, "Exchange code :%s:",
                              st_ordbook.c_xchng_cd );
 		fn_userlog( c_ServiceName, "Product Type  :%c:",
                                st_ordbook.c_prd_typ );
 		fn_userlog( c_ServiceName, "Underlyng     :%s:",
                                st_ordbook.c_undrlyng );
 		fn_userlog( c_ServiceName, "Expiry date   :%s:",
                                st_ordbook.c_expry_dt);
 		fn_userlog( c_ServiceName, "Excercise Type:%c:",
                               st_ordbook.c_exrc_typ );
 		fn_userlog( c_ServiceName, "Option type   :%c:",
                               st_ordbook.c_opt_typ );
 		fn_userlog( c_ServiceName, "Strike price  :%ld:",
                               st_ordbook.l_strike_prc );
 		fn_userlog( c_ServiceName, "Category      :%c:",
                               st_ordbook.c_ctgry_indstk );
 		fn_userlog( c_ServiceName, "Order flow B/S:%c:",
                               st_ordbook.c_ordr_flw );
 		fn_userlog( c_ServiceName, "Lmt/Mkt/StpLss:%c:",
                               st_ordbook.c_slm_flg );
 		fn_userlog( c_ServiceName, "Order Qty     :%ld:",
                               st_ordbook.l_ord_tot_qty );
 		fn_userlog( c_ServiceName, "Limit rate    :%ld:",
                               st_ordbook.l_ord_lmt_rt );
 		fn_userlog( c_ServiceName, "CHANNEL   :%s:",
                                st_ordbook.c_channel);
 		fn_userlog( c_ServiceName, "ALIAS   :%s:",
                                c_alias);
		fn_userlog( c_ServiceName, "Market Type   :%c:",															/**** Ver 2.5 ****/
																st_ordbook.c_mrkt_typ);
		fn_userlog( c_ServiceName, "Fresh Limit Rate :%ld:",													/**** Ver 2.5 ****/
																l_lmt_rt);
		fn_userlog( c_ServiceName, "Request Type :%c:",																/**** Ver 2.5 ****/
															 st_ordbook.c_req_typ);
	}

	st_ordbook.l_dsclsd_qty = 0 ;
  c_spl_flg = 'N';



	/*** Ver 5.1 starts ***/
  if ( st_ordbook.c_req_typ == 'P' && (st_ordbook.c_ctgry_indstk != 'I' || st_ordbook.c_ctgry_indstk != 'S') )
  {
    SETLEN(c_exp_dt);

     EXEC SQL
      SELECT FTQ_INDSTK
      INTO  :st_ordbook.c_ctgry_indstk
      FROM  FTQ_FO_TRD_QT
      WHERE FTQ_XCHNG_CD  =:st_ordbook.c_xchng_cd
      AND   FTQ_PRDCT_TYP = DECODE(:st_ordbook.c_prd_typ,'P','F','U','F','I','O',:st_ordbook.c_prd_typ)
      AND   FTQ_UNDRLYNG  =:st_ordbook.c_undrlyng
      AND   FTQ_OPT_TYP   =:st_ordbook.c_opt_typ
      AND   FTQ_STRK_PRC  =:st_ordbook.l_strike_prc
      AND   FTQ_EXPRY_DT  =:c_exp_dt;

      if (SQLCODE != 0)
      {
        fn_errlog( c_ServiceName, "S31075", SQLMSG,c_err_msg.arr  );
        tpfree ( ( char * ) ptr_fml_Sbuf );
        tpfree ( ( char * ) ptr_fml_Rbuf );
        tpfree ( ( char * ) ptr_fml_Obuf );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
  }
  /*** Ver 5.1 ends ***/

  /*** Ver 2.7 Starts ***/
	/** Ver 5.0 Starts **/
   st_cntrct_insdr.c_prd_typ = st_ordbook.c_prd_typ;
   st_cntrct_insdr.c_ctgry_indstk = st_ordbook.c_ctgry_indstk;
	 strcpy(st_cntrct_insdr.c_undrlyng,st_ordbook.c_undrlyng);
		
	/** Ver 5.0 Ends **/
  i_returncode = fn_chk_und_insider(c_ServiceName,
                                    st_usr_prfl,
																		st_cntrct_insdr, /** Ver 5.0 **/
                                    /* st_ordbook.c_undrlyng, ** Ver 5.0 Comment **/
                                    &insider_exist);
  if (i_returncode == -1)
  {
      fn_errlog( c_ServiceName, "S31080", "Error in Function fn_chk_und_insider", c_err_msg.arr);
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
      /**fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); commented in Ver 3.9 **/
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
   }
    if (insider_exist == 1)
  {
      fn_errlog( c_ServiceName, "B91164", DEFMSG, c_err_msg.arr  ); /** Ver 5.0 B21042 changed to B91164 **/
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
      /**fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); commented in Ver 3.9 **/
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
   }

  /*** Ver 2.7 Ends ***/

	/*** Ver 1.6 Starts ***/

	/*** Commented in Ver 2.0 ***
  if ( (strncmp(st_usr_prfl.c_cln_mtch_accnt, "750", 3)  == 0 ) ||
       (strncmp(st_usr_prfl.c_cln_mtch_accnt, "751", 3)  == 0 ) ||
       (strncmp(st_usr_prfl.c_cln_mtch_accnt, "650", 3)  == 0 ) ||
       (strncmp(st_usr_prfl.c_cln_mtch_accnt, "651", 3)  == 0 )
     )
   {
      if(DEBUG_MSG_LVL_3)
      {
        fn_userlog(c_ServiceName,"NRI Customer Trying To Place SLTP FuturePlus Order .");
      }

      fn_errlog( c_ServiceName, "S31085", "This facility is not enabled for NRI customers.", c_err_msg  );
      strcpy(c_err_msg,"This facility is not enabled for NRI customers");
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG,c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
   }
	 ***/

  /*** Ver 1.6 Ends ***/
	
	/**Call function for trading limit check **/
  	i_returncode = fn_chk_trdng_limit(c_ServiceName,
    	                                st_ordbook.l_ord_tot_qty,
      	                              st_ordbook.l_ord_lmt_rt,
        	                            &c_trdng_psswrd_flg,
          	                          &st_usr_prfl,
            	                        &st_err_msg );
  	if ( i_returncode == -1 )
  	{
			/**fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); commented in Ver 3.9 **/
 	   	fn_errlog( c_ServiceName, "S31090", LIBMSG, c_err_msg.arr );
			tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
      tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
      tpfree ( ( char * ) ptr_fml_Obuf ); /** Ver 3.9 **/
  	  Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );
    	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );  
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
    	Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	}

 	 	if(DEBUG_MSG_LVL_5)
  	{
   		fn_userlog( c_ServiceName, "c_trdng_psswrd_flg:%c:", c_trdng_psswrd_flg );
  	}

 	  SETLEN( c_usr_usr_psswrd );
 		if ( c_trdng_psswrd_flg == YES )
  	{
    	strcpy( c_temp_psswrd, (char *)c_usr_usr_psswrd.arr );
  	}
	
  i_returncode =  fn_check_user_ip ( c_ServiceName,
                                      &st_usr_prfl ,
                                      c_temp_psswrd,
                                      c_trdng_psswrd_flg,
                                      c_ip_address,
                                      c_txn_flg,                   /*** Ver 3.4 ***/
                                      &st_err_msg );

  if ( i_returncode == -1 )
  {
		/**fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); **/
    fn_errlog( c_ServiceName, "S31095", LIBMSG, c_err_msg.arr );
		tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
		tpfree ( ( char * ) ptr_fml_Rbuf );	/** Ver 3.9 **/
    tpfree ( ( char * ) ptr_fml_Obuf );	/** Ver 3.9 **/
		fn_userlog(c_ServiceName,"error message :%s:",st_err_msg.c_err_msg);
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );

    if ( c_trdng_psswrd_flg ==  'Y' )
    {
      i_actn_id = 1;
    }
    else
    {
      i_actn_id = -1;
    }

    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
		Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/	
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  /*** if(DEBUG_MSG_LVL_3) Commented in Ver 3.7 ***/
  if(DEBUG_MSG_LVL_1)
  {
    fn_userlog(c_ServiceName,"ip address:%s:",c_ip_address);
  }
  /*** Ver 1.3 ** Starts *** Select User Current Pipe ID ******/

	/*** Added from above for Ver 3.5 ***/
  i_trnsctn = fn_begintran( c_ServiceName, c_err_msg.arr );
  if ( i_trnsctn == -1 )
  {
    fn_errlog( c_ServiceName, "S31100", LIBMSG , c_err_msg.arr );
		tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
		tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
		tpfree ( ( char * ) ptr_fml_Obuf ); /** Ver 3.9 **/
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
	  tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
	

  /*** version 4.4 starts ***/
  if( st_ordbook.c_req_typ == 'M' || st_ordbook.c_req_typ == 'C' )
  {
      i_err[0]= Fget32(ptr_fml_Ibuf, FFO_ORDR_RFRNC,0,(char *)&c_frsh_ordr_rfrnc, 0);
      i_ferr [ 0 ] = Ferror32; 
      i_err[1]= Fget32(ptr_fml_Ibuf, FFO_ORDR_RFRNC,1,(char *)&c_cvr_ordr_rfrnc, 0);
      i_ferr [ 1 ] = Ferror32;

      for( i=0; i < 2; i++ )
      {
      		if ( (i_err[ i ] == -1 ) )
          {
              fn_errlog( c_ServiceName, "S31105",Fstrerror32(i_ferr[i]),c_err_msg.arr);
              tpfree ( ( char * ) ptr_fml_Sbuf );
              tpfree ( ( char * ) ptr_fml_Rbuf );
              tpfree ( ( char * ) ptr_fml_Obuf );
              fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
              Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
              Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
              Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          }
      }

      EXEC    SQL
      SELECT  FOD_ORDR_RFRNC,
              FOD_SLTP_ORDR_RFRNC,
							FOD_INDSTK  /***Ver 4.9 ***/
      INTO    :c_ordr_rfrnc_lck,
              :c_sltp_ord_rfrnc_lck ,
							:c_indstk  /*** Ver 4.9 ***/ 
      FROM    FOD_FO_ORDR_DTLS
      WHERE   FOD_ORDR_RFRNC in ( :c_frsh_ordr_rfrnc,:c_cvr_ordr_rfrnc )
        FOR   UPDATE OF FOD_ORDR_RFRNC; 

    if ( SQLCODE != 0  )
    {
        if (SQLCODE == -54)
        {
             fn_userlog( c_ServiceName, "Resource busy and failed to acquire lock" );
        }
              tpfree ( ( char * ) ptr_fml_Sbuf );
              tpfree ( ( char * ) ptr_fml_Rbuf );
              tpfree ( ( char * ) ptr_fml_Obuf );
              fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
              Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
              Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
              Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
    else
    {
      fn_userlog( c_ServiceName, "Sucessfully acquired FOR UPDATE lock on :%s: and :%s:",c_frsh_ordr_rfrnc,c_cvr_ordr_rfrnc );
    }

		st_ordbook.c_ctgry_indstk = c_indstk[0][0];  /*** Ver 4.9 ***/
		fn_userlog( c_ServiceName, "Navina:%c:%c:%c:%c:",c_indstk[0][0],c_indstk[0][1],c_indstk[1][0],c_indstk[1][1]);	/*** Ver 4.9 ***/
  }
  /*** version 4.4 ends ***/
  /* i_returncode = fn_lock_usr( c_ServiceName, st_usr_prfl.c_cln_mtch_accnt ); commented in 5.2 */
  i_returncode = fn_lock_fno( c_ServiceName, st_usr_prfl.c_cln_mtch_accnt ); /* added in 5.2 */
  if ( i_returncode == -1 )
  {
    fn_errlog( c_ServiceName, "S31110", LIBMSG , c_err_msg.arr );
    tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
    tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
    tpfree ( ( char * ) ptr_fml_Obuf ); /** Ver 3.9 **/
    fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
   /*** End for Ver 3.5 ***/
/******* Commented in Ver 4.0 ****
  EXEC SQL
      SELECT  PCM_CRNT_PIPE_ID
      INTO    :st_usr_prfl.c_pipe_id
      FROM    PCM_PIPE_CLM_MAP
      WHERE   PCM_CLM_MTCH_ACCNT  = :st_usr_prfl.c_cln_mtch_accnt
      AND     PCM_XCHNG_CD        = :st_ordbook.c_xchng_cd ;

  if( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
  {
    fn_errlog( c_ServiceName, "S31115", SQLMSG,c_err_msg.arr  );
		tpfree ( ( char * ) ptr_fml_Sbuf ); ** Ver 3.9 **
		tpfree ( ( char * ) ptr_fml_Rbuf ); ** Ver 3.9 **
		tpfree ( ( char * ) ptr_fml_Obuf ); ** Ver 3.9 **
    fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); *** Ver 2.2 ***
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); *** Ver 2.2 ***
	  tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  *** Ver 1.3 Ends ***

		********Check whether trading on SLTP is allowed******

   *** Column names in below query changed to capital case in Ver 4.1 ***

		EXEC SQL
				SELECT 	MTM_SLTP_ALLWD_STTS,
								MTM_SLTP_EOS_FLG
	    	INTO    :c_sltp_stts,
       				  :c_sltp_eos_flg
 				FROM    MTM_APPLN_STTS
 				WHERE  	MTM_XCHNG_CD =  :st_ordbook.c_xchng_cd
 				AND    	MTM_PIPE_ID  =  :st_usr_prfl.c_pipe_id;

		if( SQLCODE != 0 )
 		{
   		fn_errlog( c_ServiceName, "S31120", SQLMSG,c_err_msg.arr  );
			tpfree ( ( char * ) ptr_fml_Sbuf ); ** Ver 3.9 **
			tpfree ( ( char * ) ptr_fml_Rbuf ); ** Ver 3.9 **
			tpfree ( ( char * ) ptr_fml_Obuf ); ** Ver 3.9 **
   		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      *** Ver 1.3 ***
	    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); *** Ver 2.2 ***
    	Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); *** Ver 2.2 ***
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
 		}***** Comment End in Ver 4.0 ****/
    
    /*********** Ver 4.0 Starts *************/

		fn_userlog( c_ServiceName, "CR-ISEC14-144377 Index/Stock :%c:",  st_ordbook.c_ctgry_indstk );		/*** Added in Ver 4.9 ***/

    EXEC SQL
        SELECT  PCM_CRNT_PIPE_ID,
                /*** MTM_SLTP_ALLWD_STTS,	
								MTM_SLTP_EOS_FLG	Commented in Ver 4.9 ***/
								/**** DECODE Added in Ver 4.9 ***/ 
								DECODE ( :st_ordbook.c_ctgry_indstk,'I',MTM_SLTP_ALLWD_STTS_I,'S',MTM_SLTP_ALLWD_STTS_S,'N' ),
								DECODE ( :st_ordbook.c_ctgry_indstk,'I',MTM_SLTP_EOS_FLG,'S',MTM_SLTP_EOS_FLG_S,'N' )
        INTO    :st_usr_prfl.c_pipe_id,
                :c_sltp_stts,
                :c_sltp_eos_flg
        FROM    PCM_PIPE_CLM_MAP,
                MTM_APPLN_STTS
        WHERE   PCM_CLM_MTCH_ACCNT  = :st_usr_prfl.c_cln_mtch_accnt
        AND     PCM_XCHNG_CD        = :st_ordbook.c_xchng_cd
        AND     MTM_XCHNG_CD =  :st_ordbook.c_xchng_cd
        AND     MTM_PIPE_ID = PCM_CRNT_PIPE_ID;

    if( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31125", SQLMSG,c_err_msg.arr  );
      fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
      tpfree ( ( char * ) ptr_fml_Sbuf );  /*** Ver 3.2 ***/
      tpfree ( ( char * ) ptr_fml_Rbuf );  /*** Ver 3.2 ***/
      tpfree ( ( char * ) ptr_fml_Obuf );  /*** Ver 3.2 ***/
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

    /******** Ver 4.0 Ends ************/
		if (c_sltp_stts == 'N' )
 		{
			tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
			tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
			tpfree ( ( char * ) ptr_fml_Obuf ); /** Ver 3.9 **/
			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
   		fn_errlog( c_ServiceName, "B35013",DEFMSG,c_err_msg.arr);
   		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
   	  Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
    	Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
 		}

		if(c_sltp_eos_flg =='Y')
		{
			tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
			tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
			tpfree ( ( char * ) ptr_fml_Obuf ); /** Ver 3.9 **/
			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
			fn_errlog( c_ServiceName, "B35014",DEFMSG,c_err_msg.arr);
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
		  Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
    	Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
	
   /*** Column names in below query changed to capital case in Ver 4.1 ***/ 
	
		EXEC SQL
		 SELECT /*** to_char( exg_nxt_trd_dt, 'DD-Mon-YYYY' ),
           	to_char( exg_nxt_trd_dt, 'YYYYMMDD' ),  *** Commented in VQC ***/
           	EXG_CRRNT_STTS
   	 INTO   /*** :c_trd_dt,
           	:c_date,			*** Commented in VQC ***/
          	:c_exg_stts
   	 FROM  	EXG_XCHNG_MSTR
  	 WHERE  EXG_XCHNG_CD = :st_ordbook.c_xchng_cd
   	 /*** AND    EXG_MKT_TYP  = 'D';  *** Commented in Ver 4.1 ***/
     AND    EXG_MKT_TYP  = :c_exg_d_mkt_typ ;  /*** Ver 4.1 bind variable used instead of hard coded value ***/

		if ( SQLCODE != 0 )
  	{
		 tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
		 tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
		 tpfree ( ( char * ) ptr_fml_Obuf ); /** Ver 3.9 **/
     fn_errlog( c_ServiceName, "S31130",SQLMSG,c_err_msg.arr);
		 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
     Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		 Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
     Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
     Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/ 
		 tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
   	}

    /*** Commented in VQC
		SETNULL ( c_trd_dt );
		SETNULL ( c_date );
    ***/

		if( c_exg_stts != EXCHANGE_OPEN )
 		{
			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
   		tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
			tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
			tpfree ( ( char * ) ptr_fml_Obuf ); /** Ver 3.9 **/
			fn_errlog( c_ServiceName, "S31135","FuturePlus with Stop Loss Limit Margin orders can be placed only when the Exchange is open",c_err_msg.arr);
			strcpy(c_err_msg.arr,"FuturePlus with Stop Loss Limit Margin orders can be placed only when the Exchange is open");
   		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 ); 
    	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
   	  Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
    	Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
 		}

		if( st_ordbook.c_req_typ == 'P')																						/*** if() added in Ver 2.5 ***/
		{

			/*** Ver 3.0 Starts ***/
			c_source_flg = 'P'; /*** Ver 3.0 Call from Placement ***/
			c_rqst_typ  = 'L';   /*** Ver 3.0 Call from Placement ***/

  		if(DEBUG_MSG_LVL_3)  /** Ver 3.7 **/
  		{
				fn_userlog( c_ServiceName, "st_ordbook.c_ordr_flw.................:%c:",st_ordbook.c_ordr_flw);
			}

			if(st_ordbook.c_ordr_flw == 'B')
			{
				c_cvr_ordr_flw='S';
			}
			else
			{
				c_cvr_ordr_flw='B';
			}
  		if(DEBUG_MSG_LVL_3)  /** Ver 3.7 **/
  		{
				fn_userlog( c_ServiceName, "c_cvr_ordr_flw.................:%c:",c_cvr_ordr_flw);
			}

			i_returncode  = fn_call_svc_fml ( c_ServiceName,
																					 c_err_msg.arr,
																					 "SFO_LMT_PRC_CAL",
																					 0,
																					 13,
																					 1,
																					 FFO_USR_ID                 , (char *)st_usr_prfl.c_user_id,
																					 FFO_SSSN_ID                , (char *)&st_usr_prfl.l_session_id,
																					 FFO_XCHNG_CD               , (char *)st_ordbook.c_xchng_cd,
																					 FFO_ORDR_FLW               , (char *)&c_cvr_ordr_flw,
																					 FFO_UNDRLYNG               , (char *)st_ordbook.c_undrlyng,
																					 FFO_EBA_MTCH_ACT_NO        , (char *)st_usr_prfl.c_cln_mtch_accnt,
																					 FFO_RQST_TYP               , (char *)&c_rqst_typ ,
																					 FFO_PRDCT_TYP              , (char *)&st_ordbook.c_prd_typ,
																					 FFO_OPT_TYP                , (char *)&st_ordbook.c_opt_typ,
																					 FFO_STRK_PRC               , (char *)&st_ordbook.l_strike_prc,
																					 FFO_STP_LSS_TGR            , (char *)&st_ordbook.l_stp_lss_tgr,
																					 FFO_EXPRY_DT               , (char *)c_exp_dt.arr,
																					 FFO_SOURCE_FLG             , (char *)&c_source_flg ,
																					 FFO_LMT_RT                 , (char *)&l_ret_limit_rt ,NULL
																				);

			if (i_returncode != 0)
			{
					fn_errlog( c_ServiceName, "S31140", "Error while calling SFO_LMT_PRC_CAL", c_err_msg.arr);
					fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
					tpfree ( ( char * ) ptr_fml_Sbuf );
					tpfree ( ( char * ) ptr_fml_Rbuf );
					tpfree ( ( char * ) ptr_fml_Obuf );
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
					Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}

  		if(DEBUG_MSG_LVL_3)  /** Ver 3.7 **/
  		{
			  fn_userlog( c_ServiceName, "l_ret_limit_rt.................:%ld:",l_ret_limit_rt);
			}

		if(st_ordbook.l_ord_lmt_rt != l_ret_limit_rt)
		{
				fn_errlog( c_ServiceName, "S31145", "Incorrect Limit Rate received", c_err_msg.arr);
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
				tpfree ( ( char * ) ptr_fml_Sbuf );
				tpfree ( ( char * ) ptr_fml_Rbuf );
				tpfree ( ( char * ) ptr_fml_Obuf );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
				Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
	
		/*** Ver 3.0 Ends ***/
				/******check whether underlying is enabled for trading ***/
		
     l_max_allw_qty = 0;   /*** Added in VQC ****/
	
			EXEC SQL
				SELECT NVL(FUM_QT_TRDNG_FLG,'Q'),
   						 NVL(FUM_SLTP_FP_TRDNG_FLG,'Q'),
               NVL(FUM_SLTPFP_LMT_ALLWD_FLG,'N'),   /*** Added in VQC ***/
               NVL(FUM_SLTPFP_MKT_MAX_ALLWD_QTY,0)  /*** Added in VQC ***/
				INTO   :c_qt_trd_flg,
						 	 :c_sltp_trd_flg,
               :c_lmt_allwd_flg,                    /*** Added in VQC ***/
               :l_max_allw_qty                      /*** Added in VQC ***/
				FROM	 FUM_FO_UNDRLYNG_MSTR
				WHERE	 FUM_XCHNG_CD= :st_ordbook.c_xchng_cd
			/***	AND		 FUM_PRDCT_TYP = 'F'   *** Commented in Ver 4.1 ***/
        AND    FUM_PRDCT_TYP = :c_fum_fut_prd_typ    /*** Ver 4.1 bind variable used instead of hard coded value ***/
				AND    FUM_UNDRLYNG = :st_ordbook.c_undrlyng
				AND		 FUM_CTGRY_INDSTK = :st_ordbook.c_ctgry_indstk;

				if ( SQLCODE  !=  0 && SQLCODE != NO_DATA_FOUND)
  			{
     			fn_errlog( c_ServiceName, "S31150",SQLMSG,c_err_msg.arr);
		 			tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
					tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
					tpfree ( ( char * ) ptr_fml_Obuf ); /** Ver 3.9 **/
					fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
     			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		 			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
         	Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
     			Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/ 
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
   			}
		
				if( c_qt_trd_flg != 'T' || c_sltp_trd_flg != 'T' || SQLCODE == NO_DATA_FOUND )
				{
					fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
					fn_errlog( c_ServiceName, "S31155","This Underlying is currently disabled",c_err_msg.arr);
 					strcpy(c_err_msg.arr,"This Underlying is currently disabled"); 
    			tpfree ( ( char * ) ptr_fml_Sbuf );
    			tpfree ( ( char * ) ptr_fml_Rbuf );
    			tpfree ( ( char * ) ptr_fml_Obuf );
    			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
					Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
        	Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
    			Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/		
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
	
				/**** Check whether contract is enabled ***/
				c_qt_trd_flg = '\0';
				c_sltp_trd_flg = '\0';

				/*** Commented in Ver 2.6 ***

				EXEC SQL
					SELECT nvl(FCM_QT_TRDNG_FLG,'Q'),
  							 nvl(FCM_SLTP_FP_QT_TRDNG_FLG,'Q')
					INTO 	 :c_qt_trd_flg,
								 :c_sltp_trd_flg
					FROM	 FCM_FO_CNTRCT_MSTR 
					WHERE	 FCM_XCHNG_CD = :st_ordbook.c_xchng_cd
					AND		 FCM_PRDCT_TYP = 'F'  
					AND		 FCM_INDSTK = :st_ordbook.c_ctgry_indstk
					AND		 FCM_UNDRLYNG = :st_ordbook.c_undrlyng
					AND    FCM_EXPRY_DT = :st_ordbook.c_expry_dt
					AND    FCM_EXER_TYP = :st_ordbook.c_exrc_typ
					AND		 FCM_OPT_TYP	= :st_ordbook.c_opt_typ
					AND		 FCM_STRK_PRC = :st_ordbook.l_strike_prc;

				*** Ver 2.6 commnet Ends ***/

				/*** Ver 2.6 Starts ***/

				EXEC SQL
					SELECT NVL(FTQ_QT_TRDNG_FLG,'Q'),
								 NVL(FTQ_SLTP_FP_QT_TRDNG_FLG,'Q')
					INTO   :c_qt_trd_flg,
								 :c_sltp_trd_flg
					FROM   FTQ_FO_TRD_QT
					WHERE  FTQ_XCHNG_CD 	= :st_ordbook.c_xchng_cd
		/***	AND    FTQ_PRDCT_TYP 	= 'F'  Commented in Ver 4.1 ***/
          AND    FTQ_PRDCT_TYP	= :c_fum_fut_prd_typ  /*** Ver 4.1 bind variable used instead of hard coded value ***/
					AND    FTQ_INDSTK 		= :st_ordbook.c_ctgry_indstk
					AND    FTQ_UNDRLYNG 	= :st_ordbook.c_undrlyng
					AND    FTQ_EXPRY_DT 	= :st_ordbook.c_expry_dt
					AND    FTQ_EXER_TYP 	= :st_ordbook.c_exrc_typ
					AND    FTQ_OPT_TYP  	= :st_ordbook.c_opt_typ
					AND    FTQ_STRK_PRC 	= :st_ordbook.l_strike_prc;

				/*** Ver 2.6 Ends ***/
		
				if ( SQLCODE  !=  0 && SQLCODE != NO_DATA_FOUND)
  			{
     			fn_errlog( c_ServiceName, "S31160",SQLMSG,c_err_msg.arr);
		 			tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
					tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
					tpfree ( ( char * ) ptr_fml_Obuf ); /** Ver 3.9 **/
					fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
     			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		 			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
     			Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/		
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
   			}

				/** if(DEBUG_MSG_LVL_0) Commented in Ver 3.7 **/
				if(DEBUG_MSG_LVL_3) /** Ver 3.7 **/
  			{
    			fn_userlog( c_ServiceName, "FTQ QT TRADING FLG :%c:", c_qt_trd_flg);
    			fn_userlog( c_ServiceName, "FTQ SLTP FP QT TRADING FLG :%c:", c_sltp_trd_flg);
				}

  			if( c_qt_trd_flg != 'T' || c_sltp_trd_flg != 'T' ||  SQLCODE == NO_DATA_FOUND )
  			{
					fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
     			fn_errlog( c_ServiceName, "S31165","This Contract is currently disabled",c_err_msg.arr);
		 			strcpy(c_err_msg.arr,"This Contract is currently disabled");
     			tpfree ( ( char * ) ptr_fml_Sbuf );
     			tpfree ( ( char * ) ptr_fml_Rbuf );
    			tpfree ( ( char * ) ptr_fml_Obuf );
     			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		 			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
     	    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
     			Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/	
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
   			}
			
			/*** Ver 2.5 starts ***/
     
      /******* Commented in VQC *************

			EXEC SQL
      	SELECT  NVL(FUM_SLTPFP_LMT_ALLWD_FLG,'N')
        	INTO  :c_lmt_allwd_flg
        	FROM  FUM_FO_UNDRLYNG_MSTR
        WHERE  FUM_UNDRLYNG = :st_ordbook.c_undrlyng
				AND  FUM_XCHNG_CD = :st_ordbook.c_xchng_cd
				AND  FUM_PRDCT_TYP = decode(:st_ordbook.c_prd_typ,'U','F','I','O','P','F',:st_ordbook.c_prd_typ);;

				if ( SQLCODE  !=  0 && SQLCODE != NO_DATA_FOUND)
  			{
     			fn_errlog( c_ServiceName, "S31170",SQLMSG,c_err_msg.arr);
		 			tpfree ( ( char * ) ptr_fml_Sbuf ); ** Ver 3.9 **
					tpfree ( ( char * ) ptr_fml_Rbuf ); ** Ver 3.9 **
					tpfree ( ( char * ) ptr_fml_Obuf ); ** Ver 3.9 **
					fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
     			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		 			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); 
     			Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); 
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
   			}

        *** VQC Comment Ends ***/

  		if(st_ordbook.c_mrkt_typ == 'L' && c_lmt_allwd_flg == 'N')
  		{
    		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    		tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
				tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
				tpfree ( ( char * ) ptr_fml_Obuf ); /** Ver 3.9 **/
				fn_errlog( c_ServiceName,"S31175","Only Market orders are allowed in this stock. Please enter market as order type to place your order.",c_err_msg.arr);
    		strcpy(c_err_msg.arr,"Only Market orders are allowed in this stock. Please enter market as order type to place your order.");
    		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG,c_err_msg.arr , 0 );
    		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    		Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
				Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  		}	
		  /*** Ver 2.5 Ends ***/	
		}

  /******** Moved this query here from below in VQC *******/

  EXEC SQL
       SELECT  NVL(CLM_SPAN_ALLWD,'N'),
               NVL(CLM_BSESPAN_ALLWD,'N'),
               CLM_CLNT_LVL
       INTO    :c_spn_allwd_flg,
               :c_bse_span_flag,
               :c_clm_clnt_lvl
       FROM    CLM_CLNT_MSTR
       WHERE   CLM_MTCH_ACCNT  = :st_usr_prfl.c_cln_mtch_accnt;

  if ( SQLCODE  !=  0 )
  {
    tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
    tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
    tpfree ( ( char * ) ptr_fml_Obuf ); /** Ver 3.9 **/
    fn_aborttran( c_ServiceName, i_trnsctn,c_err_msg.arr );
    fn_errlog( c_ServiceName, "S31180",SQLMSG,c_err_msg.arr);
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  /*** Ver 4.3 Starts ***/

  if(st_ordbook.c_req_typ == 'P')
  {
   st_cntrct.c_prd_typ = st_ordbook.c_prd_typ;

    i_returncode = fn_disallow_frsh_expsre(c_ServiceName,
                             st_usr_prfl.c_cln_mtch_accnt,
                             c_spn_allwd_flg,
                             st_ordbook.c_ordr_flw,
                             st_ordbook.l_ord_tot_qty,
                             l_old_ord_qty,
                             &st_cntrct,
                             &st_err_msg );
    if (i_returncode == -1 || i_returncode == -2)
    {
      fn_errlog( c_ServiceName, "S31185", "Error in Function fn_disallow_frsh_expsre",c_err_msg.arr);
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
      fn_aborttran( c_ServiceName, i_trnsctn, st_err_msg.c_err_msg );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG,  st_err_msg.c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
  }
  /*** Ver 4.3 Ends ***/ 
	if( st_ordbook.c_req_typ == 'P' || st_ordbook.c_req_typ == 'M')						/** if() added in Ver 2.5 **/
	{	
		if( (st_ordbook.l_ord_lmt_rt <=0) || (st_ordbook.l_stp_lss_tgr <= 0) )
		{
			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
			tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
			tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
			tpfree ( ( char * ) ptr_fml_Obuf ); /** Ver 3.9 **/
			fn_errlog( c_ServiceName, "S31190","Limit rate or SLTP cannot be less than or equal to Zero.",c_err_msg.arr);
			strcpy(c_err_msg.arr,"Limit rate or SLTP cannot be less than or equal to Zero.");
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
    	Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
	
  /*** Ver 1.6 ** Starts ***/

  if ( st_ordbook.l_stp_lss_tgr != 0 )
  {
    if ( st_ordbook.c_ordr_flw == SELL )        /*** Cover Order Flow Buy ***/
    {
      /** Stop loss trigger price cannot be greater than limit rate **/
      /** for Buy order                                             **/
      if ( st_ordbook.l_stp_lss_tgr > st_ordbook.l_ord_lmt_rt )
      {
				tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
				tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
				tpfree ( ( char * ) ptr_fml_Obuf ); /** Ver 3.9 **/
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        fn_errlog( c_ServiceName, "S31195","Stop loss trigger price cannot be greater than limit rate  for Cover Buy order.",
c_err_msg.arr);
        strcpy(c_err_msg.arr,"Stop loss trigger price cannot be greater than limit rate  for Cover Buy order.");
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
		    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
    }
    if ( st_ordbook.c_ordr_flw == BUY  )      /*** Cover Order Flow Sell ***/
    {
      /** Stop loss trigger price cannot be less  than limit rate   **/
      /** for Sell order                                            **/
      if ( st_ordbook.l_stp_lss_tgr < st_ordbook.l_ord_lmt_rt )
      {
				tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
				tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
				tpfree ( ( char * ) ptr_fml_Obuf ); /** Ver 3.9 **/
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        fn_errlog( c_ServiceName, "S31200","Stop loss trigger price cannot be less  than limit rate for Cover Sell order.",c_err_msg.arr);
        strcpy(c_err_msg.arr,"Stop loss trigger price cannot be less  than limit rate for Cover Sell order.");
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
		    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
    }
  }

  /*** Ver 1.6 ** Ends ***/

  /*** Ver 2.5 ** Starts ***/
	if ( st_ordbook.c_mrkt_typ == 'L' )
  {
		if ( st_ordbook.c_ordr_flw == SELL )        /*** Cover Order Flow Buy ***/
    {
			/** Stop loss triger price and limit price of cover Buy order shall be more than the limit price of civer order **/
			/** for fresh sell order **/
			if(st_ordbook.l_stp_lss_tgr < l_lmt_rt)
			{
				tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
				tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
				tpfree ( ( char * ) ptr_fml_Obuf ); /** Ver 3.9 **/
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        fn_errlog( c_ServiceName, "S31205","Stop loss trigger price and limit price of cover order must be greater than limit rate of fresh SELL order.",c_err_msg.arr);
				strcpy(c_err_msg.arr,"Stop loss trigger price and limit price of cover order must be greater than limit rate of fresh SELL order.");
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); 
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); 
	      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
		}
		
		if ( st_ordbook.c_ordr_flw == BUY  )      /*** Cover Order Flow Sell ***/
		{
			/** Stop loss triger price and limit price of cover Sell order shall be less than  the limit price of Fresh order **/
			/** for fresh Buy order **/
			if(st_ordbook.l_stp_lss_tgr > l_lmt_rt)
      {
				tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
				tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
				tpfree ( ( char * ) ptr_fml_Obuf ); /** Ver 3.9 **/
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        fn_errlog( c_ServiceName, "S31210","Stop loss trigger price and limit price of cover Sell order must be Less than limit rate of fresh BUY order.",c_err_msg.arr);
        strcpy(c_err_msg.arr,"Stop loss trigger price and limit price of cover Sell order must be Less than limit rate of fresh BUY order.");
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
    }
	}
  /*** Ver 2.5 ** Ends ***/
	
	/**** Check order placement will be allowed only to the extent of first 5 bids/offer qty **/
		
  /*** Below query changed to upper case in Ver 4.1 ***/
	
	EXEC SQL
		 SELECT  NVL(FTQ_BST1_BID_PRC,0),
     				 NVL(FTQ_BST1_BID_QTY,0),
             NVL(FTQ_BST2_BID_PRC,0),
           	 NVL(FTQ_BST2_BID_QTY,0),
           	 NVL(FTQ_BST3_BID_PRC,0),
             NVL(FTQ_BST3_BID_QTY,0),
             NVL(FTQ_BST4_BID_PRC,0),
             NVL(FTQ_BST4_BID_QTY,0),
             NVL(FTQ_BST5_BID_PRC,0),
             NVL(FTQ_BST5_BID_QTY,0),
             NVL(FTQ_BST1_OFFR_PRC,0),
             NVL(FTQ_BST1_OFFR_QTY,0),
             NVL(FTQ_BST2_OFFR_PRC,0),
             NVL(FTQ_BST2_OFFR_QTY,0),
             NVL(FTQ_BST3_OFFR_PRC,0),
             NVL(FTQ_BST3_OFFR_QTY,0),
             NVL(FTQ_BST4_OFFR_PRC,0),
             NVL(FTQ_BST4_OFFR_QTY,0),
             NVL(FTQ_BST5_OFFR_PRC,0),
             NVL(FTQ_BST5_OFFR_QTY,0)
 			INTO   :l_bst_bid_prc[0],
             :l_bst_bid_qty[0],
             :l_bst_bid_prc[1],
             :l_bst_bid_qty[1],
             :l_bst_bid_prc[2],
             :l_bst_bid_qty[2],
             :l_bst_bid_prc[3],
             :l_bst_bid_qty[3],
             :l_bst_bid_prc[4],
             :l_bst_bid_qty[4],
             :l_bst_offr_prc[0],
             :l_bst_offr_qty[0],
             :l_bst_offr_prc[1],
             :l_bst_offr_qty[1],
             :l_bst_offr_prc[2],
             :l_bst_offr_qty[2],
             :l_bst_offr_prc[3],
             :l_bst_offr_qty[3],
             :l_bst_offr_prc[4],
             :l_bst_offr_qty[4]
 			FROM   FTQ_FO_TRD_QT
 			WHERE  FTQ_XCHNG_CD  = :st_ordbook.c_xchng_cd 
 /***	AND    FTQ_PRDCT_TYP = 'F'  Commented in Ver 4.1 ***/
      AND    FTQ_PRDCT_TYP = :c_fum_fut_prd_typ   /*** Ver 4.1 bind variable used instead of hard coded value ***/ 
 			AND    FTQ_UNDRLYNG  = :st_ordbook.c_undrlyng
 			AND    FTQ_EXPRY_DT  = :st_ordbook.c_expry_dt
  		AND    FTQ_EXER_TYP  = :st_ordbook.c_exrc_typ
 			AND    FTQ_OPT_TYP   = :st_ordbook.c_opt_typ
 			AND    FTQ_STRK_PRC  = :st_ordbook.l_strike_prc;

	if ( SQLCODE  !=  0 )
  {
		 tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
		 tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
		 tpfree ( ( char * ) ptr_fml_Obuf ); /** Ver 3.9 **/
		 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
     fn_errlog( c_ServiceName, "S31215",SQLMSG,c_err_msg.arr);
     Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		 Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
     Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
     Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
	   tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
   }
	
	d_tot_bid_qty	=	l_bst_bid_qty[0] +
									l_bst_bid_qty[1] +
									l_bst_bid_qty[2] +
									l_bst_bid_qty[3] + 
									l_bst_bid_qty[4];

	d_tot_offr_qty = l_bst_offr_qty[0] +
									 l_bst_offr_qty[1] +
									 l_bst_offr_qty[2] +
									 l_bst_offr_qty[3] +
							 		 l_bst_offr_qty[4];



	if(DEBUG_MSG_LVL_3)
  {	
		fn_userlog( c_ServiceName, "d_tot_bid_qty :%lf:",d_tot_bid_qty);
		fn_userlog( c_ServiceName, "d_tot_offr_qty :%lf:",d_tot_offr_qty);
    fn_userlog(c_ServiceName, "c_clm_clnt_lvl:%c:", c_clm_clnt_lvl);    /*** Added VQC ***/
	}
 
	/***** Fetching sltp % diff *****/
 	EXEC SQL
 			 SELECT NVL(FMM_SLTP_DIFF_PRCNT,0),
         		  NVL(FMM_SLTP_PRCNT,0)
 			 INTO   :d_sltp_diff_prcnt,
       				:d_sltp_prcnt
 			 FROM   FMM_FO_MRGN_MSTR
 			/*** WHERE  FMM_PRDCT_TYP='F'  Commented in Ver 4.1 ***/
       WHERE  FMM_PRDCT_TYP = :c_fum_fut_prd_typ /*** Ver 4.1 bind variable used instead of hard coded value ***/
 			 AND    FMM_UNDRLYNG  = :st_ordbook.c_undrlyng
 			 AND    FMM_XCHNG_CD  = :st_ordbook.c_xchng_cd
			 AND   	FMM_UNDRLYNG_BSKT_ID =(SELECT  FCB_UNDRLYNG_BSKT_ID
    														     FROM    FCB_FO_CLN_BSKT_ALLTD
                                     WHERE   FCB_CLN_LVL = :c_clm_clnt_lvl /*Replaced subquery with bind variable in VQC*/);
                                                           /*** Commented subquery in VQC ***  (SELECT CLM_CLNT_LVL
                                										       FROM    CLM_CLNT_MSTR
                                     										   WHERE   CLM_MTCH_ACCNT = :st_usr_prfl.c_cln_mtch_accnt);  ***/
	if ( SQLCODE  !=  0 )
  {
		 tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
		 tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
		 tpfree ( ( char * ) ptr_fml_Obuf ); /** Ver 3.9 **/
		 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
     fn_errlog( c_ServiceName, "S31220",SQLMSG,c_err_msg.arr);
     Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		 Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
     Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
     Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
	   tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
   }
}

  /******* Moved this query above in VQC *******
	
	EXEC SQL
       SELECT  NVL(CLM_SPAN_ALLWD,'N'),
							 NVL(CLM_BSESPAN_ALLWD,'N')
     	 INTO    :c_spn_allwd_flg,
							 :c_bse_span_flag
     	 FROM    CLM_CLNT_MSTR
       WHERE   CLM_MTCH_ACCNT  = :st_usr_prfl.c_cln_mtch_accnt;

	if ( SQLCODE  !=  0 )
  {
		tpfree ( ( char * ) ptr_fml_Sbuf ); ** Ver 3.9 **
		tpfree ( ( char * ) ptr_fml_Rbuf ); ** Ver 3.9 **
		tpfree ( ( char * ) ptr_fml_Obuf ); ** Ver 3.9 **
		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    fn_errlog( c_ServiceName, "S31225",SQLMSG,c_err_msg.arr);
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      *** Ver 1.3 ***
	  Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); *** Ver 2.2 ***
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); *** Ver 2.2 ***
	  tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  **********************************************/ 

	if(DEBUG_MSG_LVL_3)
  {
		fn_userlog(c_ServiceName,"SPAN ALLWD FLAG IS :%c:",c_spn_allwd_flg);
		fn_userlog(c_ServiceName,"percentage :%lf:",((st_ordbook.l_stp_lss_tgr * d_sltp_diff_prcnt)/100.00));
	}

	if( st_ordbook.c_req_typ == 'P' || st_ordbook.c_req_typ == 'M')           /** if() added in Ver 2.5 **/
  {
		strcpy ( ptr_st_pstn_actn.c_cln_mtch_accnt,st_usr_prfl.c_cln_mtch_accnt);
  	strcpy ( ptr_st_pstn_actn.c_xchng_cd, st_ordbook.c_xchng_cd );
    
    /*** Commented in VQC
  	strcpy ( st_pstn_action.c_cln_mtch_accnt,st_usr_prfl.c_cln_mtch_accnt);
  	strcpy ( st_pstn_action.c_xchng_cd, st_ordbook.c_xchng_cd );
    ***/	
		l_temp_ord_lmt_rt = st_ordbook.l_ord_lmt_rt;
		l_temp_stp_lss_tgr = st_ordbook.l_stp_lss_tgr;
		st_ordbook.l_mdfctn_cntr = 1;

		if (st_ordbook.c_ordr_flw == 'S') /** for cover ordr flw buy **/
		{
			d_diff_amt =  st_ordbook.l_ord_lmt_rt - st_ordbook.l_stp_lss_tgr;  
		}
		else if(st_ordbook.c_ordr_flw == 'B')
		{
	  	d_diff_amt = st_ordbook.l_stp_lss_tgr - st_ordbook.l_ord_lmt_rt; 
		}

		if(DEBUG_MSG_LVL_3)
  	{
	 		fn_userlog(c_ServiceName,"difference :%lf:",d_diff_amt);
		}

		i_flg = 0;

    /************ Commented in VQC ***********
		EXEC SQL
	 		SELECT 1 
	 		INTO   :i_flg
	 		FROM 	 dual
	 		WHERE  :d_diff_amt < ((:st_ordbook.l_stp_lss_tgr * :d_sltp_diff_prcnt)/100.00);

		if ( SQLCODE  !=  0  && SQLCODE != NO_DATA_FOUND)
  	{
			tpfree ( ( char * ) ptr_fml_Sbuf ); ** Ver 3.9 **
			tpfree ( ( char * ) ptr_fml_Rbuf ); ** Ver 3.9 **
			tpfree ( ( char * ) ptr_fml_Obuf ); ** Ver 3.9 **
    	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    	fn_errlog( c_ServiceName, "S31230",SQLMSG,c_err_msg);
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      *** Ver 1.3 ***
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); *** Ver 2.2 ***
    	Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); *** Ver 2.2 ***
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	}

    ********** VQC Commenting Ends ***************/

    /******* Added in VQC *******/

    d_temp_diff_amt = (st_ordbook.l_stp_lss_tgr * d_sltp_diff_prcnt) / 100;

    if( d_diff_amt < d_temp_diff_amt )
    {
        i_flg = 1;
    }

    /******** VQC Ends **********/
  
		if( i_flg == 1)
		{	
			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    	fn_errlog( c_ServiceName, "S31235","Limit and trigger price difference of cover order is less than the defined value",c_err_msg.arr);
			strcpy(c_err_msg.arr,"Limit and trigger price difference of cover order is less than the defined value");
    	tpfree ( ( char * ) ptr_fml_Sbuf );
    	tpfree ( ( char * ) ptr_fml_Rbuf );
    	tpfree ( ( char * ) ptr_fml_Obuf );
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
 		  Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
    	Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
   
	/*Check if the limit price and the trigger price of the cover order are in multiples of 5 paise*/

   if( (fn_5paisa(st_ordbook.l_ord_lmt_rt)!= 0) &&
         (fn_5paisa(st_ordbook.l_stp_lss_tgr)!= 0))
   {
		 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
     fn_errlog( c_ServiceName, "S31240","limit price and the trigger price of the cover order must be in multiples of paise ",c_err_msg.arr);
		 strcpy(c_err_msg.arr,"limit price and the trigger price of the cover order must be in multiples of paise ");
     tpfree ( ( char * ) ptr_fml_Sbuf );
     tpfree ( ( char * ) ptr_fml_Rbuf );
     tpfree ( ( char * ) ptr_fml_Obuf );
     Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		 Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
     Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
     Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
		 tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
	}	
			/********* For Loop Begins *********************/
	 if(st_ordbook.c_req_typ == 'P')																/*** if() added in Ver 2.5 ***/
	 {	
   	for( i_cnt=0; i_cnt < 2; i_cnt++)
   	{
			if(i_cnt == 0 )
			{
				if(st_ordbook.c_mrkt_typ == 'L')
				{
					st_ordbook.c_slm_flg = st_ordbook.c_mrkt_typ;
				} 
				else
				{
					st_ordbook.c_slm_flg = 'M';
				}
				st_ordbook.l_stp_lss_tgr = 0;			
	 	/***		st_first_ordbk.l_ord_tot_qty = st_ordbook.l_ord_tot_qty;	
				strcpy(st_first_ordbk.c_xchng_cd ,st_ordbook.c_xchng_cd);
				st_first_ordbk.c_prd_typ = st_ordbook.c_prd_typ;
				strcpy(st_first_ordbk.c_undrlyng ,st_ordbook.c_undrlyng);
				strcpy(st_first_ordbk.c_expry_dt ,st_ordbook.c_expry_dt);
	 			st_first_ordbk.c_exrc_typ = st_ordbook.c_exrc_typ;	
				st_first_ordbk.c_opt_typ = st_ordbook.c_opt_typ;
				st_first_ordbk.l_strike_prc = st_ordbook.l_strike_prc;    **** Commented in VQC ***/

					/*** Ver 1.8 starts here ***/
				if(st_ordbook.c_mrkt_typ == 'M')									/** if() added in Ver 2.5 **/
				{ 
      		if((st_ordbook.c_ordr_flw == 'S' && st_ordbook.l_ord_tot_qty > d_tot_bid_qty ) ||
        	 	(st_ordbook.c_ordr_flw == 'B' && st_ordbook.l_ord_tot_qty > d_tot_offr_qty))
      		{
						if ( strcmp (st_ordbook.c_undrlyng,"NIFTY") == 0 )
       			{
						
							/** Ver 2.5 starts from Here **/

              /*** Commented in VQC ***
	
							l_max_allw_qty = 0;

							EXEC SQL
          			SELECT  nvl(FUM_SLTPFP_MKT_MAX_ALLWD_QTY,0)
            			INTO  :l_max_allw_qty
            			FROM  FUM_FO_UNDRLYNG_MSTR
           			 WHERE  FUM_XCHNG_CD = :st_ordbook.c_xchng_cd
             			 AND  FUM_UNDRLYNG = :st_ordbook.c_undrlyng
             			 AND  FUM_PRDCT_TYP = 'F';

        			if( SQLCODE != 0 )
        			{
								tpfree ( ( char * ) ptr_fml_Sbuf ); ** Ver 3.9 **
								tpfree ( ( char * ) ptr_fml_Rbuf ); ** Ver 3.9 **
								tpfree ( ( char * ) ptr_fml_Obuf ); ** Ver 3.9 **
          			fn_errlog( c_ServiceName, "S31245", SQLMSG,c_err_msg.arr  );
          			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
          			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          			Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); 
     						Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); 
								tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        			}

              *** VQC comment ends ***/

							if(DEBUG_MSG_LVL_3)
							{
								fn_userlog(c_ServiceName,"Max allowed Qty IS :%ld:",l_max_allw_qty);
							}
							/** Ver 2.5 Ends Here **/
			
          	/**	if ( st_ordbook.l_ord_tot_qty > 5000) commented in Ver 2.5 **/
							if ( st_ordbook.l_ord_tot_qty > l_max_allw_qty)
          		{
            		/*** fn_errlog( c_ServiceName, "S31250","Maximum allowed quantity per order for NIFTY is 5000",c_err_msg.arr); *** Commented in Ver 2.5 ***/
            		/*** strcpy(c_err_msg,"Maximum allowed quantity per order for NIFTY is 5000");  *** Commented in Ver 2.5 ***/
								sprintf(c_err_msg.arr,"Maximum allowed quantity for fresh market order in %s is %ld",st_ordbook.c_undrlyng,l_max_allw_qty);  /*** Ver 2.5 ***/ /*** Ver 2.9 error msg changed ***/
								/* fn_errlog( c_ServiceName, "S31255",c_err_msg.arr,c_err_msg.arr * c_err_msg1 *);  *** Ver 2.5 *** ** Changed from c_err_msg1 to c_err_msg in VQC ***** Commented in ver 4.5 ***/
								fn_errlog( c_ServiceName, "S31260",c_err_msg.arr,c_err_msg1.arr); /*** Ver 4.5 ***/
								fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
            		tpfree ( ( char * ) ptr_fml_Sbuf );
            		tpfree ( ( char * ) ptr_fml_Rbuf );
            		tpfree ( ( char * ) ptr_fml_Obuf );
            		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
            		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
            		Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
            		Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
            		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          		}
          		else
          		{
            		fn_userlog(c_ServiceName,"Order Quantity is greater total bid/offer qty but less than Max Quantity allowed for NIFTY");
            		i_cal_on_wrst_prc = 1;
          		}
       		 }
       		else
       		{
          	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
          	fn_errlog( c_ServiceName, "S31265","Order Quantity is greater than total quantity of best 5 bids/offers",c_err_msg.arr);
          	strcpy(c_err_msg.arr,"Order Quantity is greater than total quantity of best 5 bids/offers");
          	tpfree ( ( char * ) ptr_fml_Sbuf );
          	tpfree ( ( char * ) ptr_fml_Rbuf );
          	tpfree ( ( char * ) ptr_fml_Obuf );
          	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
          	Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
          	Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
          	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
       	 	} 					
     		}
			}	
      /*** Ver 1.8 ends here ***/
		
			/*** Calculating weighted avg price ****/
			if(st_ordbook.c_mrkt_typ == 'M')														/*** if() added in Ver 2.5 ***/
			{			
				if(st_ordbook.c_ordr_flw == 'S' )
				{
					if (i_cal_on_wrst_prc == 1 )    /*** Ver 1.8 ***/
        	{
          	d_avg_prc = (double) l_bst_bid_prc[4];
        	}
        	else    /*** Else loop added in  Ver 1.8 ***/
        	{
						fn_avg_price(c_ServiceName,l_bst_bid_qty,l_bst_bid_prc,&d_avg_prc,st_ordbook.l_ord_tot_qty); /* Service name added in Ver 2.3 */
					}

          /*** ver 4.6 starts ***/
          /*** For Fresh sell order, the weighted average price should not be greater than the *
             * SLTP of cover Buy order ***/
          if(DEBUG_MSG_LVL_3)
          {
             fn_userlog( c_ServiceName," THE l_temp_stp_lss_tgr is :%ld: and d_avg_prc is :%lf:",l_temp_stp_lss_tgr,d_avg_prc);
          }

          if( (double)l_temp_stp_lss_tgr < d_avg_prc )
          {
              fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
              fn_errlog( c_ServiceName, "B22009",DEFMSG,c_err_msg.arr);
              tpfree ( ( char * ) ptr_fml_Sbuf );
              tpfree ( ( char * ) ptr_fml_Rbuf );
              tpfree ( ( char * ) ptr_fml_Obuf );
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
              Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
              Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
              Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); 
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          } 
          /*** ver 4.6 ends ***/
			}
			else if (st_ordbook.c_ordr_flw == 'B')
			{
				if (i_cal_on_wrst_prc == 1 )  /*** Ver 1.8 ***/
        {
          d_avg_prc = (double) l_bst_offr_prc[4];
        }
        else  /*** Else loop added in  Ver 1.8 ***/
        {
					fn_avg_price(c_ServiceName,l_bst_offr_qty,l_bst_offr_prc,&d_avg_prc,st_ordbook.l_ord_tot_qty); /* Service name adde
d in Ver 2.3 */
				}
        
        /*** ver 4.6 starts ***/ 
        /*** For Fresh buy order, the weighted average price should not be less than the *
           * SLTP of cover sell order ***/

        if(DEBUG_MSG_LVL_3)
        {
			     fn_userlog( c_ServiceName," THE l_temp_stp_lss_tgr is :%ld: and d_avg_prc is :%lf:",l_temp_stp_lss_tgr,d_avg_prc);
	      }
        if( (double)l_temp_stp_lss_tgr > d_avg_prc )
        {
              fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
              fn_errlog( c_ServiceName, "B22010",DEFMSG,c_err_msg.arr );
              tpfree ( ( char * ) ptr_fml_Sbuf );
              tpfree ( ( char * ) ptr_fml_Rbuf );
              tpfree ( ( char * ) ptr_fml_Obuf );
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
              Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
              Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
              Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
        /*** ver 4.6 ends ***/
			}
			st_ordbook.l_ord_lmt_rt = 0;
			l_lmt_rt= (long) d_avg_prc;
		}
		else if(st_ordbook.c_mrkt_typ == 'L')											/*** Added in Ver 2.5 ***/
		{
			
			d_avg_prc = (double) l_lmt_rt;
			st_ordbook.l_ord_lmt_rt = (long) d_avg_prc;
  		if(DEBUG_MSG_LVL_3)  /** Ver 3.7 **/
  		{
				fn_userlog( c_ServiceName,"d_avg_prc:%lf:",d_avg_prc);		
				fn_userlog( c_ServiceName,"l_lmt_rt:%ld:",l_lmt_rt);	
			}
		}

			/*** Commented in Ver 2.5    
			d_mrgn_amt= ((st_ordbook.l_ord_tot_qty * d_avg_prc *d_sltp_prcnt)/100);
		 	d_lss_amt = (st_ordbook.c_ordr_flw == 'B' )?
     							 st_ordbook.l_ord_tot_qty * (d_avg_prc - st_ordbook.l_ord_lmt_rt):
     	 						 st_ordbook.l_ord_tot_qty * (d_avg_prc - st_ordbook.l_ord_lmt_rt ) * -1;

			d_mrgn_amt = (long long)d_mrgn_amt;
			d_lss_amt	=	(long long) d_lss_amt;  ***/
			if(DEBUG_MSG_LVL_3)
    	{
			/**	fn_userlog( c_ServiceName, "d_lss_amt = :%lf:",d_lss_amt);		Commented in Ver 2.5
				fn_userlog( c_ServiceName, "d_mrgn_amt :%lf:",d_mrgn_amt); **/
				fn_userlog( c_ServiceName, "st_ordbook.l_ord_tot_qty :%ld:",st_ordbook.l_ord_tot_qty); /** %d changed %ld Ver 3.9 **/
				fn_userlog( c_ServiceName, "d_sltp_prcnt is :%lf:",d_sltp_prcnt);		
				fn_userlog( c_ServiceName, "st_ordbook.l_ord_tot_qty = :%ld:",st_ordbook.l_ord_tot_qty);
				fn_userlog( c_ServiceName, "d_avg_prc = :%lf:",d_avg_prc);
				fn_userlog( c_ServiceName, "st_ordbook.l_ord_lmt_rt = :%ld:",st_ordbook.l_ord_lmt_rt);
			}
	 	}
   	else
   	{
		  st_ordbook.c_slm_flg='S';
			/* VER TOL : TUX on LINUX -- Changed blank space to \0 (Ravindra) */
			st_ordbook.c_ordr_flw =(st_ordbook.c_ordr_flw == 'B'?'S':(st_ordbook.c_ordr_flw == 'S'?'B':'\0'));
      st_ordbook.l_ord_lmt_rt = l_temp_ord_lmt_rt;
      st_ordbook.l_stp_lss_tgr =  l_temp_stp_lss_tgr;
		
  		if(DEBUG_MSG_LVL_3)  /** Ver 3.7 **/
  		{	
				fn_userlog( c_ServiceName, "Cover Order Flow :%c:",st_ordbook.c_ordr_flw);
			}
	  }

		/*** Commented in Ver 1.8 ***
		if((st_ordbook.c_ordr_flw == 'B' && st_ordbook.l_ord_tot_qty > d_tot_bid_qty) ||
        (st_ordbook.c_ordr_flw == 'S' && st_ordbook.l_ord_tot_qty > d_tot_offr_qty))
    {
			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
      fn_errlog( c_ServiceName,"S31270","Order Quantity is greater than total quantity of best 5 bids/offers",c_err_msg.arr);
			strcpy(c_err_msg.arr,"Order Quantity is greater than total quantity of best 5 bids/offers");
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      *** Ver 1.3 ***
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     }
		 ***/

		 if ( (c_spn_allwd_flg == 'Y' && strcmp(st_ordbook.c_xchng_cd,"NFO")==0) ||  
					( c_bse_span_flag == 'Y' && strcmp(st_ordbook.c_xchng_cd,"BFO")==0 ))
		 {
		 	strcpy(c_srvc_nm,"SFO_SPN_PLC_ORD");
		 }
		 else 
		 {
		 	strcpy(c_srvc_nm,"SFO_FUT_PLC_ORD");
		 }


    i_err[0] = Fchg32 ( ptr_fml_Sbuf, FFO_XCHNG_CD, 0,
                                      (char *)st_ordbook.c_xchng_cd, 0);
    i_ferr [ 0 ] = Ferror32;

    i_err[1] = Fchg32 ( ptr_fml_Sbuf, FFO_PRDCT_TYP, 0,
                                     (char *)&st_ordbook.c_prd_typ, 0);
    i_ferr [ 1 ] = Ferror32;

    i_err[2] = Fchg32 ( ptr_fml_Sbuf, FFO_UNDRLYNG, 0,
                                     (char *)st_ordbook.c_undrlyng, 0);
    i_ferr [ 2 ] = Ferror32;

    i_err[3] = Fchg32 ( ptr_fml_Sbuf, FFO_EXPRY_DT, 0,
                                      (char *)c_exp_dt.arr, 0);
    i_ferr [ 3 ] = Ferror32;

    i_err[4] = Fchg32 ( ptr_fml_Sbuf, FFO_EXER_TYP, 0,
                                      (char *)&st_ordbook.c_exrc_typ, 0);
    i_ferr [ 4 ] = Ferror32;
		
	  i_err[5] = Fchg32 ( ptr_fml_Sbuf, FFO_OPT_TYP, 0,
                                      (char *)&st_ordbook.c_opt_typ, 0);
    i_ferr [ 5 ] = Ferror32;

    i_err[6] = Fchg32 ( ptr_fml_Sbuf, FFO_STRK_PRC, 0,
                                      (char *)&st_ordbook.l_strike_prc, 0);
    i_ferr [ 6 ] = Ferror32;

    i_err[7] = Fchg32 ( ptr_fml_Sbuf, FFO_CTGRY_INDSTK, 0,
                                      (char *)&st_ordbook.c_ctgry_indstk, 0);
    i_ferr [ 7 ] = Ferror32;

    i_err[8] = Fchg32 ( ptr_fml_Sbuf, FFO_ORDR_FLW, 0,
                                      (char *)&st_ordbook.c_ordr_flw, 0);
    i_ferr [ 8 ] = Ferror32;

    i_err[9] = Fchg32 ( ptr_fml_Sbuf, FFO_LMT_MKT_SL_FLG, 0,
                                      (char *)&st_ordbook.c_slm_flg, 0);
    i_ferr [ 9 ] = Ferror32;

    i_err[10] = Fchg32 ( ptr_fml_Sbuf, FFO_ORD_TYP, 0,
                                      (char *)&st_ordbook.c_ord_typ, 0);
    i_ferr [ 10 ] = Ferror32;

    i_err[11] = Fchg32 ( ptr_fml_Sbuf, FFO_ORD_TOT_QTY, 0,
                                      (char *)&st_ordbook.l_ord_tot_qty, 0);
    i_ferr [ 11 ] = Ferror32;

    i_err[12] = Fchg32 ( ptr_fml_Sbuf, FFO_LMT_RT, 0,
                                      (char *)&st_ordbook.l_ord_lmt_rt, 0);
    i_ferr [ 12 ] = Ferror32;

    i_err[13] = Fchg32 ( ptr_fml_Sbuf, FFO_DSCLSD_QTY, 0,
                                      (char *)&st_ordbook.l_dsclsd_qty, 0);
    i_ferr [ 13 ] = Ferror32;
		i_err[14] = Fchg32 ( ptr_fml_Sbuf, FFO_STP_LSS_TGR, 0,
                                      (char *)&st_ordbook.l_stp_lss_tgr, 0);
    i_ferr [ 14 ] = Ferror32;

    i_err[15] = Fchg32 ( ptr_fml_Sbuf, FFO_CHANNEL, 0,
                                      (char *)st_ordbook.c_channel, 0); 
    i_ferr [ 15 ] = Ferror32;

    i_err[16] = Fchg32 ( ptr_fml_Sbuf, FFO_ALIAS, 0,
                                      (char *)c_alias, 0); 
    i_ferr [ 16 ] = Ferror32;

    i_err[17] = Fchg32 ( ptr_fml_Sbuf, FFO_SPL_FLG, 0,
                                      (char *)&c_spl_flg, 0);
    i_ferr [ 17 ] = Ferror32;

    i_err[18] = Fchg32 ( ptr_fml_Sbuf, FFO_SVC_NAME, 0,
                                      (char *)c_srvc_nm, 0);
    i_ferr [ 18 ] = Ferror32;

    i_err[19] = Fchg32 ( ptr_fml_Sbuf, FFO_STATUS_FLG, 0, (char *)&c_src_flg, 0);                    /*** Ver 3.3 ***/
    i_ferr [ 19 ] = Ferror32;

    i_err[20] = Fchg32 ( ptr_fml_Sbuf, FFO_OI_INDCTR, 0, (char *)c_ip_address, 0);                    /*** Ver 3.8 ***/
    i_ferr [ 20 ] = Ferror32;

    /** for(i=0; i < 19; i++) commented in Ver 3.3 ***/
    for(i=0; i < 21; i++)               /** changed from 20 to 21 in Ver 3.8 **/
    {
      if ( (i_err[ i ] == -1 ) )
      {
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
				fn_userlog(c_ServiceName,"count :%d:",i);
        fn_errlog( c_ServiceName, "S31275",
                              Fstrerror32(i_ferr[i]),c_err_msg.arr);
        tpfree ( ( char * ) ptr_fml_Sbuf );
        tpfree ( ( char * ) ptr_fml_Rbuf );
        tpfree ( ( char * ) ptr_fml_Obuf );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
				Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
			  tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
     }
		
    i_err[0]= Fget32(ptr_fml_Ibuf, FFO_SETTLOR,i_cnt,
                                        (char *)st_ordbook.c_settlor, 0);
    i_ferr [ 0 ] = Ferror32;

    if (( i_err[0] == -1 ) && ( i_ferr[0] != FNOTPRES ))
    {
			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
      fn_errlog( c_ServiceName, "S31280", Fstrerror32(i_ferr[0]),c_err_msg.arr);
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
		  tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
    else if ( i_ferr[0] == FNOTPRES )
		{
      c_settlor_flg = NO;
    }
    else
    {
      c_settlor_flg = YES;
      i_returncode = Fchg32 ( ptr_fml_Sbuf, FFO_SETTLOR, 0,
                                  (char *)st_ordbook.c_settlor, 0);
      if ( i_returncode == -1 )
      {
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        fn_errlog( c_ServiceName, "S31285",FMLMSG,c_err_msg.arr);
        tpfree ( ( char * ) ptr_fml_Sbuf );
        tpfree ( ( char * ) ptr_fml_Rbuf );
        tpfree ( ( char * ) ptr_fml_Obuf );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
				Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
			  tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
     }

		/*** Ver 1.1 starts here ***/
		MEMSET(c_call_source);
		strcpy(c_call_source,"PLC_SLTPFP");
		i_returncode = Fchg32 ( ptr_fml_Sbuf, FFO_ACTION1, 0, (char *)c_call_source, 0);
		if ( i_returncode == -1 )
		{
			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
			fn_errlog( c_ServiceName, "S31290",FMLMSG,c_err_msg.arr);
			tpfree ( ( char * ) ptr_fml_Sbuf );
			tpfree ( ( char * ) ptr_fml_Rbuf );
			tpfree ( ( char * ) ptr_fml_Obuf );
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
	    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/	
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
	 /*** Ver 1.1 ends here ***/

		/*** Ver 5.1 starts ***/
    i_returncode = Fchg32 ( ptr_fml_Sbuf, FFO_USER_CODE, 0, (char *)c_ven_id.arr, 0);
    if ( i_returncode == -1 )
    {
      fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
      fn_errlog( c_ServiceName, "S31295",FMLMSG,c_err_msg.arr);
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
   /*** Ver 1.1 ends here ***/
		/*** Ver 5.1 ends ***/

		i_returncode = tpcall("SFO_ORD_ROUT", (char *)ptr_fml_Sbuf, 0,
                      (char **)&ptr_fml_Rbuf, &l_recvbuff, 0);

		
			if (i_returncode == -1)
      {
        if (TPCODE != TPESVCFAIL)
        {
          fn_errlog( c_ServiceName, "S31300",TPMSG,c_err_msg.arr);
          fn_userlog( c_ServiceName, "TP CODE IS    |%d|",TPCODE);
        }
        else
        {
          i_returncode = Fget32(ptr_fml_Rbuf, FFO_ERR_MSG, 0, c_err_msg.arr, 0);

          if (i_returncode == -1)
          {
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
            fn_errlog( c_ServiceName, "S31305",FMLMSG,c_err_msg.arr);
            tpfree ( ( char * ) ptr_fml_Sbuf );
            tpfree ( ( char * ) ptr_fml_Rbuf );
            tpfree ( ( char * ) ptr_fml_Obuf );
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
            Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
            Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
            Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
		        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          }
        }

				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        tpfree ( ( char * ) ptr_fml_Sbuf );
        tpfree ( ( char * ) ptr_fml_Rbuf );
        tpfree ( ( char * ) ptr_fml_Obuf );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/   
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
	
    i_returncode= Fget32(ptr_fml_Rbuf, FFO_ORDR_RFRNC,0,
                                    (char *)st_ordbook.c_ordr_rfrnc, 0);

    if (i_returncode == -1)
    {
			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
      fn_errlog( c_ServiceName, "S31310",FMLMSG,c_err_msg.arr);
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/   
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

    i_returncode= Fget32(ptr_fml_Rbuf, FFO_PIPE_ID,0,
                                    (char *)c_pipe_id, 0);

  	if (i_returncode == -1)
    {
			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
      fn_errlog( c_ServiceName, "S31315",FMLMSG,c_err_msg.arr);
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/   
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

		/*** Commented in Ver 1.5 ** Starts ***

    i_returncode = Fadd32 ( ptr_fml_Obuf, FFO_ORDR_RFRNC,
                                    ( char *)st_ordbook.c_ordr_rfrnc, 0 );
    if( i_returncode == -1)
    {
			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
      fn_errlog( c_ServiceName, "S31320",FMLMSG,c_err_msg);
      tpfree ( ( char * ) ptr_fml_Sbuf );
      tpfree ( ( char * ) ptr_fml_Rbuf );
      tpfree ( ( char * ) ptr_fml_Obuf );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      *** Ver 1.3 ***
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

		 *** Commented in Ver 1.5 ** Ends ***/

  	 /*** Ver 1.5 *** Starts ***/

  	 i_returncode = Fconcat32(ptr_fml_Obuf,ptr_fml_Rbuf);

  	 if( i_returncode == -1)
  	 {
     	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
     	fn_errlog( c_ServiceName, "S31325",FMLMSG,c_err_msg.arr);
     	tpfree ( ( char * ) ptr_fml_Sbuf );
     	tpfree ( ( char * ) ptr_fml_Rbuf );
     	tpfree ( ( char * ) ptr_fml_Obuf );
     	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
     	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
		 	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	 }

  	 /*** Ver 1.5 *** Ends ***/
                 

  	i_err[0] = 0 ;
    i_ferr[0] = 0 ;

  	if(i_cnt == 0)
		{
			strcpy(c_frsh_ordr_rfrnc,st_ordbook.c_ordr_rfrnc);
		}
		else if ( i_cnt == 1)
		{
			strcpy(c_cvr_ordr_rfrnc,st_ordbook.c_ordr_rfrnc);
		}
    if ( Finit32 ( ptr_fml_Rbuf,
                  ( FLDLEN32 ) Fsizeof32 ( ptr_fml_Rbuf ) ) == -1 )
    {
			 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
       fn_errlog( c_ServiceName, "S31330",FMLMSG,c_err_msg.arr);
       tpfree ( ( char * ) ptr_fml_Sbuf );
       tpfree ( ( char * ) ptr_fml_Rbuf );
       tpfree ( ( char * ) ptr_fml_Obuf );
       Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
			 Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
       Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
       Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/  
			 tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     }

 		if(DEBUG_MSG_LVL_5)
    {
      fn_userlog(c_ServiceName,"Printing Values for Instance:%d:",i_cnt);
    }

	 }	/***end of for loop ***/
		/** Ver 2.5 starts from here **/
		EXEC SQL
       UPDATE  FOD_FO_ORDR_DTLS
				  SET	 FOD_SLTP_ORDR_RFRNC = :c_cvr_ordr_rfrnc,	 	
				/***			 FOD_FC_FLAG = 'F'  Commented in Ver 4.1 ***/
               FOD_FC_FLAG = :c_fum_fut_prd_typ  /*** Ver 4.1 bind variable used instead of hard coded value ***/ 
				WHERE  FOD_ORDR_RFRNC = :c_frsh_ordr_rfrnc; 	

			if( SQLCODE != 0 )
      {
				tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
				tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
				tpfree ( ( char * ) ptr_fml_Obuf ); /** Ver 3.9 **/
        fn_errlog( c_ServiceName, "S31335", SQLMSG,c_err_msg.arr  );
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); 
    		Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);   
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }	
		
			EXEC SQL
        UPDATE  FOD_FO_ORDR_DTLS
           SET  FOD_SLTP_ORDR_RFRNC = :c_frsh_ordr_rfrnc,
			/***		  FOD_FC_FLAG = 'C',
                FOD_AMT_BLCKD = 0 ,   
                FOD_LSS_AMT_BLCKD = 0   *** Commented in Ver 4.1 ***/
                FOD_FC_FLAG = :c_fod_cvr_flg,         /*** Ver 4.1 bind variable used instead of hard coded value ***/    
                FOD_AMT_BLCKD = :l_fod_zero_val,      /*** Ver 4.1 bind variable used instead of hard coded value ***/
                FOD_LSS_AMT_BLCKD = :l_fod_zero_val,   /*** Ver 4.1 bind variable used instead of hard coded value ***/ 
								FOD_SLTP_MRGN			= :l_fod_zero_val,				/*** Ver 4.8 ***/	
                FOD_SLTP_PL				= :l_fod_zero_val,				/*** Ver 4.8 ***/	 
                FOD_SLTP_SEBI_MRGN= :l_fod_zero_val					/*** Ver 4.8 ***/
         WHERE  FOD_ORDR_RFRNC = :c_cvr_ordr_rfrnc;

			if( SQLCODE != 0 )
      {
				tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
				tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
				tpfree ( ( char * ) ptr_fml_Obuf ); /** Ver 3.9 **/
        fn_errlog( c_ServiceName, "S31340", SQLMSG,c_err_msg.arr  );
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); 
    		Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);     
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
	
    /**Call function for margin calcluation **/
		
  	 if(DEBUG_MSG_LVL_3)  /** Ver 3.7 **/
  	 {	
		 	 fn_userlog( c_ServiceName, "c_frsh_ordr_rfrnc= :%s:",c_frsh_ordr_rfrnc);
		 	 fn_userlog( c_ServiceName, "l_lmt_rt= :%ld:",l_lmt_rt);
		 	 fn_userlog( c_ServiceName, "st_ordbook.l_ord_lmt_rt= :%ld:",st_ordbook.l_ord_lmt_rt);
		 	 fn_userlog( c_ServiceName, "d_mrgn_amt= :%lf:",d_mrgn_amt);
		 	 fn_userlog( c_ServiceName, "d_lss_amt= :%lf:",d_lss_amt);		
		 }
																
 	   i_returncode =  fn_cal_mrgn_sltp(c_ServiceName,																						
                                    c_frsh_ordr_rfrnc,
                                    l_lmt_rt,
                                    st_ordbook.l_ord_lmt_rt,
                                    &d_mrgn_amt,
                                    &d_lss_amt,
																		c_ref_rmrks,  /*** Ver 4.8 ***/
																		&d_comp1_mrgn,/*** Ver 4.8 ***/
																		&d_comp1_pl,	/*** Ver 4.8 ***/
																		&d_xchng_amt, /*** Ver 4.8 ***/
																		c_err_msg.arr);
    if ( i_returncode == -1 )
    {
			tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
			tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
			tpfree ( ( char * ) ptr_fml_Obuf ); /** Ver 3.9 **/
      fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
      fn_errlog( c_ServiceName, "S31345", LIBMSG, c_err_msg.arr );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
			Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }		
				
   	d_mrgn_amt = (long long)d_mrgn_amt;
   	d_lss_amt  = (long long)d_lss_amt;
			  
		if(DEBUG_MSG_LVL_3)
    {
		  fn_userlog( c_ServiceName, "d_lss_amt = :%lf:",d_lss_amt);
		  fn_userlog( c_ServiceName, "d_mrgn_amt :%lf:",d_mrgn_amt);
		}
			/** Ver 2.5 Ends here **/
		  sprintf(ptr_st_pstn_actn.c_ref_rmrks,"%s-%ld",c_frsh_ordr_rfrnc, st_ordbook.l_mdfctn_cntr);

  		strcpy( c_narration_id , ON_ORDER_PLACEMENT);
  		c_dr_without_lmt_flg = DEBIT_WHEN_LIMIT;
  		d_required_amt = 0;  /** ver 1.2 **/
  		c_insuff_flg = 'N' ; /** ver 1.2 **/

  		strcpy ( st_ordbook.c_cln_mtch_accnt,st_usr_prfl.c_cln_mtch_accnt); /** Ver 2.3 **/

  		if( d_mrgn_amt != 0 )
  		{
    		if( d_mrgn_amt !=0 )
    		i_returncode = fn_upd_limits( c_ServiceName,
        		                            &ptr_st_pstn_actn,
            		                        &st_err_msg,
                		                    c_narration_id,
                    		                c_dr_without_lmt_flg,
                        		            d_mrgn_amt * -1,
                            		        &d_balance_amt);

    		if ( i_returncode != 0 )
    		{
      		switch ( i_returncode )
      		{
        		case  INSUFFICIENT_LIMITS :
          		fn_userlog(c_ServiceName," Inside INSUFFICIENT_LIMITS.");
          		fn_errlog( c_ServiceName, "S31350", LIBMSG, c_err_msg.arr  );
          		strcpy(c_err_msg.arr,st_err_msg.c_err_msg);
          		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
          		tpfree ( ( char * ) ptr_fml_Obuf );
          /******* Ver 1.2 Starts Here *****/
          		c_insuff_flg = 'Y';
          		strcpy(c_err_msg.arr,strtok(c_err_msg.arr,"|"));
          		d_required_amt = atof(strtok(NULL,"|"));

		          d_required_amt = d_required_amt + (d_lss_amt / 100 );

		          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
          		Fadd32( ptr_fml_Ibuf,FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);

 		          strcpy(c_err_msg.arr,strtok(c_err_msg.arr,"<"));

 		          sprintf(c_err_msg.arr,"%s < %0.2lf >",c_err_msg.arr,d_required_amt);

 		         if(DEBUG_MSG_LVL_3)
    		      {
        		   fn_userlog(c_ServiceName,"d_lss_amt :%lf:",d_lss_amt);
           		 fn_userlog(c_ServiceName,"d_required_amt :%lf:",d_required_amt);
          		}
          /******* Ver 1.2 Ends Here *******/
					/*** Ver 1.4 Starts ***/

          		c_actn_flg = 'P';
          		strcpy ( st_ordbook.c_cln_mtch_accnt,st_usr_prfl.c_cln_mtch_accnt);

 		          i_trnsctn = fn_begintran( c_ServiceName, c_err_msg.arr );
          		if ( i_trnsctn == -1 )
          		{
								tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
								tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
								fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); /** Ver 3.9 **/
            		fn_errlog( c_ServiceName, "S31355",LIBMSG,c_err_msg.arr);
            		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
            		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&i_actn_id, 0 );
                Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
            		Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
			      		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          		}	


          		i_returncode =  fn_ins_ffl_log_tbl  (  c_ServiceName,
              		                                   st_ordbook,
                  		                               c_err_msg.arr,
                      		                           d_required_amt,
                          		                       c_actn_flg
                              		                  );
          		if ( i_returncode != 0 )
          		{
								tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
								tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
            		fn_errlog( c_ServiceName, "S31360", LIBMSG, c_err_msg.arr  );
            		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
            		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
            		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID , (char *)&i_actn_id , 0 );
            		Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
            		Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
								tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          		}

          		if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg.arr ) == -1 )
          		{
								fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); /** Ver 3.9 **/
								tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
								tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
            		fn_errlog( c_ServiceName, "S31365",LIBMSG,c_err_msg.arr);
            		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
            		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&i_actn_id, 0 );
            	  Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
            		Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
								tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          		}

          /*** Ver 1.4  Ends   ***/
							tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
							tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
 		          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
          		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );

        	default:
          		fn_errlog( c_ServiceName, "S31370", LIBMSG, c_err_msg.arr  );
          		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
          		tpfree ( ( char * ) ptr_fml_Obuf );
							tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/  
							tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/  
          		strcpy(c_err_msg.arr,st_err_msg.c_err_msg);
          		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
          		Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
          		Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      		}
				}
  		}

  		strcpy( c_narration_id , ON_ORDER_PLACEMENT);
  		c_dr_without_lmt_flg = DEBIT_WHEN_LIMIT;

  		if( d_lss_amt != 0)
  		{

				/*** Ver 4.8 started ***/
        MEMSET(c_tmp_rmrks);    
        strcpy ( c_tmp_rmrks, ptr_st_pstn_actn.c_ref_rmrks );
				/*** Ver 5.2 Started ***/
				if(DEBUG_MSG_LVL_0)
				{
					fn_userlog( c_ServiceName, "Length of remarks Before is :%d: Temp Remarks is :%d: Ref Remarks is :%d:",strlen(ptr_st_pstn_actn.c_ref_rmrks),strlen(c_tmp_rmrks),strlen(c_ref_rmrks));
				}
				/*** Ver 5.2 Ends ***/ 
        sprintf(ptr_st_pstn_actn.c_ref_rmrks,"%s%s",c_ref_rmrks,c_tmp_rmrks);  
				/*** Ver 4.8 ends ***/
				/*** Ver 5.2 Started ***/
				if(DEBUG_MSG_LVL_0)
				{
					fn_userlog( c_ServiceName, "Length of remarks After is :%d:",strlen(ptr_st_pstn_actn.c_ref_rmrks));
				}
				/*** Ver 5.2 Ends ***/

 		     i_returncode = fn_upd_limits( c_ServiceName,
    		                                  &ptr_st_pstn_actn,
        		                              &st_err_msg,
            		                          c_narration_id,
                		                      c_dr_without_lmt_flg,
                    		                  d_lss_amt * -1,
                        		              &d_balance_amt);

      	if ( i_returncode != 0 )
       	{
        	  switch ( i_returncode )
          	{
            	case  INSUFFICIENT_LIMITS :
              	fn_userlog(c_ServiceName," Inside INSUFFICIENT_LIMITS.");
              	fn_errlog( c_ServiceName, "S31375", LIBMSG, c_err_msg.arr  );
              	strcpy(c_err_msg.arr,st_err_msg.c_err_msg);
              	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
              	tpfree ( ( char * ) ptr_fml_Obuf );

              /******* Ver 1.2 Starts Here *****/
 		            c_insuff_flg = 'Y';
    		        strcpy(c_err_msg.arr,strtok(c_err_msg.arr,"|"));
              	d_required_amt = atof(strtok(NULL,"|"));

              	if(DEBUG_MSG_LVL_5)
              	{
               		fn_userlog(c_ServiceName,"d_required_amt :%lf:",d_required_amt);
              	}

              	Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
              	Fadd32( ptr_fml_Ibuf,FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);

              /******* Ver 1.2 Ends Here *******/
              /*** Ver 1.4 Starts ***/

               c_actn_flg = 'P';

               i_trnsctn = fn_begintran( c_ServiceName, c_err_msg.arr );
               if ( i_trnsctn == -1 )
               {
								 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); /** Ver 3.9 **/
								 tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
								 tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
                 fn_errlog( c_ServiceName, "S31380",LIBMSG,c_err_msg.arr);
                 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
                 Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&i_actn_id, 0 );
                 Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
                 Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
								 tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
               }
							 
							 i_returncode =  fn_ins_ffl_log_tbl  (  c_ServiceName,
                                                      st_ordbook,
                                                      c_err_msg.arr,
                                                      d_required_amt,
                                                      c_actn_flg
                                                   );
               if ( i_returncode != 0 )
               {
								 tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
								 tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
                 fn_errlog( c_ServiceName, "S31385", LIBMSG, c_err_msg.arr  );
                 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
                 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
                 Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID , (char *)&i_actn_id , 0 );
					       Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
                 Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/		
								 tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );

               }

               if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg.arr ) == -1 )
               {
								 tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
								 tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
								 fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); /** Ver 3.9 **/
                 fn_errlog( c_ServiceName, "S31390",LIBMSG,c_err_msg.arr);
                 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
                 Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&i_actn_id, 0 );
                 Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
                 Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/     
								 tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
               }

              /*** Ver 1.4  Ends   ***/
							tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
						  tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
              Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );

           default:
              fn_errlog( c_ServiceName, "S31395", LIBMSG, c_err_msg.arr  );
              fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
              tpfree ( ( char * ) ptr_fml_Obuf );
							tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
							tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
              Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
              Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
              Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/  
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          }
        }
				strcpy ( ptr_st_pstn_actn.c_ref_rmrks, c_tmp_rmrks);    /**** Ver 4.8 ***/
        MEMSET(c_tmp_rmrks);																/**** Ver 4.8 ***/
    	}

			EXEC SQL
       	UPDATE  FOD_FO_ORDR_DTLS
       	   SET  FOD_LMT_RT = :d_avg_prc,
        	     /** FOD_SLTP_ORDR_RFRNC = :c_cvr_ordr_rfrnc, Commented in Ver 2.5 ***/
                FOD_AMT_BLCKD = :d_mrgn_amt,
                FOD_LSS_AMT_BLCKD = :d_lss_amt,
								FOD_SLTP_MRGN = :d_comp1_mrgn,/*** Ver 4.8 ***/
								FOD_SLTP_PL   = :d_comp1_pl,	/*** Ver 4.8 ***/
								FOD_SLTP_SEBI_MRGN = :d_xchng_amt /*** Ver 4.8 ***/
               /** FOD_FC_FLAG = 'F' Commented in Ver 2.5 ***/
         WHERE  FOD_ORDR_RFRNC = :c_frsh_ordr_rfrnc;


  		if( SQLCODE != 0 )
  		{
				tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
				tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
				tpfree ( ( char * ) ptr_fml_Obuf ); /** Ver 3.9 **/
    		fn_errlog( c_ServiceName, "S31400", SQLMSG,c_err_msg.arr  );
    		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
    		Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/ 		
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  		}

  		EXEC SQL
   		  UPDATE  FXB_FO_XCHNG_BOOK
   				 SET  FXB_LMT_RT = :d_avg_prc
   			 WHERE  FXB_ORDR_RFRNC  = :c_frsh_ordr_rfrnc;

  		if( SQLCODE != 0 )
  		{
				tpfree ( ( char * ) ptr_fml_Sbuf ); /** Ver 3.9 **/
				tpfree ( ( char * ) ptr_fml_Rbuf ); /** Ver 3.9 **/
				tpfree ( ( char * ) ptr_fml_Obuf ); /** Ver 3.9 **/
    		fn_errlog( c_ServiceName, "S31405", SQLMSG,c_err_msg.arr  );
    		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
    		Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/	
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  		}

 /** Commented in VQC and updated below values(FOD_AMT_BLCKD, FOD_LSS_AMT_BLCKD) above in already existing update statment**

  		EXEC SQL
   			UPDATE  FOD_FO_ORDR_DTLS
   				** SET  FOD_SLTP_ORDR_RFRNC = :c_frsh_ordr_rfrnc, commented in Ver 2.5 **
         	SET		FOD_AMT_BLCKD = 0 ,
         				FOD_LSS_AMT_BLCKD = 0
         	**			FOD_FC_FLAG = 'C' commented in Ver 2.5 **
   			 WHERE  FOD_ORDR_RFRNC = :c_cvr_ordr_rfrnc;

  		if( SQLCODE != 0 )
  		{
				tpfree ( ( char * ) ptr_fml_Sbuf ); ** Ver 3.9 **
				tpfree ( ( char * ) ptr_fml_Rbuf ); ** Ver 3.9 **
				tpfree ( ( char * ) ptr_fml_Obuf ); ** Ver 3.9 **
    		fn_errlog( c_ServiceName, "S31410", SQLMSG,c_err_msg  );
    		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      *** Ver 1.3 ***
    	  Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); *** Ver 2.2 ***
    		Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); *** Ver 2.2 ***
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  		}	
  
     ********************* VQC Comment Ends ***************************/
	
		}
	/*** Ver 2.5 Starts from Here ***/
		if(st_ordbook.c_req_typ == 'M')
		{
			c_usr_flg = 'W';
			
		/** comment starts for ver 4.4 **	i_err[0]= Fget32(ptr_fml_Ibuf, FFO_ORDR_RFRNC,0,
      	                             (char *)&c_frsh_ordr_rfrnc, 0);
  		i_ferr [ 0 ] = Ferror32;

  		i_err[1]= Fget32(ptr_fml_Ibuf, FFO_ORDR_RFRNC,1,
      	                             (char *)&c_cvr_ordr_rfrnc, 0);
  		i_ferr [ 1 ] = Ferror32;

  		if(DEBUG_MSG_LVL_1)  ** Ver 3.7 **
  		{	
				fn_userlog( c_ServiceName, "c_frsh_ordr_rfrnc :%s:",c_frsh_ordr_rfrnc);
      	fn_userlog( c_ServiceName, "c_cvr_ordr_rfrnc:%s:",c_cvr_ordr_rfrnc);	
			}

			for(i=0; i < 2; i++)																		
			{
  			if ( (i_err[ i ] == -1 ) )
  			{
   				fn_errlog( c_ServiceName, "S31415",
   				Fstrerror32(i_ferr[i]),c_err_msg.arr);
   				tpfree ( ( char * ) ptr_fml_Sbuf );
   				tpfree ( ( char * ) ptr_fml_Rbuf );
   				tpfree ( ( char * ) ptr_fml_Obuf );
   				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
   				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
   				Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
   				Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
					Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  			}
			} *** comment ends ***/
		/*** Start of 'for' loop for modification ***/
			for( i_cnt=0; i_cnt < 2; i_cnt++)
   		{
				if( i_cnt == 0 )
				{
					st_ordbook.c_slm_flg = st_ordbook.c_mrkt_typ;
     			st_ordbook.l_ord_lmt_rt = l_lmt_rt; 
			/***		st_first_ordbk.l_ord_tot_qty = st_ordbook.l_ord_tot_qty;
     			strcpy(st_first_ordbk.c_xchng_cd ,st_ordbook.c_xchng_cd);
     			st_first_ordbk.c_prd_typ = st_ordbook.c_prd_typ;
     			strcpy(st_first_ordbk.c_undrlyng ,st_ordbook.c_undrlyng);
     			strcpy(st_first_ordbk.c_expry_dt ,st_ordbook.c_expry_dt);
     			st_first_ordbk.c_exrc_typ = st_ordbook.c_exrc_typ;
     			st_first_ordbk.c_opt_typ = st_ordbook.c_opt_typ;
     			st_first_ordbk.l_strike_prc = st_ordbook.l_strike_prc;   *** Commented in VQC ***/
					st_ordbook.l_stp_lss_tgr = 0;
				}
				else
				{
				  st_ordbook.c_slm_flg='S';
			/* VER TOL : TUX on LINUX -- Changed black space to \0 (Ravindra) */
      		st_ordbook.c_ordr_flw =(st_ordbook.c_ordr_flw == 'B'?'S':(st_ordbook.c_ordr_flw == 'S'?'B':'\0'));
      		st_ordbook.l_ord_lmt_rt = l_temp_ord_lmt_rt;
      		st_ordbook.l_stp_lss_tgr =  l_temp_stp_lss_tgr;

  				if(DEBUG_MSG_LVL_3)  /** Ver 3.7 **/
  				{
      			fn_userlog( c_ServiceName, "Cover Order Flow :%c:",st_ordbook.c_ordr_flw);
					}
				}

				if ( (c_spn_allwd_flg == 'Y' && strcmp(st_ordbook.c_xchng_cd,"NFO")==0) ||
   					 ( c_bse_span_flag == 'Y' && strcmp(st_ordbook.c_xchng_cd,"BFO")==0 ))
				{
 					strcpy(c_srvc_nm,"SFO_SPN_MOD_ORD");
				}
				else
				{
 					strcpy(c_srvc_nm,"SFO_PLCMOD_FUT");
				}
			
				i_err[0] = Fchg32 ( ptr_fml_Sbuf, FFO_XCHNG_CD, 0,
        	                        (char *)st_ordbook.c_xchng_cd, 0);
				i_ferr [ 0 ] = Ferror32;

				i_err[1] = Fchg32 ( ptr_fml_Sbuf, FFO_USR_ID, 0,
        	                       (char *)&st_usr_prfl.c_user_id, 0);
				i_ferr [ 1 ] = Ferror32;

				i_err[2] = Fchg32 ( ptr_fml_Sbuf, FFO_SSSN_ID, 0,
        	                       (char *)&st_usr_prfl.l_session_id, 0);
				i_ferr [ 2 ] = Ferror32;

				i_err[3] = Fchg32 ( ptr_fml_Sbuf, FFO_EBA_MTCH_ACT_NO, 0,
        	                        (char *)&st_usr_prfl.c_cln_mtch_accnt, 0);
				i_ferr [ 3 ] = Ferror32;

				i_err[4] = Fchg32 ( ptr_fml_Sbuf, FFO_ORD_TOT_QTY, 0,
      	                          (char *)&st_ordbook.l_ord_tot_qty, 0);
				i_ferr [ 4 ] = Ferror32;

				i_err[5] = Fchg32 ( ptr_fml_Sbuf, FFO_LMT_RT, 0,
        	                        (char *)&st_ordbook.l_ord_lmt_rt, 0);
	  		i_ferr [ 5 ] = Ferror32;

				i_err[6] = Fchg32 ( ptr_fml_Sbuf, FFO_ORDR_RFRNC, 0,
        	                        (char *)&st_ordbook.c_ordr_rfrnc, 0);
				i_ferr [ 6 ] = Ferror32;

        if(i_cnt == 0)
        {		
					i_err[7] = Fchg32 ( ptr_fml_Sbuf, FFO_STP_LSS_TGR, 0,
        		                        (char *)&st_ordbook.l_stp_lss_tgr, 0);
					i_ferr [ 7 ] = Ferror32;
				}
				else
				{
					i_err[7] = Fchg32 ( ptr_fml_Sbuf, FFO_STP_LSS_TGR, 0,
                                  (char *)&st_ordbook.l_stp_lss_tgr, 0);
          i_ferr [ 7 ] = Ferror32;
				}		
				i_err[8] = Fchg32 ( ptr_fml_Sbuf, FFO_ORDR_FLW, 0,
        	                        (char *)&st_ordbook.c_ordr_flw, 0);
				i_ferr [ 8 ] = Ferror32;

				i_err[9] = Fchg32 ( ptr_fml_Sbuf, FFO_LMT_MKT_SL_FLG, 0,
        	                        (char *)&st_ordbook.c_slm_flg, 0);
				i_ferr [ 9 ] = Ferror32;

				i_err[10] = Fchg32 ( ptr_fml_Sbuf, FFO_ORD_TYP, 0,
        	                        (char *)&st_ordbook.c_ord_typ, 0);
				i_ferr [ 10 ] = Ferror32;
					
				i_err[11] = Fchg32 ( ptr_fml_Sbuf, FFO_DSCLSD_QTY, 0,
        	                        (char *)&st_ordbook.l_dsclsd_qty, 0);
				i_ferr [ 11 ] = Ferror32;

				i_err[12] = Fchg32 ( ptr_fml_Sbuf, FFO_PIPE_ID, 0,
        	                        (char *)&st_usr_prfl.c_pipe_id, 0);
				i_ferr [ 12 ] = Ferror32;

				i_err[13] = Fchg32 ( ptr_fml_Sbuf, FFO_SVC_NAME, 0,
                                      (char *)c_srvc_nm, 0);
    		i_ferr [ 13 ] = Ferror32;
				i_err[14] = Fchg32(ptr_fml_Sbuf, FFO_TRD_PSSWD,0,
                                     (char *)c_temp_psswrd,0);
  			i_ferr [ 14 ] = Ferror32;
				if(i_cnt == 0)
				{
         	i_err[15] = Fchg32 ( ptr_fml_Sbuf,FFO_ORDR_RFRNC , 0,
                                  (char *)&c_frsh_ordr_rfrnc, 0);
         	i_ferr [ 15 ] = Ferror32;
				}
				else
				{	
         	i_err[15] = Fchg32 ( ptr_fml_Sbuf, FFO_ORDR_RFRNC, 0,
                                  (char *)&c_cvr_ordr_rfrnc, 0);
         	i_ferr [ 15 ] = Ferror32;
				}
	
        /*** Commented in Ver 4.2 as data-type of FML used is long and variable data-type is char ***	
				i_err[16] = Fchg32 ( ptr_fml_Sbuf,FFO_USR_FLG, 0,
                               (char *)&c_usr_flg, 0);
        ***/

        i_err[16] = Fchg32 ( ptr_fml_Sbuf,FFO_CLSR_TYP, 0,
                               (char *)&c_usr_flg, 0);  /*** Ver 4.2 ***/
        i_ferr [ 16 ] = Ferror32;	
			
				i_err[17] = Fchg32 ( ptr_fml_Sbuf, FFO_ALIAS, 0,
																		 (char *)c_alias, 0);
    		i_ferr [ 17 ] = Ferror32;												

    		i_err[18] = Fchg32 ( ptr_fml_Sbuf, FFO_OI_INDCTR, 0, (char *)c_ip_address, 0);                    /*** Ver 3.8 ***/
    		i_ferr [ 18 ] = Ferror32;

				/** for(i=0; i < 17; i++)   Ver 2.5 ***/
				for(i=0; i < 19; i++)		/*** Changed from 18 to 19 in Ver 3.8 ***/		
     		{
     			if ( (i_err[ i ] == -1 ) )
     			{
     				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
     				fn_userlog(c_ServiceName,"count :%d:",i);
     				fn_errlog( c_ServiceName, "S31420",
          	Fstrerror32(i_ferr[i]),c_err_msg.arr);
     				tpfree ( ( char * ) ptr_fml_Sbuf );
     				tpfree ( ( char * ) ptr_fml_Rbuf );
     				tpfree ( ( char * ) ptr_fml_Obuf );
     				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
     				Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
     				Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
						Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     			}
     		}

				i_returncode = tpcall("SFO_ORD_ROUT", (char *)ptr_fml_Sbuf, 0,
      					              (char **)&ptr_fml_Rbuf, &l_recvbuff, 0);

      	if (i_returncode == -1)
      	{
      		if (TPCODE != TPESVCFAIL)
       		{
       			fn_errlog( c_ServiceName, "S31425",TPMSG,c_err_msg.arr);
       			fn_userlog( c_ServiceName, "TP CODE IS    |%d|",TPCODE);
       		}
       		else
       		{
       			i_returncode = Fget32(ptr_fml_Rbuf, FFO_ERR_MSG, 0, c_err_msg.arr, 0);
	
       			if (i_returncode == -1)
       			{
         			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
         			fn_errlog( c_ServiceName, "S31430",FMLMSG,c_err_msg.arr);
         			tpfree ( ( char * ) ptr_fml_Sbuf );
         			tpfree ( ( char * ) ptr_fml_Rbuf );
         			tpfree ( ( char * ) ptr_fml_Obuf );
         			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
         			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
         			Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
							Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);	
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
       			}
						
						i_returncode = Fget32(ptr_fml_Rbuf, FFO_BAL_AMT, 0, (char *)&d_required_amt, 0);

            if (i_returncode == -1)
            {
              fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
              fn_errlog( c_ServiceName, "S31435",FMLMSG,c_err_msg.arr);
              tpfree ( ( char * ) ptr_fml_Sbuf );
              tpfree ( ( char * ) ptr_fml_Rbuf );
              tpfree ( ( char * ) ptr_fml_Obuf );
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
              Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
              Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
              Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }

						i_returncode = Fget32(ptr_fml_Rbuf, FFO_MOD_CAN_FLG, 0, &c_insuff_flg, 0);

            if (i_returncode == -1)
            {
              fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
              fn_errlog( c_ServiceName, "S31440",FMLMSG,c_err_msg.arr);
              tpfree ( ( char * ) ptr_fml_Sbuf );
              tpfree ( ( char * ) ptr_fml_Rbuf );
              tpfree ( ( char * ) ptr_fml_Obuf );
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
              Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
              Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
              Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }
       		}

       	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
       	tpfree ( ( char * ) ptr_fml_Sbuf );
       	tpfree ( ( char * ) ptr_fml_Rbuf );
       	tpfree ( ( char * ) ptr_fml_Obuf );
       	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
       	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
       	Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

		}/*** End of for loop ***/
  
     /*** Ver 5.1 Starts Here *******/ 
    i_actn_id = 0 ;

  /********************Ver Successfull message on api **************************/
  strcpy(c_err_msg.arr,"The order has been modified Successfully ");
  Fadd32( ptr_fml_Obuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
  Fadd32( ptr_fml_Obuf, FFO_ACTN_ID, (char *)&i_actn_id, 0 );
  /********************Ver 5.1 Ends Here **************************/

	}
	if(st_ordbook.c_req_typ == 'C')
	{
		c_usr_flg = 'W';	
		
    /*** commented in ver 4.4 
    i_err[0]= Fget32(ptr_fml_Ibuf, FFO_ORDR_RFRNC,0,
                                  (char *)&c_frsh_ordr_rfrnc, 0);
    i_ferr [ 0 ] = Ferror32;

    i_err[1]= Fget32(ptr_fml_Ibuf, FFO_ORDR_RFRNC,1,
                                  (char *)&c_cvr_ordr_rfrnc, 0);
    i_ferr [ 1 ] = Ferror32;

    for(i=0; i < 2; i++)
    {
      if ( (i_err[ i ] == -1 ) && i_ferr[15] != FNOTPRES  )
      {
        fn_errlog( c_ServiceName, "S31445",
        Fstrerror32(i_ferr[i]),c_err_msg.arr);
        tpfree ( ( char * ) ptr_fml_Sbuf );
        tpfree ( ( char * ) ptr_fml_Rbuf );
        tpfree ( ( char * ) ptr_fml_Obuf );
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
    } *** comment ends for ver 4.4 ***/ 
			
	/*** Start of 'for' loop for Cancellation ***/
	  for( i_cnt=0; i_cnt < 2; i_cnt++)
    {
			
		  if( i_cnt == 0 )
      {
       /***  strcpy(st_first_ordbk.c_xchng_cd ,st_ordbook.c_xchng_cd);   *** Commented in VQC ***/
      }
      else
      {
        st_ordbook.c_slm_flg='S';
		/* VER TOL : TUX on LINUX -- Changed blank space to \0 (Ravindra) */
        st_ordbook.c_ordr_flw =(st_ordbook.c_ordr_flw == 'B'?'S':(st_ordbook.c_ordr_flw == 'S'?'B':'\0'));
        st_ordbook.l_ord_lmt_rt = l_temp_ord_lmt_rt;
        st_ordbook.l_stp_lss_tgr =  l_temp_stp_lss_tgr;

  			if(DEBUG_MSG_LVL_3)  /** Ver 3.7 **/
  			{
        	fn_userlog( c_ServiceName, "Cover Order Flow :%c:",st_ordbook.c_ordr_flw);
				}
      }
			
      if ( (c_spn_allwd_flg == 'Y' && strcmp(st_ordbook.c_xchng_cd,"NFO")==0) ||
           ( c_bse_span_flag == 'Y' && strcmp(st_ordbook.c_xchng_cd,"BFO")==0 ))
      {
        strcpy(c_srvc_nm,"SFO_SPN_CANCEL");
      }
      else
      {
        strcpy(c_srvc_nm,"SFO_CANCEL_FUT");
      }
 
      i_err[0] = Fchg32 ( ptr_fml_Sbuf, FFO_XCHNG_CD, 0,
                             (char *)st_ordbook.c_xchng_cd, 0);
      i_ferr [ 0 ] = Ferror32;

      i_err[1] = Fchg32 ( ptr_fml_Sbuf, FFO_USR_ID, 0,
                             (char *)&st_usr_prfl.c_user_id, 0);
      i_ferr [ 1 ] = Ferror32;

      i_err[2] = Fchg32 ( ptr_fml_Sbuf, FFO_SSSN_ID, 0,
                             (char *)&st_usr_prfl.l_session_id, 0);
      i_ferr [ 2 ] = Ferror32;

      i_err[3] = Fchg32 ( ptr_fml_Sbuf, FFO_EBA_MTCH_ACT_NO, 0,
                              (char *)&st_usr_prfl.c_cln_mtch_accnt, 0);
      i_ferr [ 3 ] = Ferror32;				
					
	  	i_err[4] = Fchg32 ( ptr_fml_Sbuf, FFO_PIPE_ID, 0,
                              (char *)&st_usr_prfl.c_pipe_id, 0);
      i_ferr [ 4 ] = Ferror32;
			i_err[5] = Fchg32 ( ptr_fml_Sbuf, FFO_SVC_NAME, 0,
                              (char *)c_srvc_nm, 0);
    i_ferr [ 5 ] = Ferror32;
				
			if(i_cnt == 0)
      {
        i_err[6] = Fchg32 ( ptr_fml_Sbuf,FFO_ORDR_RFRNC , 0,
                              (char *)&c_frsh_ordr_rfrnc, 0);
        i_ferr [ 6 ] = Ferror32;
      }
      else
      {
        i_err[6] = Fchg32 ( ptr_fml_Sbuf, FFO_ORDR_RFRNC, 0,
                              (char *)&c_cvr_ordr_rfrnc, 0);
        i_ferr [ 6 ] = Ferror32;
      }

      /*** Commented in Ver 4.2 as data-type of FML used is long and variable data-type is char ***
			i_err[7] = Fchg32 ( ptr_fml_Sbuf,FFO_USR_FLG, 0,
                            (char *)&c_usr_flg, 0);
      ***/
     
      i_err[7] = Fchg32 ( ptr_fml_Sbuf,FFO_CLSR_TYP, 0,
                            (char *)&c_usr_flg, 0); /*** Ver 4.2 ***/
      i_ferr [ 7 ] = Ferror32;

			i_err[8] = Fchg32 ( ptr_fml_Sbuf, FFO_ALIAS, 0,  
                                     (char *)c_alias, 0);
      i_ferr [ 8 ] = Ferror32;                        

      i_err[9] = Fchg32 ( ptr_fml_Sbuf, FFO_OI_INDCTR, 0, (char *)c_ip_address, 0);                    /*** Ver 3.8 ***/
      i_ferr [ 9 ] = Ferror32;

      /** for(i=0; i < 8; i++)    	*** Ver 2.5 ***/
      for(i=0; i < 10; i++)			/*** Changed from 9 to 10 in Ver 3.8 ***/	
      {
        if ( (i_err[ i ] == -1 ) )
        {
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
          fn_userlog(c_ServiceName,"count :%d:",i);
          fn_errlog( c_ServiceName, "S31450",
          Fstrerror32(i_ferr[i]),c_err_msg.arr);
          tpfree ( ( char * ) ptr_fml_Sbuf );
          tpfree ( ( char * ) ptr_fml_Rbuf );
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); 
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      }

     i_returncode = tpcall("SFO_ORD_ROUT", (char *)ptr_fml_Sbuf, 0,
                   (char **)&ptr_fml_Rbuf, &l_recvbuff, 0);


     if (i_returncode == -1)
     {
       if (TPCODE != TPESVCFAIL)
       {
         fn_errlog( c_ServiceName, "S31455",TPMSG,c_err_msg.arr);
         fn_userlog( c_ServiceName, "TP CODE IS    |%d|",TPCODE);
       }
       else
       {
         i_returncode = Fget32(ptr_fml_Rbuf, FFO_ERR_MSG, 0, c_err_msg.arr, 0);

         if (i_returncode == -1)
         {
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
          fn_errlog( c_ServiceName, "S31460",FMLMSG,c_err_msg.arr);
          tpfree ( ( char * ) ptr_fml_Sbuf );
          tpfree ( ( char * ) ptr_fml_Rbuf );
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
         }
       }

       fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
       tpfree ( ( char * ) ptr_fml_Sbuf );
       tpfree ( ( char * ) ptr_fml_Rbuf );
       tpfree ( ( char * ) ptr_fml_Obuf );
       Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
       Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
			 tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     }	
	 }	/*** End of for loop ***/
 }
	/*** Ver 2.5 Ends Here ***/

  tpfree ( ( char * ) ptr_fml_Rbuf );
  tpfree ( ( char * ) ptr_fml_Sbuf );


  if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg.arr ) == -1 )
  {
    tpfree ( ( char * ) ptr_fml_Obuf );
		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /*** Ver 1.3 ***/
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /*** Ver 2.2 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 2.2 ***/
	  tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  /*** Ver 5.3 : starts here ***/
  i_returncode = 0;

  i_returncode = fn_upd_mrgn_reporting( st_usr_prfl.c_cln_mtch_accnt,
                                        st_ordbook.c_xchng_cd,
                                        c_ServiceName,
                                        c_err_msg.arr);

  if ( i_returncode != 0 )
  {
    fn_errlog(c_ServiceName, "S31465", LIBMSG , c_err_msg.arr );
    fn_userlog(c_ServiceName,"Pls check, Nikhil Error while calling function fn_upd_mrgn_reporting..");
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID , (char *)&i_actn_id , 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
  /*** Ver 5.3 : Ends here ***/

	/********************************************************/
  /****Changes for Tux4 Triggers***************************/
  /********************************************************/


  /* To post the Trigger in Tux3 Domain Call the service SFO_FOS_TRG */

  strcpy ( c_fno_dmn_nm, "FNO" );
  strcpy ( c_fno_trg_nm, "TRG_LOOK_TAB" );
  strcpy ( c_fno_trg_dat, "TRG_LOOK_TAB" );

  i_returncode = fn_call_svc_fml ( c_ServiceName,
                                   c_err_msg.arr,
                                   "SFO_FOS_TRG",
                                   0,
                                   4,
                                   0,
                                   FFO_DMN_NM, (char *)c_fno_dmn_nm,
                                   FFO_TRG_NM, (char *)c_fno_trg_nm,
                                   FFO_ABT_TRG_DATA, (char *)c_fno_trg_dat,
                                   FFO_ABT_FILTER, (char *)c_pipe_id);

  if ( i_returncode != SUCC_BFR )
  {
    fn_errlog( c_ServiceName, "S31470", LIBMSG, c_err_msg.arr  );
  }

  /********************************************************/
  /****Changes for Tux4 Triggers ends**********************/
  /********************************************************/

  /*** Ver 1.3 *** Starts ***/

  i_actn_id = 0 ;
  Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );

  /*** Ver 1.3 *** Ends ***/
	
  tpreturn( TPSUCCESS, 0, (char *)ptr_fml_Obuf, 0 , 0 );
	
}
/* void fn_avg_price(long *l_arr_qty,long *l_arr_price, double *d_avg_price,int sql_ord_ordr_qty) ** commented in Ver 2.3 **/

void fn_avg_price(char *c_ServiceName,long *l_arr_qty,long *l_arr_price, double *d_avg_price,int sql_ord_ordr_qty)/**Ver 2.3 **/
{
  int     i_loop;
  long    l_total_qty;
  double  d_total_value;

  l_total_qty = 0;
  d_total_value = 0;

  for(i_loop = 0; i_loop < 5; i_loop++)
  {
    if(sql_ord_ordr_qty == l_total_qty)
      break;
    else if((sql_ord_ordr_qty - l_total_qty) >= l_arr_qty[i_loop])
    {
      d_total_value = d_total_value + ((double)l_arr_qty[i_loop] * (double)l_arr_price[i_loop]); /* typecast to double in Ver 2.4 */
      l_total_qty += l_arr_qty[i_loop];
    }
    else if((sql_ord_ordr_qty - l_total_qty) < l_arr_qty[i_loop])
    {
      d_total_value = d_total_value + (((double)sql_ord_ordr_qty - (double)l_total_qty) * (double)l_arr_price[i_loop]); /* typecast to double in Ver 2.4 */
      l_total_qty += sql_ord_ordr_qty - l_total_qty;
    }
		 /* Add logs in Ver 2.3 */
    if(DEBUG_MSG_LVL_5)
    {
      fn_userlog(c_ServiceName, "sql_ord_ordr_qty is :%d",sql_ord_ordr_qty);
      fn_userlog(c_ServiceName, "l_arr_qty is :%ld:",l_arr_qty[i_loop]);
      fn_userlog(c_ServiceName, "l_arr_price is :%ld:",l_arr_price[i_loop]);
      fn_userlog(c_ServiceName, "l_total_qty is :%ld:",l_total_qty);
      fn_userlog(c_ServiceName, "d_total_value is :%lf:",d_total_value);
    }
   /* End logs in Ver 2.3 */
  }
 	 *d_avg_price = d_total_value/l_total_qty;
	
  fn_round2(d_avg_price);
}
/***********Function for rounding off to 2 decimal places*************/
void fn_round2(double *d_vl)
{
  char c_temp[30];
  long l_temp;

  *d_vl = (*d_vl + 0.005) * 100;

  sprintf(c_temp, "%lf", *d_vl);
  sscanf(c_temp, "%ld", &l_temp);

  *d_vl = ((double)l_temp)/100;
}

/***********Function for 5 paisa check**************/
int fn_5paisa(long l_temp)
{
  if((l_temp%5) != 0)
    return -1;
  return 0;
}
