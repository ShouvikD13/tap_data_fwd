/************************************************************************************/
/*	Program				:	SFO_MODCAN_PLG																									*/
/* 																																									*/
/*	Input					:																																	*/	
/*								FFO_USR_ID          																							*/
/*								FFO_EBA_MTCH_ACT_NO 																							*/
/*								FFO_SSSN_ID         																							*/
/*								FFO_OPERATION_TYP   																							*/
/*								FFO_CHANNEL         																							*/
/*								FFO_DPID            																							*/ 
/*								FFO_DP_CLNT_ID      																							*/
/*								FFO_STCK_CD         																							*/
/*								FFO_ORD_TOT_QTY																										*/
/*								FFO_ORD_DT																												*/
/*								FFO_ORD_TYP																												*/
/*																																									*/
/*	Output				:	FFO_ORDR_RFRNC(for spot)																				*/
/*								FFO_ACTN_ID																												*/
/*								FFO_ERR_MSG																												*/
/*								FFO_PLG_ORDR_RFRNC																								*/ 
/*																																									*/
/*	Description		: To modify or cancel requested pledge and withdrwal requests			*/
/*                                                                                  */
/*	Log						:	1.0 22-Sep-2004		Krishnan.V																		*/
/*									1.1	13-Mar-2007		Sushil Sharma																	*/
/*                  1.3 14-Dec-2007   Vidyayini Krish                               */
/*                  1.4 02-Sep-2009   Vidyayini Krish																*/
/*									1.5 14-Jan-2011   Diwakar Sharma																*/
/*                  1.6 23-Jan-2012   Diwakar Sharma                                */
/*                  1.7 24-Sep-2012   Giving effect of FNO BSE limit (DS)           */
/*									1.8	03-Jul-2013   Bhushan Sonwane						 										*/
/*                  1.9 12-Sep-2013	  Akshay Joshi                                  */
/*                  2.0 11-Dec-2014   Sachin Birje                                  */
/*                  2.1 10-Feb-2015   Samip M																				*/
/*                  2.2 09-Jun-2015   Tanmay W                                      */
/*                  2.3 10-Jul-2020   Tanmay Patel                                  */
/*                  2.4 21-Sep-2020   Tanmay Patel                                  */
/*                  2.5 13-Jun-2021   Tanmay Patel                                  */
/*                  2.6 18-Jun-2022   Samip M                                  			*/
/*                  2.7 18-Oct-2022   Samip M                                  			*/
/*                  2.8 09-Feb-2023   Samip M                                       */
/************************************************************************************/
/*	1.0		-		New Release																														*/
/*	1.1		-		DL Revamp																															*/
/*  1.2   -   IBM Changes                                                           */
/*  1.3   -   CRCSN35839-Disable Spot in NSE and enable in BSE											*/
/*  1.5   -   EQUITY SAM Changes                                                    */
/*  1.6   -   EQUITY SAM changes - nvl to fab_nwb_amt                               */
/*  1.7   -   Giving effect of FNO BSE limit     (DS)                               */
/*  1.8		-		Source flag for New DL .NET																						*/
/*  1.9   -   Changing error msg while revaluation process is running               */
/*  2.0   -   View to FML Changes                                                   */
/*  2.1   -   SAM Block Unblock changes																							*/
/*  2.2   -   Check for PLEDGE_REVELATION                                           */
/*  2.3   -   CR-ISEC14-138293 Margin Pledge                                        */
/*  2.4   -   CR-ISEC04-142904 Withdrawal & Invocation order clubbing               */ 
/*  2.5   -   Minor change for limit issue                                          */
/*  2.6   -   Not allowe Modification/Cancel																				*/
/*  2.7   -   NWB Removal																														*/
/*  2.8   -   Prev SAM Update                                                       */
/************************************************************************************/
#include <stdio.h>      /* C Header File                */
#include <stdlib.h>     /* C Header File                */
#include <sqlca.h>      /* Oracle header file           */
#include <atmi.h>       /* TUXEDO Header File           */
#include <userlog.h>    /* TUXEDO Header File           */
#include <fml32.h>      /* TUXEDO Header File           */
#include <Usysflds.h>   /* TUXEDO Field Definitions  */

/* User defined h files */
#include <fml_def.h>    /* created for FML handling */
#include <fo.h>
#include <fo_fml_def.h>
/** #include <fo_view_def.h> ** ver 2.0 **/
#include <fo_view_def.h>  /** ver 2.0 **/
#include <fn_log.h>
#include <fn_session.h>
#include <fn_tuxlib.h>
#include <fn_ddr.h>
#include <string.h> /* Ver 1.2 */
#include <fn_read_debug_lvl.h> /* Ver 1.3 */
#include <fn_eqsam.h> /* Ver 1.5 EQ SAM*/
#include <fn_pos.h> /* Ver 2.0 */


EXEC SQL INCLUDE "table/pps_plg_pstn.h";
EXEC SQL INCLUDE "table/pod_plg_ordr_dtls.h"; /*** Ver 2.1 *** Uncommented in Ver 2.3 ***/
EXEC SQL INCLUDE "table/sbd_sam_bkubk_dtls.h"; /** Ver 2.1 **/
EXEC SQL INCLUDE "table/dbd_dp_blck_dtls.h";
EXEC SQL INCLUDE "table/clm_clnt_mstr.h";
EXEC SQL INCLUDE "table/ppp_par_plg_prmtr.h";
EXEC SQL INCLUDE "table/stk_stk_mstr.h";
EXEC SQL INCLUDE "table/ltq_trd_qt.h";
EXEC SQL INCLUDE "table/pml_plg_mod_log.h";
EXEC SQL INCLUDE "table/fab_fo_alc_bft_smry.h";

int Z;
#define INIT(x,y)  for(Z=0; Z< y; Z++) x[Z] =0
/**	#define MEMSET(A) memset(A.arr,0,sizeof(A.arr));	***/
#define  BUF_MULTIPLY 1
#define TOTAL_FML 12
#define MIN(x,y)  ( (x < y) ? x : y )

void SFO_MODCAN_PLG( TPSVCINFO *rqst)
{

	FBFR32 *ptr_fml_Ibuf;
	FBFR32 *ptr_fml_Obuf;

	struct vw_usr_prfl st_usr_prfl;
  struct vw_err_msg st_err_msg;
	struct vw_gt_lmt_dtls st_gt_lmt;

	int i;
	char c_ServiceName[33];
	char c_narration[255+1];		/** Ver 1.5 EQ SAM **/
	int i_err[TOTAL_FML];
	int   i_trnsctn = 0;
	int   i_rowcount = 0;
	int   i_level_exists = 0;	
	int   i_returncode = 0;
  int i_count = 0 ;           /** Ver 2.2 **/	
	char c_err_msg[256];
	char c_null_msg [ 18 ];
	char sql_oprn_typ;
/**	long l_acnt_id = 0;				** Ver 1.1 Commented	***/
	long l_ip_len  = 0;
  long l_pod_cnt = 0;    /** Ver 2.4 **/
 
	EXEC SQL BEGIN DECLARE SECTION;
	varchar sql_usr_id[10];
  varchar sql_mtch_accnt[11];
	long sql_sssn_id;
  varchar pod_ordr_seq[16];
  varchar sql_alias[10];
	long sql_qty_plg = 0;
	long sql_net_qty_plg = 0;
	long sql_tot_pod_ordr_qty = 0;
	long li_tot_blck_qty = 0;
	long sql_pps_seq = 0;
  long sql_prs_seq = 0 ;
	double d_eq_sam_limit = 0.0; 		/** Ver 1.5 EQ SAM **/
	double sql_stck_net_plg_val = 0.0; /*Holds the old plg val in Pledge and net value in Withdrwal case*/
  long long	ll_stck_net_plg_val = 0; /* long long used for rounding off*/
	double sql_stck_plg_val = 0.0;/*Holds the Effective quantity  value in case of modification and whole request value in case of cancellation*/
	double sql_eab_plg_amt =0.0;	/** Ver 2.7 **/

  /** Ver 1.7 **/
  double d_nfo_limit=0.0;
  double d_bfo_limit=0.0;
  double d_net_fno_limit=0.0;
  /** V1.7 ends **/

	long long ll_stck_plg_val = 0;
	varchar sql_nxt_trd_dt[13];
	long l_old_ordr_qty = 0; /*This will contain the old pledge order quantity request for withdrawal*/
	long l_new_req_qty = 0;/*This will contain the new calculated revoke request quantity*/
	long l_new_cov_qty = 0;/*This will contain the new calculated revoke cover quantity*/
	EXEC SQL END DECLARE SECTION;		
	ptr_fml_Ibuf = (FBFR32 *)rqst->data;
	ptr_fml_Obuf = (FBFR32 *)NULL;
	strcpy( c_ServiceName, rqst->name );
  INITDBGLVL(c_ServiceName);	

	strcpy(c_null_msg,"\0");
	INIT(i_err,TOTAL_FML);
	MEMSET(sql_usr_id);
	MEMSET(sql_mtch_accnt);
	MEMSET(sql_pml_channel);
  MEMSET(sql_pod_ordr_no);/** Ver 2.3 **/ 
  MEMSET(sql_pod_ordr_dt); /*** Ver 2.1 *** Uncommented in Ver 2.3 **/
	/** MEMSET(sql_sbd_bkubk_dt);		** Ver 2.1 *** commented in Ver 2.3 **/
		
	i_err[0] = Fget32(ptr_fml_Ibuf,FFO_USR_ID,0,(char *)sql_usr_id.arr,0);
	i_err[1] = Fget32(ptr_fml_Ibuf,FFO_EBA_MTCH_ACT_NO,0,(char *)sql_mtch_accnt.arr,0);
	i_err[2] = Fget32(ptr_fml_Ibuf,FFO_SSSN_ID,0,(char *)&sql_sssn_id,0);
	i_err[3] = Fget32(ptr_fml_Ibuf,FFO_OPERATION_TYP,0,(char *)&sql_oprn_typ,0);
	i_err[4] = Fget32(ptr_fml_Ibuf,FFO_CHANNEL,0,(char *)sql_pml_channel.arr,0);
	i_err[5] = Fget32(ptr_fml_Ibuf,FFO_DPID,0,(char *)sql_dbd_dp_id,0);
	i_err[6] = Fget32(ptr_fml_Ibuf,FFO_DP_CLNT_ID,0,(char *)sql_dbd_dp_clnt_id,0);
	i_err[7] = Fget32(ptr_fml_Ibuf,FFO_STCK_CD,0,(char *)sql_stk_stck_cd,0);
	i_err[8] = Fget32(ptr_fml_Ibuf,FFO_ORD_TOT_QTY,0,(char *)&sql_qty_plg,0);
	i_err[9] = Fget32(ptr_fml_Ibuf,FFO_ORD_DT,0,(char *)sql_pod_ordr_dt.arr,0); /*** Ver 2.1 ** Uncommented  in Ver 2.3 ***/
/**	i_err[9] = Fget32(ptr_fml_Ibuf,FFO_ORD_DT,0,(char *)sql_sbd_bkubk_dt.arr,0); *** Ver 2.1 ** Commented in Ver 2.3 ***/
	i_err[10] = Fget32(ptr_fml_Ibuf,FFO_ORD_TYP,0,(char *)&sql_sbd_sam_bkubk_typ,0);
  i_err[11] = Fget32(ptr_fml_Ibuf,FFO_PLG_ORDR_RFRNC,0,(char *)sql_pod_ordr_no.arr,0); /** Ver 2.3 ***/

	for (i=0; i < 12;i++)  /** Change from 11 to 12 in Ver 2.3 ***/
	{
		if(i_err[i] == -1)
		{
			fn_errlog( c_ServiceName, "S31005", FMLMSG, c_err_msg  );
			fn_userlog(c_ServiceName, "The Fget32 error at [%d]",i);
/**		l_acnt_id = -1;
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented	***/
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
	}

	SETLEN(sql_usr_id);
	SETLEN(sql_mtch_accnt);
  SETLEN(sql_pod_ordr_no);  /** Ver 2.3 **/ 
  SETNULL(sql_pod_ordr_no); /** Ver 2.3 **/
  
	SETLEN(sql_pml_channel);
	SETLEN(sql_pod_ordr_dt);  /** Uncommented in Ver 2.3 ** Ver 2.1 ***/
	/** SETLEN(sql_sbd_bkubk_dt);	** Ver 2.1 ** Commented in Vre 2.3 **/

	if(DEBUG_MSG_LVL_0)
	{
		fn_userlog(c_ServiceName, "The User Id is [%s]",sql_usr_id.arr);
		fn_userlog(c_ServiceName, "The Match Account is [%s]",sql_mtch_accnt.arr);
		fn_userlog(c_ServiceName, "The Session Id is [%ld]",sql_sssn_id);
		fn_userlog(c_ServiceName, "The Operation Type is [%c]",sql_oprn_typ);
		fn_userlog(c_ServiceName, "The Channel is [%s]",sql_pml_channel.arr);
		fn_userlog(c_ServiceName, "The Dp Id is [%s]",sql_dbd_dp_id);
		fn_userlog(c_ServiceName, "The Dp Client Id is [%s]",sql_dbd_dp_clnt_id);
		fn_userlog(c_ServiceName, "The Stock Cd is [%s]",sql_stk_stck_cd);
		fn_userlog(c_ServiceName, "The Plg Quantity is [%ld]",sql_qty_plg);
		fn_userlog(c_ServiceName, "The Order Date is [%s]",sql_pod_ordr_dt.arr); /** Ver 2.1 ** Uncommented in ver 2.3 **/
	  /** fn_userlog(c_ServiceName, "The Order Date is [%s]",sql_sbd_bkubk_dt.arr); *** Ver 2.1 *** Commented in Ver 2.3 **/
		fn_userlog(c_ServiceName, "The Order Type is [%c]",sql_sbd_sam_bkubk_typ);
    fn_userlog(c_ServiceName, "The Order No is [%s]",sql_pod_ordr_no.arr); /** Ver 2.3 **/
	}

	/************************	VER 1.1 ADDITION START	**************************/


	/** Added for Ver 2.6 **/
	if(strcmp( sql_pml_channel.arr, "SYS") != 0)
	{
   	fn_userlog(c_ServiceName, "Modify/Cancel is not allowed for Pledge request." );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "Modify/Cancel is not allowed for Pledge request.", 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}
	/** End for Ver 2.6 **/

	if ( strcmp( sql_pml_channel.arr, "1" ) == 0 )
	{
		strcpy( (char *)sql_pml_channel.arr, "APP" );
	}
	else if ( strcmp( sql_pml_channel.arr, "2" ) == 0 )
	{
		strcpy( (char *)sql_pml_channel.arr, "VSA" );
	}
	
	/*** 	VER 1.8 START  	***/

  else if ( strcmp( sql_pml_channel.arr, "Y" ) == 0 )			/*** For New Trade Racer ***/
	{
		strcpy( (char *)sql_pml_channel.arr, "NET" );
	}
	else if ( strcmp( sql_pml_channel.arr, "Z" ) == 0 )			/*** For New Trade Racer by super user ***/
	{
		strcpy( (char *)sql_pml_channel.arr, "CN2" );
	}

	/*** 	VER 1.8 ENDS 	***/

	SETLEN(sql_pml_channel);

	if(DEBUG_MSG_LVL_0)
	{
		fn_userlog(c_ServiceName, "The Channel is [%s]",sql_pml_channel.arr);
	}

	/************************ VER 1.1 ADDITION ENDS		**************************/	

	/**************************** Check Session of User ****************************/

	if(DEBUG_MSG_LVL_0)
	{
  	fn_userlog( c_ServiceName, "Checking Session ");
	}

  strcpy( st_usr_prfl.c_user_id, sql_usr_id.arr );
  st_usr_prfl.l_session_id = sql_sssn_id;
  strcpy( st_usr_prfl.c_cln_mtch_accnt,sql_mtch_accnt.arr);

  fn_cpy_ddr ( st_usr_prfl.c_rout_crt );       /*** Added for Order Routing ***/

  i_returncode = fn_chk_sssn( c_ServiceName, &st_usr_prfl, &st_err_msg );

  if ( i_returncode == -1 )
  {
  	fn_errlog( c_ServiceName,"S31010",LIBMSG , st_err_msg.c_err_msg  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg,0);
/*  l_acnt_id = -1;
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );	 ** Ver 1.1 : Commented  ***/
    tpreturn(TPFAIL, 0L, (char *)ptr_fml_Ibuf, 0, 0 );
  }

	if(DEBUG_MSG_LVL_0)
	{
  	fn_userlog( c_ServiceName, "Checking Session Done ");
	}


  /***** Ver 2.3 Starts ****/
   EXEC SQL
   SELECT COUNT(1)
   INTO   :l_pod_cnt
   FROM   POD_PLG_ORDR_DTLS_CNV
   WHERE   POD_CLNT_MTCH_ACCNT = :sql_mtch_accnt
   AND     POD_DP_CLNT_ACCNT   = :sql_dbd_dp_clnt_id
   AND     POD_DP_ACCNT        = :sql_dbd_dp_id
   AND     POD_STCK_CD         = :sql_stk_stck_cd
   AND     POD_ORDR_NO         = :sql_pod_ordr_no
   AND     trunc(POD_ORDR_DT)  = trunc(to_date(:sql_pod_ordr_dt,'dd-Mon-yyyy hh24:mi:ss'));

  if( SQLCODE !=0 )
  {
    fn_errlog( c_ServiceName, "S31015", SQLMSG, c_err_msg  );
    fn_userlog(c_ServiceName, "VER 1.1 ORDER STATUS UNAVAILABLE" );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }


    fn_userlog( c_ServiceName, "OPERATION TYPE IS [%c]", sql_oprn_typ );
    fn_userlog( c_ServiceName, "Requested count  [%ld]", l_pod_cnt );

  if( ( sql_oprn_typ == 'M' || sql_oprn_typ == 'C' )&& ( l_pod_cnt > 0 ) )
  {
    fn_userlog(c_ServiceName, "Modify/Cancel is not allowed for Pledge conversion request." );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "Modify/Cancel is not allowed for Pledge conversion request.", 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
  /***** Ver 2.3 Ends   ****/

	/************************ VER 1.1 ADDITION STARTS	**************************/

	/**** Commented for 2.1 ********** Uncommented in Ver 2.3 ***/
	EXEC SQL
	SELECT 	POD_ORDR_STTS, POD_ORDR_QTY,POD_PLG_REV_TYP
	INTO 		:sql_pod_ordr_stts, :sql_sbd_bkubk_qty,:sql_sbd_sam_bkubk_typ
	FROM		POD_PLG_ORDR_DTLS
	WHERE		POD_CLNT_MTCH_ACCNT	=	:sql_mtch_accnt
	AND 		POD_DP_CLNT_ACCNT		=	:sql_dbd_dp_clnt_id
	AND			POD_DP_ACCNT				=	:sql_dbd_dp_id
  AND			POD_STCK_CD					=	:sql_stk_stck_cd
  AND     POD_ORDR_NO         = :sql_pod_ordr_no
	AND			trunc(POD_ORDR_DT)  =	trunc(to_date(:sql_pod_ordr_dt,'dd-Mon-yyyy hh24:mi:ss')); 

	/**** Commented for 2.1 ********** Uncommented in Ver 2.3 ***/

	/** Commented in Ver 2.3 ** Added for Ver 2.1 *****
	EXEC SQL
	SELECT 	SBD_BKUBK_STTS, SBD_BKUBK_QTY
	INTO 		:sql_sbd_bkubk_stts, :sql_sbd_bkubk_qty
	FROM		SBD_SAM_BKUBK_DTLS
	WHERE
		SBD_CLNT_MTCH_ACCNT = :sql_mtch_accnt
		AND SBD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
		AND	SBD_DP_ACCNT = :sql_dbd_dp_id
		AND SBD_STCK_CD = :sql_stk_stck_cd
		AND SBD_BKUBK_DT = to_date(:sql_sbd_bkubk_dt,'dd-Mon-yyyy hh24:mi:ss');

	*** Ver 2.1 ***/

	/******** Ver 2.1 ******** Uncommented in Ver 2.3 ***/
	if(DEBUG_MSG_LVL_0)
	{
    fn_userlog( c_ServiceName, "ORDER STATUS IS 	[%c]", sql_pod_ordr_stts );
		fn_userlog( c_ServiceName, "OPERATION TYPE IS [%c]", sql_oprn_typ );
		fn_userlog( c_ServiceName, "REQUEST TYPE IS		[%c]", sql_sbd_sam_bkubk_typ ); 
		fn_userlog( c_ServiceName, "FETCHED ORDER QTY [%ld]", sql_sbd_bkubk_qty );
	}
	/*********** Ver 2.1 ******* Uncommented in Ver 2.3 ***/

	/** Commented in Ver 2.3  *** Added for Ver 2.1 ***
	if(DEBUG_MSG_LVL_0)
	{
    fn_userlog( c_ServiceName, "ORDER STATUS IS 	[%c]", sql_sbd_bkubk_stts );
		fn_userlog( c_ServiceName, "OPERATION TYPE IS [%c]", sql_oprn_typ );
		fn_userlog( c_ServiceName, "REQUEST TYPE IS		[%c]", sql_sbd_sam_bkubk_typ ); 
		fn_userlog( c_ServiceName, "FETCHED ORDER QTY [%ld]", sql_sbd_bkubk_qty );
	}
	***** Ver 2.1 ***/
 
	if( SQLCODE !=0 )
	{
		fn_errlog( c_ServiceName, "S31020", SQLMSG, c_err_msg  );
  	fn_userlog(c_ServiceName, "VER 1.1 ORDER STATUS UNAVAILABLE" );
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/** l_acnt_id = -1;
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		 ** Ver 1.1 : Commented  ***/
		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); 
	}

	if( ( sql_oprn_typ == 'M' || sql_oprn_typ == 'C' )&& ( sql_sbd_sam_bkubk_typ == 'I' || sql_pod_ordr_stts != 'R' ) ) /*** Variable change for Ver 2.1 ***/ /** change to sql_pod_ordr_stts from sql_sbd_bkubk_stts in ver 2.3 ***/
	{
		fn_userlog(c_ServiceName, "VER 1.1 MODIFICATION/CANCELATION NOT ALLOWED" );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "MODIFICATION/CANCELATION NOT ALLOWED", 0 );
/** l_acnt_id = -1;
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		 ** Ver 1.1 : Commented  ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}

	if(DEBUG_MSG_LVL_0)
	{
  	fn_userlog( c_ServiceName, "FOR OPERATION TYPE :%c: ORDER QUANTITY IS :%ld:", sql_oprn_typ, sql_qty_plg );
	}

	if( sql_oprn_typ == 'C' && sql_qty_plg == 0 )
	{
		sql_qty_plg = sql_sbd_bkubk_qty;

		if(DEBUG_MSG_LVL_0)
		{
  		fn_userlog( c_ServiceName, "FOR OPERATION TYPE :%c: ORDER QUANTITY NOW IS :%ld:", sql_oprn_typ, sql_qty_plg );
		}
	}

	/************************ VER 1.1 ADDITION ENDS   **************************/

	tpfree ( ( char * )ptr_fml_Obuf);
  ptr_fml_Obuf = (FBFR32 *)tpalloc( "FML32", NULL, MIN_FML_BUF_LEN * BUF_MULTIPLY );

	if(DEBUG_MSG_LVL_0)
	{
		fn_userlog(c_ServiceName, "The value of oprn type is [%c]",sql_oprn_typ);
	}

	if(sql_usr_id.arr[0] == BPID)
	{
		MEMSET(sql_alias);	
		if((Fget32(ptr_fml_Ibuf,FFO_ALIAS,0,(char *)sql_alias.arr,0)) == -1)
		{
			fn_errlog( c_ServiceName, "S31025", FMLMSG, c_err_msg  );
   		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**		l_acnt_id = -1;
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		 ** Ver 1.1 : Commented  ***/
			tpfree ( ( char * )ptr_fml_Obuf);
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );	
		}	
		SETLEN(sql_alias);
		
		i_level_exists = 0;
  	
		EXEC SQL
    SELECT 1
    INTO   :i_level_exists
    FROM   clm_clnt_mstr
    WHERE  clm_mtch_accnt = :sql_mtch_accnt
    AND    clm_bp_id      = :sql_usr_id
    AND    clm_alias_name = :sql_alias;

		if(DEBUG_MSG_LVL_0)
		{	
			fn_userlog(c_ServiceName,"BP alias  is [%s]",sql_alias.arr);
			fn_userlog(c_ServiceName,"BP channel  is [%s]",sql_pml_channel);
		}
		
		if(i_level_exists != 1 )
		{
    	fn_errlog( c_ServiceName, "B55006", "", c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**		l_acnt_id = -1;
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		 ** Ver 1.1 : Commented  ***/
			tpfree ( ( char * )ptr_fml_Obuf);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
		strcpy(sql_sbd_bp_id.arr,sql_usr_id.arr);
		SETLEN(sql_sbd_bp_id);
	}
	else
	{
		strcpy(sql_sbd_bp_id.arr,"*");
		SETLEN(sql_sbd_bp_id);
	}


	sql_ppp_min_dep_amt =  0;

	EXEC SQL SELECT PPP_PLG_OPNCLS_FLG, PPP_MIN_DEP_AMT 
	INTO :sql_ppp_plg_opncls_flg, :sql_ppp_min_dep_amt
	FROM PPP_PAR_PLG_PRMTR;

	if( SQLCODE !=0 )
	{
 		fn_errlog( c_ServiceName, "S31030", SQLMSG, c_err_msg  );
		fn_userlog(c_ServiceName, "The value flag is [%c]",sql_ppp_plg_opncls_flg);
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**	lacnt_id = -1;
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		 ** Ver 1.1 : Commented  ***/
		tpfree ( ( char * )ptr_fml_Obuf);
		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}

	if( sql_ppp_plg_opncls_flg == 'N')
	{
		/* Commented in ver 1.9 fn_userlog(c_ServiceName, "At present the facility of Shares as Margin has been suspended");
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "At present the facility of Shares as Margin has been suspended", 0 ); */
		fn_userlog(c_ServiceName, "Please try depositing later as shares as margin process is underway");         /* Ver 1.9 */
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "Please try depositing later as shares as margin process is underway", 0 );   /* Ver 1.9 */
/**	l_acnt_id = -1;
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
		tpfree ( ( char * )ptr_fml_Obuf);
		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}

	EXEC SQL 
	SELECT nvl(CLM_PLG_ALLWD_FLG,'N') 
	INTO :sql_clm_plg_allwd_flg
	FROM CLM_CLNT_MSTR 
	WHERE CLM_MTCH_ACCNT = :sql_mtch_accnt;

	if( SQLCODE !=0 )
	{
		fn_errlog( c_ServiceName, "S31035", SQLMSG, c_err_msg  );
		fn_userlog(c_ServiceName, "The value for mtch [%s][%ld] is [%c]",sql_mtch_accnt.arr,sql_mtch_accnt.len,sql_clm_plg_allwd_flg);
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**	l_acnt_id = -1;
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
		tpfree ( ( char * )ptr_fml_Obuf);
		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}

  /********* Added in Ver 2.2 ***************/
  i_count=0;
  EXEC SQL
  select count(*)
  INTO   :i_count
  FROM   SPP_STCK_PLG_PRCSNG
  WHERE  SPP_CLM_MTCH_ACCNT = :sql_mtch_accnt
  AND    SPP_PRCS_FLG in ('I','N');

  if( SQLCODE !=0 )
  {
      fn_errlog( c_ServiceName, "S31040", SQLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      tpfree ( ( char * )ptr_fml_Obuf);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  if(i_count > 0 )
  {
    fn_userlog(c_ServiceName,"Please try later as shares as margin process is underway");
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "Please try later as shares as margin process is underway", 0 );
    tpfree ( ( char * )ptr_fml_Obuf);
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  /********** Added in Ver 2.2 ***************/ 

/* The old pledge amount is required for inserting in FAL table*/
	
	EXEC SQL 
	SELECT FAB_PLG_AMT ,
		nvl(FAB_NWB_AMT,0)							/*Ver 1.5 EQ SAM *//*V1.6 nvl*/
	INTO :sql_fab_plg_amt ,
			 :sql_fab_nwb_amt		    /*Ver 1.5 EQ SAM */
	FROM FAB_FO_ALC_BFT_SMRY
	WHERE FAB_CLM_MTCH_ACCNT = :sql_mtch_accnt;
	
	if( SQLCODE !=0 )
  {
    fn_errlog( c_ServiceName, "S31045", SQLMSG, c_err_msg  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**	l_acnt_id = -1;
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
		tpfree ( ( char * )ptr_fml_Obuf);
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

	if(DEBUG_MSG_LVL_0)
	{
		fn_userlog(c_ServiceName, "The value of old plg is [%lf]",sql_fab_plg_amt);
	}

	if (sql_qty_plg <= 0)
	{
		strcpy( c_err_msg, "Quantity cannot be zero or negative" );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**	l_acnt_id = -1;
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
		tpfree ( ( char * )ptr_fml_Obuf);
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}
	switch (sql_sbd_sam_bkubk_typ)
	{
		/* First case to consider is that of pledging*/

		case 'P' :   /**** pledge ****/
		{
				if (sql_ppp_plg_opncls_flg == 'N' )
				{
					/* Commented in ver 1.9 fn_userlog(c_ServiceName, "At present the facility of Shares as Margin has been suspended");
    			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "At present the facility of Shares as Margin has been suspended", 0 );*/
					fn_userlog(c_ServiceName, "Please try depositing later as shares as margin process is underway");  /* Ver 1.9 */
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "Please try depositing later as shares as margin process is underway",0);  /* Ver 1.9 */
/**				l_acnt_id = -1;
        	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
					tpfree ( ( char * )ptr_fml_Obuf);
	    		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );	
				}	

				if ( sql_clm_plg_allwd_flg != 'Y' && sql_clm_plg_allwd_flg != 'W')
				{
					fn_userlog(c_ServiceName, "At present the facility of Shares as Margin has been suspended");
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "At present the facility of Shares as Margin has been suspended", 0 );
/**				l_acnt_id = -1;
        	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
					tpfree ( ( char * )ptr_fml_Obuf);
			  	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}

				EXEC SQL 
				SELECT 
				nvl(STK_PLG_ALLWD,'N'),
				nvl(STK_PLG_CONC,0),
				nvl(STK_PLG_CLNT_CONC,0),
			/***	nvl(STK_PLG_HAIRCUT,0), ** Ver 1.5 **/
				nvl(STK_PLG_MIN_DPST,0)   
	    	INTO 
				:sql_stk_plg_allwd,
				:sql_stk_plg_conc,
				:sql_stk_plg_clnt_conc,
			/**	:sql_stk_plg_haircut, ** Ver 1.5 **/
				:sql_stk_plg_min_dpst
				FROM STK_STK_MSTR 
				WHERE STK_STCK_CD = :sql_stk_stck_cd;	
		
				if( SQLCODE !=0 )
				{
					fn_errlog( c_ServiceName, "S31050", SQLMSG, c_err_msg  );
					fn_userlog(c_ServiceName, "For stck code : [%s][%ld]",sql_stk_stck_cd,sizeof(sql_stk_stck_cd));
     			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**				l_acnt_id = -1;
        	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
					tpfree ( ( char * )ptr_fml_Obuf);
     			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}

				/**** Ver 1.5 EQ SAM starts ***/

				i_returncode = fn_get_haircut(c_ServiceName, 
																				sql_mtch_accnt.arr,
																				sql_stk_stck_cd , 
																				&sql_stk_plg_haircut , 
																				c_err_msg);

				if(i_returncode == -1)
				{
					fn_errlog( c_ServiceName, "S31055", "Invalid Haircut value ", c_err_msg  );
          fn_userlog(c_ServiceName, "Invalid Haircut value For stck code : [%s]",sql_stk_stck_cd);
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpfree ( ( char * )ptr_fml_Obuf);
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
				/**** Ver 1.5 ends ****/

				if((sql_stk_plg_haircut < 0) || (sql_stk_plg_haircut > 100))
				{
					fn_errlog( c_ServiceName, "S31060", "Invalid Haircut value ", c_err_msg  );
					fn_userlog(c_ServiceName, "Invalid Haircut value For stck code : [%s]",sql_stk_stck_cd);
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**				l_acnt_id = -1;
        	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
					tpfree ( ( char * )ptr_fml_Obuf);
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}

				if(DEBUG_MSG_LVL_0)
				{
				fn_userlog(c_ServiceName,"The value is STK_PLG_ALLWD is [%c]",sql_stk_plg_allwd);
				fn_userlog(c_ServiceName,"The value is STK_PLG_CONC  is [%ld]",sql_stk_plg_conc);
				fn_userlog(c_ServiceName,"The value is STK_PLG_CLNT_CONC is [%ld]",sql_stk_plg_clnt_conc);
				fn_userlog(c_ServiceName,"The value is STK_PLG_HAIRCUT is [%ld]",sql_stk_plg_haircut);
				fn_userlog(c_ServiceName,"The value is STK_PLG_MIN_DPST is [%ld]",sql_stk_plg_min_dpst);
				}

				if (sql_stk_plg_allwd == 'N' || sql_stk_plg_allwd == 'R' )
				{
					if(sql_stk_plg_allwd == 'N')
					{
						fn_userlog(c_ServiceName, "At present the scrip has been disabled from the facility of Shares as Margin");
						strcpy(c_err_msg,"At present the scrip has been disabled from the facility of Shares as Margin");
						Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
						tpfree ( ( char * )ptr_fml_Obuf);
/**					l_acnt_id = -1;
          	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ) ;
					}
					else
					{
						fn_userlog(c_ServiceName, "Cannot  modify/cancel as the scrip is under revaluation");
						strcpy(c_err_msg,"Cannot  modify/cancel as the scrip is under revaluation");
       			Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
						Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
/**					l_acnt_id = -1;
          	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
          	Fadd32( ptr_fml_Ibuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
						tpfree ( ( char * )ptr_fml_Obuf);
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
				}
				
				EXEC SQL 
				SELECT LTQ_PLG_RT 
				INTO :sql_ltq_plg_rt 
				FROM LTQ_TRD_QT
				WHERE LTQ_STCK_CD = :sql_stk_stck_cd
				AND LTQ_XCHNG_CD = 'BSE'; /* ver 1.4 */
				
				if (SQLCODE != 0)
				{
					fn_errlog( c_ServiceName, "S31065", SQLMSG, c_err_msg  );
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**				l_acnt_id = -1;
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
					tpfree ( ( char * )ptr_fml_Obuf);
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
	
				EXEC SQL 
				SELECT nvl(DBD_TOT_QTY,0),
				nvl(DBD_QTY_BLCKD,0),
        /***  Uncommented in ver 2.3 Starts***/
        nvl(DBD_PLG_REQ_QTY,0),
				/** nvl(DBD_TIFP_QTY,0), ** Ver 2.1 **/
        nvl(DBD_REV_REQ_QTY,0),
				nvl(DBD_REV_COV_QTY,0),
        nvl(DBD_INV_REQ_QTY,0),
				nvl(DBD_INV_COV_QTY,0),
        /*** Uncommented in Ver 2.3 Ends ** Ver 2.1 ***/
				nvl(DBD_SAM_BLCKD_QTY,0),
        nvl(DBD_BLOCK_FOR_SALE,0),
				DBD_ISIN_NMBR
				INTO :sql_dbd_tot_qty,
				:sql_dbd_qty_blckd,
        :sql_dbd_plg_req_qty,
				/** :sql_dbd_tifp_qty, ** Ver 2.1 **/
        :sql_dbd_rev_req_qty,
        :sql_dbd_rev_cov_qty,
				:sql_dbd_inv_req_qty,
        :sql_dbd_inv_cov_qty, 
        /** Uncommented in Ver 2.3  **** Ver 2.1 ***/
				:sql_dbd_sam_blckd_qty,
        :sql_dbd_block_for_sale,
				:sql_dbd_isin_nmbr
				FROM DBD_DP_BLCK_DTLS
				WHERE DBD_STCK_CD = :sql_stk_stck_cd
				AND DBD_CLM_MTCH_ACCNT = :sql_mtch_accnt
				AND DBD_DP_ID = :sql_dbd_dp_id
				AND DBD_DP_CLNT_ID = :sql_dbd_dp_clnt_id;

				if (SQLCODE != 0)
				{
					fn_errlog( c_ServiceName, "S31070", SQLMSG, c_err_msg  );
				  Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**				l_acnt_id = -1;
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );	** Ver 1.1 : Commented  ***/
					tpfree ( ( char * )ptr_fml_Obuf);
				  tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
				if(DEBUG_MSG_LVL_0)
				{	
				fn_userlog(c_ServiceName,"The value of DBD_TOT_QTY is [%ld]",sql_dbd_tot_qty);
				fn_userlog(c_ServiceName,"The value of DBD_QTY_BLCKD is [%ld]",sql_dbd_qty_blckd);
				/*** Changed for ver 2.1 **/
				fn_userlog(c_ServiceName,"The value of DBD_PLG_REQ_QTY is [%ld]",sql_dbd_plg_req_qty);
				/*** fn_userlog(c_ServiceName,"The value of DBD_TIFP_QTY is [%ld]",sql_dbd_tifp_qty); ***/
				fn_userlog(c_ServiceName,"The value of DBD_REV_REQ_QTY is [%ld]",sql_dbd_rev_req_qty);
				fn_userlog(c_ServiceName,"The value of DBD_REV_COV_QTY is [%ld]",sql_dbd_rev_cov_qty);
				fn_userlog(c_ServiceName,"The value of DBD_INV_REQ_QTY is [%ld]",sql_dbd_inv_req_qty);
				fn_userlog(c_ServiceName,"The value of DBD_INV_COV_QTY is [%ld]",sql_dbd_inv_cov_qty); 
				fn_userlog(c_ServiceName,"The value of DBD_TIFP_QTY is [%ld]",sql_dbd_sam_blckd_qty);
				fn_userlog(c_ServiceName,"The value of DBD_BLOCK_FOR_SALE is [%ld]",sql_dbd_block_for_sale);
				fn_userlog(c_ServiceName,"The value of DBD_ISIN_NMBR is [%s]",sql_dbd_isin_nmbr);
				}

			switch(sql_oprn_typ)
			{
				case 'M' :
				{
						sql_pml_mod_type ='M';
						MEMSET(sql_pml_rmrks);
						strcpy(sql_pml_rmrks.arr,"User modified");
						SETLEN(sql_pml_rmrks);
	/** Uncommented in Ver 2.3 ** comm**** Ver 2.1 ****/
						if (sql_dbd_plg_req_qty <= 0)
						{
							fn_userlog(c_ServiceName,"There is no Pledge request to Modify.");
							strcpy(c_err_msg,"There is no Pledge request to Modify.");
/**           l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );	** Ver 1.1 : Commented  ***/
	  					Fadd32( ptr_fml_Ibuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
							Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ) ;				
						}

						if(sql_dbd_rev_req_qty > 0)
						{
							fn_userlog(c_ServiceName,"The Revoke quantity is [%ld]. Hence rejected.", sql_dbd_rev_req_qty);
							strcpy(c_err_msg,"There is a pending withdrawal request present.Please cancel/modify the same.");
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
							Fadd32( ptr_fml_Ibuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
							Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ) ;				
						}

			/******** ver 2.1 ***/
						
						if(sql_stk_plg_min_dpst > sql_qty_plg)
						{
							fn_userlog( c_ServiceName, "The new pledged qty is less the minimum deposit quantity");
							strcpy(c_err_msg,"The new pledged qty is less the minimum deposit quantity");
							Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
							Fadd32( ptr_fml_Ibuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}			


				/** Uncommented in Ver 2.3 Starts *** Ver 2.1 *******/
						if(((sql_ppp_plg_opncls_flg == 'W')
							|| (sql_clm_plg_allwd_flg == 'W')) && (sql_qty_plg >= sql_dbd_plg_req_qty))
						{
				    /* Commented in ver 1.9 fn_userlog(c_ServiceName,"At present depositing additional shares as margin has been suspended");*
                
							* Commented in ver 1.9 strcpy(c_err_msg,"At present depositing additional shares as margin has been suspended"); */
              fn_userlog(c_ServiceName,"Please try depositing later as shares as margin process is underway");
							strcpy(c_err_msg,"Please try depositing later as shares as margin process is underway");
							Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
							Fadd32( ptr_fml_Ibuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );	
						}
						
						if((sql_stk_plg_allwd == 'W')	&& (sql_qty_plg >= sql_dbd_plg_req_qty))
						{	
							fn_userlog(c_ServiceName,"At present depositing additional shares of this scrip has been suspended"); 
							strcpy(c_err_msg,"At present depositing additional shares of this scrip has been suspended");
							Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
							Fadd32( ptr_fml_Ibuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );	
						}

			/** Uncommented in Ver 2.3 Ends 	******* Ver 2.1 *****/

		/*The sql_net_qty_plg can be negative indicating that there has been a reduction in pledge
		The variable sql_qty_plg has the effective quantity sent by the front - end*/	

		/*If there is an addition of Pledge, then check in the DBD for free quantity*/	

         if( sql_qty_plg > sql_sbd_bkubk_qty) /** ver 2.3 **/
         {
						if(((sql_qty_plg ) > 0 ) && ((sql_dbd_tot_qty - sql_dbd_qty_blckd) < (sql_qty_plg - sql_sbd_bkubk_qty))) /** sql_sbd_bkubk_qty added in Ver 2.3 **/
						{
							fn_userlog(c_ServiceName,"The value free is [%ld] and pledged is [%ld]",li_tot_blck_qty,sql_qty_plg); 
							fn_userlog(c_ServiceName,"The free quantity for pledge is less than that requested"); 
							strcpy(c_err_msg,"The free quantity for pledge is less than that requested");
							Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );	** Ver 1.1 : Commented  ***/
							Fadd32( ptr_fml_Ibuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );	
						}
         }

						/*The following variable will be used to hold the value of the old stock pledged 
						This will be used for entry in FAB table as the old pledge value has to be removed*/	

/**						sql_stck_net_plg_val = (sql_dbd_plg_req_qty * (sql_ltq_plg_rt *(1 - ((double)(sql_stk_plg_haircut)/100))))*100; ** diwa typecast float to double **/

						if((long long)(sql_stck_net_plg_val * 100)%100 > 50)
						{
							sql_stck_net_plg_val = sql_stck_net_plg_val + 1.0;
						}

						if(DEBUG_MSG_LVL_0)
						{
							fn_userlog( c_ServiceName, "The rounded off amount of Old Plg val is [%lf]", sql_stck_net_plg_val );
						//	fn_userlog( c_ServiceName, "The Qty Pledged is [%ld]",sql_dbd_plg_req_qty);
						}

					
						ll_stck_net_plg_val = (long long) sql_stck_net_plg_val;

						sql_stck_net_plg_val = (double) ll_stck_net_plg_val;

						
						/*The following variable will be used to hold the value of the stock pledged*/	

						sql_stck_plg_val = (sql_qty_plg * (sql_ltq_plg_rt *(1 - ((double)(sql_stk_plg_haircut)/100))))*100; /** diwa typecast float to double **/

						if((long long)(sql_stck_plg_val * 100)%100 > 50)
						{
							sql_stck_plg_val = sql_stck_plg_val + 1.0;
						}

						if(DEBUG_MSG_LVL_0)
						{
							fn_userlog( c_ServiceName, "The rounded off amount of New Plg val is [%lf]",sql_stck_plg_val);
							fn_userlog( c_ServiceName, "The New Qty Plg is [%ld]",sql_qty_plg);
						}


						ll_stck_plg_val = (long long) sql_stck_plg_val;

						sql_stck_plg_val = (double) ll_stck_plg_val;

						if(DEBUG_MSG_LVL_0)
						{
							fn_userlog(c_ServiceName,"The plg val is [%lf] for rate [%lf]",sql_stck_plg_val,sql_ltq_plg_rt);
						}



		/*check limits in case of pledge only if the new pledge quantity is less than the old pledge qunatity that is, it is a net withdrawal*/

						/** if(sql_dbd_plg_req_qty > sql_qty_plg) ** diwa comment - lower order modification **/
						if(0 > sql_qty_plg)
						{
/**************** Comment Start Ver 2.3 ***********************************
							*****The following portion gets the Limits avaliable for the user before pledge modify***
							memset(&st_gt_lmt,'\0' , sizeof( struct vw_gt_lmt_dtls) );
							strcpy(st_gt_lmt.c_xchng_cd , "NFO" );

							MEMSET(sql_nxt_trd_dt);

							EXEC SQL 
							SELECT EXG_NXT_TRD_DT 
							INTO :sql_nxt_trd_dt 
							FROM EXG_XCHNG_MSTR
							WHERE EXG_XCHNG_CD = 'NFO';
			
							if (SQLCODE != 0)
							{
								fn_errlog( c_ServiceName, "S31075", SQLMSG, c_err_msg  );
								Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
								tpfree ( ( char * )ptr_fml_Obuf);
								tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
							}
			
							SETNULL(sql_nxt_trd_dt);
			
							strcpy(st_gt_lmt.c_trd_dt, sql_nxt_trd_dt.arr );
							strcpy(st_gt_lmt.c_cln_mtch_accnt, sql_mtch_accnt.arr);
							l_ip_len = (long) sizeof ( struct vw_gt_lmt_dtls);
							st_gt_lmt.c_rqst_typ = LIMIT_X;
							fn_cpy_ddr ( st_gt_lmt.c_rout_crt );
		          
              **** Commented in Ver 2.0 ************************** 	
							i_returncode = fn_call_svc( c_ServiceName, c_err_msg, &st_gt_lmt, &st_gt_lmt,
																				"vw_gt_lmt_dtls", "vw_gt_lmt_dtls", l_ip_len,
																				l_ip_len, 0, "SFO_GET_LIMITS" );
			
							if ( i_returncode == -1 )
							{
								fn_errlog( c_ServiceName, "S31080", LIBMSG, c_err_msg );
								fn_userlog(c_ServiceName,"SFO_GET_LIMITS FAIL  ");
								Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
								Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
								tpfree ( ( char * )ptr_fml_Obuf);
								tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
							}
              ************** Ver 2.0 ******************************

							**** Ver 2.0 Starts Here ******** 
              i_returncode = fo_get_trd_limit(c_ServiceName,
                                    st_gt_lmt.c_cln_mtch_accnt,
                                    st_gt_lmt.c_trd_dt,
                                    st_gt_lmt.c_rqst_typ,
                                    st_gt_lmt.c_xchng_cd,
                                    st_gt_lmt.l_gid,
                                    &st_gt_lmt.d_amt,
                                    c_err_msg
                                    );
              if ( i_returncode == -1 )
              {
                fn_errlog( c_ServiceName, "S31085", LIBMSG, c_err_msg );
                fn_userlog(c_ServiceName,"SFO_GET_LIMITS FAIL  ");
                Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
                Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
                tpfree ( ( char * )ptr_fml_Obuf);
                tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
              }   
              **** Ver 2.0 Ends Here **********


              *****Ver 1.7 Get BFO limit. The net FNO limit will be minimum of NSE and BSE limit ***

							d_nfo_limit = st_gt_lmt.d_amt;

              memset(&st_gt_lmt,'\0' , sizeof( struct vw_gt_lmt_dtls) );
              strcpy(st_gt_lmt.c_xchng_cd , "BFO" );

              MEMSET(sql_nxt_trd_dt);

              EXEC SQL
              SELECT EXG_NXT_TRD_DT
              INTO :sql_nxt_trd_dt
              FROM EXG_XCHNG_MSTR
              WHERE EXG_XCHNG_CD = 'BFO';

              if (SQLCODE != 0)
              {
                fn_errlog( c_ServiceName, "S31090", SQLMSG, c_err_msg  );
                Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
                tpfree ( ( char * )ptr_fml_Obuf);
                tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
              }

              SETNULL(sql_nxt_trd_dt);

              strcpy(st_gt_lmt.c_trd_dt, sql_nxt_trd_dt.arr );
              strcpy(st_gt_lmt.c_cln_mtch_accnt, sql_mtch_accnt.arr);
              l_ip_len = (long) sizeof ( struct vw_gt_lmt_dtls);
              st_gt_lmt.c_rqst_typ = LIMIT_X;
              fn_cpy_ddr ( st_gt_lmt.c_rout_crt );

              ********* Commented in Ver 2.0 ***********
              i_returncode = fn_call_svc( c_ServiceName, c_err_msg, &st_gt_lmt, &st_gt_lmt,
                                        "vw_gt_lmt_dtls", "vw_gt_lmt_dtls", l_ip_len,
                                        l_ip_len, 0, "SFO_GET_LIMITS" );

              if ( i_returncode == -1 )
              {
                fn_errlog( c_ServiceName, "S31095", LIBMSG, c_err_msg );
                fn_userlog(c_ServiceName,"SFO_GET_LIMITS FAIL  ");
                Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
                Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
                tpfree ( ( char * )ptr_fml_Obuf);
                tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
              }
              ********** Ver 2.0 Ends Here ********** 

              **** Ver 2.0 Starts Here ********
              i_returncode = fo_get_trd_limit(c_ServiceName,
                                    st_gt_lmt.c_cln_mtch_accnt,
                                    st_gt_lmt.c_trd_dt,
                                    st_gt_lmt.c_rqst_typ,
                                    st_gt_lmt.c_xchng_cd,
                                    st_gt_lmt.l_gid,
                                    &st_gt_lmt.d_amt,
                                    c_err_msg
                                    );
              if ( i_returncode == -1 )
              {
                fn_errlog( c_ServiceName, "S31100", LIBMSG, c_err_msg );
                fn_userlog(c_ServiceName,"fo_get_trd_limit FAIL  ");
                Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
                Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
                tpfree ( ( char * )ptr_fml_Obuf);
                tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
              }  
              **** Ver 2.0 Ends Here **********
              

							d_bfo_limit = st_gt_lmt.d_amt;

      				d_net_fno_limit =  MIN(d_nfo_limit,d_bfo_limit);

      				if(DEBUG_MSG_LVL_0){
        				fn_userlog( c_ServiceName,"NFO Limit Calculated :%lf:",d_nfo_limit);
        				fn_userlog( c_ServiceName,"BFO Limit Calculated :%lf:",d_bfo_limit);
        				fn_userlog( c_ServiceName,"Net FNO limit        :%lf:",d_net_fno_limit);
      				}
      				****   Ver 1.7 ends **************

							**** Ver 1.5 Get the Equity SAM limit with the effect of -ve cash limit ***************


							i_returncode = fn_get_eqsam_limit (	c_ServiceName,
																				       	sql_mtch_accnt.arr,
                        												&d_eq_sam_limit,
																								sql_usr_id.arr,
																								sql_sssn_id,
                        												c_err_msg
																							);

							if(i_returncode == -1)
							{
								fn_errlog( c_ServiceName, "S31105", LIBMSG, c_err_msg );
								Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
								tpfree ( ( char * )ptr_fml_Obuf);
								tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
							}	

							if(DEBUG_MSG_LVL_0)
							{
								**fn_userlog( c_ServiceName,"Limit Calculated :%lf:",st_gt_lmt.d_amt); ** Ver 1.7**
								fn_userlog( c_ServiceName,"EQ SAM limit			:%lf:",d_eq_sam_limit);
							}

							*********** Ver 1.5 ends *************

			
						************** check limit is allowed for pledge withdrawal *************************
			
						**if(sql_stck_plg_val + st_gt_lmt.d_amt < sql_stck_net_plg_val) * Commented * Ver1.5 EQ SAM **

						if((sql_stck_plg_val + MIN(d_net_fno_limit,sql_fab_plg_amt) + sql_fab_nwb_amt + d_eq_sam_limit ) < sql_stck_net_plg_val) *** Ver1.5 EQ SAM also need to consider eq sam limit + neagtive cash limit ***** d_net_fno_limit added for st_gt_lmt.d_amt **
						{
							**fn_userlog(c_ServiceName,"The value in plg [%lf] and request for withdrwal is [%lf]",(sql_stck_plg_val + st_gt_lmt.d_amt) , sql_stck_net_plg_val);*** Ver 1.7*
							fn_userlog(c_ServiceName,"The value in plg [%lf] and request for withdrwal is [%lf]",(sql_stck_plg_val + MIN(d_net_fno_limit,sql_fab_plg_amt) + sql_fab_nwb_amt + d_eq_sam_limit) , sql_stck_net_plg_val); ** Ver 1.7*
							fn_userlog(c_ServiceName,"Cannot withdraw this quantity as the limit has been used.");
							**strcpy(c_err_msg,"Cannot withdraw this quantity as the imit has been used."); Ver 1.5**
							strcpy(c_err_msg,"Please try again as your withdrawal request is more than the free securities limit available."); *Ver 1.5*
							Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
							Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}
*******************Comment ends Ver 2.3 ************************/							
					}
/*In case of addition of pledge only we need to check concentration*/
					else
					{

						EXEC SQL 
						SELECT (/** SUM(nvl(DBD_PLG_REQ_QTY,0))+ **/ SUM(nvl(DBD_SAM_BLCKD_QTY,0)) /** ver 2.1 **/
						+ SUM(nvl(DBD_BLOCK_FOR_SALE,0)))
						INTO :sql_tot_pod_ordr_qty
						FROM DBD_DP_BLCK_DTLS
						WHERE DBD_STCK_CD = :sql_stk_stck_cd;
					
						if(SQLCODE !=0) 
						{
							fn_errlog( c_ServiceName, "S31110", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}
/* The dbd_plg_req_qty for the client is reduced below as the old request is effectively
cancelled and the new pledge request qunatity is sql_qty_plg*/

						if(sql_stk_plg_conc < (sql_tot_pod_ordr_qty + sql_qty_plg ))	
						{
							fn_userlog( c_ServiceName, "Pledge concentration for this stock has been exceeded." );
							/**strcpy(c_err_msg,"Pledge concentration for this stock has been exceeded."); **Ver 1.5*/
							strcpy(c_err_msg,"Please enter quantity less than the maximum acceptable quantity."); /**Ver 1.5*/
							Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
							Fadd32( ptr_fml_Ibuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ) ;	
						}
		/*As required by product team during testing, global concetration check
 is done after client level cocentration check*/

						if(sql_stk_plg_clnt_conc < ((sql_qty_plg + sql_dbd_sam_blckd_qty + sql_dbd_block_for_sale) ))
						{
							fn_userlog( c_ServiceName, "Pledge concentration for this stock for you has been exceeded. Please reduce the pledged quantity" );
							fn_userlog(c_ServiceName,"The Pledge clnt concentation is [%ld], the quantity pledged is [%ld]",sql_stk_plg_clnt_conc, ((sql_qty_plg + sql_dbd_sam_blckd_qty + sql_dbd_block_for_sale) ));
							strcpy(c_err_msg,"Pledge concentration for this stock for you has been exceeded. Please reduce the pledged quantity");
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
							Fadd32( ptr_fml_Ibuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
							Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ) ;
						}

					}/*end of else of addition*/
					
					if ( sql_stck_plg_val <= (sql_ppp_min_dep_amt*100))
					{
						fn_userlog(c_ServiceName,"The value pledge is [%lf] and minimum reqd is [%ld]",sql_stck_plg_val,sql_ppp_min_dep_amt);
						sprintf(c_err_msg,"The new pledged value is less than the minimum pledge amount of %ld",sql_ppp_min_dep_amt);
						Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );	** Ver 1.1 : Commented  ***/
						Fadd32( ptr_fml_Ibuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ) ;
				 	}

					EXEC SQL 
					SELECT PRS_PLG_REV_SEQ.nextval 
					INTO :sql_prs_seq
					FROM DUAL;

					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31115", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
						
					i_trnsctn = fn_begintran( c_ServiceName, c_err_msg );
					if ( i_trnsctn == -1 )
					{
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
						fn_errlog( c_ServiceName, "S31120",LIBMSG,c_err_msg);
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

/*** Uncommented in Ver 2.3 Starts Commented for Ver 2.1 ****/
						EXEC SQL 
						UPDATE POD_PLG_ORDR_DTLS SET
						POD_ORDR_QTY = :sql_qty_plg,
						POD_HAIRCUT = :sql_stk_plg_haircut,
						POD_ORDR_VL = :sql_stck_plg_val,
						POD_RMRKS = :sql_pml_rmrks
						WHERE POD_CLNT_MTCH_ACCNT = :sql_mtch_accnt
						AND POD_DP_ACCNT = :sql_dbd_dp_id
						AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
						AND POD_PLG_REV_TYP = 'P'
						AND POD_ORDR_STTS = 'R'
						AND POD_STCK_CD = :sql_stk_stck_cd
            AND POD_ORDR_NO = :sql_pod_ordr_no; /** Ver 2.3 **/
						/** RETURNING POD_ORDR_NO 
						INTO :sql_pod_ordr_no; ** Ver 2.3 **/
							
						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31125", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );	** Ver 1.1 : Commented  ***/
							tpfree ( ( char * )ptr_fml_Obuf);
							fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}
		/***** Ver 2.1 *******/
						
/*** Commented for Ver 2.1 ****/
						/** SETNULL(sql_pod_ordr_no); ** Ver 2.3 **/

						EXEC SQL 
						SELECT (COUNT(*)+1) 
						INTO :sql_pml_mod_cntr 
						FROM PML_PLG_MOD_LOG
						WHERE PML_ORDR_NO = :sql_pod_ordr_no
						AND PML_MOD_TYPE IN ('N','M','C','J');
			
						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31130", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
							tpfree ( ( char * )ptr_fml_Obuf);
							fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}

						if(DEBUG_MSG_LVL_0)
						{
							fn_userlog(c_ServiceName,"The mod counter is [%ld]",sql_pml_mod_cntr);
						}
		/** Uncommented in ver 2.3 Ends ****** Ver 2.1 *******/
					
						EXEC SQL 
						UPDATE DBD_DP_BLCK_DTLS SET
						/** DBD_TOT_QTY = (DBD_TOT_QTY) - :sql_qty_plg 	*** Ver 2.1 ** Commented in Ver 2.3 **/
						DBD_TOT_QTY = (DBD_TOT_QTY + :sql_dbd_plg_req_qty) - :sql_qty_plg,
				 		DBD_PLG_REQ_QTY = :sql_qty_plg /*** Ver 2.1 *** Uncommented in Ver 2.3 **/
						WHERE DBD_STCK_CD = :sql_stk_stck_cd
						AND DBD_CLM_MTCH_ACCNT = :sql_mtch_accnt
						AND DBD_DP_ID = :sql_dbd_dp_id
						AND DBD_DP_CLNT_ID = :sql_dbd_dp_clnt_id;
						
						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31135", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
							tpfree ( ( char * )ptr_fml_Obuf);
							fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}

						/*************** Ver 1.5 EQ SAM commented ************************************************
						MEMSET(sql_fab_bnk_accnt);

						EXEC SQL 
						UPDATE FAB_FO_ALC_BFT_SMRY SET
						FAB_PLG_AMT = FAB_PLG_AMT - :sql_stck_net_plg_val	+ :sql_stck_plg_val
						WHERE FAB_CLM_MTCH_ACCNT = :sql_mtch_accnt
						RETURNING FAB_BNK_ACCNT,FAB_ALCTD_AMT,FAB_BFT_AMT
						INTO :sql_fab_bnk_accnt,:sql_fab_alctd_amt,:sql_fab_bft_amt;

						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31140", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***
							tpfree ( ( char * )ptr_fml_Obuf);
							fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}
							
						SETNULL(sql_fab_bnk_accnt);

						EXEC SQL INSERT INTO FAL_FO_ALCBFT_LOG
						(FAL_CLM_MTCH_ACCNT,
						FAL_BNK_ACCNT,
						FAL_ALCTD_AMT,
						FAL_BFT_AMT,
						FAL_TRN_DT,
						FAL_OLD_PLG_AMT,
						FAL_PLG_CHG_AMT,
						FAL_NARRATION)
						VALUES
						(:sql_mtch_accnt,
						:sql_fab_bnk_accnt,
						:sql_fab_alctd_amt,
						:sql_fab_bft_amt,
						sysdate,
						:sql_fab_plg_amt,
						(:sql_stck_plg_val - :sql_stck_net_plg_val),
						'Pledge Modification');

						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31145", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***
							tpfree ( ( char * )ptr_fml_Obuf);
							fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}
						****************** Ver 1.5 comment ends *****************************************/

						/******* Ver 1.5 EQ SAM Starts ****************************/

						strcpy(c_narration , "Pledge Modification");

           /***** Comment Starts Ver 2.4 *****

						if(sql_stck_plg_val - sql_stck_net_plg_val  < 0) *lower value modification. sam limit to be reduced*
						{
							i_returncode = fn_reduce_sam_limit ( c_ServiceName,
																									sql_mtch_accnt.arr,
																									(sql_stck_net_plg_val - sql_stck_plg_val) ,
																									c_narration,
																									c_err_msg);	
							if(i_returncode == -1)
							{
								fn_errlog( c_ServiceName, "S31150", SQLMSG, c_err_msg  );
              	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              	tpfree ( ( char * )ptr_fml_Obuf);
              	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
              	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
							}

						}
						else
						{
							
							EXEC SQL 
								UPDATE FAB_FO_ALC_BFT_SMRY 
								SET FAB_NWB_AMT = nvl(FAB_NWB_AMT,0) + (:sql_stck_plg_val - :sql_stck_net_plg_val)
          			WHERE FAB_CLM_MTCH_ACCNT = :sql_mtch_accnt
          			RETURNING FAB_BNK_ACCNT,FAB_ALCTD_AMT,FAB_BFT_AMT
          			INTO :sql_fab_bnk_accnt,:sql_fab_alctd_amt,:sql_fab_bft_amt;
		
          		if (SQLCODE != 0)
          		{
            		fn_errlog( c_ServiceName, "S31155", SQLMSG, c_err_msg  );
            		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
            		tpfree ( ( char * )ptr_fml_Obuf);
            		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
            		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          		}
		
          		SETNULL(sql_fab_bnk_accnt);
		
          		EXEC SQL 
								INSERT INTO FAL_FO_ALCBFT_LOG
          				(FAL_CLM_MTCH_ACCNT,
          				FAL_BNK_ACCNT,
          				FAL_ALCTD_AMT,
          				FAL_BFT_AMT,
          				FAL_TRN_DT,
          				FAL_OLD_PLG_AMT,
          				FAL_NARRATION,
          				FAL_NWB_AMT,
          				FAL_NWB_CHG_AMT)
          				VALUES
          				(:sql_mtch_accnt,
          				:sql_fab_bnk_accnt,
          				:sql_fab_alctd_amt,
          				:sql_fab_bft_amt,
          				sysdate,
          				:sql_fab_plg_amt,
          				'Pledge Modification',
          				:sql_fab_nwb_amt,
          				:sql_stck_plg_val - :sql_stck_net_plg_val);
				
          			if (SQLCODE != 0)
          			{
            			fn_errlog( c_ServiceName, "S31160", SQLMSG, c_err_msg  );
            			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
            			tpfree ( ( char * )ptr_fml_Obuf);
            			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
            			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          			}


            }

            ***** Comment Ends Ver 2.4 *****/
						/************ Ver 1.5 ends *******************************/

  /******** Uncomment Started for Ver 2.3 **************/
	/******** Commented for Ver 2.1 ***/
						if(DEBUG_MSG_LVL_0)
						{
						fn_userlog(c_ServiceName,"The PML_ORDR_NO is [%s]",sql_pod_ordr_no.arr);
						fn_userlog(c_ServiceName,"The PML_STCK_CD is [%s]",sql_stk_stck_cd);
						fn_userlog(c_ServiceName,"The PML_ORDR_QTY is [%ld]",sql_qty_plg);
						fn_userlog(c_ServiceName,"The PML_NET_ORDR_QTY is [%ld]",sql_net_qty_plg);
						fn_userlog(c_ServiceName,"The PML_HAIRCUT is [%ld]",sql_stk_plg_haircut);
						fn_userlog(c_ServiceName,"The PML_ORDR_VL is [%lf]",sql_stck_plg_val);
						fn_userlog(c_ServiceName,"The PML_ISIN_NO is [%s]",sql_dbd_isin_nmbr);
						fn_userlog(c_ServiceName,"The PML_DP_CLNT_ACCNT is [%s]",sql_dbd_dp_clnt_id);
						fn_userlog(c_ServiceName,"The PML_DP_ACCNT is [%s]",sql_dbd_dp_id);
						fn_userlog(c_ServiceName,"The PML_CLNT_MTCH_ACCNT is [%s]",sql_mtch_accnt.arr);
						fn_userlog(c_ServiceName,"The PML_MOD_TYPE is [%c]",sql_pml_mod_type);
						fn_userlog(c_ServiceName,"The PML_MOD_CNTR is [%ld]",sql_pml_mod_cntr);
						fn_userlog(c_ServiceName,"The PML_PLCD_SQNC is [%ld]",sql_prs_seq);
						fn_userlog(c_ServiceName,"The PML_CHANNEL is [%s]",sql_pml_channel.arr);
						}	
						EXEC SQL INSERT INTO PML_PLG_MOD_LOG
						(PML_ORDR_NO,
						PML_STCK_CD,
						PML_ORDR_QTY,
						PML_ORDR_TM,
						PML_HAIRCUT,
						PML_ORDR_VL,
						PML_ISIN_NO,
						PML_DP_CLNT_ACCNT,
						PML_DP_ACCNT,
						PML_CLNT_MTCH_ACCNT,
						PML_PLG_REV_TYP,
						PML_MOD_TYPE,
						PML_STTS,
						PML_MOD_CNTR,
						PML_PLCD_SQNC,
						PML_BP_ID,
						PML_CHANNEL,
						PML_RMRKS)
						VALUES
						(:sql_pod_ordr_no,
						:sql_stk_stck_cd,
						:sql_qty_plg,
						sysdate,
						:sql_stk_plg_haircut,
						:sql_stck_plg_val,
						:sql_dbd_isin_nmbr,
						:sql_dbd_dp_clnt_id,
						:sql_dbd_dp_id,
						:sql_mtch_accnt,
						'P',
						:sql_pml_mod_type,
						'R',
						:sql_pml_mod_cntr,
						:sql_prs_seq,	
						:sql_sbd_bp_id,
						:sql_pml_channel,
						:sql_pml_rmrks);
							
						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31165", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );	** Ver 1.1 : Commented  ***/
							tpfree ( ( char * )ptr_fml_Obuf);
							fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}
				/******* Ver 2.1 *** Uncomment End for Ver 2.3 ****/

						EXEC SQL 
						INSERT INTO DLD_DP_LOG_DTLS
						(DLD_CLM_MTCH_ACCNT,
						DLD_DP_ID,
						DLD_DP_CLNT_ID,
						DLD_ISIN_NMBR,
						DLD_STCK_CD,
						DLD_TOT_QTY_CHG,
						DLD_QTY_BLCKD_CHG,
            /** Uncomment Start Ver 2.3 **/
						DLD_PLG_REQ_QTY_CHG,
						/** DLD_TIFP_QTY_CHG, ** Ver 2.1 **/ 
						DLD_REV_COV_QTY_CHG,
						DLD_REV_REQ_QTY_CHG, 
						DLD_SAM_BLCKD_QTY_CHG, 	/*** Ver 2.1 ** Uncomment Ends Ver 2.3 **/
						DLD_CHG_TM,
						DLD_BLK_FR_SALE_CHG,
						DLD_INV_REQ_QTY_CHG,
						DLD_INV_COV_QTY_CHG,  /*** Ver 2.1 ** Uncomment in ver 2.3 **/
						DLD_RMRKS)
						VALUES
						(:sql_mtch_accnt,
						:sql_dbd_dp_id,
						:sql_dbd_dp_clnt_id,
						:sql_dbd_isin_nmbr,
						:sql_stk_stck_cd,
						(:sql_dbd_tot_qty  + :sql_dbd_plg_req_qty ) - :sql_qty_plg, /** sql_dbd_plg_req_qty uncomment in ver 2.3 **//** Ver 2.1 **/
						:sql_dbd_qty_blckd,
            /** Uncomment Start Ver 2.3 **/
					  (:sql_qty_plg - :sql_dbd_plg_req_qty),
						/** :sql_dbd_tifp_qty, ** Ver 2.1 **/
						:sql_dbd_rev_cov_qty,
						:sql_dbd_rev_req_qty, /** Ver 2.1 *** Uncomment Ends Ver 2.3 **/
						:sql_dbd_sam_blckd_qty,	/** Ver 2.1 **/
						sysdate,
						:sql_dbd_block_for_sale,
						:sql_dbd_inv_req_qty,
						:sql_dbd_inv_cov_qty,	/*** Ver 2.1 *** Uncomment in ver 2.3 **/
						'Pledge Modification');

						if(DEBUG_MSG_LVL_0)
						{
							fn_userlog(c_ServiceName,"After DLD Insert [%s]",sql_pml_rmrks.arr);
						}

						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31170", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
							tpfree ( ( char * )ptr_fml_Obuf);
							fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}

						if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg ) == -1 )
						{
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 ); 
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
							tpfree ( ( char * )ptr_fml_Obuf);
							fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
							tpreturn ( TPFAIL, ERR_BFR, ( char * )ptr_fml_Ibuf, 0, 0 );
						}
						
						strcpy(c_err_msg,"Success");
/**					l_acnt_id = 0;		** Ver 1.1 : Commented  ***/
						i_err[0] = Fadd32(ptr_fml_Obuf,FFO_PLG_ORDR_RFRNC,(char *)sql_sbd_ordr_no.arr,0);
						i_err[1] = Fadd32(ptr_fml_Obuf,FFO_HAIRCUT ,(char *)&sql_stk_plg_haircut,0);
						i_err[2] = Fadd32(ptr_fml_Obuf,FFO_PLG_ORD_VAL,(char *)&sql_stck_plg_val,0);
/**					i_err[3] = Fadd32(ptr_fml_Obuf,FFO_ACTN_ID,(char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						i_err[3] = Fadd32(ptr_fml_Obuf,FFO_STCK_CD,(char *)sql_stk_stck_cd, 0 ); 
						i_err[4] = Fadd32(ptr_fml_Obuf,FFO_ERR_MSG,c_err_msg, 0 ); 
						
						for (i=0; i < 5; i++)
						{
							if(i_err[i] == -1)
							{
								fn_errlog( c_ServiceName, "S31175", FMLMSG, c_err_msg  );
								fn_userlog(c_ServiceName, "The Fget32 error at [%d]",i);
/**							l_acnt_id = -1;
								Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
								Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
								tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
							}
						}

						tpreturn( TPSUCCESS, 0, (char *)ptr_fml_Obuf, 0, 0 );		
						
						break; /* Break from Case for Pledge Modify*/

				} /*** End of pledge modify ***/

				case 'C' :
				{
						/* if(sql_dbd_plg_req_qty < sql_qty_plg) */
						if(0 < (sql_sbd_bkubk_qty-sql_qty_plg) ) /** sql_sbd_bkubk_qty ** added in Ver 2.3 **/

						{
							fn_userlog(c_ServiceName,"The plg req qty is [%ld] and request for cancel is [%ld]",sql_dbd_plg_req_qty, sql_qty_plg);
							fn_userlog(c_ServiceName,"Cannot withdraw this quantity as pledge pending request is [%ld].",sql_dbd_plg_req_qty);
							strcpy(c_err_msg,"Cannot withdraw this quantity as pledge request quantity is less.");
							Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
							Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}
						
						/*The following variable will be used to hold the value of the stock pledge*/	

						sql_stck_plg_val = (sql_qty_plg * (sql_ltq_plg_rt *(1 - ((double)(sql_stk_plg_haircut)/100))))*100; /** diwa typecast float to double **/

						if((long long)(sql_stck_plg_val * 100)%100 > 50)
						{
							sql_stck_plg_val = sql_stck_plg_val + 1.0;

							if(DEBUG_MSG_LVL_0)
							{
								fn_userlog( c_ServiceName, "The rounded off amount is [%lf]",sql_stck_plg_val);
							}
						}
					
						ll_stck_plg_val = (long long) sql_stck_plg_val;
			
						sql_stck_plg_val = (double) ll_stck_plg_val;

						if(DEBUG_MSG_LVL_0)
						{
							fn_userlog(c_ServiceName,"The plg val is [%lf] for rate [%lf]",sql_stck_plg_val,sql_ltq_plg_rt);
						}

						/*****The following portion gets the Limits avaliable for the user before cancel***/

/*********** Comment starts Ver 2.3 ********************************
						memset(&st_gt_lmt,'\0' , sizeof( struct vw_gt_lmt_dtls) );
						strcpy(st_gt_lmt.c_xchng_cd , "NFO" );

						MEMSET(sql_nxt_trd_dt);

						EXEC SQL 
						SELECT EXG_NXT_TRD_DT 
						INTO :sql_nxt_trd_dt 
						FROM EXG_XCHNG_MSTR
						WHERE EXG_XCHNG_CD = 'NFO';

						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31180", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}

						SETNULL(sql_nxt_trd_dt);

						strcpy(st_gt_lmt.c_trd_dt, sql_nxt_trd_dt.arr );
						strcpy(st_gt_lmt.c_cln_mtch_accnt, sql_mtch_accnt.arr);
						l_ip_len = (long) sizeof ( struct vw_gt_lmt_dtls);
						st_gt_lmt.c_rqst_typ = LIMIT_X;
						fn_cpy_ddr ( st_gt_lmt.c_rout_crt );
           *** Commented in Ver 2.0 *****************
						i_returncode = fn_call_svc( c_ServiceName, c_err_msg, &st_gt_lmt, &st_gt_lmt,
																			"vw_gt_lmt_dtls", "vw_gt_lmt_dtls", l_ip_len,
																			l_ip_len, 0, "SFO_GET_LIMITS" );

						if ( i_returncode == -1 )
						{
							fn_errlog( c_ServiceName, "S31185", LIBMSG, c_err_msg );
							fn_userlog(c_ServiceName,"SFO_GET_LIMITS FAIL  ");
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
							Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}
            ************ Ver 2.0 **********************

            **** Ver 2.0 Starts Here ********
              i_returncode = fo_get_trd_limit(c_ServiceName,
                                    st_gt_lmt.c_cln_mtch_accnt,
                                    st_gt_lmt.c_trd_dt,
                                    st_gt_lmt.c_rqst_typ,
                                    st_gt_lmt.c_xchng_cd,
                                    st_gt_lmt.l_gid,
                                    &st_gt_lmt.d_amt,
                                    c_err_msg
                                    );
              if ( i_returncode == -1 )
              {
                fn_errlog( c_ServiceName, "S31190", LIBMSG, c_err_msg );
                fn_userlog(c_ServiceName,"fo_get_trd_limit FAIL  ");
                Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
                Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
                tpfree ( ( char * )ptr_fml_Obuf);
                tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
              }
              **** Ver 2.0 Ends Here **********
              *****Ver 1.7 Get BFO limit. The net FNO limit will be minimum of NSE and BSE limit ***

              d_nfo_limit = st_gt_lmt.d_amt;

              memset(&st_gt_lmt,'\0' , sizeof( struct vw_gt_lmt_dtls) );
              strcpy(st_gt_lmt.c_xchng_cd , "BFO" );

              MEMSET(sql_nxt_trd_dt);

              EXEC SQL
              SELECT EXG_NXT_TRD_DT
              INTO :sql_nxt_trd_dt
              FROM EXG_XCHNG_MSTR
              WHERE EXG_XCHNG_CD = 'BFO';

              if (SQLCODE != 0)
              {
                fn_errlog( c_ServiceName, "S31195", SQLMSG, c_err_msg  );
                Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
                tpfree ( ( char * )ptr_fml_Obuf);
                tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
              }

              SETNULL(sql_nxt_trd_dt);

              strcpy(st_gt_lmt.c_trd_dt, sql_nxt_trd_dt.arr );
              strcpy(st_gt_lmt.c_cln_mtch_accnt, sql_mtch_accnt.arr);
              l_ip_len = (long) sizeof ( struct vw_gt_lmt_dtls);
              st_gt_lmt.c_rqst_typ = LIMIT_X;
              fn_cpy_ddr ( st_gt_lmt.c_rout_crt );
              *********** Commented in Ver 2.0 ****************
              i_returncode = fn_call_svc( c_ServiceName, c_err_msg, &st_gt_lmt, &st_gt_lmt,
                                        "vw_gt_lmt_dtls", "vw_gt_lmt_dtls", l_ip_len,
                                        l_ip_len, 0, "SFO_GET_LIMITS" );

              if ( i_returncode == -1 )
              {
                fn_errlog( c_ServiceName, "S31200", LIBMSG, c_err_msg );
                fn_userlog(c_ServiceName,"SFO_GET_LIMITS FAIL  ");
                Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
                Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
                tpfree ( ( char * )ptr_fml_Obuf);
                tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
              }
              *********** Ver 2.0 ******************************
              **** Ver 2.0 Starts Here ********
              i_returncode = fo_get_trd_limit(c_ServiceName,
                                    st_gt_lmt.c_cln_mtch_accnt,
                                    st_gt_lmt.c_trd_dt,
                                    st_gt_lmt.c_rqst_typ,
                                    st_gt_lmt.c_xchng_cd,
                                    st_gt_lmt.l_gid,
                                    &st_gt_lmt.d_amt,
                                    c_err_msg
                                    );
              if ( i_returncode == -1 )
              {
                fn_errlog( c_ServiceName, "S31205", LIBMSG, c_err_msg );
                fn_userlog(c_ServiceName,"fo_get_trd_limit FAIL  ");
                Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
                Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
                tpfree ( ( char * )ptr_fml_Obuf);
                tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
              } 
              **** Ver 2.0 Ends Here **********
  
              d_bfo_limit = st_gt_lmt.d_amt;

              d_net_fno_limit =  MIN(d_nfo_limit,d_bfo_limit);

              if(DEBUG_MSG_LVL_0){
                fn_userlog( c_ServiceName,"NFO Limit Calculated :%lf:",d_nfo_limit);
                fn_userlog( c_ServiceName,"BFO Limit Calculated :%lf:",d_bfo_limit);
                fn_userlog( c_ServiceName,"Net FNO limit        :%lf:",d_net_fno_limit);
              }
              ****   Ver 1.7 ends **************


						****** Get the Equity SAM limit and negative cash limit ***************

						i_returncode = fn_get_eqsam_limit (	c_ServiceName,
																				       	sql_mtch_accnt.arr,
                        												&d_eq_sam_limit,
																								sql_usr_id.arr,
																								sql_sssn_id,
                        												c_err_msg
																							);

						if(i_returncode == -1)
						{
								fn_errlog( c_ServiceName, "S31210", LIBMSG, c_err_msg );
								Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
								tpfree ( ( char * )ptr_fml_Obuf);
								tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}

						if(DEBUG_MSG_LVL_0)
						{
							**fn_userlog( c_ServiceName,"Limit Calculated :%lf:",st_gt_lmt.d_amt); ** Ver 1.7 *
							fn_userlog( c_ServiceName,"EQ SAM limit			:%lf:",d_eq_sam_limit);
						}

				************** check limit is allowed for Pledge cancel *************************

					**if(sql_stck_plg_val > st_gt_lmt.d_amt) ** Ve 1.5 EQ SAM ****
					if(sql_stck_plg_val > (MIN(d_net_fno_limit,sql_fab_plg_amt) + sql_fab_nwb_amt + d_eq_sam_limit)) ** Ve 1.5 EQ SAM also need to consider eq sam limit + negative cash **** ** d_net_fno_limit added for st_gt_lmt.d_amt **
					{
						*fn_userlog(c_ServiceName,"The value in plg [%lf] and request for withdrwal is [%lf]",sql_stck_plg_val, st_gt_lmt.d_amt);** Ver 1.7*
						fn_userlog(c_ServiceName,"The value in plg [%lf] and request for withdrwal is [%lf]",sql_stck_plg_val, MIN(d_net_fno_limit,sql_fab_plg_amt) + sql_fab_nwb_amt + d_eq_sam_limit); ** Ver 1.7*
						fn_userlog(c_ServiceName,"Cannot withdraw this quantity as the limit has been used.");
						**strcpy(c_err_msg,"Cannot withdraw this quantity as the limit has been used."); Ver 1.5**
						strcpy(c_err_msg,"Please try again as your withdrawal request is more than the free securities limit available."); *Ver 1.5*
						Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
						Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
						tpfree ( ( char * )ptr_fml_Obuf);
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

**************** Comment Ends Ver 2.3 *******************************/

						i_trnsctn = fn_begintran( c_ServiceName, c_err_msg );
						if ( i_trnsctn == -1 )
						{
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
							fn_errlog( c_ServiceName, "S31215",LIBMSG,c_err_msg);
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}


						sql_pml_mod_type ='C';
						MEMSET(sql_pml_rmrks);
						strcpy(sql_pml_rmrks.arr,"User modified : Cancelled");
						SETLEN(sql_pml_rmrks);
			
						EXEC SQL 
						SELECT PRS_PLG_REV_SEQ.nextval 
						INTO :sql_prs_seq
						FROM DUAL;

						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31220", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}

				/*** Commented for Ver 2.1 ********** Uncommented in Ver 2.3 ***/	
						EXEC SQL 
						UPDATE POD_PLG_ORDR_DTLS SET
						POD_ORDR_STTS = 'X',    /*** replaced 'C' with 'X' in Ver 2.3 ***/
						POD_RMRKS = :sql_pml_rmrks
						WHERE POD_CLNT_MTCH_ACCNT = :sql_mtch_accnt
						AND POD_DP_ACCNT = :sql_dbd_dp_id
						AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
						AND POD_PLG_REV_TYP = 'P'
						AND POD_ORDR_STTS = 'R'
						AND POD_STCK_CD = :sql_stk_stck_cd
            AND POD_ORDR_NO = :sql_pod_ordr_no; /** Ver 2.3 **/ 
						/** RETURNING POD_ORDR_NO 
						INTO :sql_pod_ordr_no; Commented in ver 2.3 **/

						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31225", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}

         /** Ver 2.4 Starts **/

            EXEC SQL
            UPDATE PTD_TIFP_DTLS
            SET    PTD_TIFP_STTS ='X'
            WHERE  PTD_CLM_MTCH_ACCNT = :sql_mtch_accnt
            AND    PTD_DP_ID          = :sql_dbd_dp_id
            AND    PTD_DP_CLNT_ID     = :sql_dbd_dp_clnt_id
            AND    PTD_PLG_REV_TYP    = 'P'
            AND    PTD_TIFP_STTS      = 'N'
            AND    PTD_POD_REF_NO     = :sql_pod_ordr_no
            AND    trim(PTD_STCK_CD)  = trim(:sql_stk_stck_cd); 

            if (SQLCODE != 0 && SQLCODE!= NO_DATA_FOUND)
            {
              fn_errlog( c_ServiceName, "S31230", SQLMSG, c_err_msg  );
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              tpfree ( ( char * )ptr_fml_Obuf);
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }

         /** Ver 2.4 Ends **/
 
						/** SETNULL(sql_pod_ordr_no); *8 Ver 2.3 **/

						EXEC SQL 
						SELECT (COUNT(*)+1) 
						INTO :sql_pml_mod_cntr 
						FROM PML_PLG_MOD_LOG
						WHERE PML_ORDR_NO = :sql_pod_ordr_no
						AND PML_CLNT_MTCH_ACCNT = :sql_mtch_accnt
						AND PML_DP_ACCNT = :sql_dbd_dp_id
						AND PML_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
						AND PML_PLG_REV_TYP = 'P'
						AND PML_MOD_TYPE IN ('N','M','C','J');
			
						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31235", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}

						if(DEBUG_MSG_LVL_0)
						{
							fn_userlog(c_ServiceName,"The mod counter is [%ld]",sql_pml_mod_cntr);
						}	

			/********* Ver 2.1 ******* Uncommet End for Ver 2.3 ****/

						EXEC SQL 
						UPDATE DBD_DP_BLCK_DTLS SET
						DBD_TOT_QTY = DBD_TOT_QTY + :sql_qty_plg,
						DBD_PLG_REQ_QTY = DBD_PLG_REQ_QTY - :sql_qty_plg /*** Ver 2.1 *** Uncommented in Ver 2.3 **/
						WHERE DBD_STCK_CD = :sql_stk_stck_cd
						AND DBD_CLM_MTCH_ACCNT = :sql_mtch_accnt
						AND DBD_DP_ID = :sql_dbd_dp_id
						AND DBD_DP_CLNT_ID = :sql_dbd_dp_clnt_id;
						
						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31240", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}

						/*********** Ver 1.5 EQ SAM commented ********************************
						MEMSET(sql_fab_bnk_accnt);

						EXEC SQL 
						UPDATE FAB_FO_ALC_BFT_SMRY SET
						FAB_PLG_AMT = FAB_PLG_AMT - :sql_stck_plg_val	
						WHERE FAB_CLM_MTCH_ACCNT = :sql_mtch_accnt
						RETURNING FAB_BNK_ACCNT,FAB_ALCTD_AMT,FAB_BFT_AMT
						INTO :sql_fab_bnk_accnt,:sql_fab_alctd_amt,:sql_fab_bft_amt;

						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31245", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );	** Ver 1.1 : Commented  ***
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}
							
						SETNULL(sql_fab_bnk_accnt);

						EXEC SQL 
						INSERT INTO FAL_FO_ALCBFT_LOG
						(FAL_CLM_MTCH_ACCNT,
						FAL_BNK_ACCNT,
						FAL_ALCTD_AMT,
						FAL_BFT_AMT,
						FAL_TRN_DT,
						FAL_OLD_PLG_AMT,
						FAL_PLG_CHG_AMT,
						FAL_NARRATION)
						VALUES
						(:sql_mtch_accnt,
						:sql_fab_bnk_accnt,
						:sql_fab_alctd_amt,
						:sql_fab_bft_amt,
						sysdate,
						:sql_fab_plg_amt,
						-(:sql_stck_plg_val),
						'Pledge Cancelled');

						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31250", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}
						************************** Ver 1.5 comment ends ***********************/

						/********* Ver 1.5 EQ SAM Starts *****************/

            /***** Comment Starts Ver 2.5 *****

						strcpy(c_narration,"Pledge Cancelled");

						i_returncode = fn_reduce_sam_limit ( c_ServiceName,
                                                  sql_mtch_accnt.arr,
                                                  sql_stck_plg_val ,
                                                  c_narration,
                                                  c_err_msg);
            if(i_returncode == -1)
            {
              fn_errlog( c_ServiceName, "S31255", SQLMSG, c_err_msg  );
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              tpfree ( ( char * )ptr_fml_Obuf);
              fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }

            ***** Comment Ends Ver 2.5 *****/
        
						/******** Ver 1.5 ends ****************************/


				/******** Commented for Ver 2.1 ******* Uncomment Start for Ver 2.3 ***/
						if(DEBUG_MSG_LVL_0)
						{
							fn_userlog(c_ServiceName,"The PML_ORDR_NO is [%s]",sql_pod_ordr_no.arr);
							fn_userlog(c_ServiceName,"The PML_STCK_CD is [%s]",sql_stk_stck_cd);
							fn_userlog(c_ServiceName,"The PML_ORDR_QTY is [%ld]",sql_qty_plg);
							fn_userlog(c_ServiceName,"The PML_HAIRCUT is [%ld]",sql_stk_plg_haircut);
							fn_userlog(c_ServiceName,"The PML_ORDR_VL is [%ld]",sql_stck_plg_val);
							fn_userlog(c_ServiceName,"The PML_ISIN_NO is [%s]",sql_dbd_isin_nmbr);
							fn_userlog(c_ServiceName,"The PML_DP_CLNT_ACCNT is [%s]",sql_dbd_dp_clnt_id);
							fn_userlog(c_ServiceName,"The PML_DP_ACCNT is [%s]",sql_dbd_dp_id);
							fn_userlog(c_ServiceName,"The PML_CLNT_MTCH_ACCNT is [%s]",sql_mtch_accnt.arr);
							fn_userlog(c_ServiceName,"The PML_MOD_TYPE is [%c]",sql_pml_mod_type);
							fn_userlog(c_ServiceName,"The PML_MOD_CNTR is [%ld]",sql_pml_mod_cntr);
							fn_userlog(c_ServiceName,"The PML_PLCD_SQNC is [%ld]",sql_prs_seq);
							fn_userlog(c_ServiceName,"The PML_CHANNEL is [%s]",sql_pml_channel.arr);
						}

						EXEC SQL 
						INSERT INTO PML_PLG_MOD_LOG
						(PML_ORDR_NO,
						PML_STCK_CD,
						PML_ORDR_QTY,
						PML_ORDR_TM,
						PML_HAIRCUT,
						PML_ORDR_VL,
						PML_ISIN_NO,
						PML_DP_CLNT_ACCNT,
						PML_DP_ACCNT,
						PML_CLNT_MTCH_ACCNT,
						PML_PLG_REV_TYP,
						PML_MOD_TYPE,
						PML_STTS,
						PML_MOD_CNTR,
						PML_PLCD_SQNC,
						PML_BP_ID,
						PML_CHANNEL,
						PML_RMRKS)
						VALUES
						(:sql_pod_ordr_no,
						:sql_stk_stck_cd,
						:sql_qty_plg,
						sysdate,
						:sql_stk_plg_haircut,
						:sql_stck_plg_val,
						:sql_dbd_isin_nmbr,
						:sql_dbd_dp_clnt_id,
						:sql_dbd_dp_id,
						:sql_mtch_accnt,
						'P',
						:sql_pml_mod_type,
						'C',
						:sql_pml_mod_cntr,
						:sql_prs_seq,	
						:sql_sbd_bp_id,
						:sql_pml_channel,
						:sql_pml_rmrks);
							
						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31260", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}

		/********** Ver 2.1 ******* Uncomment End for ver 2.3 ***/

						EXEC SQL 
						INSERT INTO DLD_DP_LOG_DTLS
						(DLD_CLM_MTCH_ACCNT,
						DLD_DP_ID,
						DLD_DP_CLNT_ID,
						DLD_ISIN_NMBR,
						DLD_STCK_CD,
						DLD_TOT_QTY_CHG,
						DLD_QTY_BLCKD_CHG,
            /** Uncomment Starts for Ver 2.3 **/
				  	DLD_PLG_REQ_QTY_CHG,
						/** DLD_TIFP_QTY_CHG, ** Ver 2.1 **/
						DLD_REV_COV_QTY_CHG,
						DLD_REV_REQ_QTY_CHG, /*** Ver 2.1 ** Uncomment End for Ver 2.3 **/
						DLD_SAM_BLCKD_QTY_CHG,		/*** Ver 2.1 ***/
						DLD_CHG_TM,
						DLD_BLK_FR_SALE_CHG,
				  	DLD_INV_REQ_QTY_CHG,
						DLD_INV_COV_QTY_CHG, /*** Ver 2.1 *** Uncommented in Ver 2.3 **/
						DLD_RMRKS)
						VALUES
						(:sql_mtch_accnt,
						:sql_dbd_dp_id,
						:sql_dbd_dp_clnt_id,
						:sql_dbd_isin_nmbr,
						:sql_stk_stck_cd,
						:sql_dbd_tot_qty,
						:sql_dbd_qty_blckd,
					 	-(:sql_qty_plg),
						/** :sql_dbd_tifp_qty, ** Ver 2.1 **/
						:sql_dbd_rev_cov_qty,
						:sql_dbd_rev_req_qty,  /** Ver 2.1 ***/
						:sql_dbd_sam_blckd_qty, /** Ver 2.1 **/
						sysdate,
						:sql_dbd_block_for_sale,
						:sql_dbd_inv_req_qty,
						:sql_dbd_inv_cov_qty, /*** Ver 2.1 ***/
						'Pledge Cancelled');

						if(DEBUG_MSG_LVL_0)
						{
							fn_userlog(c_ServiceName,"After DLD Insert [%s]",sql_pml_rmrks.arr);
						}

						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31265", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}

						if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg ) == -1 )
						{
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 ); 
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn ( TPFAIL, ERR_BFR, ( char * )ptr_fml_Ibuf, 0, 0 );
						}
						
						strcpy(c_err_msg,"Success");
/**					l_acnt_id = 0;			** Ver 1.1 : Commented  ***/
						i_err[0] = Fadd32(ptr_fml_Obuf,FFO_PLG_ORDR_RFRNC,(char *)sql_sbd_ordr_no.arr,0);
						i_err[1] = Fadd32(ptr_fml_Obuf,FFO_HAIRCUT ,(char *)&sql_stk_plg_haircut,0);
						i_err[2] = Fadd32(ptr_fml_Obuf,FFO_PLG_ORD_VAL,(char *)&sql_stck_plg_val,0);
/**					i_err[3] = Fadd32(ptr_fml_Obuf,FFO_ACTN_ID,(char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						i_err[3] = Fadd32(ptr_fml_Obuf,FFO_STCK_CD,(char *)sql_stk_stck_cd, 0 ); 
						i_err[4] = Fadd32(ptr_fml_Obuf,FFO_ERR_MSG,c_err_msg, 0 ); 
						for (i=0; i < 5; i++)
						{
							if(i_err[i] == -1)
							{
								fn_errlog( c_ServiceName, "S31270", FMLMSG, c_err_msg  );
								fn_userlog(c_ServiceName, "The Fget32 error at [%d]",i);
/**							l_acnt_id = -1;
								Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
								Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
								tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
							}
						}

						tpreturn( TPSUCCESS, 0, (char *)ptr_fml_Obuf, 0, 0 );		
					
						break; /* Break from Case for Pledge Cancel */

				} /***** End of Pledge Cancel ****/

				default:
				{
						strcpy(c_err_msg,"Invalid Operation Type" );
						fn_errlog ( c_ServiceName, "S31275", DEFMSG, c_err_msg);
						tpfree ( ( char * )ptr_fml_Obuf);
						tpreturn ( TPFAIL, ERR_BFR, ( char * )ptr_fml_Ibuf, 0, 0 );

						break;
				}

  		} /*end of operation type (Modify/Cancel) switch for Pledge*/		

			break;
	  } /******* End of Pledge *********/

		case 'W' : /***** Withdraw *****/
		{	
			if (sql_ppp_plg_opncls_flg == 'N')
			{
				/* Commented in ver 1.9 fn_userlog(c_ServiceName, "At present the facility of Shares as Margin has been suspended");
   			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "At present the facility of Shares as Margin has been suspended", 0 );  */
				fn_userlog(c_ServiceName,"Please try depositing later as shares as margin process is underway");  /* Ver 1.9 */
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG,"Please try depositing later as shares as margin process is underway",0); /* Ver 1.9 */
/**			l_acnt_id = -1;
       	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
				tpfree ( ( char * )ptr_fml_Obuf);
    		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );	
			}	

			if ( sql_clm_plg_allwd_flg == 'N')
			{
				fn_userlog(c_ServiceName, "At present the facility of Shares as Margin has been suspended");
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "At present the facility of Shares as Margin has been suspended", 0 );
/**			l_acnt_id = -1;
       	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
				tpfree ( ( char * )ptr_fml_Obuf);
		  	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}

			EXEC SQL 
			SELECT nvl(STK_PLG_ALLWD,'N'),nvl(STK_PLG_CONC,0),nvl(STK_PLG_CLNT_CONC,0),
			/**nvl(STK_PLG_HAIRCUT,0), V1.5**/ nvl(STK_PLG_MIN_DPST,0)   
    	INTO :sql_stk_plg_allwd,:sql_stk_plg_conc,:sql_stk_plg_clnt_conc,
			/**:sql_stk_plg_haircut, **V1.5**/ :sql_stk_plg_min_dpst
			FROM STK_STK_MSTR 
			WHERE STK_STCK_CD = :sql_stk_stck_cd;	
		
			if( SQLCODE !=0 )
			{
				fn_errlog( c_ServiceName, "S31280", SQLMSG, c_err_msg  );
				fn_userlog(c_ServiceName, "For stck code : [%s][%ld]",sql_stk_stck_cd,sizeof(sql_stk_stck_cd));
     		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**			l_acnt_id = -1;
       	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
				tpfree ( ( char * )ptr_fml_Obuf);
     		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}

			/**** Ver 1.5 EQ SAM starts ***/

      i_returncode = fn_get_haircut(c_ServiceName,
                                    sql_mtch_accnt.arr,
                                    sql_stk_stck_cd ,
                                    &sql_stk_plg_haircut ,
                                    c_err_msg);

      if(i_returncode == -1)
      {
        fn_errlog( c_ServiceName, "S31285", "Invalid Haircut value ", c_err_msg  );
        fn_userlog(c_ServiceName, "Invalid Haircut value For stck code : [%s]",sql_stk_stck_cd);
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        tpfree ( ( char * )ptr_fml_Obuf);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
      /**** Ver 1.5 ends ****/

			if((sql_stk_plg_haircut < 0) || (sql_stk_plg_haircut > 100))
			{
				fn_errlog( c_ServiceName, "S31290", "Invalid Haircut value ", c_err_msg  );
				fn_userlog(c_ServiceName, "Invalid Haircut value For stck code : [%s]",sql_stk_stck_cd);
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**			l_acnt_id = -1;
       	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
				tpfree ( ( char * )ptr_fml_Obuf);
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}

			if(DEBUG_MSG_LVL_0)
			{
			fn_userlog(c_ServiceName,"The value is STK_PLG_ALLWD is [%c]",sql_stk_plg_allwd);
			fn_userlog(c_ServiceName,"The value is STK_PLG_CONC  is [%ld]",sql_stk_plg_conc);
			fn_userlog(c_ServiceName,"The value is STK_PLG_CLNT_CONC is [%ld]",sql_stk_plg_clnt_conc);
			fn_userlog(c_ServiceName,"The value is STK_PLG_HAIRCUT is [%ld]",sql_stk_plg_haircut);
			fn_userlog(c_ServiceName,"The value is STK_PLG_MIN_DPST is [%ld]",sql_stk_plg_min_dpst);
			}

			if (sql_stk_plg_allwd == 'N' || sql_stk_plg_allwd == 'R')
			{
				if(sql_stk_plg_allwd == 'N')
				{
					fn_userlog(c_ServiceName, "At present the scrip has been disabled from the facility of Shares as Margin");
					strcpy(c_err_msg,"At present the scrip has been disabled from the facility of Shares as Margin");
					Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
					tpfree ( ( char * )ptr_fml_Obuf);
/**				l_acnt_id = -1;
         	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ) ;
				}
				else
				{
					fn_userlog(c_ServiceName, "Cannot  modify/cancel as the scrip is under revaluation");
					strcpy(c_err_msg,"Cannot  modify/cancel as the scrip is under revaluation");
     			Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
					Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
/**				l_acnt_id = -1;
         	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
					tpfree ( ( char * )ptr_fml_Obuf);
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
			}

				
			EXEC SQL SELECT LTQ_PLG_RT 
			INTO :sql_ltq_plg_rt 
			FROM LTQ_TRD_QT
			WHERE LTQ_STCK_CD = :sql_stk_stck_cd
			AND LTQ_XCHNG_CD = 'BSE'; /* ver 1.4 */
			
			if (SQLCODE != 0)
			{
				fn_errlog( c_ServiceName, "S31295", SQLMSG, c_err_msg  );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**			l_acnt_id = -1;
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			** Ver 1.1 : Commented  ***/
				tpfree ( ( char * )ptr_fml_Obuf);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
			EXEC SQL SELECT nvl(DBD_TOT_QTY,0),
			nvl(DBD_QTY_BLCKD,0),
     /*** 
       nvl(DBD_PLG_REQ_QTY,0),
			nvl(DBD_TIFP_QTY,0),***/
    /*** Uncomment starts ver 2.4 ***/
      nvl(DBD_REV_REQ_QTY,0),
			nvl(DBD_REV_COV_QTY,0),nvl(DBD_INV_REQ_QTY,0),
			nvl(DBD_INV_COV_QTY,0), 
     /****** Commented and added for Ver 2.1 *** Uncomment Ends ver 2.4 ***/ 
			nvl(DBD_SAM_BLCKD_QTY,0),nvl(DBD_BLOCK_FOR_SALE,0),
			DBD_ISIN_NMBR
			INTO :sql_dbd_tot_qty,:sql_dbd_qty_blckd,
     /*** 
      :sql_dbd_plg_req_qty,
			:sql_dbd_tifp_qty, ***/
     /*** Uncomment starts ver 2.4 ***/
      :sql_dbd_rev_req_qty,
      :sql_dbd_rev_cov_qty,
			:sql_dbd_inv_req_qty,
      :sql_dbd_inv_cov_qty,
     /** Commented and added for Ver 2.1 *** Uncomment ends Ver 2.4 ***/
			:sql_dbd_sam_blckd_qty,:sql_dbd_block_for_sale,
			:sql_dbd_isin_nmbr
			FROM DBD_DP_BLCK_DTLS
			WHERE DBD_STCK_CD = :sql_stk_stck_cd
			AND DBD_CLM_MTCH_ACCNT = :sql_mtch_accnt
			AND DBD_DP_ID = :sql_dbd_dp_id
			AND DBD_DP_CLNT_ID = :sql_dbd_dp_clnt_id;

			if (SQLCODE != 0)
			{
				fn_errlog( c_ServiceName, "S31300", SQLMSG, c_err_msg  );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**			l_acnt_id = -1;
				Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
				tpfree ( ( char * )ptr_fml_Obuf);
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}	
	/***** Ver 2.1 ***** Uncommented in Ver 2.3 **/ 
			if(DEBUG_MSG_LVL_0)
			{
				fn_userlog(c_ServiceName,"The value of DBD_TOT_QTY is [%ld]",sql_dbd_tot_qty);
				fn_userlog(c_ServiceName,"The value of DBD_QTY_BLCKD is [%ld]",sql_dbd_qty_blckd);
				fn_userlog(c_ServiceName,"The value of DBD_PLG_REQ_QTY is [%ld]",sql_dbd_plg_req_qty);
				/** fn_userlog(c_ServiceName,"The value of DBD_TIFP_QTY is [%ld]",sql_dbd_tifp_qty); **/
				fn_userlog(c_ServiceName,"The value of DBD_REV_REQ_QTY is [%ld]",sql_dbd_rev_req_qty);
				fn_userlog(c_ServiceName,"The value of DBD_REV_COV_QTY is [%ld]",sql_dbd_rev_cov_qty);
				fn_userlog(c_ServiceName,"The value of DBD_INV_REQ_QTY is [%ld]",sql_dbd_inv_req_qty);
				fn_userlog(c_ServiceName,"The value of DBD_INV_COV_QTY is [%ld]",sql_dbd_inv_cov_qty);
				fn_userlog(c_ServiceName,"The value of DBD_BLOCK_FOR_SALE is [%ld]",sql_dbd_block_for_sale);
			}
		/********* Ver 2.1 ****/
	
/*Withdrawal Modification/Cancellation*/	
			switch(sql_oprn_typ)
      {
				/*Add or Reduce withdrawal*/
      	case 'M' :
				{														
					sql_pml_mod_type ='M';
					MEMSET(sql_pml_rmrks);
					strcpy(sql_pml_rmrks.arr,"User Modified Withdrawal");
					SETLEN(sql_pml_rmrks);

				/***** Commented for Ver 2.1 ******** Uncomment Start for Ver 2.3 **/
					EXEC SQL SELECT POD_ORDR_QTY 
					INTO :l_old_ordr_qty
					FROM POD_PLG_ORDR_DTLS
					WHERE POD_STCK_CD = :sql_stk_stck_cd
					AND POD_CLNT_MTCH_ACCNT = :sql_mtch_accnt
					AND POD_DP_ACCNT = :sql_dbd_dp_id
					AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
          AND POD_ORDR_NO = :sql_pod_ordr_no
					AND POD_PLG_REV_TYP = 'W'
					aND POD_ORDR_STTS = 'R';
		
					if ((SQLCODE != 0) && (SQLCODE != NO_DATA_FOUND))
					{
						fn_errlog( c_ServiceName, "S31305", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

					if (SQLCODE == NO_DATA_FOUND)
					{
						fn_userlog(c_ServiceName,"There is no Withdrawal request to Modify.");
						strcpy(c_err_msg,"There is no Withdrawal request to Modify.");
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						Fadd32( ptr_fml_Ibuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
						Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
						tpfree ( ( char * )ptr_fml_Obuf);
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ) ;				
					}
				/***** Commented for Ver 2.1 ********/
	/*If a Pledge Request exists, then do not allow to withdraw*/

				/*** Commented for Ver 2.1 ***/
					if(sql_dbd_plg_req_qty > 0)
					{
						fn_userlog(c_ServiceName,"The Withdrawal quantity is [%ld]. The Plg Request qty is [%ld]. Hence rejected.",sql_dbd_rev_req_qty, sql_dbd_plg_req_qty);
						strcpy(c_err_msg,"There is a pending Pledge request present.Please cancel/modify the same.");
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			** Ver 1.1 : Commented  ***/
						Fadd32( ptr_fml_Ibuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
						Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
						tpfree ( ( char * )ptr_fml_Obuf);
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ) ;				
					}
				/******** ver 2.1 *** Uncomment End for Ver 2.3 **/

					/*The sql_net_qty_plg can be negative indicating that there has been a reduction in withdrawal*/	
					sql_net_qty_plg = sql_qty_plg - l_old_ordr_qty ;
					
					if (((sql_ppp_plg_opncls_flg == 'W')
							|| (sql_clm_plg_allwd_flg == 'W')
							|| (sql_stk_plg_allwd == 'W')) && (sql_net_qty_plg <= 0))
					{
						fn_userlog(c_ServiceName, "The quantity cannot be reduced as only withdrawal is allowed at present [%ld]",sql_net_qty_plg);
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, "The quantity cannot be reduced as only withdrawal is allowed at present", 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );	
					}

					if(DEBUG_MSG_LVL_0)
					{
						fn_userlog(c_ServiceName,"The net withdraw qty is [%ld], withdraw request sent is [%ld], existing request is [%ld]",sql_net_qty_plg, sql_qty_plg, l_old_ordr_qty); 
					}

					li_tot_blck_qty = (sql_dbd_rev_req_qty + sql_dbd_rev_cov_qty + sql_dbd_inv_req_qty + sql_dbd_inv_cov_qty ); /*** Ver 2.1 ***Uncomment for Ver 2.3 **/
					/** li_tot_blck_qty = 0; ** Commented in Ver 2.4 ***/

					if(DEBUG_MSG_LVL_0)
					{
						fn_userlog(c_ServiceName,"The Total Block qty is [%ld] and Effective withdrawal is [%ld]",li_tot_blck_qty, sql_qty_plg); 
					}

					if((sql_dbd_sam_blckd_qty - li_tot_blck_qty) < sql_net_qty_plg)
					{
						fn_userlog(c_ServiceName,"The value free is [%ld] and pledged is [%ld]",(sql_dbd_sam_blckd_qty - li_tot_blck_qty) ,  sql_net_qty_plg); 
						strcpy(c_err_msg,"The free quantity for withdrawal is less than that requested");
						Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						Fadd32( ptr_fml_Ibuf, FFO_STCK_CD, (char *)sql_stk_stck_cd, 0 );
						tpfree ( ( char * )ptr_fml_Obuf);
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );	
					}

					/*The following variable will be used to hold the value of the net stock pledged This will be used for entry in FAB table as the old pledge value has to be removed*/	

					sql_stck_net_plg_val = (sql_net_qty_plg * (sql_ltq_plg_rt *(1 - ((double)(sql_stk_plg_haircut)/100))))*100; /*diwa typecast float to double **/
					
					if((long long)(sql_stck_net_plg_val * 100)%100 > 50)
					{
						sql_stck_net_plg_val = sql_stck_net_plg_val + 1.0;

						if(DEBUG_MSG_LVL_0)
						{
							fn_userlog( c_ServiceName, "The rounded off amount is [%lf]",sql_stck_net_plg_val);
						}
					}
				
					ll_stck_net_plg_val = (long long) sql_stck_net_plg_val;

					sql_stck_net_plg_val = (double) ll_stck_net_plg_val;


					/*The following variable will be used to hold the value of the stock pledged*/	
					sql_stck_plg_val = (sql_qty_plg * (sql_ltq_plg_rt *(1 - ((double)(sql_stk_plg_haircut)/100))))*100; /*diwa
 typecast float to double **/
					
					if((long long)(sql_stck_plg_val * 100)%100 > 50)
					{
						sql_stck_plg_val = sql_stck_plg_val + 1.0;
	
						if(DEBUG_MSG_LVL_0)
						{		
						fn_userlog( c_ServiceName, "The rounded off amount is [%lf]",sql_stck_plg_val);
						}
					}
				
					ll_stck_plg_val = (long long) sql_stck_plg_val;

					sql_stck_plg_val = (double) ll_stck_plg_val;

					if(DEBUG_MSG_LVL_0)
					{
						fn_userlog(c_ServiceName,"The net withdrawal val is [%lf] for net qty [%ld] ",sql_stck_net_plg_val,sql_net_qty_plg);
						fn_userlog(c_ServiceName,"The withdrawal val is [%lf] for rate [%lf]",sql_stck_plg_val,sql_ltq_plg_rt);
					}

					/*****The following portion gets the Limits avaliable for the user before modification***/

					memset(&st_gt_lmt,'\0' , sizeof( struct vw_gt_lmt_dtls) );
					strcpy(st_gt_lmt.c_xchng_cd , "NFO" );

					MEMSET(sql_nxt_trd_dt);

					EXEC SQL SELECT EXG_NXT_TRD_DT 
					INTO :sql_nxt_trd_dt 
					FROM EXG_XCHNG_MSTR
					WHERE EXG_XCHNG_CD = 'NFO';

					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31310", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
						tpfree ( ( char * )ptr_fml_Obuf);
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

					SETNULL(sql_nxt_trd_dt);

					strcpy(st_gt_lmt.c_trd_dt, sql_nxt_trd_dt.arr );
					strcpy(st_gt_lmt.c_cln_mtch_accnt, sql_mtch_accnt.arr);
					l_ip_len = (long) sizeof ( struct vw_gt_lmt_dtls);
					st_gt_lmt.c_rqst_typ = LIMIT_X;
					fn_cpy_ddr ( st_gt_lmt.c_rout_crt );

          /************ Commented in Ver 2.0 ******************
					i_returncode = fn_call_svc( c_ServiceName, c_err_msg, &st_gt_lmt, &st_gt_lmt,
																		"vw_gt_lmt_dtls", "vw_gt_lmt_dtls", l_ip_len,
																		l_ip_len, 0, "SFO_GET_LIMITS" );

					if ( i_returncode == -1 )
					{
						fn_errlog( c_ServiceName, "S31315", LIBMSG, c_err_msg );
						fn_userlog(c_ServiceName,"SFO_GET_LIMITS FAIL  ");
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
						Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
						tpfree ( ( char * )ptr_fml_Obuf);
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
          ****** Ver 2.0 **************************************/

          /**** Ver 2.0 Starts Here ********/
          i_returncode = fo_get_trd_limit(c_ServiceName,
                                    st_gt_lmt.c_cln_mtch_accnt,
                                    st_gt_lmt.c_trd_dt,
                                    st_gt_lmt.c_rqst_typ,
                                    st_gt_lmt.c_xchng_cd,
                                    st_gt_lmt.l_gid,
                                    &st_gt_lmt.d_amt,
                                    c_err_msg
                                    );
              if ( i_returncode == -1 )
              {
                fn_errlog( c_ServiceName, "S31320", LIBMSG, c_err_msg );
                fn_userlog(c_ServiceName,"fo_get_trd_limit FAIL  ");
                Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
                Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
                tpfree ( ( char * )ptr_fml_Obuf);
                tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
              }

          /**** Ver 2.0 Ends Here **********/


          /*****Ver 1.7 Get BFO limit. The net FNO limit will be minimum of NSE and BSE limit ***/

          d_nfo_limit = st_gt_lmt.d_amt;

          memset(&st_gt_lmt,'\0' , sizeof( struct vw_gt_lmt_dtls) );
          strcpy(st_gt_lmt.c_xchng_cd , "BFO" );

          MEMSET(sql_nxt_trd_dt);

          EXEC SQL
          SELECT EXG_NXT_TRD_DT
          INTO :sql_nxt_trd_dt
          FROM EXG_XCHNG_MSTR
          WHERE EXG_XCHNG_CD = 'BFO';

          if (SQLCODE != 0)
          {
            fn_errlog( c_ServiceName, "S31325", SQLMSG, c_err_msg  );
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
            tpfree ( ( char * )ptr_fml_Obuf);
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          }

          SETNULL(sql_nxt_trd_dt);

          strcpy(st_gt_lmt.c_trd_dt, sql_nxt_trd_dt.arr );
          strcpy(st_gt_lmt.c_cln_mtch_accnt, sql_mtch_accnt.arr);
          l_ip_len = (long) sizeof ( struct vw_gt_lmt_dtls);
          st_gt_lmt.c_rqst_typ = LIMIT_X;
          fn_cpy_ddr ( st_gt_lmt.c_rout_crt );
          /**** Commented in Ver 2.0 ************
          i_returncode = fn_call_svc( c_ServiceName, c_err_msg, &st_gt_lmt, &st_gt_lmt,
                                    "vw_gt_lmt_dtls", "vw_gt_lmt_dtls", l_ip_len,
                                    l_ip_len, 0, "SFO_GET_LIMITS" );

          if ( i_returncode == -1 )
          {
            fn_errlog( c_ServiceName, "S31330", LIBMSG, c_err_msg );
            fn_userlog(c_ServiceName,"SFO_GET_LIMITS FAIL  ");
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
            Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
            tpfree ( ( char * )ptr_fml_Obuf);
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          }
          ********** Ver 2.0 *******************/

          /**** Ver 2.0 Starts Here ********/
           i_returncode = fo_get_trd_limit(c_ServiceName,
                                    st_gt_lmt.c_cln_mtch_accnt,
                                    st_gt_lmt.c_trd_dt,
                                    st_gt_lmt.c_rqst_typ,
                                    st_gt_lmt.c_xchng_cd,
                                    st_gt_lmt.l_gid,
                                    &st_gt_lmt.d_amt,
                                    c_err_msg
                                    );
           if ( i_returncode == -1 )
           {
             fn_errlog( c_ServiceName, "S31335", LIBMSG, c_err_msg );
             fn_userlog(c_ServiceName,"fo_get_trd_limit FAIL  ");
             Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
             Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
             tpfree ( ( char * )ptr_fml_Obuf);
             tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
           } 
          /**** Ver 2.0 Ends Here **********/

          d_bfo_limit = st_gt_lmt.d_amt;

          d_net_fno_limit =  MIN(d_nfo_limit,d_bfo_limit);

          if(DEBUG_MSG_LVL_0){
            fn_userlog( c_ServiceName,"NFO Limit Calculated :%lf:",d_nfo_limit);
            fn_userlog( c_ServiceName,"BFO Limit Calculated :%lf:",d_bfo_limit);
            fn_userlog( c_ServiceName,"Net FNO limit        :%lf:",d_net_fno_limit);
          }
          /****   Ver 1.7 ends **************/

	
					/****** Get the Equity SAM limit and negative cash limit ***************/


						i_returncode = fn_get_eqsam_limit (	c_ServiceName,
																				       	sql_mtch_accnt.arr,
                        												&d_eq_sam_limit,
																								sql_usr_id.arr,
																								sql_sssn_id,
                        												c_err_msg
																							);

						if(i_returncode == -1)
						{
								fn_errlog( c_ServiceName, "S31340", LIBMSG, c_err_msg );
								Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
								tpfree ( ( char * )ptr_fml_Obuf);
								tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}


						if(DEBUG_MSG_LVL_0)
						{
							/**fn_userlog( c_ServiceName,"Limit Calculated :%lf:",st_gt_lmt.d_amt); ** Ver 1.7*/
							fn_userlog( c_ServiceName,"EQ SAM limit			:%lf:",d_eq_sam_limit);
						}


				/************** check limit is allowed for withdrawal modify *************************/

				/***if(sql_stck_net_plg_val > st_gt_lmt.d_amt) *Commented Ver 1.5 EQ SAM **/
				if(sql_stck_net_plg_val > (MIN(d_net_fno_limit,sql_fab_plg_amt) + sql_fab_nwb_amt + d_eq_sam_limit ) ) /* 1.5 EQ SAM also need to consider eq sam limit + neagative cash**//** d_net_fno_limit added for st_gt_lmt.d_amt **/
				{
					/**fn_userlog(c_ServiceName,"The new value in plg [%lf] and  Limit is [%lf]",sql_stck_net_plg_val, st_gt_lmt.d_amt); ** Ver 1.7 */
					fn_userlog(c_ServiceName,"The new value in plg [%lf] and  Limit is [%lf]",sql_stck_net_plg_val, MIN(d_net_fno_limit,sql_fab_plg_amt) + sql_fab_nwb_amt + d_eq_sam_limit ); /** Ver 1.7 */
					fn_userlog(c_ServiceName,"Cannot withdraw this quantity as the limit has been used.");
					/**strcpy(c_err_msg,"Cannot withdraw this quantity as the limit has been used."); Ver 1.5**/
					strcpy(c_err_msg,"Please try again as your withdrawal request is more than the free securities limit available."); /*Ver 1.5*/
					Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
					Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
					tpfree ( ( char * )ptr_fml_Obuf);
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
					
					i_trnsctn = fn_begintran( c_ServiceName, c_err_msg );
					if ( i_trnsctn == -1 )
					{
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
						fn_errlog( c_ServiceName, "S31345",LIBMSG,c_err_msg);
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

					EXEC SQL SELECT PRS_PLG_REV_SEQ.nextval 
					INTO :sql_prs_seq
					FROM DUAL;

					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31350", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

			/*** Commented for Ver 2.1 *** Uncomment Start for Ver 2.3 **/
					EXEC SQL 
					UPDATE POD_PLG_ORDR_DTLS SET
					POD_ORDR_QTY = :sql_qty_plg,
					POD_HAIRCUT = :sql_stk_plg_haircut,
					POD_ORDR_VL = :sql_stck_plg_val,
					POD_RMRKS = :sql_pml_rmrks
					WHERE POD_CLNT_MTCH_ACCNT = :sql_mtch_accnt
					AND POD_DP_ACCNT = :sql_dbd_dp_id
					AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
					AND POD_PLG_REV_TYP = 'W'
					AND POD_ORDR_STTS = 'R'
          AND POD_ORDR_NO = :sql_pod_ordr_no
					AND POD_STCK_CD = :sql_stk_stck_cd;
					/** RETURNING POD_ORDR_NO 
					INTO :sql_pod_ordr_no; ** Ver 2.3 **/
						
					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31355", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
					
					/** SETNULL(sql_pod_ordr_no); ** Ver 2.3 **/

					EXEC SQL 
					SELECT (COUNT(*)+1) INTO :sql_pml_mod_cntr 
					FROM PML_PLG_MOD_LOG
					WHERE PML_ORDR_NO = :sql_pod_ordr_no
					AND PML_CLNT_MTCH_ACCNT = :sql_mtch_accnt
					AND PML_DP_ACCNT = :sql_dbd_dp_id
					AND PML_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
					AND PML_PLG_REV_TYP = 'W'
					AND PML_MOD_TYPE IN ('N','M','C');
		
					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31360", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

					if(DEBUG_MSG_LVL_0)
					{
						fn_userlog(c_ServiceName,"The mod counter is [%ld]",sql_pml_mod_cntr);	
					}

					EXEC SQL SELECT 
					nvl(PPS_L5_POS,0)
					INTO :sql_pps_l5_pos
					FROM PPS_PLG_PSTN
					WHERE PPS_CLM_MTCH_ACCNT = :sql_mtch_accnt
					AND PPS_STCK_CD = :sql_stk_stck_cd
					AND PPS_DP_ACCNT = :sql_dbd_dp_id
					AND PPS_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id;

					if ((SQLCODE != 0) && (SQLCODE != NO_DATA_FOUND))
					{
						fn_errlog( c_ServiceName, "S31365", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

   /**** Commented in Ver 2.4 *** 

					if(SQLCODE == NO_DATA_FOUND)
					{
						fn_userlog(c_ServiceName,"The pledge has not been passed to DP.");
						strcpy(c_err_msg,"The pledge has not been passed to DP.");
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
						Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
	 **********/		
				/******* Ver 2.1 **** Uncomment End for Ver 2.3 **/

					if(DEBUG_MSG_LVL_0)
					{
					fn_userlog(c_ServiceName,"The value of PPS_L5_POS is [%ld]",sql_pps_l5_pos);
					}
	/*********** Commented for Ver 2.1 ***** Uncomment start for Ver 2.3 **/
         /***** Comment Starts Ver 2.4 *****
 					if(l_old_ordr_qty > sql_dbd_rev_req_qty )*Existing withdraw position in cover* 
					{
						if(sql_qty_plg <= sql_pps_l5_pos) *New withdraw position not in cover*
						{
							l_new_req_qty = sql_qty_plg;
							l_new_cov_qty = sql_dbd_rev_cov_qty - (l_old_ordr_qty - sql_dbd_rev_req_qty);
	* (l_old_ordr_qty - sql_dbd_rev_req_qty) will give the old requests part which was present
	in cover quantity*	
						}
						else *New withdraw position in cover*
						{
							l_new_req_qty = sql_dbd_rev_req_qty;
							l_new_cov_qty = sql_dbd_rev_cov_qty - (l_old_ordr_qty - sql_dbd_rev_req_qty);
							l_new_cov_qty = l_new_cov_qty + (sql_qty_plg - sql_dbd_rev_req_qty);
						}
						
					}
					else *Existing withdraw position not in cover*
					{
						if(sql_qty_plg <= sql_pps_l5_pos) *New withdraw position not in cover*
						{
							l_new_req_qty = sql_qty_plg;
							l_new_cov_qty = sql_dbd_rev_cov_qty;	
						}
						else *New withdraw position in cover*
						{
							l_new_req_qty = sql_pps_l5_pos;
							l_new_cov_qty = sql_dbd_rev_cov_qty + (sql_qty_plg - sql_pps_l5_pos);
						}

					}
         ***** Comment Ends Ver 2.4 *****/

          l_new_req_qty = sql_qty_plg;  /** Ver 2.4 **/
          l_new_cov_qty = 0;            /** Ver 2.4 **/

					EXEC SQL UPDATE DBD_DP_BLCK_DTLS SET
					/** DBD_REV_REQ_QTY = :l_new_req_qty, **/
					DBD_REV_REQ_QTY = DBD_REV_REQ_QTY + :sql_net_qty_plg,
					DBD_REV_COV_QTY = :l_new_cov_qty
					WHERE DBD_STCK_CD = :sql_stk_stck_cd
					AND DBD_CLM_MTCH_ACCNT = :sql_mtch_accnt
					AND DBD_DP_ID = :sql_dbd_dp_id
					AND DBD_DP_CLNT_ID = :sql_dbd_dp_clnt_id;
				
					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31370", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

					EXEC SQL UPDATE POD_PLG_ORDR_DTLS SET
					POD_CONF_QTY = :l_new_req_qty
					WHERE  POD_DP_ACCNT = :sql_dbd_dp_id
					AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
					AND POD_PLG_REV_TYP = 'W'
					AND POD_ORDR_STTS = 'R'
					AND POD_STCK_CD = :sql_stk_stck_cd
					AND POD_ORDR_NO = TRIM(:sql_pod_ordr_no);
					
					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31375", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			** Ver 1.1 : Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

			/*** Ver 2.1 *** Uncomment End for Ver 2.3 **/
		
				/*commented	
					if (sql_qty_plg <= sql_pps_l5_pos)
					{
						EXEC SQL UPDATE DBD_DP_BLCK_DTLS SET
						DBD_REV_REQ_QTY = :sql_qty_plg
						WHERE DBD_STCK_CD = :sql_stk_stck_cd
						AND DBD_CLM_MTCH_ACCNT = :sql_mtch_accnt
						AND DBD_DP_ID = :sql_dbd_dp_id
						AND DBD_DP_CLNT_ID = :sql_dbd_dp_clnt_id;
			
						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31380", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
							l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );
							tpfree ( ( char * )ptr_fml_Obuf);
							fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}	*/
						
						EXEC SQL 
						INSERT INTO DLD_DP_LOG_DTLS
						(DLD_CLM_MTCH_ACCNT,
						DLD_DP_ID,
						DLD_DP_CLNT_ID,
						DLD_ISIN_NMBR,
						DLD_STCK_CD,
						DLD_TOT_QTY_CHG,
						DLD_QTY_BLCKD_CHG,
						/** Uncomment Start for Ver 2.3 **/
            DLD_PLG_REQ_QTY_CHG,
						/** DLD_TIFP_QTY_CHG, Ver 2.1 **/
						DLD_REV_COV_QTY_CHG,
						DLD_REV_REQ_QTY_CHG, /*** Ver 2.1 *** Uncomment End for Ver 2.3 **/
						DLD_SAM_BLCKD_QTY_CHG,	/** Ver 2.1 **/
						DLD_CHG_TM,
						DLD_BLK_FR_SALE_CHG,
						DLD_INV_REQ_QTY_CHG,
						DLD_INV_COV_QTY_CHG, /*** Ver 2.1 ** Uncomment for Ver 2.3 **/
						DLD_RMRKS)
						VALUES
						(:sql_mtch_accnt,
						:sql_dbd_dp_id,
						:sql_dbd_dp_clnt_id,
						:sql_dbd_isin_nmbr,
						:sql_stk_stck_cd,
						:sql_dbd_tot_qty,
						:sql_dbd_qty_blckd,
						0,
						0, 
						(:l_new_cov_qty - :sql_dbd_rev_cov_qty) ,
						(:l_new_req_qty - :sql_dbd_rev_req_qty), /**** ver 2.1 ***/
						sysdate,
						0,
					 	0,
						0, /** ver 2.1 **/
						'Withdraw Modification');


						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31385", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/***					l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
							tpfree ( ( char * )ptr_fml_Obuf);
							fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}
			/*commented	
					}
					else
					{
						
						sql_dbd_rev_cov_qty = sql_qty_plg - sql_pps_l5_pos;

						EXEC SQL 
						UPDATE DBD_DP_BLCK_DTLS SET
						DBD_REV_REQ_QTY = DBD_REV_REQ_QTY + :sql_pps_l5_pos,
						DBD_REV_COV_QTY = DBD_REV_COV_QTY + :sql_dbd_rev_cov_qty
						WHERE DBD_STCK_CD = :sql_stk_stck_cd
						AND DBD_CLM_MTCH_ACCNT = :sql_mtch_accnt
						AND DBD_DP_ID = :sql_dbd_dp_id
						AND DBD_DP_CLNT_ID = :sql_dbd_dp_clnt_id;

						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31390", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
							l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );
							fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}


						if(DEBUG_MSG_LVL_0)
						{	
						fn_userlog(c_ServiceName,"The value of Cover qty is [%ld]",sql_dbd_rev_cov_qty);
						}

						EXEC SQL 
						INSERT INTO DLD_DP_LOG_DTLS
						(DLD_CLM_MTCH_ACCNT,
						DLD_DP_ID,
						DLD_DP_CLNT_ID,
						DLD_ISIN_NMBR,
						DLD_STCK_CD,
						DLD_TOT_QTY_CHG,
						DLD_QTY_BLCKD_CHG,
						DLD_PLG_REQ_QTY_CHG,
						DLD_TIFP_QTY_CHG,
						DLD_REV_COV_QTY_CHG,
						DLD_REV_REQ_QTY_CHG,
						DLD_CHG_TM,
						DLD_BLK_FR_SALE_CHG,
						DLD_INV_REQ_QTY_CHG,
						DLD_INV_COV_QTY_CHG,
						DLD_RMRKS)
						VALUES
						(:sql_mtch_accnt,
						:sql_dbd_dp_id,
						:sql_dbd_dp_clnt_id,
						:sql_dbd_isin_nmbr,
						:sql_stk_stck_cd,
						:sql_dbd_tot_qty,
						:sql_dbd_qty_blckd,
						0,
						0,
						(:sql_qty_plg - :sql_pps_l5_pos - :sql_dbd_rev_cov_qty),
						:sql_pps_l5_pos,
						sysdate,
						0,
						0,
						0,
						'Withdraw Modification into Cover');


						if (SQLCODE != 0)
						{
							fn_errlog( c_ServiceName, "S31395", SQLMSG, c_err_msg  );
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
							l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );
							fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
							tpfree ( ( char * )ptr_fml_Obuf);
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}
					}
					*/	

					/****************** Ver 1.5 EQ SAM Commented *****************************
					MEMSET(sql_fab_bnk_accnt);

					EXEC SQL 
					UPDATE FAB_FO_ALC_BFT_SMRY SET
					FAB_PLG_AMT = FAB_PLG_AMT - :sql_stck_net_plg_val	
					WHERE FAB_CLM_MTCH_ACCNT = :sql_mtch_accnt
					RETURNING FAB_BNK_ACCNT,FAB_ALCTD_AMT,FAB_BFT_AMT
					INTO :sql_fab_bnk_accnt,:sql_fab_alctd_amt,:sql_fab_bft_amt;

					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31400", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
						
					SETNULL(sql_fab_bnk_accnt);

					EXEC SQL 
					INSERT INTO FAL_FO_ALCBFT_LOG
					(FAL_CLM_MTCH_ACCNT,
					FAL_BNK_ACCNT,
					FAL_ALCTD_AMT,
					FAL_BFT_AMT,
					FAL_TRN_DT,
					FAL_OLD_PLG_AMT,
					FAL_PLG_CHG_AMT,
					FAL_NARRATION)
					VALUES
					(:sql_mtch_accnt,
					:sql_fab_bnk_accnt,
					:sql_fab_alctd_amt,
					:sql_fab_bft_amt,
					sysdate,
					:sql_fab_plg_amt,
					(-:sql_stck_net_plg_val),
					'WL');

					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31405", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
					********   Ver1.5 comment ends *******************************************/

					/*******   Ver 1.5 EQ SAM Starts *************************/

					strcpy(c_narration, "WL");

					if(sql_stck_net_plg_val > 0)
					{
            i_returncode = fn_reduce_sam_limit ( c_ServiceName,
                                                sql_mtch_accnt.arr,
                                                sql_stck_net_plg_val ,
                                                c_narration,
                                                c_err_msg);
            if(i_returncode == -1)
            {
              fn_errlog( c_ServiceName, "S31410", SQLMSG, c_err_msg  );
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              tpfree ( ( char * )ptr_fml_Obuf);
              fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }

          }
          else
          {
						sql_stck_net_plg_val = sql_stck_net_plg_val * -1 ;		/** make the value +ve **/

						/*** Commented for Ver 2.7 ****

						EXEC SQL
              UPDATE FAB_FO_ALC_BFT_SMRY
              SET FAB_NWB_AMT = nvl(FAB_NWB_AMT,0) + :sql_stck_net_plg_val
              WHERE FAB_CLM_MTCH_ACCNT = :sql_mtch_accnt
              RETURNING FAB_BNK_ACCNT,FAB_ALCTD_AMT,FAB_BFT_AMT
              INTO :sql_fab_bnk_accnt,:sql_fab_alctd_amt,:sql_fab_bft_amt;

            if (SQLCODE != 0)
            {
              fn_errlog( c_ServiceName, "S31415", SQLMSG, c_err_msg  );
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              tpfree ( ( char * )ptr_fml_Obuf);
              fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }

            SETNULL(sql_fab_bnk_accnt);

            EXEC SQL
              INSERT INTO FAL_FO_ALCBFT_LOG
                (FAL_CLM_MTCH_ACCNT,
                FAL_BNK_ACCNT,
                FAL_ALCTD_AMT,
                FAL_BFT_AMT,
                FAL_TRN_DT,
                FAL_OLD_PLG_AMT,
                FAL_NARRATION,
                FAL_NWB_AMT,
                FAL_NWB_CHG_AMT)
                VALUES
                (:sql_mtch_accnt,
                :sql_fab_bnk_accnt,
                :sql_fab_alctd_amt,
                :sql_fab_bft_amt,
                sysdate,
                :sql_fab_plg_amt,
                'WL',
                :sql_fab_nwb_amt,
                :sql_stck_net_plg_val);

            if (SQLCODE != 0)
            {
              fn_errlog( c_ServiceName, "S31420", SQLMSG, c_err_msg  );
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              tpfree ( ( char * )ptr_fml_Obuf);
              fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }
				
						*** Comment ends for Ver 2.7 **/
						/** Added for Ver 2.7 **/

						EXEC SQL
							SELECT NVL(EAB_PLG_AMT,0)
							INTO :sql_eab_plg_amt
							FROM EAB_EQ_ALC_BFT_SMRY
							WHERE EAB_CLM_MTCH_ACCNT = :sql_mtch_accnt;

    					if (SQLCODE != 0 && SQLCODE!= NO_DATA_FOUND)
            	{
              	fn_errlog( c_ServiceName, "S31425", SQLMSG, c_err_msg  );
              	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              	tpfree ( ( char * )ptr_fml_Obuf);
              	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            	}

						EXEC SQL
							UPDATE EAB_EQ_ALC_BFT_SMRY
							SET EAB_PLG_AMT = NVL(EAB_PLG_AMT,0) + :sql_stck_net_plg_val/100
							WHERE EAB_CLM_MTCH_ACCNT = :sql_mtch_accnt;

           	if (SQLCODE != 0 && SQLCODE!= NO_DATA_FOUND)
            {
              fn_errlog( c_ServiceName, "S31430", SQLMSG, c_err_msg  );
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              tpfree ( ( char * )ptr_fml_Obuf);
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }
						else if (SQLCODE == NO_DATA_FOUND)
						{
							EXEC SQL
              UPDATE FAB_FO_ALC_BFT_SMRY
              SET FAB_PLG_AMT = nvl(FAB_PLG_AMT,0) + :sql_stck_net_plg_val
              WHERE FAB_CLM_MTCH_ACCNT = :sql_mtch_accnt
              RETURNING FAB_BNK_ACCNT,FAB_ALCTD_AMT,FAB_BFT_AMT
              INTO :sql_fab_bnk_accnt,:sql_fab_alctd_amt,:sql_fab_bft_amt;

            	if (SQLCODE != 0)
            	{
              	fn_errlog( c_ServiceName, "S31435", SQLMSG, c_err_msg  );
              	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              	tpfree ( ( char * )ptr_fml_Obuf);
              	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
              	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            	}

            	SETNULL(sql_fab_bnk_accnt);

            	EXEC SQL
              INSERT INTO FAL_FO_ALCBFT_LOG
                (FAL_CLM_MTCH_ACCNT,
                FAL_BNK_ACCNT,
                FAL_ALCTD_AMT,
                FAL_BFT_AMT,
                FAL_TRN_DT,
                FAL_OLD_PLG_AMT,
                FAL_NARRATION,
             		FAL_NWB_AMT,
                FAL_PLG_CHG_AMT)
                VALUES
                (:sql_mtch_accnt,
                :sql_fab_bnk_accnt,
                :sql_fab_alctd_amt,
                :sql_fab_bft_amt,
                sysdate,
                :sql_fab_plg_amt,
                'WL',
                :sql_fab_nwb_amt,
                :sql_stck_net_plg_val);

            	if (SQLCODE != 0)
            	{
              	fn_errlog( c_ServiceName, "S31440", SQLMSG, c_err_msg  );
              	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              	tpfree ( ( char * )ptr_fml_Obuf);
              	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
              	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            	}
						}
						else if (SQLCODE == 0)
						{
							  EXEC SQL
          				INSERT INTO
            			EAL_EQ_ALCBFT_LOG
              		(EAL_CLM_MTCH_ACCNT,
              		EAL_TRN_DT,
              		EAL_OLD_PLG_AMT,
              		EAL_PLG_CHG_AMT,
              		EAL_NARRATION)
          			VALUES
            		(:sql_mtch_accnt,
              	sysdate,
              	:sql_eab_plg_amt,
              	(:sql_stck_net_plg_val/100),
              	'WLMOD');

            	if (SQLCODE != 0)
            	{
              	fn_errlog( c_ServiceName, "S31445", SQLMSG, c_err_msg  );
              	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              	tpfree ( ( char * )ptr_fml_Obuf);
              	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
              	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            	}
						}

						/** End for Ver 2.7 **/
          }

          /** Added for Ver 2.8 **/
            i_returncode = fn_get_prev_sam ( c_ServiceName,
                                             sql_mtch_accnt.arr,
                                             c_err_msg);
            if(i_returncode == -1)
            {
              fn_errlog( c_ServiceName, "S31450", SQLMSG, c_err_msg  );
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              tpfree ( ( char * )ptr_fml_Obuf);
              fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }
            /** End for Ver 2.8 **/

					/********  Ver 1.5 Ends **********************************/

					/*** Commented for Ver 2.1 ********* Uncomment Start for Ver 2.3 **/
					if(DEBUG_MSG_LVL_0)
					{
					fn_userlog(c_ServiceName,"The PML_ORDR_NO is [%s]",sql_pod_ordr_no.arr);
					fn_userlog(c_ServiceName,"The PML_STCK_CD is [%s]",sql_stk_stck_cd);
					fn_userlog(c_ServiceName,"The PML_ORDR_QTY is [%ld]",sql_qty_plg);
					fn_userlog(c_ServiceName,"The PML_NET_ORDR_QTY is [%ld]",sql_net_qty_plg);
					fn_userlog(c_ServiceName,"The PML_HAIRCUT is [%ld]",sql_stk_plg_haircut);
					fn_userlog(c_ServiceName,"The PML_ORDR_VL is [%ld]",sql_stck_plg_val);
					fn_userlog(c_ServiceName,"The PML_ISIN_NO is [%s]",sql_dbd_isin_nmbr);
					fn_userlog(c_ServiceName,"The PML_DP_CLNT_ACCNT is [%s]",sql_dbd_dp_clnt_id);
					fn_userlog(c_ServiceName,"The PML_DP_ACCNT is [%s]",sql_dbd_dp_id);
					fn_userlog(c_ServiceName,"The PML_CLNT_MTCH_ACCNT is [%s]",sql_mtch_accnt.arr);
					fn_userlog(c_ServiceName,"The PML_MOD_TYPE is [%c]",sql_pml_mod_type);
					fn_userlog(c_ServiceName,"The PML_MOD_CNTR is [%ld]",sql_pml_mod_cntr);
					fn_userlog(c_ServiceName,"The PML_PLCD_SQNC is [%ld]",sql_prs_seq);
					fn_userlog(c_ServiceName,"The PML_CHANNEL is [%s]",sql_pml_channel.arr);
					}

					EXEC SQL 
					INSERT INTO PML_PLG_MOD_LOG
					(PML_ORDR_NO,
					PML_STCK_CD,
					PML_ORDR_QTY,
					PML_ORDR_TM,
					PML_HAIRCUT,
					PML_ORDR_VL,
					PML_ISIN_NO,
					PML_DP_CLNT_ACCNT,
					PML_DP_ACCNT,
					PML_CLNT_MTCH_ACCNT,
					PML_PLG_REV_TYP,
					PML_MOD_TYPE,
					PML_STTS,
					PML_MOD_CNTR,
					PML_PLCD_SQNC,
					PML_BP_ID,
					PML_CHANNEL,
					PML_RMRKS)
					VALUES
					(:sql_pod_ordr_no,
					:sql_stk_stck_cd,
					:sql_qty_plg,
					sysdate,
					:sql_stk_plg_haircut,
					:sql_stck_plg_val,
					:sql_dbd_isin_nmbr,
					:sql_dbd_dp_clnt_id,
					:sql_dbd_dp_id,
					:sql_mtch_accnt,
					'W',
					:sql_pml_mod_type,
					'R',
					:sql_pml_mod_cntr,
					:sql_prs_seq,	
					:sql_sbd_bp_id,
					:sql_pml_channel,
					:sql_pml_rmrks);
						
					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31455", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
				/********* Ver 2.1 ******* Uncomment End  for Ver 2.3 **/

					EXEC SQL 
					INSERT INTO DLD_DP_LOG_DTLS
					(DLD_CLM_MTCH_ACCNT,
					DLD_DP_ID,
					DLD_DP_CLNT_ID,
					DLD_ISIN_NMBR,
					DLD_STCK_CD,
					DLD_TOT_QTY_CHG,
					DLD_QTY_BLCKD_CHG,
				  /** Uncomment Start for Ver 2.3 **/ 
          DLD_PLG_REQ_QTY_CHG,
					/** DLD_TIFP_QTY_CHG, ** Ver 2.1 **/
					DLD_REV_COV_QTY_CHG,
					DLD_REV_REQ_QTY_CHG, /**Ver 2.1 *** Uncomment End for Ver 2.3 **/
					DLD_SAM_BLCKD_QTY_CHG,		/** Ver 2.1 **/
					DLD_CHG_TM,
					DLD_BLK_FR_SALE_CHG,
					DLD_INV_REQ_QTY_CHG,
					DLD_INV_COV_QTY_CHG, /*** Ver 2.1 *** Uncommented for Ver 2.3 **/
					DLD_RMRKS)
					VALUES
					(:sql_mtch_accnt,
					:sql_dbd_dp_id,
					:sql_dbd_dp_clnt_id,
					:sql_dbd_isin_nmbr,
					:sql_stk_stck_cd,
					:sql_dbd_tot_qty,
					:sql_dbd_qty_blckd,
					:sql_qty_plg,
					/** :sql_dbd_tifp_qty, ** Ver 2.1 **/
					:sql_dbd_rev_cov_qty,
					:sql_dbd_rev_req_qty, /*** Ver 2.1 ***/
					:sql_dbd_sam_blckd_qty,		/** Ver 2.1 **/
					sysdate,
					:sql_dbd_block_for_sale,
					:sql_dbd_inv_req_qty,
					:sql_dbd_inv_cov_qty, /*** Ver 2.1 ***/
					'Withdraw Modification');

					if(DEBUG_MSG_LVL_0)
					{
						fn_userlog(c_ServiceName,"After DLD Insert [%s]",sql_pml_rmrks.arr);
					}

					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31460", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

					if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg ) == -1 )
					{
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 ); 
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn ( TPFAIL, ERR_BFR, ( char * )ptr_fml_Ibuf, 0, 0 );
					}
					
					strcpy(c_err_msg,"Success");
/**				l_acnt_id = 0;			** Ver 1.1 : Commented  ***/
					i_err[0] = Fadd32(ptr_fml_Obuf,FFO_PLG_ORDR_RFRNC,(char *)sql_sbd_ordr_no.arr,0);
					i_err[1] = Fadd32(ptr_fml_Obuf,FFO_HAIRCUT ,(char *)&sql_stk_plg_haircut,0);
					i_err[2] = Fadd32(ptr_fml_Obuf,FFO_PLG_ORD_VAL,(char *)&sql_stck_plg_val,0);
/**				i_err[3] = Fadd32(ptr_fml_Obuf,FFO_ACTN_ID,(char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
					i_err[3] = Fadd32(ptr_fml_Obuf,FFO_STCK_CD,(char *)sql_stk_stck_cd, 0 ); 
					i_err[4] = Fadd32(ptr_fml_Obuf,FFO_ERR_MSG,c_err_msg, 0 ); 
					
					for (i=0; i < 5; i++)
					{
						if(i_err[i] == -1)
						{
							fn_errlog( c_ServiceName, "S31465", FMLMSG, c_err_msg  );
							fn_userlog(c_ServiceName, "The Fget32 error at [%d]",i);
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}
					}

					tpreturn( TPSUCCESS, 0, (char *)ptr_fml_Obuf, 0, 0 );		
					
					break;
				}
/*Withdraw Cancel*/
        case 'C' :
				{
						if(DEBUG_MSG_LVL_0)
						{
//						fn_userlog(c_ServiceName,"The withdraw req qty is [%ld] and request for cancel is [%ld]",(sql_dbd_rev_req_qty + sql_dbd_rev_cov_qty), sql_qty_plg);
						}
				/**** Ver 2.1 ****** Uncomment Start for Ver 2.3 **/	
					if((sql_dbd_rev_req_qty + sql_dbd_rev_cov_qty) < sql_qty_plg)
					{
						fn_userlog(c_ServiceName,"Cannot cancel this withdraw request as quantity is insufficient");
						strcpy(c_err_msg,"Cannot cancel this withdraw request as quantity is insufficient.");
						Fadd32( ptr_fml_Ibuf,FFO_ERR_MSG, c_err_msg, 0 );
						Fadd32( ptr_fml_Ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
						tpfree ( ( char * )ptr_fml_Obuf);
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
				/**** Ver 2.1 ****** Uncomment ENd for Ver 2.3 **/	
					/*The following variable will be used to hold the value of the stock withdraw*/	

					sql_stck_plg_val = (sql_qty_plg * (sql_ltq_plg_rt *(1 - ((double)(sql_stk_plg_haircut)/100))))*100; /*diwa
 typecast float to double **/

					if((long long)(sql_stck_plg_val * 100)%100 > 50)
					{
						sql_stck_plg_val = sql_stck_plg_val + 1.0;

						if(DEBUG_MSG_LVL_0)
						{
							fn_userlog( c_ServiceName, "The rounded off amount is [%lf]",sql_stck_plg_val);
						}
					}
				
					ll_stck_plg_val = (long long) sql_stck_plg_val;

					sql_stck_plg_val = (double) ll_stck_plg_val;
				
					if(DEBUG_MSG_LVL_0)
					{	
						fn_userlog(c_ServiceName,"The withdraw val is [%lf] for rate [%lf]",sql_stck_plg_val,sql_ltq_plg_rt);
					}
					
					i_trnsctn = fn_begintran( c_ServiceName, c_err_msg );
					if ( i_trnsctn == -1 )
					{
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
						fn_errlog( c_ServiceName, "S31470",LIBMSG,c_err_msg);
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}


					sql_pml_mod_type ='C';
					MEMSET(sql_pml_rmrks);
					strcpy(sql_pml_rmrks.arr,"User modified Withdrawal : Cancelled");
					SETLEN(sql_pml_rmrks);
		
					EXEC SQL SELECT PRS_PLG_REV_SEQ.nextval INTO :sql_prs_seq
					FROM DUAL;

					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31475", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
		
				/******** Ver 2.1 ********* Uncomment Starts for Ver 2.3 **/

					EXEC SQL UPDATE POD_PLG_ORDR_DTLS SET
					POD_ORDR_STTS = 'X', /*** replaced 'C' with 'X' in Ver 2.3 ***/	
					POD_CONF_QTY = 0,
					POD_RMRKS = :sql_pml_rmrks
					WHERE POD_CLNT_MTCH_ACCNT = :sql_mtch_accnt
					AND POD_DP_ACCNT = :sql_dbd_dp_id
					AND POD_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
					AND POD_PLG_REV_TYP = 'W'
					AND POD_ORDR_STTS = 'R'
          AND POD_ORDR_NO = :sql_pod_ordr_no  /** Ver 2.3 **/
					AND POD_STCK_CD = :sql_stk_stck_cd;
					/** RETURNING POD_ORDR_NO 
					INTO :sql_pod_ordr_no; **/

					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31480", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

          /** Ver 2.4 Starts **/

          EXEC SQL
          UPDATE PTD_TIFP_DTLS
          SET    PTD_TIFP_STTS ='X'
          WHERE  PTD_CLM_MTCH_ACCNT = :sql_mtch_accnt
          AND    PTD_DP_ID          = :sql_dbd_dp_id
          AND    PTD_DP_CLNT_ID     = :sql_dbd_dp_clnt_id
          AND    PTD_PLG_REV_TYP    = 'W'
          AND    PTD_TIFP_STTS      = 'N'
          AND    PTD_POD_REF_NO     = :sql_pod_ordr_no
          AND    trim(PTD_STCK_CD)  = trim(:sql_stk_stck_cd);

          if (SQLCODE != 0 && SQLCODE!= NO_DATA_FOUND)
          {
            fn_errlog( c_ServiceName, "S31485", SQLMSG, c_err_msg  );
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
            tpfree ( ( char * )ptr_fml_Obuf);
            fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          }

          /** Ver 2.4 Ends **/


					/** SETNULL(sql_pod_ordr_no); ** Ver 2.3 **/

					if(DEBUG_MSG_LVL_0)
					{
						fn_userlog(c_ServiceName,"The Pod ordr no is [%s][%ld]",sql_pod_ordr_no.arr,sql_pod_ordr_no.len);
					}

					EXEC SQL SELECT (COUNT(*)+1) INTO :sql_pml_mod_cntr 
					FROM PML_PLG_MOD_LOG
					WHERE PML_ORDR_NO = :sql_pod_ordr_no
					AND PML_CLNT_MTCH_ACCNT = :sql_mtch_accnt
					AND PML_DP_ACCNT = :sql_dbd_dp_id
					AND PML_DP_CLNT_ACCNT = :sql_dbd_dp_clnt_id
					AND PML_PLG_REV_TYP = 'W'
					AND PML_MOD_TYPE IN ('N','M','C');
		
					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31490", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

					if(DEBUG_MSG_LVL_0)
					{
						fn_userlog(c_ServiceName,"The mod counter is [%ld]",sql_pml_mod_cntr);
					}
				
					EXEC SQL UPDATE DBD_DP_BLCK_DTLS SET
					/** DBD_REV_REQ_QTY = 0, **/
					DBD_REV_REQ_QTY = DBD_REV_REQ_QTY - :sql_qty_plg,
					DBD_REV_COV_QTY = 0
					WHERE DBD_STCK_CD = :sql_stk_stck_cd
					AND DBD_CLM_MTCH_ACCNT = :sql_mtch_accnt
					AND DBD_DP_ID = :sql_dbd_dp_id
					AND DBD_DP_CLNT_ID = :sql_dbd_dp_clnt_id;
					
					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31495", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

					if(DEBUG_MSG_LVL_0)
					{
						fn_userlog(c_ServiceName,"The Adding in Plg limits amount in paise [%lf]",sql_stck_plg_val); 
					}

			/********* Ver 2.1 *** Uncomment End for Ver 2.3 **/

					MEMSET(sql_fab_bnk_accnt);

					/*** Commented for Ver 2.7 ***

					EXEC SQL UPDATE FAB_FO_ALC_BFT_SMRY SET
					**FAB_PLG_AMT = FAB_PLG_AMT + :sql_stck_plg_val	 *** V1.5 EQ SAM *
					FAB_NWB_AMT = nvl(FAB_NWB_AMT,0) + :sql_stck_plg_val	     * V1.5 EQ SAM* *Ver 1.6 nvl**
					WHERE FAB_CLM_MTCH_ACCNT = :sql_mtch_accnt
					RETURNING FAB_BNK_ACCNT,FAB_ALCTD_AMT,FAB_BFT_AMT
					INTO :sql_fab_bnk_accnt,:sql_fab_alctd_amt,:sql_fab_bft_amt;

					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31500", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

					SETNULL(sql_fab_bnk_accnt);

					EXEC SQL INSERT INTO FAL_FO_ALCBFT_LOG
					(FAL_CLM_MTCH_ACCNT,
					FAL_BNK_ACCNT,
					FAL_ALCTD_AMT,
					FAL_BFT_AMT,
					FAL_TRN_DT,
					FAL_OLD_PLG_AMT,
					FAL_NARRATION,
					FAL_NWB_AMT,
					FAL_NWB_CHG_AMT)				*Ver 1.5 *
					VALUES
					(:sql_mtch_accnt,
					:sql_fab_bnk_accnt,
					:sql_fab_alctd_amt,
					:sql_fab_bft_amt,
					sysdate,
					:sql_fab_plg_amt,
					'WL',
					:sql_fab_nwb_amt,				*Ver 1.5 *
					:sql_stck_plg_val);

					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31505", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

					*** End for Ver 2.7 ***/
			
						/** Added for Ver 2.7 **/

						EXEC SQL
							SELECT NVL(EAB_PLG_AMT,0)
							INTO :sql_eab_plg_amt
							FROM EAB_EQ_ALC_BFT_SMRY
							WHERE EAB_CLM_MTCH_ACCNT = :sql_mtch_accnt;

    					if (SQLCODE != 0 && SQLCODE!= NO_DATA_FOUND)
            	{
              	fn_errlog( c_ServiceName, "S31510", SQLMSG, c_err_msg  );
              	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              	tpfree ( ( char * )ptr_fml_Obuf);
              	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            	}

						EXEC SQL
							UPDATE EAB_EQ_ALC_BFT_SMRY
							SET EAB_PLG_AMT = NVL(EAB_PLG_AMT,0) + :sql_stck_plg_val/100
							WHERE EAB_CLM_MTCH_ACCNT = :sql_mtch_accnt;

           	if (SQLCODE != 0 && SQLCODE!= NO_DATA_FOUND)
            {
              fn_errlog( c_ServiceName, "S31515", SQLMSG, c_err_msg  );
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              tpfree ( ( char * )ptr_fml_Obuf);
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }
						else if (SQLCODE == NO_DATA_FOUND)
						{
							EXEC SQL
              UPDATE FAB_FO_ALC_BFT_SMRY
              SET FAB_PLG_AMT = nvl(FAB_PLG_AMT,0) + :sql_stck_plg_val
              WHERE FAB_CLM_MTCH_ACCNT = :sql_mtch_accnt
              RETURNING FAB_BNK_ACCNT,FAB_ALCTD_AMT,FAB_BFT_AMT
              INTO :sql_fab_bnk_accnt,:sql_fab_alctd_amt,:sql_fab_bft_amt;

            	if (SQLCODE != 0)
            	{
              	fn_errlog( c_ServiceName, "S31520", SQLMSG, c_err_msg  );
              	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              	tpfree ( ( char * )ptr_fml_Obuf);
              	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
              	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            	}

            	SETNULL(sql_fab_bnk_accnt);

            	EXEC SQL
              INSERT INTO FAL_FO_ALCBFT_LOG
                (FAL_CLM_MTCH_ACCNT,
                FAL_BNK_ACCNT,
                FAL_ALCTD_AMT,
                FAL_BFT_AMT,
                FAL_TRN_DT,
                FAL_OLD_PLG_AMT,
                FAL_NARRATION,
             		FAL_NWB_AMT,
                FAL_PLG_CHG_AMT)
                VALUES
                (:sql_mtch_accnt,
                :sql_fab_bnk_accnt,
                :sql_fab_alctd_amt,
                :sql_fab_bft_amt,
                sysdate,
                :sql_fab_plg_amt,
                'WL',
                :sql_fab_nwb_amt,
                :sql_stck_plg_val);

            	if (SQLCODE != 0)
            	{
              	fn_errlog( c_ServiceName, "S31525", SQLMSG, c_err_msg  );
              	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              	tpfree ( ( char * )ptr_fml_Obuf);
              	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
              	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            	}
						}
						else if (SQLCODE == 0)
						{
							  EXEC SQL
          				INSERT INTO
            			EAL_EQ_ALCBFT_LOG
              		(EAL_CLM_MTCH_ACCNT,
              		EAL_TRN_DT,
              		EAL_OLD_PLG_AMT,
              		EAL_PLG_CHG_AMT,
              		EAL_NARRATION)
          			VALUES
            		(:sql_mtch_accnt,
              	sysdate,
              	:sql_eab_plg_amt,
              	(:sql_stck_plg_val/100),
              	'WLCAN');

            	if (SQLCODE != 0)
            	{
              	fn_errlog( c_ServiceName, "S31530", SQLMSG, c_err_msg  );
              	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              	tpfree ( ( char * )ptr_fml_Obuf);
              	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
              	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            	}
						}

						/** End for Ver 2.7 **/
          /** Added for Ver 2.8 **/
            i_returncode = fn_get_prev_sam ( c_ServiceName,
                                             sql_mtch_accnt.arr,
                                             c_err_msg);
            if(i_returncode == -1)
            {
              fn_errlog( c_ServiceName, "S31535", SQLMSG, c_err_msg  );
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              tpfree ( ( char * )ptr_fml_Obuf);
              fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }
            /** End for Ver 2.8 **/
			/**** Commented for ver 2.1 *** Uncommented For Ver 2.3 **/

					if(DEBUG_MSG_LVL_0)
					{
					fn_userlog(c_ServiceName,"The PML_ORDR_NO is [%s]",sql_pod_ordr_no.arr);
					fn_userlog(c_ServiceName,"The PML_STCK_CD is [%s]",sql_stk_stck_cd);
					fn_userlog(c_ServiceName,"The PML_ORDR_QTY is [%ld]",sql_qty_plg);
					fn_userlog(c_ServiceName,"The PML_HAIRCUT is [%ld]",sql_stk_plg_haircut);
					fn_userlog(c_ServiceName,"The PML_ORDR_VL is [%ld]",sql_stck_plg_val);
					fn_userlog(c_ServiceName,"The PML_ISIN_NO is [%s]",sql_dbd_isin_nmbr);
					fn_userlog(c_ServiceName,"The PML_DP_CLNT_ACCNT is [%s]",sql_dbd_dp_clnt_id);
					fn_userlog(c_ServiceName,"The PML_DP_ACCNT is [%s]",sql_dbd_dp_id);
					fn_userlog(c_ServiceName,"The PML_CLNT_MTCH_ACCNT is [%s]",sql_mtch_accnt.arr);
					fn_userlog(c_ServiceName,"The PML_MOD_TYPE is [%c]",sql_pml_mod_type);
					fn_userlog(c_ServiceName,"The PML_MOD_CNTR is [%ld]",sql_pml_mod_cntr);
					fn_userlog(c_ServiceName,"The PML_PLCD_SQNC is [%ld]",sql_prs_seq);
					fn_userlog(c_ServiceName,"The PML_CHANNEL is [%s]",sql_pml_channel.arr);
					}	

					EXEC SQL INSERT INTO PML_PLG_MOD_LOG
					(PML_ORDR_NO,
					PML_STCK_CD,
					PML_ORDR_QTY,
					PML_ORDR_TM,
					PML_HAIRCUT,
					PML_ORDR_VL,
					PML_ISIN_NO,
					PML_DP_CLNT_ACCNT,
					PML_DP_ACCNT,
					PML_CLNT_MTCH_ACCNT,
					PML_PLG_REV_TYP,
					PML_MOD_TYPE,
					PML_STTS,
					PML_MOD_CNTR,
					PML_PLCD_SQNC,
					PML_BP_ID,
					PML_CHANNEL,
					PML_RMRKS)
					VALUES
					(:sql_pod_ordr_no,
					:sql_stk_stck_cd,
					:sql_qty_plg,
					sysdate,
					:sql_stk_plg_haircut,
					:sql_stck_plg_val,
					:sql_dbd_isin_nmbr,
					:sql_dbd_dp_clnt_id,
					:sql_dbd_dp_id,
					:sql_mtch_accnt,
					'W',
					:sql_pml_mod_type,
					'C',
					:sql_pml_mod_cntr,
					:sql_prs_seq,	
					:sql_sbd_bp_id,
					:sql_pml_channel,
					:sql_pml_rmrks);
						
					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31540", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			** Ver 1.1 : Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
		
				/********* ver 2.1 **** Uncomment End for Ver 2.3 **/

					EXEC SQL 
					INSERT INTO DLD_DP_LOG_DTLS
					(DLD_CLM_MTCH_ACCNT,
					DLD_DP_ID,
					DLD_DP_CLNT_ID,
					DLD_ISIN_NMBR,
					DLD_STCK_CD,
					DLD_TOT_QTY_CHG,
					DLD_QTY_BLCKD_CHG,
          /** Uncomment Start for Ver 2.3 **/
					DLD_PLG_REQ_QTY_CHG,
					/** DLD_TIFP_QTY_CHG, ** Ver 2.1 **/
					DLD_REV_COV_QTY_CHG,
					DLD_REV_REQ_QTY_CHG, /**** Ver 2.1 *** Uncomment End for Ver 2.3 **/
					DLD_SAM_BLCKD_QTY_CHG,		/*** Ver 2.1 ***/
					DLD_CHG_TM,
					DLD_BLK_FR_SALE_CHG,
				  DLD_INV_REQ_QTY_CHG,
					DLD_INV_COV_QTY_CHG, /*** Ver 2.1 *** Uncommenyt for Ver 2.3 **/
					DLD_RMRKS)
					VALUES
					(:sql_mtch_accnt,
					:sql_dbd_dp_id,
					:sql_dbd_dp_clnt_id,
					:sql_dbd_isin_nmbr,
					:sql_stk_stck_cd,
					:sql_dbd_tot_qty,
					:sql_dbd_qty_blckd,
					:sql_qty_plg,
					/** :sql_dbd_tifp_qty, ** ver 2.1 **/
					0,
					0, /**** Ver 2.1 ***/
					:sql_dbd_sam_blckd_qty,	/*** Ver 2.1 ***/
					sysdate,
					:sql_dbd_block_for_sale,
					:sql_dbd_inv_req_qty,
					:sql_dbd_inv_cov_qty, /*** Ver 2.1 ***/
					'Withdraw Cancellation');

					if (SQLCODE != 0)
					{
						fn_errlog( c_ServiceName, "S31545", SQLMSG, c_err_msg  );
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}

					if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg ) == -1 )
					{
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 ); 
/**					l_acnt_id = -1;
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
						tpfree ( ( char * )ptr_fml_Obuf);
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
						tpreturn ( TPFAIL, ERR_BFR, ( char * )ptr_fml_Ibuf, 0, 0 );
					}
					
					strcpy(c_err_msg,"Success");
/**				l_acnt_id = 0;			** Ver 1.1 : Commented  ***/
					i_err[0] = Fadd32(ptr_fml_Obuf,FFO_PLG_ORDR_RFRNC,(char *)sql_sbd_ordr_no.arr,0);
					i_err[1] = Fadd32(ptr_fml_Obuf,FFO_HAIRCUT ,(char *)&sql_stk_plg_haircut,0);
					i_err[2] = Fadd32(ptr_fml_Obuf,FFO_PLG_ORD_VAL,(char *)&sql_stck_plg_val,0);
/**				i_err[3] = Fadd32(ptr_fml_Obuf,FFO_ACTN_ID,(char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
					i_err[3] = Fadd32(ptr_fml_Obuf,FFO_STCK_CD,(char *)sql_stk_stck_cd, 0 ); 
					i_err[4] = Fadd32(ptr_fml_Obuf,FFO_ERR_MSG,c_err_msg, 0 ); 
		
					for (i=0; i < 5; i++)
					{
						if(i_err[i] == -1)
						{
							fn_errlog( c_ServiceName, "S31550", FMLMSG, c_err_msg  );
							fn_userlog(c_ServiceName, "The Fget32 error at [%d]",i);
/**						l_acnt_id = -1;
							Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		** Ver 1.1 : Commented  ***/
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
							tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
						}
					}
					
					tpreturn( TPSUCCESS, 0, (char *)ptr_fml_Obuf, 0, 0 );		
					

					break;
				}
        default:
    		strcpy(c_err_msg,"Invalid Operation Type" );
    		fn_errlog ( c_ServiceName, "S31555", DEFMSG, c_err_msg);
    		tpfree ( ( char * )ptr_fml_Obuf);
    		tpreturn ( TPFAIL, ERR_BFR, ( char * )ptr_fml_Ibuf, 0, 0 );
    		break;
  		} /*end of operation type (Modify/Cancel) switch for Withdraw*/

			break;

	  }	 /********* End of Withdraw *******/

		default:
		{
						strcpy(c_err_msg,"Invalid Operation Type" );
						fn_errlog ( c_ServiceName, "S31560", DEFMSG, c_err_msg);
						tpfree ( ( char * )ptr_fml_Obuf);
						tpreturn ( TPFAIL, ERR_BFR, ( char * )ptr_fml_Ibuf, 0, 0 );
						break;
		}
 	}	/*end of sql_sbd_sam_bkubk_typ switch*/
	
}/*end of service*/
