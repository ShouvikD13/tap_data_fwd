/******************************************************************************/
/*	Program	    			:	SFO_OPT_PLC_ORD                                       */
/*                                                                            */
/*  Input             : FFO_USR_ID                                            */
/*                      FFO_SSSN_ID                                           */
/*                      FFO_EBA_MTCH_ACT_NO																		*/
/*                      FFO_XCHNG_CD                                          */
/*                      FFO_PRDCT_TYP                                         */
/*                      FFO_UNDRLYNG                                          */
/*                      FFO_EXPRY_DT                                          */
/*                      FFO_EXER_TYP                                          */
/*                      FFO_OPT_TYP                                           */
/*                      FFO_STRK_PRC                                          */
/*                      FFO_CTGRY_INDSTK                                      */
/*                      FFO_ORDR_FLW                                          */
/*                      FFO_LMT_MKT_SL_FLG                                    */
/*                      FFO_ORD_TYP                                           */
/*                      FFO_DSCLSD_QTY                                        */
/*                      FFO_STP_LSS_TGR                                       */
/*                      FFO_ORD_TOT_QTY                                       */
/*                      FFO_LMT_RT                                            */
/*                      FFO_PIPE_ID                                           */
/*                      FFO_SPL_FLG                                           */
/*											FFO_CTCL_ID  					CTCL id		< Version 1.7>				*/
/*                                                                            */
/*  Optional          : FFO_SPRD_ORD_IND                                      */
/*                      FFO_ORD_SEQ                                           */
/*                      FFO_SEQ_NUM                                           */
/*                      FFO_SPRD_ORD_REF                                      */
/*                      FFO_SETTLOR                                           */
/*                      FFO_ORDR_VALID_DT                                     */
/*                      FFO_TRD_PSSWD                                         */
/*                                                                            */
/*  Output            : FFO_ORDR_RFRNC                                        */
/*                      FFO_PIPE_ID                                           */
/*                      FFO_CANCL_QTY                                         */
/*                      FFO_CHANNEL                                           */
/*                      FFO_CTGRY_INDSTK                                      */
/*                      FFO_EBA_MTCH_ACT_NO                                   */
/*                      FFO_DSCLSD_QTY                                        */
/*                      FFO_EXEC_QTY                                          */
/*                      FFO_EXER_TYP                                          */
/*                      FFO_EXPRD_QTY                                         */
/*                      FFO_EXPRY_DT                                          */
/*                      FFO_LMT_MKT_SL_FLG                                    */
/*                      FFO_LMT_RT                                            */
/*                      FFO_C_OPNPSTN_QTY                                     */
/*                      FFO_ACK_NMBR                                          */
/*                      FFO_OPT_TYP                                           */
/*                      FFO_ORD_TOT_QTY                                       */
/*                      FFO_ORD_TYP                                           */
/*                      FFO_ORD_VALID_DT                                      */
/*                      FFO_ORDR_FLW                                          */
/*                      FFO_ORDR_STTS                                         */
/*                      FFO_PRDCT_TYP                                         */
/*                      FFO_SPL_FLG                                           */
/*                      FFO_STP_LSS_TGR                                       */
/*                      FFO_STRK_PRC                                          */
/*                      FFO_TRD_DT                                            */
/*                      FFO_UNDRLYNG                                          */
/*                      FFO_XCHNG_CD                                          */
/*                                                                            */
/*  Description       : To place a fresh Options order or a Options order     */
/*                      forming part of a spread order.                       */
/*                                                                            */
/*  Log               : 1.0   13-Oct-2001   P.Senthil Kumar                   */
/*  Log               : 1.1   17-Jul-2002   Infotech|Sangeet                  */
/*  Log               : 1.2   19-Nov-2002   Infotech|Sangeet                  */
/*  Log               : 1.3   20-Jan-2003   Infotech|Sonali                   */
/*  Log               : 1.4   04-Apr-2003   Infotech|Mohit                    */
/*  Log               : 1.5   	 Jul-2003   Infotech|Sangeet                  */
/*  Log               : 1.6   24-Sep-2004   Infotech|Sangeet                  */
/*  Log               : 1.7   04-Oct-2005   Infotech|Jagapathi                */
/*  Log               : 1.8   21-Sep-2006   Infotech|Shailesh               	*/
/*  Log               : 1.9   21-Sep-2006   Infotech|Abhishek									*/
/*  Log               : 2.0   17-Apr-2007   Infotech|Vikash                   */
/*  Log               : 2.1   03-Jan-2008   Infotech|Smitha                   */
/*  Log               : 2.2   08-Jan-2007   Infotech|Vikash / Sushil          */
/*  Log               : 2.3   07-Feb-2008   Infotech|Vidya                    */
/*  Log               : 2.4   07-Nov-2008   Infotech|Shailesh                 */
/*  Log								: 2.5   02-Jan-2009		Infotech|Sandeep									*/
/*  Log               : 2.6   12-Mar-2009   Infotech|Vidyayini Krish					*/
/*  Log               : 2.7   12-Jun-2009   Infotech|Vidyayini Krish          */
/*  Log               : 2.8   15-Sep-2009   Infotech|Sangeet				          */
/*  Log               : 2.9   10-Aug-2010   Infotech|Shailesh                 */
/*	Log								: 3.0		22-Nov-2010		Infotech|Sandeep									*/
/*	Log								: 3.1		22-Nov-2010		Infotech|Sandeep									*/
/*	Log								: 3.2		05-Aug-2011		Infotech|Sandeep									*/
/*  Log               : 3.3   30-Aug-2011   Infotech|Sachin                   */
/*  Log               : 3.4   28-Nov-2011   Infotech|Navina D                 */
/*	Log								:	3.5		22-Dec-2011		Infotech|Sandeep									*/
/*  Log               : 3.6   11-Oct-2011   Infotech|Sandeep                  */
/*	Log								:	3.7		20-Jan-2012		Infotech|Navina D									*/
/*	Log								:	3.8		02-Jul-2012		Infotech|Mahesh 									*/
/*  Log               : 3.9   03-Jul-2012   Infotech|Navina 									*/
/*  Log               : 4.0   05-Nov-2012   Infotech|Sandeep                  */
/*  Log               : 4.1   02-Nov-2012   Infotech|Swati A.B								*/
/*  Log               : 4.2   05-Dec-2012   Infotech|Mahesh                   */
/*  Log               : 4.3   28-Jan-2013   Infotech|Swati A.B                */
/*  Log               : 4.4   04-Feb-2013   Infotech|Navina D.                */
/*  Log               : 4.5   13-Feb-2013   Infotech|Swati A.B								*/
/*  Log               : 4.6		25-Apr-2013   Infotech|Bhushan S                */
/*  Log               : 4.8   27-May-2013   Infotech|Bhushan S                */
/*  Log               : 4.9   13-May-2013   Infotech|Samip M                  */
/*  Log               : 5.0   03-Jun-2013   Infotech|Bhushan S                */
/*  log               : 5.1   02-Jul-2013   Infotech|Swati A.B                */
/*  Log               : 5.2   04-Jul-2013   Infotech|Sandeep                  */
/*  Log               : 5.3   01-Oct-2013   Infotech|Shashi K                 */
/*  Log               : 5.4   12-Sep-2013   Infotech|Swati A.B								*/
/*  Log               : 5.5   06-Nov-2013   Infotech|Swati A.B                */
/*  Log               : 5.7   21-Jan-2014   Infotech|Bhushan S                */
/*  Log               : 5.8   31-Jan-2014   Infotech|Sachin Birje             */
/*  Log								: 5.9		03-Feb-2014		Infotech|Bhushan S                */
/*	Log								: 6.0		13-Feb-2014		Infotech|Shailesh S.							*/
/*	Log               : 6.1   11-Mar-2014   Infotech|Bhushan S                */
/*  log               : 6.3   16-Apr-2014   Infotech|Vishnu N.                */
/*  log               : 6.4   04-Jun-2014   Infotech|Navina D.                */
/*  log               : 6.5   02-Jun-2014   Infotech|Sachin B.                */
/*  log               : 6.6   17-jun-2014   Infotech|Vishnu N.                */
/*  log               : 6.7   05-Jan-2015   Infotech|Vikram G.                */
/*  log               : 6.8   01-Aug-2014   Infotech|Vishnu N.                */
/*  log               : 6.9   05-Feb-2015   Infotech|Anand Dhopte             */
/*  log               : 7.0   24-Feb-2015   Infotech|Anand Dhopte             */
/*  log               : 7.1   07-Jul-2015   Infotech|Ritesh Deolekar          */
/*  log               : 7.2   07-Aug-2015   Infotech|Bhupendra Malik          */
/*  log               : 7.3   29-Sep-2015   Infotech|Anand Dhopte             */
/*  log               : 7.5   10-Oct-2015   Infotech|Kishor Borkar            */
/*  log               : 7.6   23-Oct-2015   Infotech|Sachin Birje             */
/*  log               : 7.7   29-Jan-2016   Infotech|Tanmay Warkhade          */
/*  log               : 7.8   22-Feb-2016   Infotech|Anand Dhopte             */
/*  log               : 7.9   26-Feb-2016   Infotech|Kishor Borkar            */
/*  log               : 8.0   10-Mar-2016   Infotech|Kishor Borkar            */
/*  log               : 8.1   05-Jul-2016   Infotech|Bhupendra Malik          */
/*  Log               : 8.2   04-Aug-2016   infotech|Tanmay Warkhade          */
/*  Log               : 8.3   29-Aug-2016   Infotech|Vishal Borhade           */
/*  Log               : 8.4   24-Oct-2016   Infotech|Bhupendra Malik/Kishor B.*/
/*  log               : 8.5   05-Dec-2016   Infotech|Kishor Borkar            */
/*  log               : 8.6   25-May-2017   Infotech|Samip M									*/
/*  log               : 8.7   14-Jun-2017   Infotech|Bhupendra Malik          */
/*  log               : 8.8   06-Mar-2017   Infotech|Kishor Borkar            */
/*  log               : 8.9   09-Mar-2018   Infotech|Navina                   */
/*  log               : 9.0   03-May-2018   Infotech|Parag Kanojia            */
/*  log               : 9.1   18-Jun-2018   Infotech|Anand Dhopte             */
/*  log               : 9.2   11-Jul-2018   Infotech|Parag Kanojia            */
/*  log               : 9.3   26-Jul-2018   Infotech|Suchita Dabir            */
/*  log               : 9.4   03-Sep-2018   Infotech|Suchita Dabir            */     
/*  log               : 9.5   09-May-2019		Infotech|Parag Kanojia            */     
/*  log               : 9.6   24-jul-2019		Infotech|Sachin Birje             */     
/*  log               : 9.7   18-Jun-2019   Infotech|Tanmay Patel             */
/*  log               : 9.8   24-Oct-2019   Infotech|Tanmay Patel             */
/*  log               : 9.9   13-Nov-2019   Infotech|Anand Dhopte             */
/*  log               : 10.0  28-Nov-2019   Infotech|Navina D.                */
/*  log               : 10.1  06-May-2020   Infotech|Navina D.                */
/*  log               : 10.2  22-OCT-2020   Infotech|Suchita Dabir            */  
/*	log								: 10.3  02-Feb-2021		Infotech|Kiran Itkar							*/  
/*	log								: 10.4  01-Mar-2021 	Infotech|Sachin Birje 						*/  
/*	log								: 10.5  18-May-2021 	Infotech|Sandip Tambe 						*/  
/*  log               : 10.6  29-May-2021   Infotech|Akash B                  */
/*  log               : 10.7  13-Jul-2021   Infotech|Kiran Itkar              */
/*	log               : 10.8  13-Jul-2021   Infotech|Gaurav C                 */
/*	log								: 10.9  10-Feb-2022   Infotech|Shlok Ghan               */	
/*  log               : 11.0  27-Jan-2022   Infotech|Sachin Birje             */
/*  log               : 11.1  07-Mar-2022   Infotech|Roshni Pawar             */
/*  log               : 11.2  27-Jun-2022   Infotech|Naveena R ,Ravi Malla    */
/*  log               : 11.3  09-Sep-2022   Infotech|Ravi Malla    						*/
/*  log               : 11.4  21-Sep-2022   Isec    |Dipin                    */
/*  log               : 11.5  02-Nov-2022   Infotech|Suchita Dabir.           */
/*  log               : 11.6  23-Nov-2022   Infotech|Ravi M          				  */
/*  log               : 11.7  06-Dec-2022   Infotech|Ravi M          				  */
/*  log               : 11.8  07-Mar-2023   Infotech|Vipul Sharma							*/
/*  log               : 11.9  22-Feb-2023   Ankita Satav                      */
/*  log     					: 12.0  30-Mar-2023   Infotech|Bhavana                  */
/******************************************************************************/
/*  1.0  -  New release                                                       */
/*  1.1  -  BP Changes                                                        */
/*  1.2  -  DT Changes                                                        */
/*  1.3  -  CR1038 To identify orders placed thro Super User                  */
/*  1.4  -  CR1041 Change in logic for calcutating the limit to be blocked    */
/*                 for Market Option Buy order.                               */
/*  1.5  -  Disabling GTD Orders																							*/
/*  1.6  -  New Locking Mechanism for Place Order															*/
/*  1.7  -  Getting ctcl_id,channel from order book  view											*/
/*  1.8  -  Handling of order flow in case of NULL														*/
/*  1.9  -  Exchange status check for corporate action using 									*/
/*					c_xchng_rmrks field from vw_xchngbook															*/
/*  2.0  -  Broker status check for NNF 803                                   */
/*  2.1  -  For MINIFT                                                        */
/*  2.2  -  DLrevamp Changes for Adding SLTP checks and Trading details check */
/*          Returning the Order Details if the Channel is APP or VSAT         */
/*					Passing user_id only when DL allowed															*/
/*					Commenting the change in category for CNXIT	underlying (SKS)			*/
/*  2.3  -  IBM Changes                                                       */
/*  2.4  -  Trading Limit Password check introduced                           */
/*	2.5  -  NNF Changes For Extended Market Hours															*/
/*  2.6  -  CRCNT22353 Adding CSE user id for CNT orders (only fresh orders)	*/
/*  2.7  -  CRCON31530 Additional check added to avoid freeze orders          */
/*  2.8  -  Order Type and SLM Flag Null Fix												          */
/*  2.9  -  Blocking Index Stk Type null bug                                  */
/*	3.0	 -  BPID Changes        																							*/
/*	3.1	 -  SILVERLIGHT Changes 																							*/
/*	3.2	 -  User ID Changes																										*/
/*  3.3  -  Global Indices Changes                                            */
/*  3.4  -  DBC user - Incorrect nick name handling                           */
/*	3.5	 -	Channel Bug Fix																										*/
/*  3.6  -  SPAN Changes                                                      */
/*	3.7	 -	BSE ORS Changes																										*/
/*	3.8	 -	Span TNC flag handling																						*/
/*	3.9	 -	Storing ip address in Exchange book																*/
/*  4.0  -  Ind/Stk Selection if condition added                              */
/*	4.1	 -	CR-Overnight Orders Changes																				*/
/*  4.2  -  Broker closeout changes                                           */
/*  4.3  -  Consolidated Order Validation changes                             */
/*  4.4  -  SPAN FuturePLUS handling                                          */
/*  4.5  -  Removal of Limit Alloc/Dealloc in Corp Action Changes							*/
/*	4.6	 -	System Place Order Changes for DL.NET                             */
/*  4.8	 -  Restrict DBC mapped customer to place order if CLM_TRD_FLG = 'N'  */
/*  4.9  -  Modify Allocation Changes                                         */
/*  5.0  -  Condition added for CNT Channel                                   */
/*  5.1  -  Changes in Error code handlingof function contract check  for     */
/*        -  Modification of orders under BAN period                          */
/*  5.2  -  Channel Handling Introduced for New Trade Racer                   */
/*  5.3  -  Handling Option Market max sell qtantity                          */
/*  5.4  -  OptionPLUS changes.  								                              */
/*  5.5  -  FNO limit Logging (Swati A.B)                                     */
/*  5.7  -  Contract Note Changes                                             */
/*  5.8  -  FO BSE Ack Number Changes                                         */
/*	5.9	 -  OptionPlus  Client and System SquareOff Changes										*/
/*  6.0  -  Price range function check added  for OptionPlus cover order      */
/*	6.1	 -  OptionPLUS Bug Fix																								*/
/*  6.3  -  Service call to SFO_GET_QT commented and function introduced      */
/*  6.4  -  Exception EOS for OptionPLUS                                      */
/*  6.5  -  FNO Common TNC Changes                                            */
/*  6.6  -  Multiple DB Hits to CLM_CLNT_MSTR reduced by fetching all         */
/*          required details into single DB hit.                              */
/*  6.7  -  Error Handling for Sqrf Qty                                       */
/*  6.8  -  Changes for AUTO MTM																							*/
/*  6.9  -  Insufficient Limits - Modify Allocation changes for DL .Net       */
/*  7.0  -  character array c_sys_msg size changed from 4 to 11(Live Bug Fix) */
/*  7.1  -  Contract master & Trade Quote merger Changes.                     */
/*  7.2  -  Include changes for Insider trading check                         */
/*  7.3  -  TPSUSPEND & TPRESUME commented in case of Insufficient Limit case */
/*          to resolve RNA isssue while placeing 2L/3L order									*/
/*  7.5	 -	Changes related Market to Limit in Option Plus.										*/	
/*  7.6  -  OptionPlus to Option convertion changes                           */
/*  7.7  -  Migration of RI to NRI                                            */
/*  7.8  -  Live Bug Fix                                                      */
/*  7.9  -  Cloud order changes                                               */
/*  8.0  -  Transaction Flag in Check Session IP                              */
/*  8.1  -  Log maintainence                                                  */
/*  8.2  -  MYEOS changes                                                     */
/*  8.3  -  Remove the Check of max order value for orders placed in          */
/*          Corporate action and Offline order upload process.                */
/*  8.4   - parameters of fn_upd_xchngbk changed             */ 
/*  8.5  -  Transaction through IP in OPTION PLUS                             */
/*  8.6  -  Check Session IP Phase 3																					*/
/*  8.7  -  Nick name issue fix for dbc customer for quick exit               */
/*  8.8  -  Optimization                                                      */
/*  8.9  -  Oplus Offline fix                                                 */
/*  9.0  -  NNF_CHANGES_7.21(PAN CHANGES)                                     */
/*  9.1  -  Disallow clients with outstanding form taking fresh exposure      */
/*  9.2  -  Physical Settlement of Stock Derivative Changes                   */
/*  9.3  -  Handling deadlock for EOS,Quick exit,sltp cover placement         */
/*  9.4  -  Physical Settlement of Stock Derivative Changes phase II          */
/*  9.5  -  EOS enhancements for Physical settlement in F&O Changes						*/
/*  9.6  -  Physical Delivery Margin Changes (Sachin Birje)                   */
/*  9.7  -  Handling checks of sqroffmode for offline order (Tanmay Patel)    */
/*  9.8  -  Ipv6 Format (Tanmay Patel)                                        */
/*  9.9  -  CR-ISEC18-127640 Sub-broker dual order placement changes          */
/*  10.0 -  Sensibull Integration (Navina D.)				   												*/
/*  10.1 -  Remove SOVL check for Optionplus  (Navina D.)                     */
/*  10.2 -  CR_ISEC14_139243 Opls changes ( Suchita Dabir)                    */
/*	10.3 -  Separate EOS for Stock and Index Underlyings in OptionPlus(Kiran) */ 
/*	10.4 -  Minor Change: Multi Leg order in single pipe id Changes           */ 
/*	10.5 -  Derivative_trd_restrict_CR_ISEC04_152948                          */ 
/*  10.6 -  FNO UCC Changes ( Akash B)                                        */
/*  10.7 -  fn_disallow_frsh_expsre                                           */
/*	10.8 -  One Click Derivative Changes ( Gaurav C )                         */
/*	10.9 -  CR-ISEC14-165712 Enhancements to Physical settlement Stocks disable contracts and EOS for Options Buy (Shlok Ghan) */
/*  11.0 -  CR-ISEC14-169739 -Introduction of Algorithm Trading Strategies (Sachin Birje)*/
/*  11.1 -  CR-ISEC14-163069 Disable market order placement for illiquid options contracts under F&O segment (Roshni Pawar) */	
/*  11.2 -  Flash Trade                                                       */
/*  11.3 -  Flash Trade - validation changes                                  */
/*  11.4 -  CR-ISEC18-175354_ Unique Device Identifiers                       */      
/*  11.5 -  Option plus live issue - validation on order link on open position page                    */      
/*  11.6 -  Flash Spira change to change 5 mins to 15mins                     */      
/*  11.7 -  Minor changes - Changing default customer consent as "Yes"        */  
/*  11.8 -  Changing fn_lock_usr to fn_lock_fno																*/    
/*  11.9 -  Flash Trade in F&O Segment,Till Expiry Spira Changes              */ 
/******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sqlca.h>
#include <atmi.h>
#include <fml32.h>
#include <fo.h>
#include <eba_to_ors.h>
#include <fo_fml_def.h>
#include <fo_view_def.h>
#include <fn_log.h>
#include <fn_session.h>
#include <fn_tuxlib.h>
#include <fn_ddr.h>
#include <fml_rout.h> /* Ver 2.3 */
#include <fn_read_debug_lvl.h> /* 2.3 */
#include<fn_val_ord.h> /* 2.4 */
#include <fn_pos.h>		/* Ver 3.9 */
#include <fo_get_records.h> /* Ver 6.3 */
EXEC SQL INCLUDE "table/fum_fo_undrlyng_mstr.h"; /* Ver 2.7 */

#define FAILED 'Y'

int fn_check_inp_opt( char *c_ServiceName,
                  struct vw_xchngbook *ptr_st_xchngbook, 
                  struct vw_cntrct_qt *ptr_st_cntrct_qt, 
									char c_fum_mrkt_typ,                 /* Ver 2.5 */
                  char c_fcm_mrkt_typ,                 /* Ver 2.5 */
                  struct vw_err_msg *ptr_st_err_msg );

int fn_check_ord_opt( char *c_ServiceName,
                  struct vw_cntrt_gen_inf *ptr_st_cntrt_gen_inf, 
                  struct vw_xchngbook *ptr_st_xchngbook, 
                  struct vw_orderbook *ptr_st_ordbook, 
                  struct vw_err_msg *ptr_st_err_msg ) ;

int fn_get_trdng_dtls(  char *user_id,
                        char *mtch_accnt,
                        char *trd_flag,
                        char *prod_code ); /* Ver 2.3 */

int fn_chk_closeout(char *c_ServiceName,
                    char *,               /* Ver 4.2 */
                    char ,                /* Ver 4.2 */
										struct vw_contract, 
                    struct vw_xchngbook *ptr_st_xchngbook,
                    struct vw_err_msg *ptr_st_err_msg ); /* Ver 2.3 */

/** Commented for Ver 8.6 ***
int fn_check_user(char *c_ServiceName,
                  struct vw_usr_prfl *ptr_st_usr_prfl,
                  char *c_usr_psswrd,
                  char c_psswd_req_flg,
                  struct vw_err_msg *ptr_st_err_msg ); * Ver 2.3 *
*** Ver 8.6 **/

int fn_chk_cntrct_sqoff(char * c_ServiceName,
                        struct vw_contract *ptr_st_cntrct,
												char *c_fum_mrkt_typ,                 /* Ver 2.5 */
                        char *c_fcm_mrkt_typ,                 /* Ver 2.5 */
                        struct vw_err_msg *ptr_st_err_msg ); /* Ver 2.3 */

int fn_chk_cntrct(char * c_ServiceName,
                  struct vw_contract *ptr_st_cntrct,
									char *c_fum_mrkt_typ,									/* Ver 2.5 */
									char *c_fcm_mrkt_typ,									/* Ver 2.5 */
                  struct vw_err_msg *ptr_st_err_msg ); /* Ver 2.3 */

int fn_ins_ordrbook ( char  *c_ServiceName,                   /***  Ver 3.1 ***/
                      char  *c_user_id,
											char   c_span_flag,                     /*** Ver 6.6 ***/
                      char   c_source_flg,                    /*** Ver 7.9 ***/
											char *c_pan_no,												/*** Added In Ver 9.0 ***/
                      char	c_setlmnt_flg,           /*** Ver 9.4 ***/ 
											char *c_ven_id,											  /*** ver 10.0 ***/
                      char *c_algo_id,               /*** Ver 11.0 **/
                      char *c_algo_ord_rmrks,        /*** Ver 11.0 **/
   										long l_sqroff_tm, /* Ver 11.2 */
                      char c_fc_flg,    /* Ver 11.2 */
                      struct vw_orderbook *ptr_st_ordbook,
                      struct vw_err_msg *ptr_st_err_msg,
                      char c_1clk_flg,          /** Ver 10.8 **/
                      char *c_1clk_prtflio_id   /** Ver 10.8 **/
                    );


/*** Ver 5.4 Starts ***/

int fn_chk_cntrct_sltpfp_sqoff(char * c_ServiceName,								
                              struct vw_contract *ptr_st_cntrct,
                              char *c_fum_mrkt_typ,
                              char *c_fcm_mrkt_typ,
                              struct vw_err_msg *ptr_st_err_msg );  


int fn_eos_optpls ( char  *c_ServiceName,												
                    char  *c_cover_ord_ref,
                    struct vw_orderbook *ptr_st_ordbook,
                    struct vw_err_msg *ptr_st_err_msg
                   );                                        

int fn_cover_optpls ( char  *c_ServiceName, 									
                    char  *c_cover_ord_ref,
                    struct vw_orderbook *ptr_st_ordbook,
                    struct vw_pstn_actn *ptr_st_pstn_actn,
                    struct vw_err_msg *ptr_st_err_msg
                   );   
int fn_off_optpls ( char  *c_ServiceName,
                    char  *c_fresh_ord_ref,
                    struct vw_orderbook *ptr_st_ordbook,
                    struct vw_err_msg *ptr_st_err_msg
                   );                                   

void fn_round2(double*); 
void fn_avg_price(long *, long *,  double *,int); 
/*** Ver 5.4 Ends ***/

/*** Ver 6.4 starts ***/
int fn_excpt_eos_optpls ( char  *c_ServiceName,												
													char  *c_cover_ord_ref,
													struct vw_orderbook *ptr_st_ordbook,
													struct vw_err_msg *ptr_st_err_msg
												);     
/*** Ver 6.4 ends ***/

int fn_get_quote_zero ( char *c_ServiceName, char c_ord_flw, long l_best_bid_price, long l_best_offer_price, long l_previous_close_price, long *l_quote_zero);   /*** Added in Ver 9.5 ***/

void SFO_OPT_PLC_ORD( TPSVCINFO *rqst )
{
	FBFR32 *ptr_fml_Ibuf;
	FBFR32 *ptr_fml_Obuf;

	char c_ServiceName[33];
	char c_err_msg[256];
	char c_msg[256];
	char c_trdng_psswrd_flg = YES;
	char  c_temp_psswrd[LEN_USR_TRDNG_PSSWRD];
  char c_usm_sup_usr_typ;				/*1.1 BP*/
  char c_channel[4];						/*1.1 BP*/
  char c_alias[9];							/*1.1 BP*/
  char c_bp_id[9];							/*1.1 BP*/
  char c_fno_dmn_nm [ 16 ];
  char c_fno_trg_nm [ 16 ];
  char c_fno_trg_dat [ 256 ];
 /**  char c_xchng_ack [ 16 ];      *2.2 DL* ** Ver 5.8 **/
  char c_xchng_ack [ 20 ];   /** Ver 5.8 **/
  char prd[4] = "FNO";          /*2.2 DL*/ /* Ver 2.3 changed from 3 to 4 */
  char c_trd_dtls;              /*2.2 DL*/
	char c_fum_mrkt_typ;					/* Ver 2.5 */
	char c_fcm_mrkt_typ;					/* Ver 2.5 */
	char c_fno_allwd;			/***	Ver	3.0	***/
  char c_user_id[16];           /* Ver 3.1 */
  char  c_trd_flg;      /***  Ver 3.2 ***/
	char c_spn_flg;       /***  Ver 3.6 ***/
	char c_bse_spn_flg;       /***  Ver 3.6 ***/
	char c_ip_address[45+1]="\0"; /** Changed to 45 from 15 in Ver 9.8 **/	/* Ver 3.9 */
	char c_request_typ = 'P';       /***  Ver 4.2 ***/
	char c_ord_val_flg = 'N';     /* Ver 4.3 */
	char c_cumopn_val_flg = 'N';     /* Ver 4.3 */
	char c_serv_call_flg = '\0';     /* Ver 4.3 */
	char c_call_source[20] = "\0";  /* Ver 5.4 */
  /***  char c_sys_msg[4] = "\0";       * Ver 5.4 *** Array size changed to 11 in Ver 7.0 ***/
	char c_sys_msg[21] = "\0";      /* Ver 7.0 */ /* VER TOL : TUX on LINUX -- Array size changed from 11 to 21 (Ravindra) */
	char c_optpls_allwd = '\0'; 		/* Ver 5.4 */
	char c_optpls_eos = '\0';   		/* Ver 5.4 */
	char c_cover_ord_ref[19]="\0";				/* Ver 5.4 */
	char c_fresh_ord_ref[19] = "\0";			/* Ver 5.4 */
	char c_ordr_ref_to_upd[19] = "\0" ;		/* Ver 5.4 */
  char c_actn_flg = '\0';     /* Ver 5.5 */
	char c_span_flag = '\0';          /* Ver 6.6 */
  char c_alias_nm[9];               /** Ver 6.6 **/
  char c_nkd_blkd_flg='\0';     /** Ver 6.8 **/
  char c_lmt_allwd_flg='\0';    /** Ver 7.5 **/
  char c_source_flg='\0';    /** Ver 7.9 **/
  char c_txn_flg='Y';             /*** Ver 8.0 ***/
  char c_myeos_frs_ord_ref[19] = "\0";/*** Ver 8.2 ***/ 
  int i_pnd_stts = 0 ;           /*** Ver 8.2 ***/
  int i_open_qt = 0 ;           /*** Ver 8.2 ***/

  char c_mleg_pipe_id[3];       /* Ver 10.4 */
  char c_ucc_flg='N';          /* Ver 10.6 */
	 
	char c_1clk_flg='\0';             /** Ver 10.8  **/
  char c_1clk_prtflio_id[11];       /** Ver 10.8  **/

	int i_mtm_flg = 0;            /* Ver 5.4 */
	int i_returncode = 0 ;				/* Ver 5.4 variable initialized ***/
	int i_trnsctn;
  int i_err[30]; /* Ver 2.3 Changed from 16 to 30 */
  int i_ferr[30]; /* Ver 2.3 Changed from 16 to 30 */
  int i_cnt;
  int i_ip_len;
  int i_op_len;
  int i_level_exists;
  int i_corp_rec_exists = 0;   /*** Ver 4.1 ***/
	int i_is_dbc_cust;            /***  Ver 4.8 ***/
	int i_excp_flag = 0; /*** Ver 6.4 ***/
  int insider_exist = 0;  /* Ver 7.2 */
  int i_popup=0;    /** Ver 11.7 **/

	long	l_record_cnt ;
	long	l_token ;
	long	l_opnpstn_qty = 0 ;
  long  l_can_qty = 0; /*2.2 DL*/
  long  l_open_qty = 0; /*2.2 DL*/
  long  l_exprd_qty = 0; /*2.2 DL*/
  long  l_ord_lmt_rt=0;  /* Ver 2.4*/
	int 	i_counter = 1;
	int 	i_actn_id	=	-1 ;			/***	Ver	3.1	***/
  long  l_cvr_qty;            /*** Ver 3.1  ***/
  long  l_opn_qty = 0;        /*** Ver 3.1  ***/
	long  l_clnt_ctgry;     /** Ver 6.6 **/
	long l_init_sltp_rt=0;	/*** Ver 8.4 ***/
  long l_init_lmt_rt=0;		/*** Ver 8.4 ***/
  long l_lTP=0;			/*** Ver 8.4 ***/
  long l_trail_amt=0;		/*** Ver 8.4 ***/
  long l_lmt_offset=0;		/*** Ver 8.4 ***/
  char c_prcimpv_flg='\0';	/*** Ver 8.4 ***/
	long l_sqroff_tm=0; /*** Ver 11.2 ***/
	char c_fc_flg ='\0'; /*** Ver 11.2 ***/

	/*** Ver 11.3 start***/
  long l_buy_exe_qty=0;
  long l_sell_exe_qty=0;
  long l_sell_ord_qty=0;
  long l_buy_ord_qty=0;

  long l_fe_sell_qty=0;
  long l_fe_buy_qty=0;
  long l_fp_sell_qty=0;
  long l_fp_buy_qty=0;

  long l_site_sell=0;
  long l_site_buy=0;
  long l_site_osell=0;
  long l_site_obuy=0;

  char c_popup_flg='\0';
  char c_popup='P';
	int fav_cnt=0;
  /*** Ver 11.3 end***/

	/* Ver 1.4 */
	long int li_aval_ordqty;
	int      i_condition = 1;
	double   d_totordrval = 0.0000;
	/* Ver 1.4 end */
  long int li_max_sell_ordqty=0;  /**Ver 5.3 ***/
	double   d_netadj_ord_val = 0.0000;  /*** Ver 4.3 ***/

  /* 4.9 Starts */
  double d_required_amt = 0.0;
  char c_insuff_flg = 'N';
  /* 4.9 Ends */

  /*** ver 9.3 starts ***/
  char c_sltplck_ord_ref[19];
  char c_sltp_ord_rfrnc_lck[2][19];
  char c_ordr_rfrnc_lck[2][19];
  /*** ver 9.3 ends **/

  long l_old_ord_qty = 0;   /*** Ver 9.1 ***/

	/*** Ver 9.5 Starts ***/
	int  i_phy_sqroff_check = 0;
	long l_quote_zero = 0;
	long l_best_bid_price = 0;
	long l_best_offer_price = 0;
	long l_previous_close_price = 0;
	/*** Ver 9.5 Ends ***/
  
  TPTRANID tranid  ; /*** Ver 5.5 ***/

	/*** Ver 9.2 Starts ***/
  char c_dlvry_pos_allwd = 'Y';
  char c_setlmnt_flg = 'C';
  char c_dlvry_eos_flg = 'N';
  /*** Ver 9.2 Ends ***/

  char c_mrkt_ordr_flg = '\0'; /** ver 11.1 **/

	/*** ver 10.9 start ***/
  char c_buy_allwd = '\0';
  char c_sell_allwd = '\0';
  /*** ver 10.9 end ***/

	varchar c_ven_id[50+1];  /*** Ver 10.0 ***/
	MEMSET (c_ven_id);			 /*** Ver 10.0 ***/
	varchar c_ven_nm[15] = {'\0'};        /*** Ver 10.0 ***/
  varchar c_algo_ord_rmrks[50];  /** Ver 11.0 **/
  varchar c_algo_id[50];  /** Ver 11.0 **/

	EXEC SQL BEGIN DECLARE SECTION;
		struct vw_cntrctlong_qt st_cntrctlong_qt; /* Ver 1.4 */
		struct vw_contract st_cntrct;
		struct vw_usr_prfl st_usr_prfl;
		struct vw_orderbook st_ordbook;
		struct vw_xchngbook st_xchngbook;
    varchar c_expiry_dt [ LEN_DATE ];
 /*   varchar sql_usr_usr_psswrd [ LEN_USR_TRDNG_PSSWRD ];  */		/***** VER 2.2 	*******/
		long l_ord_seq_num;
		long l_xchng_seq_num;
		char c_seq_num[9];
    varchar v_user_id [ 9 ];         /*2.2 DL*/
    varchar v_user_id_bkup [ 9 ];    /*2.2 DL*/
		varchar c_date[9];
		varchar c_trd_dt[LEN_DATE];
		varchar c_nrml_trd_dt[LEN_DATE];   /*** Ver 4.1 ***/
		varchar c_sysdate[LEN_DATE];
		varchar c_usr_usr_psswrd[50+1];
		varchar v_pan_no[30+1];						/*** Added In Ver 9.0 ***/
	EXEC SQL END DECLARE SECTION;

	EXEC SQL INCLUDE "table/usr_user_master.h";  					/******   VER 2.2   ******/
	EXEC SQL INCLUDE "table/icd_info_client_dtls.h";         /*** Ver 7.7 ***/

	struct vw_cntrct_qt st_cntrct_qt;
	struct vw_sequence st_s_sequence;
	struct vw_sequence st_r_sequence;
	struct vw_pstn_actn st_pstn_actn;
	struct vw_cntrt_gen_inf st_cntrct_gen_inf;
	struct vw_err_msg st_err_msg;
	MEMSET(st_err_msg); 											/*** Ver 4.3 ***/
	MEMSET(c_temp_psswrd);   /*** Ver 4.9 ***/
  MEMSET(c_usr_usr_psswrd); /*** Ver 4.9 ***/
	MEMSET(st_cntrctlong_qt);    /*** Ver 6.1 ***/
  MEMSET(c_err_msg);           /** Ver 6.5 **/
	MEMSET(v_pan_no);						 /*** Added In Ver 9.0 ***/

  /*** ver 9.3 startes ***/
  MEMSET( c_sltplck_ord_ref );
  MEMSET(c_sltp_ord_rfrnc_lck);
  MEMSET(c_ordr_rfrnc_lck);
  /*** ver 9.3 ends ***/

  MEMSET(c_mleg_pipe_id);   /** Ver 10.4 **/

	ptr_fml_Ibuf = (FBFR32 *)rqst->data;
	strcpy( c_ServiceName, rqst->name );
	INITDBGLVL(c_ServiceName);

	i_returncode = Fvftos32( ptr_fml_Ibuf, 
                           (char *) &st_cntrct, 
                           "vw_contract" );
	if ( i_returncode == -1 )
	{
		fn_errlog( c_ServiceName, "S31005", FMLMSG, c_err_msg  );
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
		Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}
	
  i_returncode = Fvftos32( ptr_fml_Ibuf, 
                           (char *) &st_usr_prfl, 
                           "vw_usr_prfl" );
	if ( i_returncode == -1 )
	{
		fn_errlog( c_ServiceName, "S31010", FMLMSG, c_err_msg  );
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
		Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
	  Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
  	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}

  i_returncode = Fvftos32( ptr_fml_Ibuf, 
                           (char *) &st_xchngbook, 
                           "vw_xchngbook" );
	if ( i_returncode == -1 )
	{
		fn_errlog( c_ServiceName, "S31015", FMLMSG, c_err_msg  );
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
		Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
	  Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
  	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}
  strcpy ( ( char * )c_expiry_dt.arr, st_cntrct.c_expry_dt );
  SETLEN ( c_expiry_dt );

	if(DEBUG_MSG_LVL_5)
	{
		fn_userlog(c_ServiceName,"HEMAN Exp :%s:",c_expiry_dt.arr);
	}

  /*** Ver 10.4 Starts Here ***/
  if( st_xchngbook.c_spl_flg == ROLLOVER_WITH_SPREAD ||
      st_xchngbook.c_spl_flg == ROLLOVER ||
      st_xchngbook.c_spl_flg == L2_ORDER ||
      st_xchngbook.c_spl_flg == L3_ORDER ||
      st_xchngbook.c_spl_flg == JOINT_SQUAREOFF 
    ) 
  {
    MEMSET(c_mleg_pipe_id);
    strcpy(c_mleg_pipe_id,"NA");
    i_err[0]  = Fget32(ptr_fml_Ibuf,FFO_INDX_CD,0,(char *)c_mleg_pipe_id,0);
    i_ferr [0] = Ferror32;

    if ( i_err[0] == -1 )
    {
     if ( Ferror32 != FNOTPRES )
     {
       fn_errlog( c_ServiceName, "S31020", FMLMSG, c_err_msg  );
       Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
       Fadd32( ptr_fml_Ibuf,FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
       tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     }
     else if( Ferror32 == FNOTPRES )
     {
       strcpy(c_mleg_pipe_id,"NA");
     }
    }

    fn_userlog(c_ServiceName,"c_mleg_pipe_id :%s:",c_mleg_pipe_id);

    if(strcmp(c_mleg_pipe_id,"NA") !=0 )
    {
      strcpy(st_xchngbook.c_pipe_id,c_mleg_pipe_id);
    }

    fn_userlog(c_ServiceName,"st_xchngbook.c_pipe_id :%s:",st_xchngbook.c_pipe_id);
  }
  /*** Ver 10.4 Ends Here ***/


  /*** Ver 7.9 Starts Here ***/

    i_err[0]  = Fget32(ptr_fml_Ibuf,FFO_STATUS_FLG,0,(char *)&c_source_flg,0);
    i_ferr [0] = Ferror32;

    if ( i_err[0] == -1 )
    {
      if ( Ferror32 != FNOTPRES )
      {
        fn_errlog( c_ServiceName, "S31025", FMLMSG, c_err_msg  );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
      else if( Ferror32 == FNOTPRES )
      {
        c_source_flg='O';
      }
    }
		if(DEBUG_MSG_LVL_3) /********* DEBUG_MSG_LVL Added in Ver 8.1 *******/
		{
			fn_userlog( c_ServiceName, "After getting source flag..................**************************>>:%c:",c_source_flg);
		}
		/*** Ver 7.9  Ends Here ***/

		/** Ver 11.3 by Ravi Start **/
		 l_site_sell=0;l_site_buy=0;l_site_osell=0;l_site_obuy=0;
    if( st_cntrct.c_prd_typ == 'F' || st_cntrct.c_prd_typ == 'O' )
    {
      EXEC SQL
      SELECT
          NVL(ABS(FOP_OPNPSTN_QTY),0) PSTN_QTY,
          NVL(FOP_BUY_EXCTD_QTY,0) PSTN_E_QBUY,NVL(ABS(FOP_SELL_EXCTD_QTY),0) PSTN_E_QSELL,
          NVL(GREATEST( ABS(FOP_ISELL_QTY), ABS(FOP_EXSELL_QTY)),0) PSTN_SELL_QTY,
          NVL(GREATEST( ABS(FOP_IBUY_QTY), ABS(FOP_EXBUY_QTY)),0) PSTN_BUY_QTY
      INTO
          :l_opnpstn_qty,
          :l_buy_exe_qty,:l_sell_exe_qty,
          :l_sell_ord_qty,:l_buy_ord_qty
      FROM
          FOP_FO_OPTIONS_PSTN
      WHERE
          FOP_CLM_MTCH_ACCNT    = :st_usr_prfl.c_cln_mtch_accnt
          AND FOP_UNDRLYNG        = :st_cntrct.c_undrlyng
          AND FOP_EXPRY_DT        = :st_cntrct.c_expry_dt
          AND FOP_PRDCT_TYP       = :st_cntrct.c_prd_typ
          AND FOP_XCHNG_CD        = :st_cntrct.c_xchng_cd
          AND FOP_STRK_PRC        = :st_cntrct.l_strike_prc
          AND FOP_EXER_TYP        = :st_cntrct.c_exrc_typ
          AND FOP_OPT_TYP         = :st_cntrct.c_opt_typ;

			if( (SQLCODE != NO_DATA_FOUND) && (SQLCODE != 0))
      {
        fn_errlog( c_ServiceName, "S31030",SQLMSG,c_err_msg);
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID , (char *)&i_actn_id , 0 );   /*** Ver 3.0 ***/
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT,(char *)&d_required_amt,0);   /*** Ver 5.8 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 5.8 ***/
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
      if (SQLCODE == NO_DATA_FOUND)
      {
        l_opnpstn_qty = 0;l_buy_exe_qty=0;l_sell_exe_qty=0;l_sell_ord_qty=0;l_buy_ord_qty=0;
      }

			l_fe_sell_qty=0;l_fe_buy_qty=0;l_fp_sell_qty=0;l_fp_buy_qty=0;
      EXEC SQL
      SELECT
        SUM(SELL_EXEC_QTY) SELL_EXEC_QTY,SUM(BUY_EXEC_QTY) BUY_EXEC_QTY, SUM(SELL_QTY) SELL_QTY,SUM(BUY_QTY) BUY_QTY
      INTO
        :l_fe_sell_qty,:l_fe_buy_qty,:l_fp_sell_qty,:l_fp_buy_qty
      FROM
      (
        SELECT
          NVL(SUM(DECODE(FOD_ORDR_FLW,'S',FOD_EXEC_QTY,0)),0) SELL_EXEC_QTY,
          NVL(SUM(DECODE(FOD_ORDR_FLW,'B',FOD_EXEC_QTY,0)),0) BUY_EXEC_QTY,
          NVL(SUM(DECODE(FOD_ORDR_FLW,'S',(FOD_ORDR_TOT_QTY-(FOD_CNCL_QTY+FOD_EXPRD_QTY+FOD_EXEC_QTY)),0)),0) SELL_QTY,
          NVL(SUM(DECODE(FOD_ORDR_FLW,'B',(FOD_ORDR_TOT_QTY-(FOD_CNCL_QTY+FOD_EXPRD_QTY+FOD_EXEC_QTY)),0)),0) BUY_QTY
        FROM
          FOD_FO_ORDR_DTLS
        WHERE
          FOD_XCHNG_CD          = 'NFO'
          AND FOD_PRDCT_TYP     = :st_cntrct.c_prd_typ
          AND FOD_CLM_MTCH_ACCNT  = :st_usr_prfl.c_cln_mtch_accnt
          AND FOD_ORDR_STTS       IN ('O','Q','R','P','E','B','D')
          AND FOD_UNDRLYNG        = :st_cntrct.c_undrlyng
          AND FOD_EXPRY_DT        = :st_cntrct.c_expry_dt
          AND FOD_XCHNG_CD        = :st_cntrct.c_xchng_cd
          AND FOD_STRK_PRC        = :st_cntrct.l_strike_prc
          AND FOD_EXER_TYP        = :st_cntrct.c_exrc_typ
          AND FOD_OPT_TYP         = :st_cntrct.c_opt_typ
          AND FOD_SOURCE_FLG      = 'F'
			  UNION ALL
        SELECT
          NVL(SUM(DECODE(FOD_ORDR_FLW,'S',FOD_EXEC_QTY,0)),0) SELL_EXEC_QTY,
          NVL(SUM(DECODE(FOD_ORDR_FLW,'B',FOD_EXEC_QTY,0)),0) BUY_EXEC_QTY,
          0 SELL_QTY,
          0 BUY_QTY
        FROM
          FOD_FO_ORDR_DTLS_HSTRY
        WHERE
          FOD_XCHNG_CD          = 'NFO'
          AND FOD_PRDCT_TYP     = :st_cntrct.c_prd_typ
          AND FOD_CLM_MTCH_ACCNT  = :st_usr_prfl.c_cln_mtch_accnt
          AND FOD_ORDR_STTS       IN ('P','E','B','D')
          AND FOD_UNDRLYNG        = :st_cntrct.c_undrlyng
          AND FOD_EXPRY_DT        = :st_cntrct.c_expry_dt
          AND FOD_XCHNG_CD        = :st_cntrct.c_xchng_cd
          AND FOD_STRK_PRC        = :st_cntrct.l_strike_prc
          AND FOD_EXER_TYP        = :st_cntrct.c_exrc_typ
          AND FOD_OPT_TYP         = :st_cntrct.c_opt_typ
          AND FOD_SOURCE_FLG      = 'F'
        );

			if( (SQLCODE != NO_DATA_FOUND) && (SQLCODE != 0))
      {
        fn_errlog( c_ServiceName, "S31035",SQLMSG,c_err_msg);
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID , (char *)&i_actn_id , 0 );   /*** Ver 3.0 ***/
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT,(char *)&d_required_amt,0);   /*** Ver 5.8 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 5.8 ***/
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
      if (SQLCODE == NO_DATA_FOUND)
      {
        l_fe_sell_qty=0;l_fe_buy_qty=0;l_fp_sell_qty=0;l_fp_buy_qty=0;
      }

			fav_cnt=0;
        EXEC SQL SELECT COUNT(*) INTO :fav_cnt FROM FFS_FO_FLASH_DISCRYP
        WHERE
        FFS_CLM_MTCH_ACCNT=:st_usr_prfl.c_cln_mtch_accnt
        AND FFS_XCHNG_CD=:st_cntrct.c_xchng_cd
        AND FFS_PRDCT_TYP=:st_cntrct.c_prd_typ
        AND FFS_UNDRLYNG =:st_cntrct.c_undrlyng
        AND FFS_EXPRY_DT=to_date(:st_cntrct.c_expry_dt,'DD-Mon-YYYY')
        AND FFS_OPT_TYP=DECODE(:st_cntrct.c_prd_typ,'F',FFS_OPT_TYP,:st_cntrct.c_opt_typ)
        AND FFS_STRK_PRC=DECODE(:st_cntrct.c_prd_typ,'F',FFS_STRK_PRC,:st_cntrct.l_strike_prc);

      if( (SQLCODE != NO_DATA_FOUND) && (SQLCODE != 0))
      {
        fn_errlog( c_ServiceName, "S31040",SQLMSG,c_err_msg);
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID , (char *)&i_actn_id , 0 );   /*** Ver 3.0 ***/
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT,(char *)&d_required_amt,0);   /*** Ver 5.8 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 5.8 ***/
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

      l_site_sell=l_sell_exe_qty-l_fe_sell_qty;
      l_site_buy=l_buy_exe_qty-l_fe_buy_qty;
      l_site_osell=l_sell_ord_qty-l_fp_sell_qty;
      l_site_obuy=l_buy_ord_qty-l_fp_buy_qty;
    }

    /** Ver 11.3 by Ravi End **/

  /*** Ver 11.2 starts ***/

    fn_userlog( c_ServiceName, "c_source_flg:%c:",c_source_flg);
    
		if (c_source_flg == 'F' )
		{
			/*Added FFS_MARGIN for Ver 11.9*/
      EXEC SQL
        SELECT DECODE(FFS_MARGIN,-1,FFS_MARGIN,FFS_CLS_TIME)
        INTO  :l_sqroff_tm
        FROM  FFS_FO_FLASH_SETTING
        WHERE FFS_CLM_MTCH_ACCNT = :st_usr_prfl.c_cln_mtch_accnt;

      if( (SQLCODE != NO_DATA_FOUND) && (SQLCODE != 0))
      {
        fn_errlog( c_ServiceName, "S31045",SQLMSG,c_err_msg);
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID , (char *)&i_actn_id , 0 );   /*** Ver 3.0 ***/
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT,(char *)&d_required_amt,0);   /*** Ver 5.8 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 5.8 ***/
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
      if (SQLCODE == NO_DATA_FOUND)
      {
					/** Ver 11.6 Start **/
					EXEC SQL SELECT MAX(NVL(FFC_DEF_TIMER,15)) INTO :l_sqroff_tm FROM FFC_CATEGORY_MASTER;
					if( (SQLCODE != NO_DATA_FOUND) && (SQLCODE != 0))
					{
						fn_errlog( c_ServiceName, "S31050",SQLMSG,c_err_msg);
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
						Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID , (char *)&i_actn_id , 0 );
						Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT,(char *)&d_required_amt,0);
						Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
					else
					{
					l_sqroff_tm = 15;    /** Changing from 5 to 15 in Ver 11.6 **/
					} /** Ver 11.6 end **/
      }

      if (st_xchngbook.c_spl_flg != CLIENT_SQROFF && st_xchngbook.c_spl_flg != SYSTEM_SQUAREOFF )
      {
        c_fc_flg = 'F';

			/** Ver 11.3 by Ravi Start **/


      if(l_site_sell!=l_site_buy )
      {
      fn_userlog(c_ServiceName, "This Contract not allowed in Flash Trade as Trades/Discrepancy found on this contract.");
      strcpy(c_err_msg,"This Contract not allowed in Flash Trade as Trades/Discrepancy found on this contract. ");
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
      else if (l_site_osell>0 || l_site_obuy>0)
      {
      fn_userlog(c_ServiceName, "This Contract not allowed in Flash Trade as website orders found in your trades on this contract please square off or cancel to continue with flash.");
      strcpy(c_err_msg, "This Contract not allowed in Flash Trade as website orders found in your trades on this contract pleasesquare off or cancel to continue with flash.");
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
			else if (fav_cnt >0)
      {
      fn_userlog(c_ServiceName, "Order not placed as Discrepacncy Found in Flash Trade.");
      strcpy(c_err_msg, "Order not placed as Discrepacncy Found in Flash Trade.");
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
      /** Ver 11.3 by Ravi End **/
      }
    }
    fn_userlog( c_ServiceName,"c_source_flg:%c: st_xchngbook.c_spl_flg:%c: l_sqroff_tm:%ld: c_fc_flg=:%c:",c_source_flg,st_xchngbook.c_spl_flg,l_sqroff_tm,c_fc_flg);
    /*** Ver 11.2 ends ***/

    fn_userlog( c_ServiceName,"st_cntrct.c_prd_typ:%c: st_xchngbook.c_ordr_flw:%c: st_xchngbook.c_spl_flg:%c:",st_cntrct.c_prd_typ,st_xchngbook.c_ordr_flw,st_xchngbook.c_spl_flg);

		/* Ver 11.3 by Ravi Start */
		if ( (  st_cntrct.c_prd_typ == 'F' || st_cntrct.c_prd_typ == 'O' ) && st_xchngbook.c_ordr_flw =='S'
        /*&& (st_xchngbook.c_spl_flg == CLIENT_SQROFF || st_xchngbook.c_spl_flg=='*') */
        && c_source_flg !='F'
        && (!strstr( st_xchngbook.c_xchng_rmrks,"Physical Settlement EOS")) && (st_xchngbook.c_spl_flg !=  PHYSICAL_DLVRY_SQOFF)
        && (st_xchngbook.c_spl_flg != SYSTEM_SQUAREOFF )
        && (st_xchngbook.c_spl_flg != IMTM_SYS_SQUAREOFF)
        && (st_xchngbook.c_spl_flg != LMTNEG_SYS_SQUAREOFF )
       )
    {
			i_err[0]  = Fget32(ptr_fml_Ibuf,FFO_CNTRCT_TAG,0,(char *)&c_popup_flg,0);
    	i_ferr [0] = Ferror32;

    	if ( i_err[0] == -1 )
    	{
     	 if ( Ferror32 != FNOTPRES )
     	 {
     	   fn_errlog( c_ServiceName, "S31055", FMLMSG, c_err_msg  );
     	   Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
     	   Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID , (char *)&i_actn_id , 0 );   /*** Ver 3.0 ***/
     	   Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT,(char *)&d_required_amt,0);   /*** Ver 5.8 ***/
     	   Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /*** Ver 5.8 ***/
     	   tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     	 }
     	 else if( Ferror32 == FNOTPRES )
     	 {
     	   fn_userlog( c_ServiceName," FFO_CNTRCT_TAG tag not present ");
     	   c_popup_flg ='Y';		/** Ver 11.7 **/
     	 }
    	}

    	fn_userlog( c_ServiceName," FFO_CNTRCT_TAG tag value :%c:%ld:%ld:%ld:%ld: ",c_popup_flg,l_fe_sell_qty,l_fp_sell_qty,l_fe_buy_qty,l_fp_buy_qty);

			 if(fav_cnt>0)       /* Popup already displayed */
        c_popup_flg='Z';

/** Ver 11.7 Start **/
      if(((l_fe_sell_qty+l_fp_sell_qty)-(l_fe_buy_qty+l_fp_buy_qty))!=0)
     {
	      i_popup=1;
		 }
			/** Ver 11.7 End **/

			if (  c_popup_flg == 'N' && i_popup==1 )		/** Ver 11.7  added i_popup**/
    	{
     	/**  if(((l_fe_sell_qty+l_fp_sell_qty)-(l_fe_buy_qty+l_fp_buy_qty))!=0)commented in Ver 11.7 **/
     	 {
     	 fn_userlog(c_ServiceName,"You are creating an offsetting position which might square off your existing Flash Orders/Trades")	;
   	   strcpy(c_err_msg,"You are creating an offsetting position which might square off your existing Flash Orders/Trades ");
   	   Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
   	   Fchg32( ptr_fml_Ibuf, FFO_CNTRCT_TAG,0, (char *)&c_popup, 0 );
   	   Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
   	   tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
   	   }
    	}
 	  	else
 	  	{
 	      fn_userlog( c_ServiceName, " No Flash Popup ");
 	   	}
 	 }
		/*** Ver 11.2 by Ravi End ***/

		 /*** Ver 10.8 Starts Here ***/
    MEMSET(c_1clk_prtflio_id);

    i_err[0]  = Fget32(ptr_fml_Ibuf,FFO_CLSR_TYP ,0,(char *)&c_1clk_flg,0);
    i_ferr [0] = Ferror32;
    i_err[1]  = Fget32(ptr_fml_Ibuf,FFO_BILL_NO ,0,(char *)c_1clk_prtflio_id,0);
    i_ferr [1] = Ferror32;

    if ( i_err[0] == -1 || i_err[1] == -1 )
    {
      if ( Ferror32 != FNOTPRES )
      {
        fn_errlog( c_ServiceName, "S31060", FMLMSG, c_err_msg  );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
      else if( Ferror32 == FNOTPRES )
      {
        c_1clk_flg='N';
        strcpy(c_1clk_prtflio_id,"");
      }
    }
    fn_userlog( c_ServiceName, "Portfolio flag  :%c: ",c_1clk_flg);
    fn_userlog( c_ServiceName, "Portfolio id    :%s: ",c_1clk_prtflio_id);
    /*** Ver 10.8 Ends Here ***/
/****1.7 start*******

  ***1.1 start***

  i_returncode = fn_unpack_fmltovar ( c_ServiceName,
                                      c_err_msg,
                                      ptr_fml_Ibuf,
                                      1,
                            FFO_CHANNEL, (char * )c_channel, NULL);

  if( i_returncode  == SYSTEM_ERROR )
  {
    fn_errlog( c_ServiceName, "S31065", LIBMSG , c_err_msg );
    Fadd32(ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    tpreturn( TPFAIL, ERR_BFR, ( char * )ptr_fml_Ibuf, 0, 0 );
  }


   ****************************************************************************
  * Checking for the callntrade flag in the usm_sssn_mngr table before proceeding 
  ***************************************************************************
    EXEC SQL SELECT NVL(USM_SUP_USR_TYP, 'N')
             INTO   :c_usm_sup_usr_typ
             FROM   usm_sssn_mngr
             WHERE  usm_usr_id = :st_usr_prfl.c_user_id
             AND    USM_SSSN_ID = :st_usr_prfl.l_session_id ;

      if(SQLCODE != 0 )
      {
            fn_errlog( c_ServiceName, "S31070", SQLMSG, c_err_msg  );
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

  if(c_usm_sup_usr_typ == 'C')
  {
    strcpy(c_channel,"CNT");
  }
  if(c_usm_sup_usr_typ == 'S')        ** V1.3 Super user **
  {
    strcpy(c_channel,"CN1");
  }

  **************************************************************************
  * Checking for the callntrade flag through                                
  ***************************************************************************


  ***1.1 ends***

*********1.7	ends******/
    /*** Ver 8.5 Starts ***/
    MEMSET(c_ip_address);

    i_err[1]  = Fget32(ptr_fml_Ibuf,FFO_OI_INDCTR,0,(char *)c_ip_address,0);
    i_ferr [1] = Ferror32;

    if ( i_err[1] == -1 )
    {
      if ( Ferror32 != FNOTPRES )
      {
        fn_errlog( c_ServiceName, "S31075", FMLMSG, c_err_msg  );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
    }

    if(DEBUG_MSG_LVL_0)
    {
      fn_userlog( c_ServiceName, "c_ip_address is...:%s:",c_ip_address);
    }
    /*** Ver 8.5 Ends ***/

		/*** Ver 10.0 starts here ***/
		MEMSET(c_ven_id);
    i_err[0]  = Fget32(ptr_fml_Ibuf,FFO_USER_CODE,0,(char *)c_ven_id.arr,0);
    i_ferr [0] = Ferror32;

    if ( i_err[0] == -1 )
    {
      if ( Ferror32 != FNOTPRES )
      {
        fn_errlog( c_ServiceName, "S31080", FMLMSG, c_err_msg  );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
      else if( Ferror32 == FNOTPRES )
      {
				strcpy(c_ven_id.arr,"");		
      }
    }
		i_err[0]  = Fget32(ptr_fml_Ibuf,FFO_INSTRMNT_TYP,0,(char *)c_ven_nm.arr,0);
    i_ferr [0] = Ferror32;

    if ( i_err[0] == -1 )
    {
      if ( Ferror32 != FNOTPRES )
      {
        fn_errlog( c_ServiceName, "S31085", FMLMSG, c_err_msg  );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
      else if( Ferror32 == FNOTPRES )
      {
        strcpy(c_ven_nm.arr,"");
      }
    }
		SETLEN(c_ven_nm);
		SETLEN(c_ven_id);
		fn_userlog( c_ServiceName, "Vendor id = ESP_ID	:%s:",c_ven_id.arr);
		fn_userlog( c_ServiceName, "Vendor Name :%s:",c_ven_nm.arr);

		/*** Ver 10.0 ends ***/

    /**** Ver 11.0 Starts Here ****/
    MEMSET(c_algo_id);
    MEMSET(c_algo_ord_rmrks);
    i_err[0]  = Fget32(ptr_fml_Ibuf,FFO_ACTION2,0,(char *)c_algo_id.arr,0);
    i_ferr [0] = Ferror32;

    if ( i_err[0] == -1 )
    {
      if ( Ferror32 != FNOTPRES )
      {
        fn_errlog( c_ServiceName, "S31090", FMLMSG, c_err_msg  );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
      else if( Ferror32 == FNOTPRES )
      {
        strcpy(c_algo_id.arr,"");
      }
    }
    i_err[0]  = Fget32(ptr_fml_Ibuf,FFO_PRDCT_DESC,0,(char *)c_algo_ord_rmrks.arr,0);
    i_ferr [0] = Ferror32;

    if ( i_err[0] == -1 )
    {
      if ( Ferror32 != FNOTPRES )
      {
        fn_errlog( c_ServiceName, "S31095", FMLMSG, c_err_msg  );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
      else if( Ferror32 == FNOTPRES )
      {
        strcpy(c_algo_ord_rmrks.arr,"");
      }
    }
    SETLEN(c_algo_id);
    SETLEN(c_algo_ord_rmrks);
    if(DEBUG_MSG_LVL_3)
    {
      fn_userlog( c_ServiceName, "c_algo_id :%s: c_algo_ord_rmrks  :%s:",c_algo_id.arr,c_algo_ord_rmrks.arr);
    }  
    /**** Ver 11.0 Ends Here *****/



	fn_init_ddr_pop ( st_xchngbook.c_pipe_id,TRADING_SECTION,O_CS);

	if(DEBUG_MSG_LVL_5)
	{
  	fn_userlog( c_ServiceName, "User id				:%s:", 
																	st_usr_prfl.c_user_id );
  	fn_userlog( c_ServiceName, "Session id		:%ld:", 
																	st_usr_prfl.l_session_id );
  	fn_userlog( c_ServiceName, "Match Account	:%s:", 
																	st_usr_prfl.c_cln_mtch_accnt );
  	fn_userlog( c_ServiceName, "Exchange code :%s:", 
																	st_cntrct.c_xchng_cd );
  	fn_userlog( c_ServiceName, "Product Type  :%c:", 
																	st_cntrct.c_prd_typ );
  	fn_userlog( c_ServiceName, "Underlyng     :%s:", 
																	st_cntrct.c_undrlyng );
  	fn_userlog( c_ServiceName, "Expiry date   :%s:", 
																	c_expiry_dt.arr );
  	fn_userlog( c_ServiceName, "Excercise Type:%c:", 
																	st_cntrct.c_exrc_typ );
  	fn_userlog( c_ServiceName, "Option type   :%c:", 
																 st_cntrct.c_opt_typ );
  	fn_userlog( c_ServiceName, "Strike price  :%ld:", 
																 st_cntrct.l_strike_prc );
  	fn_userlog( c_ServiceName, "Category 			:%c:", 
																 st_cntrct.c_ctgry_indstk );
  	fn_userlog( c_ServiceName, "Order flow B/S:%c:", 
																 st_xchngbook.c_ordr_flw );
  	fn_userlog( c_ServiceName, "Lmt/Mkt/StpLss:%c:", 
																 st_xchngbook.c_slm_flg );
  	fn_userlog( c_ServiceName, "GTT/GTD Order	:%c:", 
																 st_xchngbook.c_ord_typ );
  	fn_userlog( c_ServiceName, "Disclosed Qty	:%ld:", 
																 st_xchngbook.l_dsclsd_qty );
  	fn_userlog( c_ServiceName, "Stop Loss Trgg:%ld:", 
																 st_xchngbook.l_stp_lss_tgr );
  	fn_userlog( c_ServiceName, "Order Qty			:%ld:", 
																 st_xchngbook.l_ord_tot_qty );
  	fn_userlog( c_ServiceName, "Limit Rate		:%ld:", 
																 st_xchngbook.l_ord_lmt_rt );
  	fn_userlog( c_ServiceName, "special flag		:%c:", 
																 st_xchngbook.c_spl_flg );
  	fn_userlog( c_ServiceName, "Exchange remarks :%c:",					/*** Ver 4.5 ***/ 
																 st_xchngbook.c_xchng_rmrks);
	}

	/********** Ver 6.6 Starts *************/

  MEMSET(c_bp_id);
  MEMSET(c_alias_nm);
  c_trd_flg ='\0';
  c_spn_flg='\0';
  c_bse_spn_flg='\0';
  l_clnt_ctgry = 0;

 if (strncmp(st_usr_prfl.c_cln_mtch_accnt,"552",3) != 0 ) /** Ver 10.6 Starts **/
 {
  c_ucc_flg='N';

  EXEC SQL
    SELECT CLM_TRD_FLG,
           NVL(CLM_BP_ID,'*'),
           NVL(CLM_SPAN_ALLWD,'N'),
           NVL(CLM_BSESPAN_ALLWD,'N'),
           CLM_CLNT_CTGRY_ID,
           NVL(CLM_ALIAS_NAME,'*'),
           NVL(IUD_FNO_UCC_TRDNG_ENBL_FLG,'N')
    INTO   :c_trd_flg,
           :c_bp_id,
           :c_spn_flg,
           :c_bse_spn_flg,
           :l_clnt_ctgry,
           :c_alias_nm,
           :c_ucc_flg
    FROM   CLM_CLNT_MSTR,IUD_INFO_UCC_DTLS
    WHERE  IUD_UCC_CD = NVL(CLM_CLNT_CD,CLM_MTCH_ACCNT)
    AND CLM_MTCH_ACCNT = :st_usr_prfl.c_cln_mtch_accnt;

   if ( SQLCODE != 0  && SQLCODE != NO_DATA_FOUND )
   {
    fn_errlog(c_ServiceName, "S31100", SQLMSG, c_err_msg);
    Fadd32(ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0);
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0);
   }
 
   if ( SQLCODE == NO_DATA_FOUND )
   {
    fn_userlog(c_ServiceName,"Match Account :%s: UCC Flag :%c:",st_usr_prfl.c_cln_mtch_accnt,c_ucc_flg);
   } 

   if ( DEBUG_MSG_LVL_3 )
   {
    fn_userlog(c_ServiceName,"UCC flag :%c:",c_ucc_flg);
   }

   if(c_ucc_flg != 'Y' )
   {
    fn_errlog( c_ServiceName, "B14021", DEFMSG, c_err_msg  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0);
   }
 }
 else  /** Ver 10.6 Ends **/
 {
  EXEC SQL
    SELECT CLM_TRD_FLG,
           NVL(CLM_BP_ID,'*'),
           NVL(CLM_SPAN_ALLWD,'N'),
           NVL(CLM_BSESPAN_ALLWD,'N'),
           CLM_CLNT_CTGRY_ID,
           NVL(CLM_ALIAS_NAME,'*')
    INTO   :c_trd_flg,
           :c_bp_id,
           :c_spn_flg,
           :c_bse_spn_flg,
           :l_clnt_ctgry,
           :c_alias_nm
    FROM   CLM_CLNT_MSTR
    WHERE  CLM_MTCH_ACCNT = :st_usr_prfl.c_cln_mtch_accnt;

  if ( SQLCODE != 0 )
  {
    fn_errlog(c_ServiceName, "S31105", SQLMSG, c_err_msg);
    Fadd32(ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0);
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0);
  }
 }

  rtrim(c_bp_id);
  rtrim(c_alias_nm);

  if(DEBUG_MSG_LVL_3) /***** DEBUG_MSG_LVL_3 Added in Ver 8.1 ****/
	{
		fn_userlog(c_ServiceName,"Trade flag :%c:",c_trd_flg);
		fn_userlog(c_ServiceName,"BP id :%s:",c_bp_id);
		fn_userlog(c_ServiceName," NSE span flag :%c:,Bse Span Flag :%c:",c_spn_flg,c_bse_spn_flg);
		fn_userlog(c_ServiceName,"Client category Id :%ld:",l_clnt_ctgry);
		fn_userlog(c_ServiceName,"Nick Name :%s:",c_alias_nm);
	}

  if(st_usr_prfl.c_user_id[0] != BPID && strcmp(st_usr_prfl.c_user_id,"system") != 0 && c_trd_flg == 'N' && strcmp(c_bp_id,"*") != 0)
  {
    fn_userlog(c_ServiceName,"Since you are Attached to a Direct Business Catalyst, this facility has been Disabled");
    fn_errlog( c_ServiceName, "B35018", "", c_err_msg  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
  /********** Ver 6.6 Ends *************/


  /*********************************** Commented in Ver 6.6 *************************************
  ***  Ver 4.8 Starts  ***

  if(st_usr_prfl.c_user_id[0] != BPID && strcmp(st_usr_prfl.c_user_id,"system") != 0)
  {
    i_is_dbc_cust = 0;

    EXEC SQL
      SELECT 1
      INTO :i_is_dbc_cust
      FROM  CLM_CLNT_MSTR
      WHERE CLM_MTCH_ACCNT = :st_usr_prfl.c_cln_mtch_accnt
      AND   CLM_TRD_FLG = 'N'
      AND   CLM_BP_ID IS NOT NULL;

    if( (SQLCODE != NO_DATA_FOUND) && (SQLCODE != 0))
    {
      fn_errlog( c_ServiceName, "S31110",SQLMSG,c_err_msg);
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

    if ( i_is_dbc_cust == 1 )
    {
      fn_userlog(c_ServiceName,"Since you are Attached to a Direct Business Catalyst, this facility has been Disabled");
      fn_errlog( c_ServiceName, "B35018", "", c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

  }



 

  ***  Ver 4.8 Ends  ***
	******************************* Comment Ends 6.6 **************************************************/

  /*** Ver 9.9 Starts ***/ 

   if(st_usr_prfl.c_user_id[0] ==BPID)
   {
     if( fn_simaltns_ssn_term ( c_ServiceName,st_usr_prfl.c_user_id,st_usr_prfl.l_session_id,st_usr_prfl.c_cln_mtch_accnt,c_err_msg) == -1 )
     {
      fn_errlog(c_ServiceName,"S31115","Error while checking simultaneous active session",c_err_msg);
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
      Fadd32( ptr_fml_Ibuf,FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
    }  

  /*** Ver 9.9 Ends ***/

/*********** Ver 9.7 Starts ***********/

  i_returncode = Fvftos32( ptr_fml_Ibuf,
                           (char *) &st_ordbook,
                           "vw_orderbook" );

  if ( i_returncode == -1  || st_ordbook.c_ctcl_id[0]=='\0') /* VER TOL : TUX ON LINUX -- Chnaged NULL to '\0' (Ravindra) */
  {
    fn_errlog( c_ServiceName, "S31120", FMLMSG, c_err_msg  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

    fn_userlog(c_ServiceName,"channe == :%s:",st_ordbook.c_channel);

/*********** Ver 9.7 Ends ***********/



 
  /*** Ver 9.1 Starts ***/
   if(strcmp(st_ordbook.c_channel,"OFF") != 0) /*** If condition Added in Ver 9.7 ***/
   {
     if ( st_cntrct.c_prd_typ != 'I' &&  st_xchngbook.c_spl_flg != 'C' )
     {
       i_returncode = fn_disallow_frsh_expsre(c_ServiceName,
                               st_usr_prfl.c_cln_mtch_accnt,
                               c_spn_flg,
                               st_xchngbook.c_ordr_flw,
                               st_xchngbook.l_ord_tot_qty,
                               l_old_ord_qty,
                               &st_cntrct,
                               &st_err_msg );
       if (i_returncode == -1 || i_returncode == -2)
       {
          fn_errlog( c_ServiceName, "S31125", "Error in Function fn_disallow_frsh_expsre", c_err_msg);
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
       }
     }
   }

  /*** Ver 9.1 Ends ***/

	/*** Ver 10.7 starts ****/
	if ( st_cntrct.c_prd_typ == 'O' )
  {
    i_returncode = fn_disallow_frsh_ordr(c_ServiceName,
                                              st_usr_prfl.c_cln_mtch_accnt,
                                              c_spn_flg,
                                              st_xchngbook.c_ordr_flw,
                                              st_xchngbook.l_ord_tot_qty,
                                              &st_cntrct,
                                              &st_err_msg );

    if(i_returncode == -1)
    {
      fn_errlog( c_ServiceName, "S31130", "Error in Function fn_disallow_frsh_expsre", c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

  }

  /*** Ver 10.7 ends ****/
 
  /*** Ver 7.2 Starts ***/
  if ( ( st_xchngbook.c_spl_flg != CLIENT_SQROFF ) &&
  ( st_xchngbook.c_spl_flg != SYSTEM_SQUAREOFF)  &&
  ( st_xchngbook.c_spl_flg != IMTM_SYS_SQUAREOFF )  &&
  ( st_xchngbook.c_spl_flg != LMTNEG_SYS_SQUAREOFF  )  &&
  ( st_xchngbook.c_spl_flg != PHYSICAL_DLVRY_SQOFF )  &&
  ( st_xchngbook.c_spl_flg != JOINT_SQUAREOFF ) )
 	{ 
   i_returncode = fn_chk_und_insider(c_ServiceName,
                                    st_usr_prfl,
                                    /*st_cntrct.c_undrlyng, ***Ver 10.5 comment **/
                                    st_cntrct,   /** Ver 10.5 **/
                                    &insider_exist);
   if (i_returncode == -1)
   {
      fn_errlog( c_ServiceName, "S31135", "Error in Function fn_chk_und_insider", c_err_msg);
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
   }

   if (insider_exist == 1)
   {
      fn_errlog( c_ServiceName, "B91164", DEFMSG, c_err_msg  ); /** Ver 10.5 B21042 changed to B91164 **/
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
   }
  } /** Ver 10.5 if icluded to skipp insider check for square off orders **/
 /**** Ver 7.2 Ends ****/

  /**** Ver 6.5 Starts Here *******/
  strcpy((char *)v_user_id.arr,st_usr_prfl.c_user_id);

  SETLEN(v_user_id);
  if(DEBUG_MSG_LVL_5)
  {
    fn_userlog(c_ServiceName,"st_ordbook.c_user_id IS  :%s:", st_usr_prfl.c_user_id);
    fn_userlog(c_ServiceName,"v_user_id IS  :%s:", v_user_id.arr );
  }

  if ( strcmp((char *)v_user_id.arr,"system") == 0 )
  {
    if(DEBUG_MSG_LVL_3)
    {
      fn_userlog(c_ServiceName,"SYSTEM PLACING ORDER");
    }

	/*********************** Commented in ver 6.6 **************************

   EXEC SQL  SELECT  decode(nvl(clm_bp_id,'*'),'*',uac_usr_id,clm_bp_id)
              INTO    :v_user_id
              FROM    uac_usr_accnts, clm_clnt_mstr
              WHERE   clm_mtch_accnt      = :st_usr_prfl.c_cln_mtch_accnt
              AND     uac_clm_mtch_accnt  = clm_mtch_accnt;
	************************  Comment Ends ver 6.6 ************************/

	EXEC SQL  SELECT  decode(:c_bp_id,'*',uac_usr_id,:c_bp_id)              /** Ver 6.6 **/
            INTO    :v_user_id
            FROM    uac_usr_accnts
            WHERE   uac_clm_mtch_accnt  = :st_usr_prfl.c_cln_mtch_accnt;

    if(( SQLCODE != 0 ) && ( SQLCODE != NO_DATA_FOUND ))
    {
      fn_errlog( c_ServiceName, "S31140", SQLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

    SETNULL(v_user_id);

    if(DEBUG_MSG_LVL_5)
    {
      fn_userlog(c_ServiceName,"BP ID IS  :%s:", v_user_id.arr);
    }

	/**** Ver 6.8 Starts Here ****/

   i_err[0]  = Fget32(ptr_fml_Ibuf,FFO_NKD_BLKD_FLG,0,(char *)&c_nkd_blkd_flg,0);
   i_ferr [0] = Ferror32;

   if ( i_err[0] == -1 )
   {
     if ( Ferror32 != FNOTPRES )
     {
       fn_errlog( c_ServiceName, "S31145", FMLMSG, c_err_msg  );
       Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
       Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
       tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     }
   }
  /**** Ver 6.8 Ends here ****/

  }

  sql_usr_fno_accpt_flg ='\0';
  sql_usr_dt_allwd_flg ='\0';

  EXEC SQL  SELECT  USR_DT_ALLWD_FLG,
                    USR_FNO_ACCPT_FLG
            INTO    :sql_usr_dt_allwd_flg,
                    :sql_usr_fno_accpt_flg
            FROM    USR_USER_MASTER
            WHERE   USR_USR_ID  =:v_user_id;
  if( SQLCODE != 0 )
  {
    fn_errlog( c_ServiceName, "S31150", SQLMSG, c_err_msg  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  if(DEBUG_MSG_LVL_3) /**** DEBUG_MSG_LVL_3 Added in Ver 8.1 ****/
	{
		fn_userlog(c_ServiceName,"sql_usr_dt_allwd_flg :%c:",sql_usr_dt_allwd_flg);
		fn_userlog(c_ServiceName,"sql_usr_fno_accpt_flg :%c:",sql_usr_fno_accpt_flg);
	}

  if(st_usr_prfl.c_user_id[0] != BPID && strcmp(st_usr_prfl.c_user_id,"system") != 0)
  {
   if(sql_usr_fno_accpt_flg != 'Y')
   {
      fn_errlog( c_ServiceName, "B31017",DEFMSG,c_err_msg);
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
   }
  }
  /**** Ver 6.5 Ends Here ****/

  
	/***  Ver 3.6 Starts  ***/
		
	/******************************* Commented in ver 6.6*********************************

   EXEC SQL
    SELECT  NVL(CLM_SPAN_ALLWD,'N'),
            NVL(CLM_BSESPAN_ALLWD,'N')      
    INTO    :c_spn_flg,
            :c_bse_spn_flg                
    FROM    CLM_CLNT_MSTR
    WHERE   CLM_MTCH_ACCNT  = :st_usr_prfl.c_cln_mtch_accnt;

  if ( SQLCODE != 0 )
  {
    fn_userlog(c_ServiceName, "Failed To Get SPAN Flag.");
    fn_errlog(c_ServiceName, "S31155", SQLMSG, c_err_msg);
    Fadd32(ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0);
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0);
  }

	 ****************************** Comment Ends 6.6  ******************************************/

	if(DEBUG_MSG_LVL_5)
	{
  	fn_userlog(c_ServiceName,"SPAN Allowed Flag Is :%c:",c_spn_flg);
	}

 /** if ( c_spn_flg == 'Y' ) ***/

	/*** Ver 3.8 SPAN flag Z added in condition for customer who not accepted TNC ***/

 	if( ( ( c_spn_flg == 'Y' || c_spn_flg =='Z' ) && strcmp(st_cntrct.c_xchng_cd,"NFO") == 0 ) ||     
    ( c_bse_spn_flg == 'Y' && strcmp(st_cntrct.c_xchng_cd,"BFO") == 0 ) )
  {
    fn_userlog(c_ServiceName, "SPAN Customer Trying To Place Order Under Normal Margining System.");
    strcpy(c_err_msg,"You Are Marked Under SPAN.Can Place Order Only Through New Site.");
    Fadd32(ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0);
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0);
  }
	/***  Ver 3.6 Ends ***/

  /*** Ver 3.7 Starts Here *****/
 
 /****** Added in Ver 7.7 *******/
	 MEMSET(sql_icd_cust_type.arr);
   EXEC SQL
   SELECT  ICD_CUST_TYPE,
					 NVL(ICD_PAN_NO,'*')				/*** Added In Ver 9.0 ***/
   INTO    :sql_icd_cust_type,
					 :v_pan_no				/*** Added In Ver 9.0 ***/
   FROM    ICD_INFO_CLIENT_DTLS,
           IAI_INFO_ACCOUNT_INFO
   WHERE   ICD_SERIAL_NO = IAI_SERIAL_NO
   AND     IAI_MATCH_ACCOUNT_NO  = :st_usr_prfl.c_cln_mtch_accnt;

  if ( SQLCODE != 0 )
  {
    fn_userlog(c_ServiceName, "NRI Flag Not Found .");
    fn_errlog(c_ServiceName, "S31160", SQLMSG, c_err_msg);
    Fadd32(ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0);
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0);
  }

	/*** Ver 9.0 Starts ***/
  SETNULL(v_pan_no);
	if(DEBUG_MSG_LVL_3)
	{
		fn_userlog( c_ServiceName,"Fetched v_pan_no is :%s:",v_pan_no.arr);
	}
	if (v_pan_no.len != 10)
  {
    fn_errlog( c_ServiceName, "B91176", DEFMSG, c_err_msg  ); 
    Fadd32(ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0);
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0);
  }
	/*** Ver 9.0 Ends ***/

	if(strcmp(sql_icd_cust_type.arr,"NRI") == 0 && st_cntrct.c_prd_typ == 'I' )
  {
      fn_errlog( c_ServiceName, "S31165", "NRI Customer Trying To Place OptionPlus Order ", c_err_msg  );
      strcpy(c_err_msg,"Currently BSE Derivative is not allowed for NRI customers");
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG,c_err_msg, 0 );
      fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
  else if(strcmp(sql_icd_cust_type.arr,"NRI") == 0 && strcmp(st_cntrct.c_xchng_cd,"BFO") == 0 )
  {
      fn_userlog(c_ServiceName,"NRI Customer Trying To Place Order In BSE Derivatives.");
      fn_errlog( c_ServiceName, "S31170", "", c_err_msg  );
      strcpy(c_err_msg," Currently BSE Derivative is not allowed for NRI customers.");
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG,c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
	/****** Ver 7.7 ******* Ends *****/

  /********** Commented in Ver 7.7 *********
	if( strcmp(st_cntrct.c_xchng_cd,"BFO") == 0 )
  {
   if ( (strncmp(st_usr_prfl.c_cln_mtch_accnt, "750", 3)  == 0 ) ||
        (strncmp(st_usr_prfl.c_cln_mtch_accnt, "751", 3)  == 0 ) ||
        (strncmp(st_usr_prfl.c_cln_mtch_accnt, "650", 3)  == 0 ) ||
        (strncmp(st_usr_prfl.c_cln_mtch_accnt, "651", 3)  == 0 )
      )
     {
       fn_userlog(c_ServiceName,"NRI Customer Trying To Place Order In BSE Derivatives.");
       fn_errlog( c_ServiceName, "S31175", "", c_err_msg  ); 
       strcpy(c_err_msg," Currently BSE Derivative is not allowed for NRI customers.");
       Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG,c_err_msg, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); ***  Ver 6.9 ***
       Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); ***  Ver 6.9 ***
       tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     }
  }
  *** Ver 3.7 Ends Here *******

   *** Ver 5.4 Starts Here *****
   if (((strncmp(st_usr_prfl.c_cln_mtch_accnt, "750", 3)  == 0 ) ||
        (strncmp(st_usr_prfl.c_cln_mtch_accnt, "751", 3)  == 0 ) ||
        (strncmp(st_usr_prfl.c_cln_mtch_accnt, "650", 3)  == 0 ) ||
        (strncmp(st_usr_prfl.c_cln_mtch_accnt, "651", 3)  == 0 )) &&
        st_cntrct.c_prd_typ == 'I'
      )
     {
       fn_userlog(c_ServiceName,"NRI Customer Trying To Place OptionPlus Order .");
       fn_errlog( c_ServiceName, "S31180", "", c_err_msg  );
       strcpy(c_err_msg,"This facility is not enabled for NRI customers");
       Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG,c_err_msg, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); ***  Ver 6.9 ***
       Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); ***  Ver 6.9 ***
       tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     }
  *** Ver 5.4 Ends Here *******
	********** Commented Ver 7.7 Ends *********/

  /*** 2.2 Starts Cannot allow to place order if both Buy and Sell is not allowed. ***/
	if(DEBUG_MSG_LVL_5)
	{
  	fn_userlog(c_ServiceName, "Vikash going to check for Buy Sell allowed flag calling fn_get_trdng_dtls:---");
	}

  if(fn_get_trdng_dtls(st_usr_prfl.c_user_id, st_usr_prfl.c_cln_mtch_accnt, &c_trd_dtls, prd) == -1)	/* Ver 2.2 : Including user id as the 1st parameter	*/
  {
    fn_userlog(c_ServiceName, "Error in Function Call");
    fn_errlog(c_ServiceName, "S31185", FMLMSG, c_err_msg);
    Fadd32(ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0);
    Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0);
  }

	if(DEBUG_MSG_LVL_5)
	{
		fn_userlog(c_ServiceName, "Trading Flag is :%c:", c_trd_dtls);
	}

  if(c_trd_dtls != 'A')
  {
    fn_userlog( c_ServiceName, "For Placing any order in FNO both Buy and Sell must be allowed.");
    /** fn_errlog( c_ServiceName, "B", "", c_err_msg  );   Some Business Error **/
    Fadd32(ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0);
    Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0);
  }
  /*** 2.2 Ends ***/

	/**********1.5 Starts *********************/
  if(st_xchngbook.c_ord_typ == GOOD_TILL_DATE)
  {
    fn_userlog( c_ServiceName, "GTD Orders are not allowed for FNO from 30-07-2004");
    fn_errlog( c_ServiceName, "B28572", "", c_err_msg  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
  /********** 1.5 Ends  *********************/
	/**********1.8 Starts *********************/
  if(st_xchngbook.c_ordr_flw  !='B' && st_xchngbook.c_ordr_flw  != 'S')
  {
    fn_userlog( c_ServiceName, "ORDER FLOW is NULL");
    fn_errlog( c_ServiceName, "S31190", "Invalid Order Flow", c_err_msg  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
  /********** 1.8 Ends  *********************/

	/***  Ver 3.1 Starts  ***/

  if(st_xchngbook.l_stp_lss_tgr > 0 )
  {
    if(DEBUG_MSG_LVL_3) /**** Addedin ver 8.1 ****/
		{
			fn_userlog(c_ServiceName,"Inside Stop Loss Trigger Price Check.");
		}
		st_xchngbook.c_slm_flg  = 'S' ;
    fn_userlog(c_ServiceName," SLM Flag Is :%c:",st_xchngbook.c_slm_flg);

  }

  /***  Ver 3.1 Ends  ***/

  /********** Ver 2.8 Starts *********************/
  if(st_xchngbook.c_slm_flg !='L' && st_xchngbook.c_slm_flg  != 'S' && st_xchngbook.c_slm_flg !='M' )
  {
    fn_userlog( c_ServiceName, "c_slm_flg is NULL");
    fn_errlog( c_ServiceName, "S31195", "Invalid SLM Flag", c_err_msg  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
  if(st_xchngbook.c_ord_typ !='T' && st_xchngbook.c_ord_typ  != 'I')
  {
    fn_userlog( c_ServiceName, "ORDER TYPE is NULL");
    fn_errlog( c_ServiceName, "S31200", "Invalid Order Type", c_err_msg  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
  /********** Ver 2.8 Ends  *********************/
  /******** Ver 3.3  Starts **********/

	/****** Commented in Ver 7.7 *******
  if ( (strncmp(st_usr_prfl.c_cln_mtch_accnt, "750", 3)  == 0 ) ||
       (strncmp(st_usr_prfl.c_cln_mtch_accnt, "751", 3)  == 0 ) ||
       (strncmp(st_usr_prfl.c_cln_mtch_accnt, "650", 3)  == 0 ) ||
       (strncmp(st_usr_prfl.c_cln_mtch_accnt, "651", 3)  == 0 )
    )
		****** Commented Ver 7.7 Ends ******/
	/****** Added in Ver 7.7 *******/
	MEMSET(sql_icd_cust_type.arr);
   EXEC SQL
   SELECT  ICD_CUST_TYPE
   INTO    :sql_icd_cust_type
   FROM    ICD_INFO_CLIENT_DTLS,
           IAI_INFO_ACCOUNT_INFO
   WHERE   ICD_SERIAL_NO = IAI_SERIAL_NO
   AND     IAI_MATCH_ACCOUNT_NO  = :st_usr_prfl.c_cln_mtch_accnt;

   if ( SQLCODE != 0 )
   {
      fn_userlog(c_ServiceName, "NRI Flag Not Found .");
      fn_errlog(c_ServiceName, "S31205", SQLMSG, c_err_msg);
      Fadd32(ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0);
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0);
   }
  /****** Ver 7.7 ******* Ends *****/
   if(strcmp(sql_icd_cust_type.arr,"NRI") == 0)   /****** Check added in Ver 7.7 ******/
	 {
     /******** Check if NRI customer is allowed for trade or not for Underlying ***/
     if(DEBUG_MSG_LVL_3)  /*** Added in Ver 8.1 ****/
		 {
			fn_userlog(c_ServiceName,"Inside NRI Check ");
		 }

		 i_returncode = fn_nri_validation( c_ServiceName,
                                       st_cntrct.c_undrlyng,
                                       st_cntrct.c_prd_typ,
																			 st_cntrct.c_xchng_cd ,			/*** Ver 3.7 ***/ 
                                       &st_err_msg);
     if( i_returncode == -1 )
     {
       fn_errlog( c_ServiceName, "S31210", "", c_err_msg  );
       Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG,st_err_msg.c_err_msg, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
       Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/   
       tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     }
     if( i_returncode == -2 )
     {
       fn_errlog( c_ServiceName, "S31215", "Business Error", c_err_msg  );
       Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG,st_err_msg.c_err_msg, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
       Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
       tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     }
   }

  /******* Ver 3.3 Ends  ************/

  /**********2.0 Starts *********************/

  i_returncode=fn_chk_closeout(c_ServiceName,
                               st_usr_prfl.c_cln_mtch_accnt,          /*** Added in ver 4.2 ***/
                               c_request_typ,          								/*** Added in ver 4.2 ***/
															 st_cntrct,															/*** Added in ver 4.2 ***/		
                               &st_xchngbook,
                               &st_err_msg);

  if( i_returncode == -1 )
  {
    fn_errlog( c_ServiceName, "S31220", "Broker Under Closeout", c_err_msg  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG,st_err_msg.c_err_msg, 0 );
    Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

 /**********2.0 Ends*********************/ 

 /*******  Comment Starts for Ver 9.7  *******

  i_returncode = Fvftos32( ptr_fml_Ibuf, 
                           (char *) &st_ordbook, 
                           "vw_orderbook" );

	if ( i_returncode == -1  || st_ordbook.c_ctcl_id[0]==NULL)
	{
		fn_errlog( c_ServiceName, "S31225", FMLMSG, c_err_msg  );
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
		Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			***	Ver	3.1	***	
	  Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); ***  Ver 6.9 ***
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); ***  Ver 6.9 ***
  	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}

  *******  Comment Ends for Ver 9.7  *******/

  st_ordbook.c_slm_flg  = st_xchngbook.c_slm_flg;                         /***  Ver 3.1 ***/

	if(DEBUG_MSG_LVL_5)
	{
		fn_userlog(c_ServiceName," SLM Flag Is :%c:",st_ordbook.c_slm_flg);     /***  Ver 3.1 ***/
	}

	/*** Commented in Ver 6.6 ****

  ********** Ver 2.9 starts *********************

	***  Channel Added In Ver 4.0 **
  if((st_cntrct.c_ctgry_indstk !='I' && st_cntrct.c_ctgry_indstk != 'S') || (strcmp(st_ordbook.c_channel,"WE4")==0 ))
  {
		fn_userlog( c_ServiceName, "INVALID INDEX STOCK TYPE:%c:", st_cntrct.c_ctgry_indstk);
		*******************/

		/*** Commented In Ver 7.1 ***

		EXEC SQL
    SELECT FCM_INDSTK,
           FCM_LOT_SZ,                              * Ver 6.6 *
           FCM_TCK_SZ                               * Ver 6.6 * 
    INTO   :st_cntrct.c_ctgry_indstk,
           :st_cntrct_gen_inf.l_min_lot_qty,        * Ver 6.6 *
           :st_cntrct_gen_inf.l_tick_sz             * Ver 6.6 *
    FROM  FCM_FO_CNTRCT_MSTR
    WHERE FCM_XCHNG_CD  =:st_cntrct.c_xchng_cd
    AND   FCM_PRDCT_TYP ='O'                        * Ver 6.6 Product Type changed from 'F' to 'O' **
    AND   FCM_UNDRLYNG  =:st_cntrct.c_undrlyng
    AND   FCM_EXPRY_DT  =:st_cntrct.c_expry_dt
    AND   FCM_EXER_TYP  = :st_cntrct.c_exrc_typ     * Ver 6.6 *
    AND   FCM_OPT_TYP   = :st_cntrct.c_opt_typ      * Ver 6.6 *
    AND   FCM_STRK_PRC  = :st_cntrct.l_strike_prc;  * Ver 6.6 *

		*** Ver 7.1 Comment Ends ***/

		/*** Ver 7.1 Starts ***/

		EXEC SQL
    SELECT FTQ_INDSTK,
           FTQ_MIN_LOT_QTY,                            
           FTQ_TCK_SZ,
					 NVL(FTQ_BST1_BID_PRC,0),   /*** Ver 9.5 ***/
           NVL(FTQ_BST1_OFFR_PRC,0),  /*** Ver 9.5 ***/
           NVL(FTQ_CLS_PRC,0)      		/*** Ver 9.5 ***/
    INTO   :st_cntrct.c_ctgry_indstk,
           :st_cntrct_gen_inf.l_min_lot_qty,    
           :st_cntrct_gen_inf.l_tick_sz,
					 :l_best_bid_price,         /*** Ver 9.5 ***/
           :l_best_offer_price,       /*** Ver 9.5 ***/
           :l_previous_close_price    /*** Ver 9.5 ***/
    FROM  FTQ_FO_TRD_QT
    WHERE FTQ_XCHNG_CD  =:st_cntrct.c_xchng_cd
    AND   FTQ_PRDCT_TYP ='O'                  
    AND   FTQ_UNDRLYNG  =:st_cntrct.c_undrlyng
    AND   FTQ_EXPRY_DT  =:st_cntrct.c_expry_dt
    AND   FTQ_EXER_TYP  = :st_cntrct.c_exrc_typ    
    AND   FTQ_OPT_TYP   = :st_cntrct.c_opt_typ    
    AND   FTQ_STRK_PRC  = :st_cntrct.l_strike_prc;
	
		/*** Ver 7.1 Ends ***/

    if(SQLCODE != 0 )
    {
      fn_userlog( c_ServiceName, "INDEX STOCK TYPE is NULL");
      fn_errlog( c_ServiceName, "S31230", SQLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 3.1 ***/
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     }	

		st_ordbook.c_ctgry_indstk = st_cntrct.c_ctgry_indstk;
    if(DEBUG_MSG_LVL_3) /**** Added in Ver 8.1 ****/
		{
			fn_userlog( c_ServiceName, "CORRECTED FCM INDEX STOCK TYPE:%c:%c:", st_cntrct.c_ctgry_indstk,st_ordbook.c_ctgry_indstk);
		}
    if( DEBUG_MSG_LVL_0 )
    {
     fn_userlog(c_ServiceName, " Trade Quote Lot Size Is  :%ld: ", st_cntrct_gen_inf.l_min_lot_qty);
     fn_userlog(c_ServiceName, " Trade Quote Tick Size Is :%ld: " , st_cntrct_gen_inf.l_tick_sz);
    }

 	/******** Commented in Ver 6.6 *****
 }
  **********Ver 2.9 Ends *********************

	************************ comment ends ver 6.6 *****/
	
	/*** Ver 5.4 starts here ***/
  if (st_cntrct.c_prd_typ == 'I')
  {
		if(DEBUG_MSG_LVL_3)
		{
    	fn_userlog( c_ServiceName, "st_xchngbook.c_spl_flg= :%c:,st_ordbook.c_channel = :%s: ", 
																	st_xchngbook.c_spl_flg,st_ordbook.c_channel);
		}

		if (st_xchngbook.l_ord_tot_qty < 0 ) /*** Ver 6.4 ***/
		{
			st_xchngbook.l_ord_tot_qty = st_xchngbook.l_ord_tot_qty * -1;
			st_ordbook.l_ord_tot_qty = st_ordbook.l_ord_tot_qty * -1;
			i_excp_flag = 1;
			if(DEBUG_MSG_LVL_3) /****** DEBUG_MSG_LVL_3 Added in Ver 8.1 *****/
			{
				fn_userlog( c_ServiceName, "st_xchngbook.l_ord_tot_qty= :%ld:",st_xchngbook.l_ord_tot_qty);
				fn_userlog( c_ServiceName, "st_ordbook.l_ord_tot_qty= :%ld:",st_ordbook.l_ord_tot_qty);
			}
		}

    MEMSET(c_call_source);
    i_err[0]  = Fget32(ptr_fml_Ibuf,FFO_ACTION1,0,(char *)c_call_source,0);
    i_ferr [0] = Ferror32;

    if ( i_err[0] == -1 )
    {
      if ( Ferror32 != FNOTPRES )
      {
        fn_errlog( c_ServiceName, "S31235", FMLMSG, c_err_msg  );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
      else if( Ferror32 == FNOTPRES )
      {
        /*** This code checks whether service is called from...other than Order link, EOS or Offline ***/
        if ( st_xchngbook.c_spl_flg != 'C' && strcmp(st_ordbook.c_channel,"SYS") !=0 && strcmp(st_ordbook.c_channel,"OFF") !=
0 )
        {
          fn_userlog( c_ServiceName, "*** OptionPLUS product type validation fails ***");
          fn_errlog( c_ServiceName, "S31240", LIBMSG, c_err_msg  );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      }
    }
    else /* success condition */
    {
      if ( strcmp(c_call_source,"PLC_OPTPLUS") == 0 )
      {
        fn_userlog( c_ServiceName, "*** OptionPLUS order placement ***");
      }
      else /*** This code should never execute ***/
      {
        fn_userlog( c_ServiceName, "Called from :%s:",c_call_source);
        fn_errlog( c_ServiceName, "S31245", LIBMSG, c_err_msg  );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
    }
    i_err[0] = 0;
    i_ferr[0] = 0;
  }
  /*** Ver 5.4 ends here ***/


  /****************** VER 2.2 ADDITION STARTS **********************************/

  /*****Comment in  Ver 6.5 Starts Here ****************
  strcpy((char *)v_user_id.arr,st_ordbook.c_user_id);

  SETLEN(v_user_id);
	if(DEBUG_MSG_LVL_5)
	{
  	fn_userlog(c_ServiceName,"st_ordbook.c_user_id IS  :%s:", st_ordbook.c_user_id);
  	fn_userlog(c_ServiceName,"v_user_id IS  :%s:", v_user_id.arr );
	}

  if ( strcmp((char *)v_user_id.arr,"system") == 0 )
  {
		if(DEBUG_MSG_LVL_3)
		{
    	fn_userlog(c_ServiceName,"SYSTEM PLACING ORDER");
		}

   EXEC SQL  SELECT  decode(nvl(clm_bp_id,'*'),'*',uac_usr_id,clm_bp_id)
              INTO    :v_user_id
              FROM    uac_usr_accnts, clm_clnt_mstr
              WHERE   clm_mtch_accnt      = :st_ordbook.c_cln_mtch_accnt
              AND     uac_clm_mtch_accnt  = clm_mtch_accnt;

    if(( SQLCODE != 0 ) && ( SQLCODE != NO_DATA_FOUND ))
    {
      fn_errlog( c_ServiceName, "S31250", SQLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			***	Ver	3.1	***
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

    SETNULL(v_user_id);

		if(DEBUG_MSG_LVL_5)
		{
    	fn_userlog(c_ServiceName,"BP ID IS  :%s:", v_user_id.arr);
		}
  }
  ********** Ver 6.5 Ends Here *******/

  /**********************   VER 2.2 ADDITION ENDS   *****************************/

/* 1.7 starts *********/
  if (st_ordbook.c_ctcl_id[0]=='\0') /* VER TOL : TUX ON LINUX -- Chnaged NULL to '\0' (Ravindra) */
  {
    fn_userlog( c_ServiceName, "ERROR ctcl id valu is null :%s:", st_ordbook.c_ctcl_id);
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

	if(DEBUG_MSG_LVL_5)
	{
 		fn_userlog( c_ServiceName, "jagan ctcl id :%s:", st_ordbook.c_ctcl_id);
	}

/* 1.7 ends *********/	


/************* 1.7 start*********/
if(DEBUG_MSG_LVL_5)
{
		fn_userlog(c_ServiceName,"ctcl_id  	:%s:",(char *)st_ordbook.c_ctcl_id);
		fn_userlog(c_ServiceName,"channe is :%s:",(char *)st_ordbook.c_channel);
}

/************* 1.7 ends *********/

	/*Added By sangeet to OVERCOME CNXIT problem of ctgry_indstk *
  ** VEr 2.1 adds MINIFT **
  if((strcmp(st_ordbook.c_undrlyng ,"CNXIT") == 0) || (strcmp(st_ordbook.c_undrlyng ,"MINIFT") == 0))
  {
		st_ordbook.c_ctgry_indstk = 'I' ;
		st_cntrct.c_ctgry_indstk = 'I'  ;
	}		*** Ver 2.2 : Commented, as the changes is handled at the DL end	***/
			if(DEBUG_MSG_LVL_5)
			{
			fn_userlog(c_ServiceName,"After commenting c_ctgry_indstk is :%c: for :%s:",st_ordbook.c_ctgry_indstk,st_cntrct.c_undrlyng);
			fn_userlog(c_ServiceName,"c_ctgry_indstk is :%c: for :%s:",st_cntrct.c_ctgry_indstk,st_cntrct.c_undrlyng);
			}

    /***1.1 start ***/

  if(st_usr_prfl.c_user_id[0] == BPID)
  {
    if(Fget32(ptr_fml_Ibuf,FFO_ALIAS,0,(char *)c_alias,0) == -1)
    {
    	fn_errlog( c_ServiceName, "S31255", FMLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
  
	/********************************* Commented in Ver 6.6 *******************************************
 
   	i_level_exists = 0; 
   
	EXEC SQL
        SELECT 1
        INTO   :i_level_exists
        FROM   clm_clnt_mstr
        WHERE  clm_mtch_accnt = :st_usr_prfl.c_cln_mtch_accnt
        AND    clm_bp_id      = :st_usr_prfl.c_user_id
        AND    clm_alias_name = :c_alias;

  if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND)            *** Ver 3.4 Added NO_DATA_FOUND condn *** 
  {
    fn_errlog( c_ServiceName, "S31260",SQLMSG,c_err_msg);
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			***	Ver	3.1	***	
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
			if(DEBUG_MSG_LVL_5)
			{
      	fn_userlog(c_ServiceName,"BP alias  is :%s:",c_alias);
			}

			*** 1.7 **       
				fn_userlog(c_ServiceName,"BP channel  is :%s:",c_channel);  
			*** 1.7***

      if(i_level_exists != 1 )
      {
            fn_errlog( c_ServiceName, "B55006", "", c_err_msg  );
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
   	    Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			***	Ver	3.1	***	
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
		******************************** Comments Ends ver 6.6  **********************************************/
    if(DEBUG_MSG_LVL_3) /****DEBUG_MSG_LVL_3 Added in Ver 8.1 ****/
		{
			fn_userlog(c_ServiceName,"c_alias is :%s:",c_alias);        /** Ver 6.6 **/
			fn_userlog(c_ServiceName,"c_alias_nm is :%s:",c_alias_nm);  /** Ver 6.6 **/
		}
		
		/********** Ver 8.7 Starts Here ******************/
		MEMSET(c_sys_msg);
		if (st_cntrct.c_prd_typ == 'I')
		{
			i_err[0]  = Fget32(ptr_fml_Ibuf,FFO_SYS_MSG,0,(char *)c_sys_msg,0);
			i_ferr [0] = Ferror32;

			if ( i_err[0] == -1 && Ferror32 != FNOTPRES )
			{
				fn_errlog( c_ServiceName, "S31265", FMLMSG, c_err_msg  );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      	Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); 
      	Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); 
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
		rtrim(c_sys_msg);
	 }
		/*************** Ver 8.7 Ends Here ****************/
		
		if(strcmp(c_sys_msg,"MY_EOS") !=0 )  /****** Condition Added Ver 8.7 ****/
		{
    	if( strcmp(c_alias,c_alias_nm) != 0 )         /** Ver 6.6 **/
    	{
      	fn_errlog( c_ServiceName, "B55006", "", c_err_msg  );
      	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
     	  Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
      	Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    	}
		}

     strcpy(c_bp_id,st_usr_prfl.c_user_id);
    }
    else
    {
			/***  Ver 3.0 Starts  ***/

			if(DEBUG_MSG_LVL_3)
			{
    		fn_userlog(c_ServiceName,"For Normal USER ID ");
			}
		
		 /********************************* Commented in Ver 6.6 *******************************************

    	EXEC SQL
      	SELECT  NVL(CLM_BP_ID,'*')
      	INTO    :c_bp_id
      	FROM    CLM_CLNT_MSTR
      	WHERE   CLM_MTCH_ACCNT = :st_usr_prfl.c_cln_mtch_accnt;

    	if(SQLCODE != 0 )
    	{
      	fn_errlog( c_ServiceName, "S31270",SQLMSG,c_err_msg);
      	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			***	Ver	3.1	***	
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    	}

		******************************** Comments Ends ver 6.6  **********************************************/

    	if( c_bp_id[0] !='*' )
    	{
      	strcpy((char *)v_user_id.arr,st_ordbook.c_user_id);
				SETLEN(v_user_id);
    	}

    	/***  Ver 3.0 Ends  ***/

    /*  strcpy(c_bp_id,"*");	Commented In Ver 3.0	***/
    }

		/*** 1.7    
			fn_userlog(c_ServiceName,"BP channel  is :%s:",c_channel); 
		**1.7****/

    /***1.1 end ***/

/**Ver 3.0, This check is moved from above to the place after the BPID and alias verification so that normal customers 
	 for whom dt allowed flag is N, there user id will not get populated in Order book**/ 

  /**** Comment in Ver 6.5 Starts Here ***********

  EXEC SQL  SELECT  USR_DT_ALLWD_FLG
            INTO    :sql_usr_dt_allwd_flg
            FROM    usr_user_master
            WHERE   usr_usr_id  = :v_user_id;

  if( SQLCODE != 0 )
  {
    fn_errlog( c_ServiceName, "S31275", SQLMSG, c_err_msg  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			***	Ver	3.1	***
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
  ****** Ver 6.5 Ends Here *****/
 
  if( sql_usr_dt_allwd_flg != 'Y')	
  {
    MEMSET(v_user_id);
  }
	if(DEBUG_MSG_LVL_5)
	{
  	fn_userlog(c_ServiceName,"DT ALLOWED FLAG IS  :%c:", sql_usr_dt_allwd_flg);
  	fn_userlog(c_ServiceName,"USER ID IS  :%s:", v_user_id.arr);
	}


		if(DEBUG_MSG_LVL_5)
		{
		fn_userlog(c_ServiceName,"Exchange :%s:",st_cntrct.c_xchng_cd);
		}

	/*** Following commented In Ver 4.1
	EXEC SQL
		SELECT to_char( exg_nxt_trd_dt, 'DD-Mon-YYYY' ),
					 to_char( exg_nxt_trd_dt, 'YYYYMMDD' ),     ***/
	EXEC SQL
		SELECT to_char( GREATEST(exg_nxt_trd_dt,exg_tmp_trd_dt), 'DD-Mon-YYYY' ),     /*** Ver 4.1 ***/
					 to_char( GREATEST(exg_nxt_trd_dt,exg_tmp_trd_dt), 'YYYYMMDD' ),				/*** Ver 4.1 ***/
					 to_char( exg_nxt_trd_dt, 'DD-Mon-YYYY' ),															/*** Ver 4.1 ***/
					 to_char( sysdate, 'DD-Mon-YYYY hh24:mi:ss' )
		INTO	 :c_trd_dt,
					 :c_date,
					 :c_nrml_trd_dt,				/*** Ver 4.1 ***/
					 :c_sysdate
		FROM	 exg_xchng_mstr
		WHERE	 exg_xchng_cd = :st_cntrct.c_xchng_cd
		AND		 exg_mkt_typ	=	'D';
	
	if ( SQLCODE != 0 )
	{
   	fn_errlog( c_ServiceName, "S31280",SQLMSG,c_err_msg);
   	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
	  Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
 	  tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}
  SETNULL ( c_trd_dt );
  SETNULL ( c_sysdate );
  SETNULL ( c_date );

	/*** Ver 4.1 Starts ***/
	/*** Following checks whether the underlying in which client trying to place order will come under corporate action ***/

	if(DEBUG_MSG_LVL_3)
	{
		fn_userlog(c_ServiceName,"Underlying Is :%s:",st_ordbook.c_undrlyng);
		fn_userlog(c_ServiceName,"Exchange Trade date Is :%s:",c_nrml_trd_dt.arr);
	}

	i_corp_rec_exists = 0;

	if(strcmp(st_ordbook.c_channel,"OFF") != 0)
	{
	
		EXEC SQL
    	SELECT  1
    	INTO   :i_corp_rec_exists
    	FROM   FCM_FO_CORP_MSTR
    	WHERE  FCM_UNDRLYNG = :st_ordbook.c_undrlyng
    	AND    FCM_ACTN_DT  = :c_nrml_trd_dt 
			AND    FCM_RUN_STTS != 'P';
	}

	if ( i_corp_rec_exists == 1)
	{
		fn_errlog ( c_ServiceName, "B28518", DEFMSG, c_err_msg );
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
	  Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
  	tpreturn ( TPFAIL, ERR_BFR, ( char * )ptr_fml_Ibuf, 0, 0 );
	}

	/*** Ver 4.1 Ends 	***/


	strcpy( st_xchngbook.c_mod_trd_dt, (char *) c_trd_dt.arr);
	strcpy( st_ordbook.c_trd_dt, (char *) c_trd_dt.arr);

	if(DEBUG_MSG_LVL_3)
	{
		fn_userlog( c_ServiceName, "Sprd Ord Ind :%c:", 
																		 st_xchngbook.c_sprd_ord_ind );
	}

/*	st_xchngbook.c_sprd_ord_ind = '0' ; */

	/** Following moved from below in Ver 4.3 ***/

	l_ord_lmt_rt = st_cntrct.l_strike_prc;

	/** Moved from in Ver 4.3 Ends  ***/

	c_trdng_psswrd_flg = YES;
	
	/****  Added part in Ver 8.2 Starts  ***/	
  if ( ( st_xchngbook.c_spl_flg == CLIENT_SQROFF ) ||
  ( st_xchngbook.c_spl_flg == SYSTEM_SQUAREOFF)  ||
  ( st_xchngbook.c_spl_flg == IMTM_SYS_SQUAREOFF )  ||
  ( st_xchngbook.c_spl_flg == LMTNEG_SYS_SQUAREOFF  )  ||
  ( st_xchngbook.c_spl_flg == PHYSICAL_DLVRY_SQOFF )  ||  /** Ver 9.6 **/
  ( st_xchngbook.c_spl_flg == JOINT_SQUAREOFF ) )
  {
      if (st_cntrct.c_prd_typ == 'I') 
      {
        MEMSET(c_sys_msg);
        i_err[0]  = Fget32(ptr_fml_Ibuf,FFO_SYS_MSG,0,(char *)c_sys_msg,0);
        i_ferr [0] = Ferror32;

        if ( i_err[0] == -1 )
        {
          if ( Ferror32 != FNOTPRES )
          {
            fn_errlog( c_ServiceName, "S31285", FMLMSG, c_err_msg  );
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
            Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
            Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); 
            Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          }
          else if( Ferror32 == FNOTPRES )
          {
            fn_userlog(c_ServiceName," 666");
            i_mtm_flg =2;       /* if called by OptionPLUS Customer from ASP */
            strcpy(c_sys_msg,"COVER_OPTPLUS");
          }
        }
        else /* success condition */
        {
          /** if ( i_excp_flag == 1)  *** EXCPT_EOS added in Ver 6.4 ***   *** Commented in Ver 8.2 ***
          {
            strcpy(c_sys_msg,"EXCPT_EOS");
          }  **/

          if(DEBUG_MSG_LVL_3)
          {
            fn_userlog(c_ServiceName," 777");
            fn_userlog(c_ServiceName,"c_sys_msg =:%s:",c_sys_msg); /* if called from backoffice EOS */
          }
          if ( (strcmp(c_sys_msg,"EOS") == 0 || strcmp(c_sys_msg,"OFF") == 0 || strcmp(c_sys_msg,"EXCPT_EOS") == 0 )  && ( st_xchngbook.c_spl_flg == SYSTEM_SQUAREOFF || st_xchngbook.c_spl_flg == IMTM_SYS_SQUAREOFF || st_xchngbook.c_spl_flg == LMTNEG_SYS_SQUAREOFF || st_xchngbook.c_spl_flg == PHYSICAL_DLVRY_SQOFF) ) /*** Check added for IMTM_SYS_SQUAREOFF and LMTNEG_SYS_SQUAREOFF in Ver 5.7 ***/ /*** EXCPT_EOS added in Ver 6.4 ***/ /** ver 9.6 PHYSICAL_DLVRY_SQOFF added **/

          {
            i_mtm_flg=1;
          }
          else if ( strcmp(c_sys_msg,"MY_EOS") == 0 )  /*** Else if added in Ver 8.2 ***/
          {
            i_mtm_flg=2;
          }
        }
        if(DEBUG_MSG_LVL_3)
        {
          fn_userlog(c_ServiceName,"In fn_chk_cntrct_sltpfp_sqoff");
        }

        rtrim(st_cntrct.c_expry_dt);

        /** if (i_mtm_flg != 1 &&  i_mtm_flg != 2 ) *** contract check skipped in case of squareoff orders ***
        {  *** Commented in Ver 8.2  **/
          i_returncode = fn_chk_cntrct_sltpfp_sqoff(c_ServiceName,&st_cntrct,&c_fum_mrkt_typ,&c_fcm_mrkt_typ,&st_err_msg );
					if ( i_returncode != 0 )  
					{
						fn_errlog( c_ServiceName, "S31290", Fstrerror32(i_ferr[0]),c_err_msg);
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
						Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			
						Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
						Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
						tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
				 /*** Commented in Ver 8.2
        }  *****/
      } 
	}
		/****  Added part in Ver 8.2 Ends ***/

  if (( st_xchngbook.c_spl_flg != 'J' ) 		   			 &&
     	( st_xchngbook.c_spl_flg != SYSTEM_SQUAREOFF)  && 
     	( st_xchngbook.c_spl_flg != L2_ORDER)          &&
     	( st_xchngbook.c_spl_flg != L3_ORDER)          &&
     	( st_xchngbook.c_spl_flg != ARBITRAGE )				 &&
		/*** 	( st_cntrct.c_prd_typ    != OPTIONPLUS)    	   &&          ** Ver 5.4 **Commented in Ver 7.5 ***/
 			(  ( st_cntrct.c_prd_typ    != OPTIONPLUS) || ( st_cntrct.c_prd_typ==OPTIONPLUS && st_xchngbook.c_spl_flg == CLIENT_SQROFF)) && /*** added in Ver 7.8
as session check was getting skipped while Placing Cover Order from Open Position ***/ 
      ( st_xchngbook.c_spl_flg != IMTM_SYS_SQUAREOFF )  &&        /*** Ver 5.7 ***/
      ( st_xchngbook.c_spl_flg != PHYSICAL_DLVRY_SQOFF )  &&        /*** Ver 9.6 ***/
      ( st_xchngbook.c_spl_flg != LMTNEG_SYS_SQUAREOFF )  &&      /*** Ver 5.7 ***/  
			( strcmp(st_usr_prfl.c_user_id,"system") != 0 )	&&
			( c_1clk_flg != 'Y' )	)           /**Ver 2.6, added L2,L3 and arbitrage skipping **/	/** Vre 10.8 c_1clk_flg added **/
	{
  if (  strcmp(c_sys_msg , "MY_EOS") != 0 )       /** Ver 8.2 ***/
  {
  	i_err[0] = Fget32( ptr_fml_Ibuf, FFO_TRD_PSSWD, 0,
                        		(char *)c_usr_usr_psswrd.arr,0);
  	i_ferr [0] = Ferror32;

  	if (( i_err[0] == -1 ) && ( i_ferr[0] != FNOTPRES ))
  	{
   		fn_errlog( c_ServiceName, "S31295", Fstrerror32(i_ferr[0]),c_err_msg);
   		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
	  	Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
   	  Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	}
/**Commented for Ver 2.4
  	else if (( i_err[0] == -1 ) && ( i_ferr[0] == FNOTPRES ))
  	{
			c_trdng_psswrd_flg = NO;
  	}
		else
		{
			c_trdng_psswrd_flg = YES;
		}
***/

/**Ver 2.4 starts **/
		
		/*** Following taken above in Ver 4.3 

		l_ord_lmt_rt = st_cntrct.l_strike_prc; 

		***/

		/**Call function for trading limit check **/
    i_returncode = fn_chk_trdng_limit(c_ServiceName,
                                      st_xchngbook.l_ord_tot_qty,
                                      l_ord_lmt_rt,
                                      &c_trdng_psswrd_flg,
																			&st_usr_prfl,
                                      &st_err_msg );
    if ( i_returncode == -1 )
    {
      fn_errlog( c_ServiceName, "S31300", LIBMSG, c_err_msg );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
/**Ver 2.4 ends **/

		if(DEBUG_MSG_LVL_5)
		{ 
			fn_userlog( c_ServiceName, "c_trdng_psswrd_flg:%c:", 
																						c_trdng_psswrd_flg );
		}
		SETLEN( c_usr_usr_psswrd );
    /*** Ver 10.0 Starts ***/
    if (c_trdng_psswrd_flg == YES && strcmp(c_ven_nm.arr,"SENSIBULL") == 0)
    {
      fn_errlog( c_ServiceName, "S31305", "Please try placing order with lesser order value using sensibull", c_err_msg );
			strcpy(c_err_msg,"Please try placing order with lesser order value using sensibull");
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
    /*** Ver 10.0 Ends ***/
		if ( c_trdng_psswrd_flg == YES )
		{
			strcpy( c_temp_psswrd, (char *)c_usr_usr_psswrd.arr );
		}
   }
   else if( strcmp ( c_sys_msg , "MY_EOS") == 0 )    /** Else part added in Ver 8.2 **/
   {
     c_trdng_psswrd_flg= NO;
   }

		/*** Commented in Ver 3.9 ***
  	i_returncode =  fn_check_user ( c_ServiceName,
                                 		&st_usr_prfl ,
																		c_temp_psswrd,
																		c_trdng_psswrd_flg,
																		&st_err_msg );
		*****************************/
		
		/*** Added in Ver 3.9 ***/
   /*** if( st_cntrct.c_prd_typ    != OPTIONPLUS )  *** If condition added in Ver 7.5
    { *** Commented in Ver 7.8 ***/
			i_returncode =  fn_check_user_ip ( c_ServiceName,
																				 &st_usr_prfl ,
																				 c_temp_psswrd,
																				 c_trdng_psswrd_flg,
																				 c_ip_address,
                                         c_txn_flg,                   /*** Ver 8.0 ***/
																				 &st_err_msg );
		/*************************/

  	if ( i_returncode == -1 )
  	{
			fn_errlog( c_ServiceName, "S31310", LIBMSG, c_err_msg );
   		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );
			/*** Ver	3.1	Starts	***/

			if ( c_trdng_psswrd_flg == 'Y' )
			{
				i_actn_id	=	1;
			}
			else
			{
				i_actn_id	=	-1;
			}

    	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );     
				/*** Ver  3.1 Ends	***/
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/

   		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
  /***  } Ver 7.8 Comment Ends ***/
	} 
	/**** Ver 6.8 *** Starst Here ****/
	if(DEBUG_MSG_LVL_3)
  {
  	fn_userlog(c_ServiceName," c_nkd_blkd_flg :%c:",c_nkd_blkd_flg);
  }

	if( c_nkd_blkd_flg == 'A' || c_nkd_blkd_flg == 'G' ) /*** Auto MTM Process Call (System SQ order) ***/ /* Ver 11.2  */
  {
    MEMSET(c_ip_address);
    sprintf(c_ip_address,"%c",c_nkd_blkd_flg);
  }

  /*** Ver 6.8 *** Ends Here ***/

	if(DEBUG_MSG_LVL_3)	/*** Ver 3.9 ***/
	{
		fn_userlog(c_ServiceName,"ip address:%s:",c_ip_address);
	}
		
	i_returncode = 0 ; /*** Ver 5.4 Variable initialized ***/

	if ( ( st_xchngbook.c_spl_flg == CLIENT_SQROFF ) || 
				( st_xchngbook.c_spl_flg == SYSTEM_SQUAREOFF)  ||
        ( st_xchngbook.c_spl_flg == IMTM_SYS_SQUAREOFF )  ||               /*** Ver 5.7 ***/
        ( st_xchngbook.c_spl_flg == PHYSICAL_DLVRY_SQOFF )  ||               /*** Ver 9.6 ***/
        ( st_xchngbook.c_spl_flg == LMTNEG_SYS_SQUAREOFF  )  ||            /*** Ver 5.7 ***/
				( st_xchngbook.c_spl_flg == JOINT_SQUAREOFF ) )
	{

			if ( st_cntrct.c_prd_typ == 'O')  /*** Ver 5.4 if condition added ***/
			{

				if(DEBUG_MSG_LVL_5)
				{
 					fn_userlog(c_ServiceName,"INSIDE SQUARE OFF for :%s: and :%s:",st_usr_prfl.c_cln_mtch_accnt,st_cntrct.c_undrlyng); 
				}

				i_returncode = fn_chk_cntrct_sqoff( c_ServiceName,
   		  	                                 &st_cntrct,
																					 &c_fum_mrkt_typ,                 /* Ver 2.5 */
            	            								 &c_fcm_mrkt_typ,                 /* Ver 2.5 */
     		      	                           &st_err_msg );
 	
		
				/*******************************************************************************/
    		/*****************1.5 by sangeet for false position in square off **************/
    		/*******************************************************************************/
    		EXEC SQL
    		SELECT fop_opnpstn_qty,
      		     DECODE(FOP_OPNPSTN_FLW,'S',GREATEST(ABS(FOP_IBUY_QTY),ABS(FOP_EXBUY_QTY)),'B',GREATEST( ABS(FOP_ISELL_QTY), 
							 ABS(FOP_EXSELL_QTY)),0)     /***  Added field in Ver 3.1  ***/
    		INTO   :l_opnpstn_qty,
               :l_cvr_qty   /***  Added field in Ver 3.1  ***/
    		FROM   fop_fo_options_pstn
    		WHERE  fop_clm_mtch_accnt = :st_usr_prfl.c_cln_mtch_accnt
    		and    fop_xchng_cd       = :st_cntrct.c_xchng_cd
    		and    fop_undrlyng       = :st_cntrct.c_undrlyng
    		and    fop_expry_dt       = :c_expiry_dt
    		and    fop_exer_typ       = :st_cntrct.c_exrc_typ
    		and    fop_opt_typ       	= :st_cntrct.c_opt_typ
    		and    fop_strk_prc       = :st_cntrct.l_strike_prc   ;

    		if(SQLCODE != 0 )
    		{
      	  fn_errlog( c_ServiceName, "S31315", SQLMSG, c_err_msg  );
        	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 3.1 ***/
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
        	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    		}

				if(DEBUG_MSG_LVL_5)
				{
  				fn_userlog( c_ServiceName, " C_ORDR_FLW :%c:", st_xchngbook.c_ordr_flw );
  				fn_userlog( c_ServiceName, " L_OPNPSTN_QTY :%ld:", l_opnpstn_qty );
				}
     
    		if(st_xchngbook.c_ordr_flw == 'B' && l_opnpstn_qty > 0)
    		{
        	fn_errlog( c_ServiceName, "S31320", "Improper square off - Buy Combination, Please contact CustomerService", c_err_msg  );
        	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 3.1 ***/
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
         	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    		}
    		if(st_xchngbook.c_ordr_flw == 'S' && l_opnpstn_qty < 0)
    		{
        	fn_errlog( c_ServiceName, "S31325", "Improper square off - Sell Combination, Please contact Customer Service", c_err_msg  );
        	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 3.1 ***/
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
        	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    		}

    		/*******************************************************************************/
    		/***********1.5 by sangeet for wrong place order in square off  ends ***********/
    		/*******************************************************************************/

    		/***   Ver 3.1 Square Off Quantity Check   ***/
    
    		if ( st_xchngbook.l_ord_tot_qty <= 0 )
    		{
      		fn_userlog(c_ServiceName,"Total Order Qty Is :%ld:",st_xchngbook.l_ord_tot_qty);
      		fn_errlog( c_ServiceName, "S31330", "Square Off Qty Can Not Be Zero/Negative. ", c_err_msg );
      		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG,"Square Off Qty Can Not Be Zero/Negative. Please Enter Valid Value." , 0 );
      		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      	  Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
         	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    		}

    		if ( st_xchngbook.c_ordr_flw == 'B' )
    		{
      		l_opn_qty = l_opnpstn_qty * (-1);
    		}
    		else
    		{
      		l_opn_qty = l_opnpstn_qty ;
    		}

    		if(l_opn_qty < (st_xchngbook.l_ord_tot_qty  + l_cvr_qty) )
    		{
      		fn_userlog(c_ServiceName,"Inside Squre Off Qty Check");
      		fn_userlog(c_ServiceName,"Open Position Qty Is :%ld:",l_opn_qty);
      		fn_userlog(c_ServiceName,"Total Order Qty Is :%ld:",st_xchngbook.l_ord_tot_qty);
      		fn_userlog(c_ServiceName,"Cover Qty Is :%ld:",l_cvr_qty);
      		fn_errlog( c_ServiceName, "S31335", "Square Off Qty Can Not Be Greater Than Available Qty", c_err_msg );
 
   /*Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG,"Square Off Qty Can Not Be Greater Than Available Qty" ,0); *Commented in Ver 6.7 */

          /*** Ver 6.7 Starts ***/
          if ( strcmp(st_ordbook.c_channel,"SYS") == 0 )
          {
            sprintf(c_err_msg,"Square Off Qty Can Not Be Greater Than Available Qty for :%s: ",st_usr_prfl.c_cln_mtch_accnt);
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg , 0 );
          }
          else
          {
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG,"Square Off Qty Can Not Be Greater Than Available Qty" , 0 );
          }
          /*** Ver 6.7 Ends ***/    


      		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
       		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    		}

    		/***  Ver 3.1 Ends  ***/ 
			}
			/*** else if (st_cntrct.c_prd_typ == 'I') *** Ver 5.4 ***     *** commented in Ver 8.2 starts and moved to line ***
			{
				MEMSET(c_sys_msg);
      	i_err[0]  = Fget32(ptr_fml_Ibuf,FFO_SYS_MSG,0,(char *)c_sys_msg,0);
      	i_ferr [0] = Ferror32;

      	if ( i_err[0] == -1 )
      	{
        	if ( Ferror32 != FNOTPRES )
        	{
          	fn_errlog( c_ServiceName, "S31340", FMLMSG, c_err_msg  );
          	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
            Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); ***  Ver 6.9 ***
            Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); ***  Ver 6.9 ***
          	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        	}
        	else if( Ferror32 == FNOTPRES )
        	{
          	fn_userlog(c_ServiceName," 666");
          	i_mtm_flg =2;       * if called by OptionPLUS Customer from ASP *
          	strcpy(c_sys_msg,"COVER_OPTPLUS");
        	}
      	}
      	else * success condition *
      	{
					** if ( i_excp_flag == 1)	*** EXCPT_EOS added in Ver 6.4 ***
					{
						strcpy(c_sys_msg,"EXCPT_EOS");
					}

        	if(DEBUG_MSG_LVL_3)
        	{
          	fn_userlog(c_ServiceName," 777");
          	fn_userlog(c_ServiceName,"c_sys_msg =:%s:",c_sys_msg); * if called from backoffice EOS *
        	}
        	if ( (strcmp(c_sys_msg,"EOS") == 0 || strcmp(c_sys_msg,"OFF") == 0 || strcmp(c_sys_msg,"EXCPT_EOS") == 0 )  && ( st_xchngbook.c_spl_flg == SYSTEM_SQUAREOFF || st_xchngbook.c_spl_flg == IMTM_SYS_SQUAREOFF || st_xchngbook.c_spl_flg == LMTNEG_SYS_SQUAREOFF ) ) *** Check added for IMTM_SYS_SQUAREOFF and LMTNEG_SYS_SQUAREOFF in Ver 5.7 ****** EXCPT_EOS added in Ver 6.4 ***
        	{
          	i_mtm_flg=1;
        	}
      	}

      	if(DEBUG_MSG_LVL_3)
      	{
      		fn_userlog(c_ServiceName,"In fn_chk_cntrct_sltpfp_sqoff");
      	}

      	rtrim(st_cntrct.c_expry_dt);

			  if (i_mtm_flg != 1 &&  i_mtm_flg != 2 ) *** contract check skipped in case of squareoff orders ***
        {
      		i_returncode = fn_chk_cntrct_sltpfp_sqoff(c_ServiceName,&st_cntrct,&c_fum_mrkt_typ,&c_fcm_mrkt_typ,&st_err_msg );
				}
			}  commented part in Ver 8.2 Ends and moved to line  ***/
       
	} /*** If ends here ***/
	else
	{
			if(DEBUG_MSG_LVL_5)
			{
 				fn_userlog(c_ServiceName,"INSIDE NORMAL for :%s: and :%s:",st_usr_prfl.c_cln_mtch_accnt,st_cntrct.c_undrlyng); 
			}

		if ( st_cntrct.c_prd_typ != 'I')  /*** Ver 5.4 if condition added ***/
		{
  		i_returncode = fn_chk_cntrct( c_ServiceName,
   			                             &st_cntrct,
																		 &c_fum_mrkt_typ,			/* Ver 2.5 */
																		 &c_fcm_mrkt_typ,			/* Ver 2.5 */
     		    	                       &st_err_msg );
		}
	}
  /*** if ( i_returncode == -1 ) Commented In Ver 5.1 ***/
   if(DEBUG_MSG_LVL_3)  /**** DEBUG_MSG_LVL_3 Added in Ver 8.1 ****/
	 {
			fn_userlog(c_ServiceName," i_returncode :%d:",i_returncode);
	 }
	if ( i_returncode != 0 )   /*** Ver 5.1 ***/
  {
     Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );
     Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
     Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
     Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
     tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}


	/** Commented Ver 6.3 ****

	fn_cpy_ddr ( st_cntrct.c_rout_crt );
	i_ip_len = sizeof ( struct vw_contract );
	i_op_len = sizeof ( struct vw_cntrct_qt );

	i_returncode = fn_call_svc( c_ServiceName,
                              c_err_msg,
                              &st_cntrct,
                              &st_cntrct_qt,
                              "vw_contract",
                              "vw_cntrct_qt",
                              i_ip_len,
                              i_op_len,
                              0,
                              "SFO_GET_QT" );
	*******/

	/*** Commented in Ver 9.2 ***

	** Ver 6.3 Ends **

  i_returncode = fn_get_qt(c_ServiceName,
                           &st_cntrct,
                           &st_cntrct_qt,
                           c_err_msg);

	** Ver 6.3 Ends **

	*** Commented in Ver 9.2 ***/

	/*** Ver 9.2 Starts here ***/

  i_returncode = fn_get_quote(c_ServiceName,
                              &st_cntrct,
                              &st_cntrct_qt,
                              &c_setlmnt_flg,
                              &c_dlvry_pos_allwd,
															&c_buy_allwd,   /*** ver 10.9 ***/
                              &c_sell_allwd,  /*** ver 10.9 ***/
                              &c_mrkt_ordr_flg, /*** ver 11.1 ***/	
                              c_err_msg);

  /*** Ver 9.2 Ends here ***/

  if ( i_returncode != SUCC_BFR )
  {
   	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
  	Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
  	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}

	/*** Ver 9.2 Starts here ***/

  /**** ver 11.1 starts **********/
 
  if(DEBUG_MSG_LVL_3)
  { 
    fn_userlog( c_ServiceName, "c_mrkt_ordr_flg :%c:, c_user_id :%s:, c_spl_flg :%c:, c_ord_typ :%c:, c_slm_flg :%c:", c_mrkt_ordr_flg
, st_usr_prfl.c_user_id, st_xchngbook.c_spl_flg, st_xchngbook.c_ord_typ, st_xchngbook.c_slm_flg);
  }

  if(st_cntrct.c_prd_typ == 'O')
  {
   if( st_xchngbook.c_slm_flg == 'M' )
    {
    if( ( c_mrkt_ordr_flg == 'N' && ( strcmp(st_usr_prfl.c_user_id,"system") != 0 )) || ( c_mrkt_ordr_flg == 'N' && (st_xchngbook.c_spl_flg == CLIENT_SQROFF && ( st_xchngbook.c_ord_typ == IMMEDIATE_OR_CANCEL ))))
    {
        if( st_xchngbook.c_spl_flg == CLIENT_SQROFF )  
        {
        fn_errlog( c_ServiceName, "B20091", "", c_err_msg  );
        }  
        else
        {  
        fn_errlog( c_ServiceName, "B20090", "", c_err_msg  );
        }
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
    } 
  }
    /**** ver 11.1 ends ***********/

	if ( st_cntrct.c_prd_typ != 'P' && st_cntrct.c_prd_typ != 'U' && st_cntrct.c_prd_typ != 'I' )
	{
   /*** commented in ver 10.9 if (c_dlvry_pos_allwd == 'N')	**/
		if((st_xchngbook.c_ordr_flw == 'B' &&  c_buy_allwd == 'N') || (st_xchngbook.c_ordr_flw == 'S' && c_sell_allwd == 'N')) /*** ver 10.9 c_buy_allwd and c_sell_allwd added ***/
   {
    if( Fget32(ptr_fml_Ibuf,FFO_BK_UBK_FLG,0,(char *)&c_dlvry_eos_flg,0) == -1 )
    {
      if ( Ferror32 != FNOTPRES )
      {
        fn_errlog( c_ServiceName, "S31345", FMLMSG, c_err_msg  );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
      else if( Ferror32 == FNOTPRES )
      {
        c_dlvry_eos_flg='N';
      }
    }

		/*** Ver 9.5 Starts ***/

		EXEC SQL
        SELECT NVL(fop_opnpstn_qty,0),
               DECODE(FOP_OPNPSTN_FLW,'S',GREATEST(ABS(FOP_IBUY_QTY),ABS(FOP_EXBUY_QTY)),'B',GREATEST( ABS(FOP_ISELL_QTY),
               ABS(FOP_EXSELL_QTY)),0)
        INTO   :l_opnpstn_qty,
               :l_cvr_qty
        FROM   fop_fo_options_pstn
        WHERE  fop_clm_mtch_accnt = :st_usr_prfl.c_cln_mtch_accnt
        and    fop_xchng_cd       = :st_cntrct.c_xchng_cd
        and    fop_undrlyng       = :st_cntrct.c_undrlyng
        and    fop_expry_dt       = :c_expiry_dt
        and    fop_exer_typ       = :st_cntrct.c_exrc_typ
        and    fop_opt_typ        = :st_cntrct.c_opt_typ
        and    fop_strk_prc       = :st_cntrct.l_strike_prc   ;

        if(SQLCODE != 0 && SQLCODE != NO_DATA_FOUND)
        {
          fn_errlog( c_ServiceName, "S31350", SQLMSG, c_err_msg  );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }

				if(SQLCODE == NO_DATA_FOUND)
    		{
      		l_opnpstn_qty = 0;
      		l_cvr_qty = 0;
    		}

				if(st_xchngbook.c_ordr_flw == 'B' && l_opnpstn_qty > 0)
        {
					/*** ver 10.9 Start ***/
          fn_userlog(c_ServiceName," You can only Square off your existing position & No new position is allowed in this contract.");
          strcpy(c_err_msg,"You can only Square off your existing position & No new position is allowed in this contract.");
         /*** ver 10.9 End ***/
        /*** comment in ver 10.9

					fn_userlog( c_ServiceName,"Improper square off - Buy Combination/No New Positions are not allowed in this contract, Please contact Customer Service");
      		strcpy( c_err_msg,"Improper square off - Buy Combination/No New Positions are not allowed in this contract, Please contact Customer Service");  comment ends ***/
      		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      		Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
      		Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
      		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}

				if(st_xchngbook.c_ordr_flw == 'S' && l_opnpstn_qty < 0)
        {
					/*** ver 10.9 Start ***/
          fn_userlog(c_ServiceName," You can only Square off your existing position & No new position is allowed in this contract.");
          strcpy(c_err_msg,"You can only Square off your existing position & No new position is allowed in this contract.");
        /** ver 10.9 Ends***/
        /*** comment starts in ver 10.9
					fn_userlog( c_ServiceName,"Improper square off - Sell Combination/No New Positions are not allowed in this contract, Please contact Customer Service");
      		strcpy( c_err_msg,"Improper square off - Sell Combination/No New Positions are not allowed in this contract, Please contact Customer Service");	 comment ends ***/
      		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      		Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
      		Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
      		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}

				if ( st_xchngbook.c_ordr_flw == 'B' )
        {
          l_opn_qty = l_opnpstn_qty * (-1);
        }
        else
        {
          l_opn_qty = l_opnpstn_qty ;
        }

 fn_userlog( c_ServiceName,"l_opn_qty :%ld: st_xchngbook.l_ord_tot_qty :%ld: l_cvr_qty :%ld:",l_opn_qty,st_xchngbook.l_ord_tot_qty,l_cvr_qty);

        if(l_opn_qty >= (st_xchngbook.l_ord_tot_qty  + l_cvr_qty) )
        {
					i_phy_sqroff_check = 1;
				}


      if( DEBUG_MSG_LVL_4 )
      { 
       fn_userlog(c_ServiceName,"l_opn_qty :%ld:",l_opn_qty);
       fn_userlog(c_ServiceName,"st_xchngbook.l_ord_tot_qty :%ld:",st_xchngbook.l_ord_tot_qty);
       fn_userlog(c_ServiceName,"l_cvr_qty :%ld:",l_cvr_qty);
       fn_userlog(c_ServiceName,"-------------- i_phy_sqroff_check----------- :%d:",i_phy_sqroff_check);
      } 
		/*** Ver 9.5 Ends ***/

/***    if (c_dlvry_eos_flg!='E')		*** Commented in Ver 9.5 ***/
		if ((c_dlvry_eos_flg!='E' && i_phy_sqroff_check != 1) && (st_xchngbook.c_spl_flg != PHYSICAL_DLVRY_SQOFF ) )	/*** Modified in Ver 9.5 ***/ /** spl flg added in 9.6 **/
    {
			/*** ver 10.9 ***/
      if( c_buy_allwd == 'N' && st_xchngbook.c_ordr_flw =='B' )
      {
        fn_userlog( c_ServiceName," Currently fresh Buy order is not allowed in this contract. However, you will be able to square off your open position in any contract.");
        strcpy(c_err_msg," Currently fresh Buy order is not allowed in this contract. However, you will be able to square off your open position in any contract.");
      }
      else if( c_sell_allwd == 'N' && st_xchngbook.c_ordr_flw == 'S' )
      {
        fn_userlog( c_ServiceName," Currently fresh Sell order is not allowed in this contract. However, you will be able to square off your open position in any contract.");
        strcpy(c_err_msg," Currently fresh Sell order is not allowed in this contract. However, you will be able to square off your open position in any contract.");
      }
      /*** ver 10.9 End ***/

     /*** ver 10.9 fn_userlog( c_ServiceName,"Currently Trading is not allowed in this contract");
      strcpy( c_err_msg,"Currently Trading is not allowed in this contract");	***/
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
   }
	}

  /*** Ver 9.2 Ends here ***/

/********** Ver 6.0 Start *****************/

	if((st_cntrct.c_prd_typ == 'I') && (st_xchngbook.c_slm_flg != MARKET))
	{
		i_returncode = fn_opls_vrfy_prc_band	( c_ServiceName ,
																						st_xchngbook.l_ord_lmt_rt,
											 											&st_ordbook,
                       											&st_err_msg );	
		if ( i_returncode == -1 )
    {
      fn_errlog( c_ServiceName, "S31355", LIBMSG, c_err_msg );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }	
	}
	
/********** Ver 6.0 Ends *****************/
	if ( (st_xchngbook.c_slm_flg == MARKET) && (st_xchngbook.c_ordr_flw == SELL) )
	{


/****** Ver 5.3 Start ******/
 EXEC SQL
      SELECT nvl(FTQ_BST1_BID_QTY,0),
             nvl(FTQ_BST2_BID_QTY,0),
             nvl(FTQ_BST3_BID_QTY,0),
             nvl(FTQ_BST4_BID_QTY,0),
             nvl(FTQ_BST5_BID_QTY,0)
      INTO   :st_cntrctlong_qt.l_bst_bid_qty[0],
             :st_cntrctlong_qt.l_bst_bid_qty[1],
             :st_cntrctlong_qt.l_bst_bid_qty[2],
             :st_cntrctlong_qt.l_bst_bid_qty[3],
             :st_cntrctlong_qt.l_bst_bid_qty[4]
     FROM   FTQ_FO_TRD_QT
      WHERE  FTQ_XCHNG_CD  = :st_cntrct.c_xchng_cd
			 AND   FTQ_PRDCT_TYP = decode(:st_cntrct.c_prd_typ,'I','O',:st_cntrct.c_prd_typ) /*** Ver 5.4 OptionPLUS Ohandling added ***/
       AND   FTQ_UNDRLYNG  = :st_cntrct.c_undrlyng
       AND   FTQ_EXPRY_DT  = to_date ( :c_expiry_dt,'dd-Mon-yyyy' )
       AND   FTQ_EXER_TYP  = :st_cntrct.c_exrc_typ
       AND   FTQ_OPT_TYP   = :st_cntrct.c_opt_typ
       AND   FTQ_STRK_PRC  = :st_cntrct.l_strike_prc;

    if(SQLCODE != 0 && SQLCODE != NO_DATA_FOUND)
    {
      fn_errlog( c_ServiceName, "S31360", SQLMSG, c_err_msg  );
			fn_userlog(c_ServiceName , "Skipping Error. OptionPlus Order.");    /***  Ver 5.9 ***/
	
			/***  commented in Ver 6.1 **	
			if ( ( ( strcmp( st_ordbook.c_channel,"SYS") == 0 ) && (st_cntrct.c_prd_typ != 'I') )
							||  ( strcmp( st_ordbook.c_channel,"SYS") != 0 && st_xchngbook.c_spl_flg == CLIENT_SQROFF 
									&& st_cntrct.c_prd_typ != 'I' ) )  ***/

			if ( ( ( strcmp( st_ordbook.c_channel,"SYS") == 0 ) && (st_cntrct.c_prd_typ != 'I') )
							||  ( (strcmp( st_ordbook.c_channel,"SYS") != 0 || st_xchngbook.c_spl_flg == CLIENT_SQROFF )
									&& st_cntrct.c_prd_typ != 'I' ) )    /*** Ver 6.1 ***/
			/*** If Condition Added in Ver 5.9 ** S kipp SYSTEM_SQUAREOFF and CLIENT_SQROFF For OptionPlus ***/
  		{
      	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
    }
    else if (SQLCODE == NO_DATA_FOUND)
    {
      fn_errlog ( c_ServiceName, "B28510", DEFMSG, c_err_msg );
			fn_userlog(c_ServiceName , "Skipping Error. OptionPlus Order.");   /***  Ver 5.9 ***/

			/***  commented in Ver 6.1 **
			if ( ( ( strcmp( st_ordbook.c_channel,"SYS") == 0 ) && (st_cntrct.c_prd_typ != 'I') )
              ||  ( strcmp( st_ordbook.c_channel,"SYS") != 0 && st_xchngbook.c_spl_flg == CLIENT_SQROFF
                  && st_cntrct.c_prd_typ != 'I' ) )  ***/

			if ( ( ( strcmp( st_ordbook.c_channel,"SYS") == 0 ) && (st_cntrct.c_prd_typ != 'I') )
							||  ( (strcmp( st_ordbook.c_channel,"SYS") != 0 || st_xchngbook.c_spl_flg == CLIENT_SQROFF )
									&& st_cntrct.c_prd_typ != 'I' ) )    /*** Ver 6.1 ***/
      /*** If Condition Added in Ver 5.9 ** S kipp SYSTEM_SQUAREOFF and CLIENT_SQROFF For OptionPlus ***/
      {
      	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
      	tpreturn ( TPFAIL, ERR_BFR, ( char * )ptr_fml_Ibuf, 0, 0 );
			}
    }

		/*** Ver 6.1 ** Starts ***/
		if(DEBUG_MSG_LVL_4)
    {
      fn_userlog(c_ServiceName,"Best 5 Bids qty are -  :%ld: :%ld: :%ld: :%ld: :%ld: ",st_cntrctlong_qt.l_bst_bid_qty[0],st_cntrctlong_qt.l_bst_bid_qty[1],st_cntrctlong_qt.l_bst_bid_qty[2],st_cntrctlong_qt.l_bst_bid_qty[3],st_cntrctlong_qt.l_bst_bid_qty[4]);
    }
		/*** Ver 6.1 ** Ends ***/	

    li_max_sell_ordqty = (st_cntrctlong_qt.l_bst_bid_qty[0] + st_cntrctlong_qt.l_bst_bid_qty[1] + st_cntrctlong_qt.l_bst_bid_qty[2]+st_cntrctlong_qt.l_bst_bid_qty[3]+st_cntrctlong_qt.l_bst_bid_qty[4]) ;

    if(DEBUG_MSG_LVL_3) /*** DEBUG_MSG_LVL_3 Added in Ver 8.1 ***/
		{
			fn_userlog(c_ServiceName,"st_xchngbook.l_ord_tot_qty is :%ld:",st_xchngbook.l_ord_tot_qty);
			fn_userlog(c_ServiceName,"Total best 5 bid qty is :%ld:",li_max_sell_ordqty);
		}

     if( DEBUG_MSG_LVL_4 )
      {
       fn_userlog(c_ServiceName,"l_opn_qty :%ld:",l_opn_qty);
       fn_userlog(c_ServiceName,"st_xchngbook.l_ord_tot_qty :%ld:",st_xchngbook.l_ord_tot_qty);
       fn_userlog(c_ServiceName,"l_cvr_qty :%ld:",l_cvr_qty);
       fn_userlog(c_ServiceName,"-------------- i_phy_sqroff_check----------- :%d:",i_phy_sqroff_check);
       fn_userlog(c_ServiceName," st_xchngbook.c_spl_flg :%c:",st_xchngbook.c_spl_flg);
      }

/***    if (st_xchngbook.l_ord_tot_qty>li_max_sell_ordqty)	*** Commented in Ver 9.5 ***/
			if ((st_xchngbook.l_ord_tot_qty>li_max_sell_ordqty ) && (i_phy_sqroff_check !=1 && st_xchngbook.c_spl_flg != PHYSICAL_DLVRY_SQOFF) )	/*** Modified in Ver 9.5 ***/ /**Spl flag added in ver 9.6 */
      {
          fn_errlog( c_ServiceName, "B91116", DEFMSG, c_err_msg  );
					fn_userlog(c_ServiceName , "Skipping Error. OptionPlus Order.");    /***  Ver 5.9 ***/

					/*** commented in Ver 6.1 ** 					
					if ( ( ( strcmp( st_ordbook.c_channel,"SYS") == 0 ) && (st_cntrct.c_prd_typ != 'I') )
              ||  ( strcmp( st_ordbook.c_channel,"SYS") != 0 && st_xchngbook.c_spl_flg == CLIENT_SQROFF
                  && st_cntrct.c_prd_typ != 'I' ) )   ***/

					if ( ( ( strcmp( st_ordbook.c_channel,"SYS") == 0 ) && (st_cntrct.c_prd_typ != 'I') )
							||  ( (strcmp( st_ordbook.c_channel,"SYS") != 0 || st_xchngbook.c_spl_flg == CLIENT_SQROFF )
									&& st_cntrct.c_prd_typ != 'I' ) )    /*** Ver 6.1 ***/
      		/*** If Condition Added in Ver 5.9 ** S kipp SYSTEM_SQUAREOFF and CLIENT_SQROFF For OptionPlus ***/
      		{					
          	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
            Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
            Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/   
          	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
      }

/****** Ver 5.3 End  ******/


		st_xchngbook.l_quote = st_cntrct_qt.l_lst_trdd_prc;
		/*** Ver 9.5 Starts ***/
    if ( st_xchngbook.l_quote == 0 && (i_phy_sqroff_check == 1 || st_xchngbook.c_spl_flg == PHYSICAL_DLVRY_SQOFF ) ) /**spl flag added in ver 9.6 **/
    {
      i_returncode = fn_get_quote_zero(c_ServiceName,st_xchngbook.c_ordr_flw,l_best_bid_price,l_best_offer_price,l_previous_close_price,&l_quote_zero);

      if( i_returncode != 1 )
      {
				fn_userlog( c_ServiceName,"function fn_get_quote_zero failure");
        strcpy( c_err_msg,"System Error.Contact Customer Support");
     		Fadd32(ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0);
     		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
     		Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
     		Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
     		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0);
			}

      st_xchngbook.l_quote = l_quote_zero;
			if(DEBUG_MSG_LVL_5)
      {
        fn_userlog( c_ServiceName,"After fn_get_quote_zero st_xchngbook.l_quote is :%ld:",st_xchngbook.l_quote);
      }
    }
    /*** Ver 9.5 Ends ***/
		strcpy ( st_xchngbook.c_qt_tm, 
             (char *)st_cntrct_qt.c_lst_trdd_time );
		st_ordbook.l_ord_lmt_rt = st_xchngbook.l_quote;
	}

  /*** Ver 7.5 Starts ***/
  if( st_xchngbook.c_slm_flg == 'L' && st_cntrct.c_prd_typ  == 'I' )
  {
    EXEC SQL
        SELECT  nvl(FUM_SLTPFP_LMT_ALLWD_FLG,'N')
        INTO  :c_lmt_allwd_flg
        FROM  FUM_FO_UNDRLYNG_MSTR
        WHERE  FUM_UNDRLYNG = :st_ordbook.c_undrlyng
        AND  FUM_XCHNG_CD = :st_cntrct.c_xchng_cd
        AND  FUM_PRDCT_TYP = decode(:st_cntrct.c_prd_typ,'U','F','I','O','P','F',:st_cntrct.c_prd_typ);

   if ( SQLCODE != 0 )
   {
     fn_userlog(c_ServiceName, "Failed To Get LIMIT Allowed Flag.");
     fn_errlog(c_ServiceName, "S31365", SQLMSG, c_err_msg);
     Fadd32(ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0);
     Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
     Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
     Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
     tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0);
   }

    if( c_lmt_allwd_flg == 'N')
    {
      fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
      fn_errlog( c_ServiceName,"S31370","Only Market orders are allowed in this stock. Please enter market as order type to place your order.",c_err_msg); 
      strcpy(c_err_msg,"Only Market orders are allowed in this stock. Please enter market as order type to place your order.");
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
  }
  /*** Ver 7.5 Ends ***/
	/****** Ver 1.4  ******/
	if ( (st_xchngbook.c_slm_flg == MARKET) && (st_xchngbook.c_ordr_flw == BUY) )
	{
		EXEC SQL
			SELECT nvl(FTQ_BST1_OFFR_QTY,0),
						 nvl(FTQ_BST2_OFFR_QTY,0),
						 nvl(FTQ_BST3_OFFR_QTY,0),
						 nvl(FTQ_BST4_OFFR_QTY,0),
						 nvl(FTQ_BST5_OFFR_QTY,0),
						 nvl(FTQ_BST1_OFFR_PRC,0),
						 nvl(FTQ_BST2_OFFR_PRC,0),
						 nvl(FTQ_BST3_OFFR_PRC,0),
						 nvl(FTQ_BST4_OFFR_PRC,0),
						 nvl(FTQ_BST5_OFFR_PRC,0)
			INTO	 :st_cntrctlong_qt.l_bst_offr_qty[0],
						 :st_cntrctlong_qt.l_bst_offr_qty[1],
						 :st_cntrctlong_qt.l_bst_offr_qty[2],
						 :st_cntrctlong_qt.l_bst_offr_qty[3],
						 :st_cntrctlong_qt.l_bst_offr_qty[4],
						 :st_cntrctlong_qt.l_bst_offr_prc[0],
						 :st_cntrctlong_qt.l_bst_offr_prc[1],
						 :st_cntrctlong_qt.l_bst_offr_prc[2],
						 :st_cntrctlong_qt.l_bst_offr_prc[3],
						 :st_cntrctlong_qt.l_bst_offr_prc[4]
			FROM	 FTQ_FO_TRD_QT
			WHERE	 FTQ_XCHNG_CD  = :st_cntrct.c_xchng_cd
       AND   FTQ_PRDCT_TYP = decode(:st_cntrct.c_prd_typ,'I','O',:st_cntrct.c_prd_typ) /*** Ver 5.4 OptionPLUS Ohandling added ***/
       AND   FTQ_UNDRLYNG  = :st_cntrct.c_undrlyng
       AND   FTQ_EXPRY_DT  = to_date ( :c_expiry_dt,'dd-Mon-yyyy' )
       AND   FTQ_EXER_TYP  = :st_cntrct.c_exrc_typ
       AND   FTQ_OPT_TYP   = :st_cntrct.c_opt_typ
       AND   FTQ_STRK_PRC  = :st_cntrct.l_strike_prc;

		if(SQLCODE != 0 && SQLCODE != NO_DATA_FOUND)
    {
    	fn_errlog( c_ServiceName, "S31375", SQLMSG, c_err_msg  );
			fn_userlog(c_ServiceName , "Skipping Error. OptionPlus Order.");    /***  Ver 5.9 ***/

			/*** Commented in Ver 6.1 **
			if ( (  ( strcmp( st_ordbook.c_channel,"SYS") == 0 ) && (st_cntrct.c_prd_typ != 'I') )
              ||  ( strcmp( st_ordbook.c_channel,"SYS") != 0 && st_xchngbook.c_spl_flg == CLIENT_SQROFF
                  && st_cntrct.c_prd_typ != 'I' ) )  ***/

			if ( ( ( strcmp( st_ordbook.c_channel,"SYS") == 0 ) && (st_cntrct.c_prd_typ != 'I') )
							||  ( (strcmp( st_ordbook.c_channel,"SYS") != 0 || st_xchngbook.c_spl_flg == CLIENT_SQROFF )
									&& st_cntrct.c_prd_typ != 'I' ) )    /*** Ver 6.1 ***/
      /*** If Condition Added in Ver 5.9 ** S kipp SYSTEM_SQUAREOFF and CLIENT_SQROFF For OptionPlus ***/
      {
    		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
    		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
    }
		else if (SQLCODE == NO_DATA_FOUND)
		{
			fn_errlog ( c_ServiceName, "B28510", DEFMSG, c_err_msg );
			fn_userlog(c_ServiceName , "Skipping Error. OptionPlus Order.");    /***  Ver 5.9 ***/

			/*** Commented in Ver 6.1 **
			if ( ( ( strcmp( st_ordbook.c_channel,"SYS") == 0 ) && (st_cntrct.c_prd_typ != 'I') )
              ||  ( strcmp( st_ordbook.c_channel,"SYS") != 0 && st_xchngbook.c_spl_flg == CLIENT_SQROFF
                  && st_cntrct.c_prd_typ != 'I' ) )   ***/
			
			if ( ( ( strcmp( st_ordbook.c_channel,"SYS") == 0 ) && (st_cntrct.c_prd_typ != 'I') )
							||  ( (strcmp( st_ordbook.c_channel,"SYS") != 0 || st_xchngbook.c_spl_flg == CLIENT_SQROFF )
									&& st_cntrct.c_prd_typ != 'I' ) )    /*** Ver 6.1 ***/
      /*** If Condition Added in Ver 5.9 ** S kipp SYSTEM_SQUAREOFF and CLIENT_SQROFF For OptionPlus ***/
      {
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
	      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
  			tpreturn ( TPFAIL, ERR_BFR, ( char * )ptr_fml_Ibuf, 0, 0 );
			}
		}

		/*** Ver 6.1 ** Starts ***/
    if(DEBUG_MSG_LVL_4)
    {
      fn_userlog(c_ServiceName,"Best 5 Offer qty are - :%ld: :%ld: :%ld: :%ld: :%ld: ",st_cntrctlong_qt.l_bst_offr_qty[0],st_cntrctlong_qt.l_bst_offr_qty[1],st_cntrctlong_qt.l_bst_offr_qty[2],st_cntrctlong_qt.l_bst_offr_qty[3],st_cntrctlong_qt.l_bst_offr_qty[4]);
		  fn_userlog(c_ServiceName,"Best 5 Offer  price are -	:%ld: :%ld: :%ld: :%ld: :%ld: ",st_cntrctlong_qt.l_bst_offr_prc[0],st_cntrctlong_qt.l_bst_offr_prc[1],st_cntrctlong_qt.l_bst_offr_prc[2],st_cntrctlong_qt.l_bst_offr_prc[3],st_cntrctlong_qt.l_bst_offr_prc[4]);
    }
    /*** Ver 6.1 ** Ends ***/
		
		li_aval_ordqty = st_xchngbook.l_ord_tot_qty;

		if ( (li_aval_ordqty - st_cntrctlong_qt.l_bst_offr_qty[0]) > 0)
		{
			d_totordrval += st_cntrctlong_qt.l_bst_offr_qty[0] * st_cntrctlong_qt.l_bst_offr_prc[0];
			li_aval_ordqty -= st_cntrctlong_qt.l_bst_offr_qty[0];
			if ( (li_aval_ordqty - st_cntrctlong_qt.l_bst_offr_qty[1]) > 0)
			{
				d_totordrval += st_cntrctlong_qt.l_bst_offr_qty[1] * st_cntrctlong_qt.l_bst_offr_prc[1];
				li_aval_ordqty -= st_cntrctlong_qt.l_bst_offr_qty[1];
				if ( (li_aval_ordqty - st_cntrctlong_qt.l_bst_offr_qty[2]) > 0)
				{
					d_totordrval += st_cntrctlong_qt.l_bst_offr_qty[2] * st_cntrctlong_qt.l_bst_offr_prc[2];
					li_aval_ordqty -= st_cntrctlong_qt.l_bst_offr_qty[2];
					if ( (li_aval_ordqty - st_cntrctlong_qt.l_bst_offr_qty[3]) > 0)
					{
						d_totordrval += st_cntrctlong_qt.l_bst_offr_qty[3] * st_cntrctlong_qt.l_bst_offr_prc[3];
						li_aval_ordqty -= st_cntrctlong_qt.l_bst_offr_qty[3];
						if ( (li_aval_ordqty - st_cntrctlong_qt.l_bst_offr_qty[4]) > 0)
						{
							if((i_phy_sqroff_check!=1) &&  (st_xchngbook.c_spl_flg != PHYSICAL_DLVRY_SQOFF) )		/*** Ver 9.5 ***/ /**Modified in ver 9.6 */
							{
					  	fn_errlog( c_ServiceName, "B56015", DEFMSG, c_err_msg  );
							fn_userlog(c_ServiceName , "Skipping Error. OptionPlus Order.");   /***  Ver 5.9 ***/
						
							/*** Commented in Ver 6.1 **	
							if ( ( ( strcmp( st_ordbook.c_channel,"SYS") == 0 ) && (st_cntrct.c_prd_typ != 'I') )
              ||  ( strcmp( st_ordbook.c_channel,"SYS") != 0 && st_xchngbook.c_spl_flg == CLIENT_SQROFF
                  && st_cntrct.c_prd_typ != 'I' ) ) ***/
		
							if ( ( ( strcmp( st_ordbook.c_channel,"SYS") == 0 ) && (st_cntrct.c_prd_typ != 'I') )
							||  ( (strcmp( st_ordbook.c_channel,"SYS") != 0 || st_xchngbook.c_spl_flg == CLIENT_SQROFF )
									&& st_cntrct.c_prd_typ != 'I' ) )    /*** Ver 6.1 ***/
          		/*** If Condition Added in Ver 5.9 ** S kipp SYSTEM_SQUAREOFF and CLIENT_SQROFF For OptionPlus ***/
          		{
      					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
								Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
                Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
                Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
      					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
							}
						  }				/*** Ver 9.5 ***/
						}
						else /* for Offer qty 4 */
						{
							d_totordrval += li_aval_ordqty * st_cntrctlong_qt.l_bst_offr_prc[4];
						}
					}
					else /* for Offer qty 3 */
					{
						d_totordrval += li_aval_ordqty * st_cntrctlong_qt.l_bst_offr_prc[3];
					}
				}
				else /* for Offer qty 2 */
				{
					d_totordrval += li_aval_ordqty * st_cntrctlong_qt.l_bst_offr_prc[2];
				}
			}
			else /* for Offer qty 1 */
    	{
				d_totordrval += li_aval_ordqty * st_cntrctlong_qt.l_bst_offr_prc[1];
    	}
		}
		else /* for Offer qty 0 */
		{
			st_xchngbook.l_quote = st_cntrctlong_qt.l_bst_offr_prc[0];
			i_condition = 0;	
		}

		if ( i_condition == 1)
		{
			st_xchngbook.l_quote = d_totordrval / st_xchngbook.l_ord_tot_qty;
		}

		/*** Ver 9.5 Starts ***/
    if ( i_phy_sqroff_check == 1 || st_xchngbook.c_spl_flg == PHYSICAL_DLVRY_SQOFF) /**spl flg added in ver 9.6 **/
    {
			st_xchngbook.l_quote = st_cntrct_qt.l_lst_trdd_prc;
			if(st_xchngbook.l_quote == 0)
			{
      	i_returncode = fn_get_quote_zero(c_ServiceName,st_xchngbook.c_ordr_flw,l_best_bid_price,l_best_offer_price,l_previous_close_price,&l_quote_zero);

      if( i_returncode != 1 )
      {
				fn_userlog( c_ServiceName,"function fn_get_quote_zero failure");
        strcpy( c_err_msg,"System Error.Contact Customer Support");
        Fadd32(ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0);
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0);
      }

      st_xchngbook.l_quote = l_quote_zero;
			}
    }
    /*** Ver 9.5 Ends ***/

		strcpy ( st_xchngbook.c_qt_tm,
             (char *)st_cntrct_qt.c_lst_trdd_time );
    st_ordbook.l_ord_lmt_rt = st_xchngbook.l_quote;
	
	} /* end of "If MARKET & BUY order" */
	/****** Ver 1.4 end ******/
	
	/*** Ver 5.4 Starts ***/

	if (st_cntrct.c_prd_typ == 'I' && i_mtm_flg == 2)   /* Client placed Square off*/
  {
		fn_userlog( c_ServiceName, "CR-ISEC14-144377 Index/Stock :%c:",  st_cntrct.c_ctgry_indstk );   /*** Added in Ver 10.3 ***/

    EXEC SQL
    SELECT /*** MTM_OP_ALLWD_STTS,
           MTM_OP_EOS_FLG Commented in Ver 10.3 ***/
					 DECODE( :st_cntrct.c_ctgry_indstk,'I',MTM_OP_ALLWD_STTS,'S',MTM_OP_ALLWD_STTS_S,'N' ),	/*** Ver 10.3 ***/
					 DECODE( :st_cntrct.c_ctgry_indstk,'I',MTM_OP_EOS_FLG,'S',MTM_OP_EOS_FLG_S,'N' )				/*** Ver 10.3 ***/ 
    INTO   :c_optpls_allwd,
           :c_optpls_eos
    FROM   mtm_appln_stts
    WHERE  mtm_xchng_cd =  :st_xchngbook.c_xchng_cd
    AND    mtm_pipe_id  =  :st_xchngbook.c_pipe_id;

    if( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31380", SQLMSG,c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

    if (c_optpls_allwd == 'N' )
    {
      fn_errlog( c_ServiceName, "B35013",DEFMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

    if ( c_optpls_eos == 'Y')
    {
      fn_errlog( c_ServiceName, "B35014",DEFMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
  }

	/*** Ver 5.4 Ends   ***/


	

	i_returncode = fn_check_inp_opt( c_ServiceName, 
                               		 &st_xchngbook, 
                               		 &st_cntrct_qt,
																	 c_fum_mrkt_typ,			/* Ver 2.5 */				
																	 c_fcm_mrkt_typ,			/* Ver 2.5 */ 
                               		 &st_err_msg );
  if ( i_returncode == -1 )
  {
   	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );
		Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/ 
  	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}                            	

	i_trnsctn = fn_begintran( c_ServiceName, c_err_msg );
	if ( i_trnsctn == -1 )
	{
   	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
		Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/ 
  	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}
	/**************1.6 - locking is removed from here*********************/

	/************* Commented in ver 6.6 ****************

	fn_cpy_ddr ( st_cntrct.c_rout_crt );
	i_ip_len = sizeof ( struct vw_contract );
	i_op_len = sizeof ( struct vw_cntrt_gen_inf );

	i_returncode = fn_call_svc( c_ServiceName,
                              c_err_msg,
                              &st_cntrct,
                              &st_cntrct_gen_inf,
                              "vw_contract",
                              "vw_cntrt_gen_inf",
                              i_ip_len,
                              i_op_len,
                              0,
                              "SFO_GETCNT_GEN" );
  if ( i_returncode != SUCC_BFR )
  {
    fn_errlog( c_ServiceName, "S31385", LIBMSG, c_err_msg  );
		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
   	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
		Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			***	Ver	3.1	***	
   	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}                            	
	
	***************** Comment Ends ver 6.6 ****************/
	
	i_returncode = fn_check_ord_opt( c_ServiceName,
                               &st_cntrct_gen_inf,
                               &st_xchngbook,
                               &st_ordbook, 
                               &st_err_msg );
  if ( i_returncode == -1 )
  {
    fn_errlog( c_ServiceName, "S31390", LIBMSG, c_err_msg  );
		fn_aborttran( c_ServiceName, i_trnsctn, st_err_msg.c_err_msg );
   	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );
		Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/ 
  	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}                            	

	if ( st_xchngbook.c_slm_flg == MARKET )
	{
		st_xchngbook.l_ord_lmt_rt = st_xchngbook.l_quote;
	}


  /*** Ver 4.3 Starts ***/
  /*** Calling Function Order max limit ****/

  c_ord_val_flg = 'N';
  c_cumopn_val_flg = 'N';
  c_serv_call_flg =  'P' ;    /*** Set to 'P' in case of placment ***/
  d_netadj_ord_val = 0.0;    /*** Set to zero in case of placment ***/

  if(DEBUG_MSG_LVL_3)
  {
    fn_userlog(c_ServiceName,"Swati-----st_xchngbook.l_ord_lmt_rt is :%ld:",st_xchngbook.l_ord_lmt_rt);
    fn_userlog(c_ServiceName,"Swati-----l_ord_lmt_rt is :%ld:",l_ord_lmt_rt);
  }

  l_ord_lmt_rt = l_ord_lmt_rt + st_xchngbook.l_ord_lmt_rt ;

  if(DEBUG_MSG_LVL_3)
  {
    fn_userlog(c_ServiceName,"Swati--New -----l_ord_lmt_rt is :%ld:",l_ord_lmt_rt);
    fn_userlog(c_ServiceName,"Before fn_chk_ord_max_limit, st_ordbook.c_channel  :%s:",st_ordbook.c_channel); /** Ver 8.3 **/
  }

	MEMSET(st_err_msg); /*** Ver 5.4 ***/

	if(strcmp(st_ordbook.c_channel,"OFF") != 0  )                 /** Ver 8.3 **/ 
  {
  	i_returncode = fn_chk_ord_max_limit(c_ServiceName,
    	                                  st_usr_prfl.c_cln_mtch_accnt,
      	                                st_xchngbook.l_ord_tot_qty,
        	                              l_ord_lmt_rt,
          	                            d_netadj_ord_val,
            	                          c_serv_call_flg,
              	                        st_xchngbook.c_slm_flg,
                	                      st_cntrct.c_xchng_cd ,
                  	                    &c_ord_val_flg,
                    	                  &c_cumopn_val_flg,
                      	                &st_err_msg );
  	if ( i_returncode == -1 )
  	{
      fn_errlog( c_ServiceName, "S31395", LIBMSG, c_err_msg );
    	fn_aborttran( c_ServiceName, i_trnsctn, st_err_msg.c_err_msg );
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );
    	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    	Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    	Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	}
	}

  if(DEBUG_MSG_LVL_3)
  {
    fn_userlog(c_ServiceName," c_ord_val_flg :%c:",c_ord_val_flg);
    fn_userlog(c_ServiceName," c_cumopn_val_flg :%c:",c_cumopn_val_flg);
    fn_userlog(c_ServiceName," st_err_msg.c_err_msg :%s:",st_err_msg.c_err_msg);
  }
                                                                                                                          
	if( (!strstr( st_xchngbook.c_xchng_rmrks,"Physical Settlement EOS")) && (st_xchngbook.c_spl_flg != PHYSICAL_DLVRY_SQOFF) ) 
                                                                                              /*** Added in Ver 9.2 **/ /**spl flg added in ver 9.6*/
	{
  if(c_cumopn_val_flg == 'Y')
  {
    fn_userlog( c_ServiceName, " Order Value exceeding max Cumulative open order value.");
    fn_errlog( c_ServiceName, "B21077", "DEFMSG", c_err_msg  );
    fn_aborttran( c_ServiceName, i_trnsctn, st_err_msg.c_err_msg );
    strcat(c_err_msg,st_err_msg.c_err_msg);
    Fadd32(ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0);
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0);
  }
	}

  if(c_ord_val_flg == 'Y')
  {
	 if ( (st_cntrct.c_prd_typ == OPTIONPLUS) && ( (strcmp(c_sys_msg,"EOS") == 0 || strcmp(c_sys_msg,"MY_EOS") == 0 || strcmp(c_sys_msg,"EXCPT_EOS") == 0) ) ) /*** if loop added in  Ver 10.1 ***/
	 {
		 fn_userlog( c_ServiceName, "SKIP check of Order value Exceeding Max Market/Limit value allowed.");
	 }
	 else
	 {
    fn_userlog( c_ServiceName, "Order value Exceeding Max Market/Limit value allowed.");
    fn_errlog( c_ServiceName, "B23035", "DEFMSG", c_err_msg  );
    fn_aborttran( c_ServiceName, i_trnsctn, st_err_msg.c_err_msg );
    strcat(c_err_msg,st_err_msg.c_err_msg);
    fn_userlog(c_ServiceName," c_err_msg :%s:",c_err_msg);
    Fadd32(ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0);
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0);
	 }
	}
  


  /*** Ver 4.3 Ends   ***/


	i_ip_len = sizeof ( struct vw_sequence );
	i_op_len = sizeof ( struct vw_sequence );

	if(DEBUG_MSG_LVL_3)  /*** Ver 4.1 ***/
	{
    fn_userlog(c_ServiceName,"channel is :%s:",(char *)st_ordbook.c_channel);
    fn_userlog(c_ServiceName,"Exchange Code is :%s:",st_xchngbook.c_xchng_cd);
	}

	/*** Following commented In Ver 4.1 	
	strcpy( st_s_sequence.c_pipe_id, st_xchngbook.c_pipe_id );  ***/

	/*** Ver 4.1 Starts ***/

	if(strcmp(st_ordbook.c_channel,"OFF") == 0)
  {
    if ( strcmp( st_xchngbook.c_xchng_cd , "NFO") == 0 )
    {
      strcpy( st_s_sequence.c_pipe_id,"99");
    }
    else if ( strcmp( st_xchngbook.c_xchng_cd , "BFO") == 0 )
    {
      strcpy( st_s_sequence.c_pipe_id,"A9");
    }
    strcpy( st_xchngbook.c_pipe_id,st_s_sequence.c_pipe_id);
  }
	else
	{
		strcpy( st_s_sequence.c_pipe_id, st_xchngbook.c_pipe_id ); 
	}

	/*** Ver 4.1 Ends ***/

  strcpy( st_s_sequence.c_trd_dt, st_xchngbook.c_mod_trd_dt );
	fn_cpy_ddr ( st_s_sequence.c_rout_crt );
  st_s_sequence.c_rqst_typ = GET_XCHNG_SEQ;

	if(DEBUG_MSG_LVL_5)
	{
		fn_userlog(c_ServiceName,"BEFORE START OF SFO_GET_SEQ");
	}
  /**************** Commented in Ver 8.8 ********************
	i_returncode = fn_call_svc( c_ServiceName,
                              c_err_msg,
                              &st_s_sequence,
                              &st_r_sequence,
                              "vw_sequence",
                              "vw_sequence",
                              i_ip_len,
                              i_op_len,
                              0,
                              "SFO_GET_SEQ" );
  ***************** Comment End in Ver 8.8  *****************/
  /******* Added in Ver 8.8 **************/
  if(DEBUG_MSG_LVL_5)
  {
  	fn_userlog(c_ServiceName,"Before Calling function fn_get_seq **********");
	}
  i_returncode = fn_get_seq(c_ServiceName,c_err_msg,st_s_sequence.c_pipe_id,&st_r_sequence.l_seq_num,st_s_sequence.c_rqst_typ);
  /******* Add ended in Ver 8.8 **************/
 	if ( i_returncode != SUCC_BFR )
 	{
    fn_errlog( c_ServiceName, "S31400", LIBMSG, c_err_msg  );
		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
 		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
		Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
 	  Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
  	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	} 
	if(DEBUG_MSG_LVL_5)
	{
		fn_userlog(c_ServiceName,"AFTER END OF SFO_GET_SEQ");
	}

	l_xchng_seq_num = st_r_sequence.l_seq_num;


	strcpy( st_s_sequence.c_pipe_id, st_xchngbook.c_pipe_id ); 
  strcpy( st_s_sequence.c_trd_dt, st_xchngbook.c_mod_trd_dt );
	fn_cpy_ddr ( st_s_sequence.c_rout_crt );
  st_s_sequence.c_rqst_typ = GET_ORDER_SEQ;
/**************** Commented in Ver 8.8 ********************
	i_returncode = fn_call_svc( c_ServiceName,
                              c_err_msg,
                              &st_s_sequence,
                              &st_r_sequence,
                              "vw_sequence",
                              "vw_sequence",
                              i_ip_len,
                              i_op_len,
                              0,
                              "SFO_GET_SEQ" );
  ***************** Comment End in Ver 8.8  *****************/
	/******* Added in Ver 8.8 **************/
  if(DEBUG_MSG_LVL_5)
  {
    fn_userlog(c_ServiceName,"Before Calling function fn_get_seq **********");
  }
  i_returncode = fn_get_seq(c_ServiceName,c_err_msg,st_s_sequence.c_pipe_id,&st_r_sequence.l_seq_num,st_s_sequence.c_rqst_typ);
  /******* Add ended in Ver 8.8 **************/
  if( i_returncode != SUCC_BFR )	
 	{
    fn_errlog( c_ServiceName, "S31405", LIBMSG, c_err_msg  );
		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
  	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
		Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/ 
  	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}                            	
	/******************1.6 - commit transaction introduced here******************/
	if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg ) == -1 )
	{
    fn_errlog( c_ServiceName, "S31410", LIBMSG, c_err_msg  );
 		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
		Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
 	  Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
  	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}

	l_ord_seq_num = st_r_sequence.l_seq_num;

	if ( ( st_xchngbook.c_ord_typ == GOOD_TILL_TODAY     ) ||
			 ( st_xchngbook.c_ord_typ == IMMEDIATE_OR_CANCEL )  )
			
	{
		strcpy ( st_xchngbook.c_valid_dt, (char *)c_trd_dt.arr ); 
	}

	sprintf( c_seq_num, "%08d", l_ord_seq_num );

	strcpy( st_xchngbook.c_ordr_rfrnc, (char *)c_date.arr );
	strcat( st_xchngbook.c_ordr_rfrnc, st_xchngbook.c_pipe_id );
	strcat( st_xchngbook.c_ordr_rfrnc, c_seq_num );
	strcpy( st_ordbook.c_ordr_rfrnc, st_xchngbook.c_ordr_rfrnc);

	st_xchngbook.l_mdfctn_cntr = 1;
	st_ordbook.l_mdfctn_cntr = 1;

  strcpy(st_pstn_actn.c_user_id, st_usr_prfl.c_user_id);
  st_pstn_actn.l_session_id  = st_usr_prfl.l_session_id;

	strcpy(st_pstn_actn.c_cln_mtch_accnt,st_ordbook.c_cln_mtch_accnt);
	st_pstn_actn.l_eba_cntrct_id = st_cntrct.l_eba_cntrct_id;
	strcpy(st_pstn_actn.c_xchng_cd,st_cntrct.c_xchng_cd);
	st_pstn_actn.c_prd_typ = st_cntrct.c_prd_typ;
	strcpy(st_pstn_actn.c_undrlyng,st_cntrct.c_undrlyng);
	strcpy(st_pstn_actn.c_expry_dt,st_cntrct.c_expry_dt);
	st_pstn_actn.c_exrc_typ = st_cntrct.c_exrc_typ;
	st_pstn_actn.c_opt_typ = st_cntrct.c_opt_typ;
	st_pstn_actn.l_strike_prc = st_cntrct.l_strike_prc;
	st_pstn_actn.c_ctgry_indstk = st_cntrct.c_ctgry_indstk;
	st_pstn_actn.l_ca_lvl = st_cntrct.l_ca_lvl;
	st_pstn_actn.c_cntrct_tag = '*';

  if ( st_xchngbook.c_spl_flg == SYSTEM_SQUAREOFF ||
       st_xchngbook.c_spl_flg == IMTM_SYS_SQUAREOFF ||
       st_xchngbook.c_spl_flg == PHYSICAL_DLVRY_SQOFF ||  /** ver 9.6 **/
       st_xchngbook.c_spl_flg == LMTNEG_SYS_SQUAREOFF ) /*** Check added for IMTM_SYS_SQUAREOFF and LMTNEG_SYS_SQUAREOFF in Ver 5.7 ***/
  {
    st_pstn_actn.l_actn_typ = SYSTEM_PLACE_ORDER;
  }
  else if ( st_xchngbook.c_spl_flg == 'J' )
  {
    st_pstn_actn.l_actn_typ = JOINT_SQUARE_OFF_ORDER;
  }
  else
  {
    st_pstn_actn.l_actn_typ = ORS_NEW_ORD_REQ;
  }

  if ( st_xchngbook.c_spl_flg == CLIENT_SQROFF)
  {
    st_pstn_actn.c_nkd_blkd_flg = 'N';
  }
  else
  {
    st_pstn_actn.c_nkd_blkd_flg = 'Y';
  }

	st_pstn_actn.c_trnsctn_flw = st_ordbook.c_ordr_flw;
	st_pstn_actn.l_orgnl_qty = 0;
	st_pstn_actn.l_orgnl_rt  = 0;
	st_pstn_actn.l_new_qty = st_xchngbook.l_ord_tot_qty;

	if ( st_xchngbook.c_slm_flg == MARKET )
	{
		st_pstn_actn.l_new_rt  = st_xchngbook.l_quote;
	}
	else
	{
		st_pstn_actn.l_new_rt  = st_xchngbook.l_ord_lmt_rt;
	}

	st_pstn_actn.l_exec_qty  = 0;
	st_pstn_actn.l_exec_rt  = 0;
	st_pstn_actn.l_fresh_qty  = 0;
	st_pstn_actn.l_cover_qty  = 0;
	st_pstn_actn.d_add_mrgn_amt  = 0;

	st_pstn_actn.l_curr_rt = st_cntrct_qt.l_lst_trdd_prc;
	sprintf(st_pstn_actn.c_ref_rmrks,"%s-%ld",st_ordbook.c_ordr_rfrnc,
														 	st_ordbook.l_mdfctn_cntr);
	rtrim(st_pstn_actn.c_ref_rmrks);
	if(DEBUG_MSG_LVL_5)
	{
		fn_userlog( c_ServiceName, "st_pstn_actn.c_ref_rmrks:%s:",
																					st_pstn_actn.c_ref_rmrks );
	}
	
	/***********begining transaction and locking user introduced here******************/
	i_trnsctn = fn_begintran( c_ServiceName, c_err_msg );
	if ( i_trnsctn == -1 )
	{
   	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
		Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			/***	Ver	3.1	***/	
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/ 
  	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}

	/*** Ver 4.5 Starts ***/

	if ((strncmp ( st_xchngbook.c_xchng_rmrks , "CORP ACTN" , 9)==0)&& (strcmp(st_ordbook.c_channel,"OFF") == 0))
	{
		st_pstn_actn.c_nkd_blkd_flg = 'P';
	}

	/*** Ver 4.5 Ends 	***/

  /*** Ver 7.6 Starts ***/

  if ((strncmp ( st_xchngbook.c_xchng_rmrks , "OptionPlus to Options" , 21)==0)&& (strcmp(st_ordbook.c_channel,"SYS") == 0))
  {
    if(DEBUG_MSG_LVL_3)
    {
        fn_userlog(c_ServiceName,"OptionPlus to Options Conversion");
    }

    st_pstn_actn.c_nkd_blkd_flg = 'P';
  }

  /*** Ver 7.6 Ends   ***/

 /*** commented in ver 9.3 ** 
  i_returncode = fn_lock_usr( c_ServiceName,
                              st_usr_prfl.c_cln_mtch_accnt );
  if ( i_returncode == -1 )
  {
    fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    Fadd32( ptr_fml_Ibuf,	FFO_ACTN_ID,(char *)&i_actn_id, 0 );			***	Ver	3.1	***	
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); ***  Ver 6.9 ***
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); ***  Ver 6.9 ***
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
  *** 9.3 comment ends ***/

	fn_cpy_ddr ( st_pstn_actn.c_rout_crt );
	i_ip_len = sizeof ( struct vw_pstn_actn );
	i_op_len = sizeof ( struct vw_pstn_actn );

  /** Ver 8.2 starts  **/

   if ( st_cntrct.c_prd_typ == 'I' && ( strcmp(c_sys_msg,"EOS") == 0 || strcmp(c_sys_msg,"COVER_OPTPLUS") == 0 /*** || strcmp(c_sys_msg,"OFF") == 0 *** Commented in Ver 8.9 ***/ || 
    strcmp(c_sys_msg,"EXCPT_EOS") == 0  || strcmp(c_sys_msg,"MY_EOS") == 0 )) /*** EXCPT_EOS added in Ver 6.4 ***/  /*** MY_EOS added in Ver 8.2 ***/
    {
      if ( strcmp(c_sys_msg,"MY_EOS") == 0 )  /*** If loop added in Ver 8.2 ***/
      {
        i_err[0]  = Fget32(ptr_fml_Ibuf,FFO_ORDR_RFRNC,0,(char *)c_myeos_frs_ord_ref,0); 
        i_ferr [0] = Ferror32;
      }
      else
      {
        i_err[0]  = Fget32(ptr_fml_Ibuf,FFO_ORDR_RFRNC,0,(char *)c_cover_ord_ref,0);
        i_ferr [0] = Ferror32;
      }
      if ( i_err[0] == -1 )
      {
        fn_errlog( c_ServiceName, "S31415", FMLMSG, c_err_msg  );
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

      if ( strcmp(c_sys_msg,"MY_EOS") == 0 )  /*** If loop added in Ver 8.2 ***/
      {
            EXEC SQL
            SELECT  decode(FOD_FC_FLAG,'F',FOD_SLTP_ORDR_RFRNC,FOD_ORDR_RFRNC),
                    FOD_SLTP_ORDR_RFRNC /*** added in ver 9.3 ***/
            INTO    :c_cover_ord_ref,
                    :c_sltplck_ord_ref /** added in ver 9.3 ***/
            FROM    FOD_FO_ORDR_DTLS
            WHERE   FOD_ORDR_RFRNC = :c_myeos_frs_ord_ref;
      
       if ( SQLCODE  !=  0 )
       {
          fn_errlog( c_ServiceName, "S31420",SQLMSG,c_err_msg);
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
       }
        /*** ver 9.3 starts ***/
        EXEC SQL
        SELECT  FOD_ORDR_RFRNC,
                FOD_SLTP_ORDR_RFRNC
        INTO    :c_ordr_rfrnc_lck,
                :c_sltp_ord_rfrnc_lck
        FROM    FOD_FO_ORDR_DTLS
        WHERE   FOD_ORDR_RFRNC in ( :c_myeos_frs_ord_ref,:c_sltplck_ord_ref )
        FOR     UPDATE OF FOD_ORDR_RFRNC;
        /*** ver 9.3 ends ***/
      }
      else /*** ver 9.3 starts ***/
      {
        EXEC SQL
        SELECT  FOD_SLTP_ORDR_RFRNC
        INTO    :c_sltplck_ord_ref
        FROM    FOD_FO_ORDR_DTLS
        WHERE   FOD_ORDR_RFRNC = :c_cover_ord_ref;      

       if ( SQLCODE  !=  0 )
       {
          fn_errlog( c_ServiceName, "S31425",SQLMSG,c_err_msg);
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); 
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); 
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
       }

        EXEC  SQL
        SELECT  FOD_ORDR_RFRNC,
                FOD_SLTP_ORDR_RFRNC
        INTO    :c_ordr_rfrnc_lck,
                :c_sltp_ord_rfrnc_lck
        FROM    FOD_FO_ORDR_DTLS
        WHERE   FOD_ORDR_RFRNC in ( :c_cover_ord_ref,:c_sltplck_ord_ref )
        FOR     UPDATE OF FOD_ORDR_RFRNC;
      }
       if ( SQLCODE  !=  0 ) 
       {
        if (SQLCODE == -54)
        {
             fn_userlog( c_ServiceName, "Resource busy and failed to acquire lock" );
        } 
          fn_errlog( c_ServiceName, "S31430",SQLMSG,c_err_msg);
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
       }
       else
       {
         fn_userlog( c_ServiceName, "Sucessfully acquired FOR UPDATE lock on :%s: and :%s: and :%s:",c_sltplck_ord_ref,c_cover_ord_ref,c_myeos_frs_ord_ref );
       }
      /*** ver 9.3 ends ***/
      {
        fn_userlog( c_ServiceName, "c_cover_ord_ref = :%s:", c_cover_ord_ref );
      }
    }


    /*** ver 9.3 starts ***/
	  /*i_returncode = fn_lock_usr( c_ServiceName, st_usr_prfl.c_cln_mtch_accnt ); Commented in Ver 11.8 */
    i_returncode = fn_lock_fno( c_ServiceName,  st_usr_prfl.c_cln_mtch_accnt ); /* Added in Ver 11.8 */
	  if ( i_returncode == -1 )
		{
			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
      fn_errlog( c_ServiceName, "S31435",LIBMSG,c_err_msg);
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );  
			Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
			Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
    /*** ver 9.3 ends ***/
 
  if(st_cntrct.c_prd_typ==OPTIONPLUS)
  {
   if( strcmp(c_sys_msg, "MY_EOS") == 0 || strcmp(c_sys_msg, "EXCPT_EOS")== 0  ||  strcmp(c_sys_msg, "EOS") == 0 || strcmp(c_sys_msg,"COVER_OPTPLUS") == 0 ) /** ver 11.5 **/
   {
    i_pnd_stts = 0;
    EXEC SQL
			SELECT count(1)
			INTO  :i_pnd_stts
			FROM FOD_FO_ORDR_DTLS
			WHERE decode( fod_fc_flag, 'F',FOD_ORDR_RFRNC ,FOD_SLTP_ORDR_RFRNC) =
			(select decode( fod_fc_flag, 'F',FOD_ORDR_RFRNC ,FOD_SLTP_ORDR_RFRNC) from FOD_FO_ORDR_DTLS where FOD_ORDR_RFRNC = :c_cover_ord_ref )
			AND FOD_ORDR_STTS IN ('O','Q','R','P');

    fn_userlog(c_ServiceName, " i_pnd_stts is :%d:",i_pnd_stts);


    if(SQLCODE != 0 && SQLCODE != NO_DATA_FOUND)
    {
       fn_errlog ( c_ServiceName, "S31440", SQLMSG, c_err_msg);
       fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
       Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
       Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
       tpfree((char*) ptr_fml_Obuf);
       tpreturn ( TPFAIL, ERR_BFR, ( char * )ptr_fml_Ibuf, 0, 0 );
    }

    fn_userlog( c_ServiceName, "st_ordbook.c_ordr_rfrnc = :%s:", st_ordbook.c_ordr_rfrnc );
    i_open_qt = 0;
    EXEC SQL
    SELECT ABS(NVL( SUM( DECODE( FOD_FC_FLAG, 'C', -1 * FTD_EXCTD_QTY, FTD_EXCTD_QTY ) ), 0 ))
    INTO   :i_open_qt
    FROM   FOD_FO_ORDR_DTLS, FTD_FO_TRD_DTLS
    WHERE  FTD_ORDR_RFRNC = FOD_ORDR_RFRNC
    AND    decode( fod_fc_flag, 'F',FOD_ORDR_RFRNC ,FOD_SLTP_ORDR_RFRNC) =(select decode( fod_fc_flag, 'F',FOD_ORDR_RFRNC ,FOD_SLTP_ORDR_RFRNC)
                                                                           from FOD_FO_ORDR_DTLS
                                                                           where FOD_ORDR_RFRNC = :c_cover_ord_ref);
									   
    if(SQLCODE != 0 )
    {
       fn_errlog ( c_ServiceName, "S31445", SQLMSG, c_err_msg);
       fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
       Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
       Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
       Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
       tpfree((char*) ptr_fml_Obuf);
       tpreturn ( TPFAIL, ERR_BFR, ( char * )ptr_fml_Ibuf, 0, 0 );
    }
    if(DEBUG_MSG_LVL_0)
    {
      fn_userlog(c_ServiceName, "i_open_qt :%d:, st_xchngbook.l_ord_tot_qty :%ld:",i_open_qt,st_xchngbook.l_ord_tot_qty);
    }
    if(i_pnd_stts > 0  || i_open_qt != st_xchngbook.l_ord_tot_qty  )
    {
      fn_userlog(c_ServiceName, " The EOS in progress, Pls refresh the status ");
      fn_errlog( c_ServiceName, "B35025","",c_err_msg);
      fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_NO, "B35025", 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 3.4 ***/
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
     tpfree((char*) ptr_fml_Obuf);  /*** Ver 8.9 **/
     tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
   }
  }
  /** Ver 8.2 Ends ***/

    /** Ver 8.2 Starts ***/
   if ( st_cntrct.c_prd_typ==OPTIONPLUS )
   {
    if(strcmp(c_sys_msg, "MY_EOS") == 0 )
    {
      st_ordbook.c_req_typ = 'M';
    }
    if(strcmp(c_sys_msg, "EOS") == 0 )
    {
      st_ordbook.c_req_typ = 'N';
    }
    if(strcmp(c_sys_msg, "EXCPT_EOS") == 0 )
    {
      st_ordbook.c_req_typ = 'E';
    }
   }
     /** Ver 8.2 Ends ***/
	
	if( st_pstn_actn.c_prd_typ != 'I' )   /*** Ver 5.4 ***/
	{
		i_returncode = fn_call_svc( c_ServiceName,
    	                         	c_err_msg,
      	                       	&st_pstn_actn,
        	                     	&st_pstn_actn,
          	                   	"vw_pstn_actn",
            	                 	"vw_pstn_actn",
              	               	i_ip_len,
                	             	i_op_len,
                  	           	0,
                    	         	"SFO_UPD_OPT_POS" );

		if( i_returncode != SUCC_BFR )
  	{
    	/* 4.9 Starts */
    	if(i_returncode == INSUFFICIENT_LIMITS)
    	{
      	c_insuff_flg = 'Y';
      	strcpy(c_err_msg,strtok(c_err_msg,"|"));
      	d_required_amt = atof(strtok(NULL,"|"));
      	fn_userlog(c_ServiceName,"c_err_msg :%s:",c_err_msg);
      	fn_userlog(c_ServiceName,"d_required_amt :%lf:",d_required_amt);
    	}
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0);
      Fadd32( ptr_fml_Ibuf,FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
    	/* 4.9 Ends */

			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );	/***abort the old transaction***/
    	fn_errlog( c_ServiceName, "S31450", LIBMSG, c_err_msg  );
   		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 3.1 ***/

			/***************************start********************************************/
			/*********************1.6 - New error condition added here*******************/
			/***************************start********************************************/
	
      /*** Commented in Ver 7.3 and taken below ***	

    	i_trnsctn = fn_begintran( c_ServiceName, c_err_msg );
			if ( i_trnsctn == -1 )
			{
				fn_errlog( c_ServiceName, "S31455", LIBMSG, c_err_msg  );
      	fn_userlog(c_ServiceName," PLEASE CHECK THE THE FORWARDING STOPPED");
     		fn_userlog(c_ServiceName," PLEASE CHECK THE SEQUENCE NO OR INCREASE BY ONE");
   			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      ***  Ver 3.1 ***
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); ***  Ver 6.9 ***
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); ***  Ver 6.9 ***
      	fn_userlog(c_ServiceName," PLEASE CHECK THE THE FORWARDING STOPPED");
      	fn_userlog(c_ServiceName," PLEASE CHECK THE SEQUENCE NO OR INCREASE BY ONE");
   			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}

      ***/

      /*** Ver 5.5  Starts ***/

      if(i_returncode == INSUFFICIENT_LIMITS && c_1clk_flg != 'Y' ) /**VEr 10.8 c_1clk_flg added **/
      {
        c_actn_flg = 'P';
        i_returncode = 0 ;

        /*** Commented in Ver 7.3 *** 

        i_returncode = tpsuspend ( &tranid, 0 );
        if ( i_returncode== -1 )
        {
          fn_errlog( c_ServiceName, "S31460", LIBMSG, c_err_msg  );
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID , (char *)&i_actn_id , 0 );
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); ***  Ver 6.9 ***
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); ***  Ver 6.9 ***
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }

        ***/

        i_returncode =  fn_ins_ffl_log_tbl  (  c_ServiceName,
                                               st_ordbook,
                                               c_err_msg,
                                               d_required_amt,
                                               c_actn_flg
                                            );
        if ( i_returncode != 0 )
        {
          fn_errlog( c_ServiceName, "S31465", LIBMSG, c_err_msg  );
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID , (char *)&i_actn_id , 0 );
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/ 
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );

        }

        /*** Commented in Ver 7.3 ***

        i_returncode = tpresume ( &tranid, 0 );
        if ( i_returncode== -1 )
        {
          fn_errlog( c_ServiceName, "S31470", LIBMSG, c_err_msg  );
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID , (char *)&i_actn_id , 0 );
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); ***  Ver 6.9 ***
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); ***  Ver 6.9 ***
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }

       ***/

      }

      /*** Ver 5.5  Ends   ***/

      /*** Ver 7.3 Starts taken from above ***/

      i_trnsctn = fn_begintran( c_ServiceName, c_err_msg );
      if ( i_trnsctn == -1 )
      {
        fn_errlog( c_ServiceName, "S31475", LIBMSG, c_err_msg  );
        fn_userlog(c_ServiceName," PLEASE CHECK THE THE FORWARDING STOPPED");
        fn_userlog(c_ServiceName," PLEASE CHECK THE SEQUENCE NO OR INCREASE BY ONE");
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );     
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); 
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); 
        fn_userlog(c_ServiceName," PLEASE CHECK THE THE FORWARDING STOPPED");
        fn_userlog(c_ServiceName," PLEASE CHECK THE SEQUENCE NO OR INCREASE BY ONE");
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      } 

      /*** Ver 7.3 Ends ***/     


			if ( st_xchngbook.c_spl_flg == '*' )
			{
				st_xchngbook.c_spl_flg = NORMAL_ORDER;
				st_ordbook.c_spl_flg = NORMAL_ORDER;
			}
		
			st_xchngbook.l_ord_seq = l_xchng_seq_num;

			st_xchngbook.c_req_typ = NEW;
			st_xchngbook.c_ex_ordr_typ = ORDINARY_ORDER;

			/*** Addition done for Temporary orders placment during expiry****/
			if ( st_xchngbook.c_spl_flg == TEMPORARY_ORDER )
			{
				strcpy ( st_xchngbook.c_rqst_tm , st_xchngbook.c_ack_tm );
			}
			else
			{
				strcpy ( st_xchngbook.c_rqst_tm , (char *)c_sysdate.arr );
			}

			st_xchngbook.c_plcd_stts = 'J'; /* 1.6 - Rejected by EBA*/

			/* Ver 2.6 Begins */
    	if(c_fcm_mrkt_typ == EXTND_MRKT &&  c_fum_mrkt_typ == EXTND_MRKT )
    	{

      	st_ordbook.c_mrkt_typ = 'X';
      	st_xchngbook.c_mkrt_typ = 'X';

    	}
			else
			{
				st_ordbook.c_mrkt_typ = 'N';
      	st_xchngbook.c_mkrt_typ = 'N';
			}
    	/* Ver 2.6 Ends */

			i_ip_len = sizeof ( struct vw_xchngbook );
			i_op_len = sizeof ( struct vw_xchngbook );

			fn_cpy_ddr ( st_xchngbook.c_rout_crt );
			st_xchngbook.c_oprn_typ = INSERTION_ON_ORDER_MODIFICATION;

			/*** Commented in Ver 3.9 ***
			i_returncode = fn_call_svc( c_ServiceName,
																	c_err_msg,
																	&st_xchngbook,
																	&st_xchngbook,
																	"vw_xchngbook",
																	"vw_xchngbook",
																	i_ip_len,
																	i_op_len,
																	0,
																	"SFO_UPD_XCHNGBK" );
			*************************/

			/*** Added in Ver 3.9 ***/
			i_returncode = fn_upd_xchngbk  ( c_ServiceName,
																			 &st_xchngbook,
																			 c_ip_address,
																			 st_usr_prfl.c_cln_mtch_accnt,		/*** Ver 4.4 ***/
																			 c_err_msg,
																			 l_init_sltp_rt,  /*** Ver 8.4 ****/     
 																			 l_init_lmt_rt,   /*** Ver 8.4 ****/     
 																			 l_lTP,           /*** Ver 8.4 ****/     
 																			 l_lmt_offset,    /*** Ver 8.4 ****/     
 																			 l_trail_amt,     /*** Ver 8.4 ****/     
 																			 c_prcimpv_flg,   /*** Ver 8.4 ****/
                                       st_usr_prfl.l_session_id   /** Ver 11.4 **/     
																		 );
			/************************/

			if( i_returncode != SUCC_BFR ) 
			{
				fn_errlog( c_ServiceName, "S31480", LIBMSG, c_err_msg  );
      	fn_userlog(c_ServiceName," PLEASE CHECK THE THE FORWARDING STOPPED");
     		fn_userlog(c_ServiceName," PLEASE CHECK THE SEQUENCE NO OR INCREASE BY ONE");
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 3.1 ***/
	      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
  			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}                            	
		 /********************* Commented in ver 6.6 ******************
			EXEC SQL
				SELECT  clm_clnt_ctgry_id
				INTO    :st_ordbook.l_clnt_ctgry
				FROM    clm_clnt_mstr
				WHERE   clm_mtch_accnt = :st_ordbook.c_cln_mtch_accnt;

			if ( SQLCODE != 0 )
			{
				fn_errlog( c_ServiceName, "S31485",SQLMSG,c_err_msg);
      	fn_userlog(c_ServiceName," PLEASE CHECK THE THE FORWARDING STOPPED");
     		fn_userlog(c_ServiceName," PLEASE CHECK THE SEQUENCE NO OR INCREASE BY ONE");
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      ***  Ver 3.1 ***
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}

		********************* comment ends 6.6 ************************/

		st_ordbook.l_clnt_ctgry = l_clnt_ctgry;  /** Ver 6.6 **/

			EXEC SQL
				SELECT  ccg_pro_cli_ind
				INTO    :st_ordbook.c_pro_cli_ind
				FROM    ccg_clnt_ctgry
				WHERE   ccg_clnt_ctgry_id = :st_ordbook.l_clnt_ctgry;

			if ( SQLCODE != 0 )
			{
				fn_errlog( c_ServiceName, "S31490",SQLMSG,c_err_msg);
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 3.1 ***/
	      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
  			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}

			strcpy( st_ordbook.c_pipe_id, st_xchngbook.c_pipe_id ); 
			st_ordbook.c_ordr_stts = FAILED;	/** 1.6 Failed by EBA	***/
			st_ordbook.c_oprn_typ = INSERT_ON_ORDER_PLACEMENT;
			strcpy ( st_ordbook.c_valid_dt,st_xchngbook.c_valid_dt);

			i_ip_len = sizeof ( struct vw_orderbook );
			i_op_len = sizeof ( struct vw_orderbook );

			/*** 1.7****	
			strcpy( st_ordbook.c_channel, c_channel );   
			***1.7*****/

			strcpy( st_ordbook.c_bp_id, c_bp_id );  
			if(DEBUG_MSG_LVL_5)
			{
				fn_userlog(c_ServiceName,"The BP id is :%s:", st_ordbook.c_bp_id);
				fn_userlog(c_ServiceName,"The Alias is :%s: ",c_alias);
				fn_userlog(c_ServiceName,"BP channel  is :%s:",st_ordbook.c_channel);
			}

			fn_cpy_ddr ( st_ordbook.c_rout_crt );

    	/******************     VER 2.2 ADDITION STARTS   **********************/

    	strcpy((char*)v_user_id_bkup.arr,st_ordbook.c_user_id);
    	SETLEN(v_user_id_bkup);
    	strcpy(st_ordbook.c_user_id,(char *)v_user_id_bkup.arr);

  		if ( strcmp(st_usr_prfl.c_user_id,"system") == 0 && (c_bp_id [0] != '*') )      /***  Ver 3.2 ***/
    	{
				/******************** Commented in Ver 6.6 *******************

      	EXEC SQL
        	SELECT  CLM_TRD_FLG
        	INTO    :c_trd_flg
        	FROM    CLM_CLNT_MSTR
        	WHERE   CLM_MTCH_ACCNT  = :st_ordbook.c_cln_mtch_accnt;

      	if ( SQLCODE  !=  0 )
      	{
        	fn_errlog( c_ServiceName, "S31495",SQLMSG,c_err_msg);
        	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
        	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      	}
				******************** Comment Ends Ver 6.6 *******************/

      	if ( c_trd_flg  !=  'Y' )
      	{
        	rtrim(c_bp_id);
        	strcpy(st_usr_prfl.c_user_id,c_bp_id);
      	}
      	else
      	{
        	EXEC SQL
          	SELECT  UAC_USR_ID
          	INTO    :st_usr_prfl.c_user_id
          	FROM    UAC_USR_ACCNTS
          	WHERE   UAC_CLM_MTCH_ACCNT  = :st_ordbook.c_cln_mtch_accnt;

        	if ( SQLCODE  !=  0 )
        	{
          	fn_errlog( c_ServiceName, "S31500",SQLMSG,c_err_msg);
          	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
          	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
            Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
            Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
          	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        	}

        	rtrim(st_usr_prfl.c_user_id);
      	}
    	}
    	else if ( strcmp(st_usr_prfl.c_user_id,"system") == 0 && (c_bp_id [0] == '*') )      /***  Ver 3.2 ***/
    	{
      	/**** Ver 4.6 Starts ***/
      	if( sql_usr_dt_allwd_flg == 'Y')
      	{
        	strcpy(st_usr_prfl.c_user_id,(char *)v_user_id.arr);
      	}
      	else
      	{
      		strcpy(st_usr_prfl.c_user_id,st_ordbook.c_user_id);
				}

      	if(DEBUG_MSG_LVL_3)
      	{
        	fn_userlog(c_ServiceName,"DT ALLOWED FLAG IS  :%c:", sql_usr_dt_allwd_flg);
        	fn_userlog(c_ServiceName,"USER ID IS  :%s:", v_user_id.arr);
      	}
				/**** Ver 4.6 Ends ***/
    	}

			if(DEBUG_MSG_LVL_5)
			{
    		fn_userlog(c_ServiceName,"v_user_id_bkup is   :%s:",v_user_id_bkup.arr);
    		fn_userlog(c_ServiceName,"st_ordbook.c_user_id is   :%s:",st_ordbook.c_user_id);
				fn_userlog(c_ServiceName,"st_ordbook.l_cse_id is :%ld:",st_ordbook.l_cse_id); /* Ver 2.6 */
    		fn_userlog(c_ServiceName,"CALLING SFO_UPD_ORDRBK");
			}

    	/*******************     VER 2.2 ADDITION ENDS     **********************/

			/***  Ver 3.1 Starts  ***/

    	i_returncode  = fn_chk_dtallwd  ( c_ServiceName,
      	                                &st_usr_prfl,
        	                              c_user_id,
          	                            &st_err_msg
            	                        );

    	if ( i_returncode != 0 )
    	{
      	fn_userlog(c_ServiceName,"Error While Selecting DL Set Up No. ");
      	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );
      	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/ 
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    	}

			if(DEBUG_MSG_LVL_3)
			{
    		fn_userlog(c_ServiceName,"User ID Is :%s:",c_user_id);
			}

			 /*** Ver 6.6 Starts ***/
    c_span_flag = 'N';
    if(strcmp(st_ordbook.c_xchng_cd,"NFO") == -1)
    {
      c_span_flag = c_spn_flg;
    }
    else if(strcmp(st_ordbook.c_xchng_cd,"BFO") == -1)
    {
      c_span_flag = c_bse_spn_flg;
    }
    /** Ver 6.6 Ends **/

			i_returncode  = fn_ins_ordrbook ( c_ServiceName,
      	                                c_user_id,
																				c_span_flag,  /** Ver 6.6 */
                                        c_source_flg, /** Ver 7.9 **/
																				v_pan_no.arr,			/*** Added In Ver 9.0 ***/
																				c_setlmnt_flg,           /*** Ver 9.4 ***/
																				c_ven_id.arr,			 /*** Ver 10.0 ***/
                                        c_algo_id.arr,      /** ver 11.0 **/
                                        c_algo_ord_rmrks.arr, /** ver 11.0 **/
																				l_sqroff_tm, /* Ver 11.2 */
																				c_fc_flg,		 /* Ver 11.2 */
        	                              &st_ordbook, 
          	                            &st_err_msg,
                                        c_1clk_flg,           /** Ver 10.8 **/
                                        c_1clk_prtflio_id     /** Ver 10.8 **/
            	                        );

    	if ( i_returncode != 0 )
    	{
      	fn_errlog( c_ServiceName, "S31505", LIBMSG, c_err_msg  );
      	fn_userlog(c_ServiceName," PLEASE CHECK THE THE FORWARDING STOPPED");
      	fn_userlog(c_ServiceName," PLEASE CHECK THE SEQUENCE NO OR INCREASE BY ONE");
      	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
      	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    	}

			/***	Ver	3.1	Ends	***/

			/***	Commented In Ver	3.1
			i_returncode = fn_call_svc( c_ServiceName,
      	 	                       	c_err_msg,
        		                      &st_ordbook,
                              		&st_ordbook,
                              		"vw_orderbook",
                              		"vw_orderbook",
                              		i_ip_len,
                              		i_op_len,
                              		0,
                              		"SFO_UPD_ORDRBK" );

 			if( i_returncode != SUCC_BFR )	
 			{
    		fn_errlog( c_ServiceName, "S31510", LIBMSG, c_err_msg  );
      	fn_userlog(c_ServiceName," PLEASE CHECK THE SEQUENCE NO OR INCREASE BY ONE");
      	fn_userlog(c_ServiceName," PLEASE CHECK THE SEQUENCE NO OR INCREASE BY ONE");
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
 				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      
 				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}

			*****************************/

			/* Ver 2.6 Comment Begins 

			********************						Ver 2.5	Starts					     ************************
			***	Code for temporary usage of immediate compliance release for extended market  ***
	  	***	Shall be aligned with order book and exchange book views in next view release **

			if(c_fcm_mrkt_typ == EXTND_MRKT &&	c_fum_mrkt_typ == EXTND_MRKT )
			{
				EXEC SQL
    			UPDATE  fod_fo_ordr_dtls
    			SET     fod_mrkt_typ = 'X'
    			WHERE   fod_ordr_rfrnc = :st_ordbook.c_ordr_rfrnc ;

  			if(SQLCODE != 0)
  			{
    			fn_errlog ( c_ServiceName, "S31515", SQLMSG, c_err_msg);
    			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    			tpreturn ( TPFAIL, ERR_BFR, ( char * )ptr_fml_Ibuf, 0, 0 );
  			}

  			EXEC SQL
    			UPDATE  fxb_fo_xchng_book
    			SET     fxb_mrkt_typ = 'X'
    			WHERE   fxb_ordr_rfrnc = :st_xchngbook.c_ordr_rfrnc
    			AND     fxb_mdfctn_cntr = :st_xchngbook.l_mdfctn_cntr ;

  			if(SQLCODE != 0)
  			{
    			fn_errlog ( c_ServiceName, "S31520", SQLMSG, c_err_msg);
    			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    			tpreturn ( TPFAIL, ERR_BFR, ( char * )ptr_fml_Ibuf, 0, 0 );
  			} 
			}

			*** Ver 2.5 Ends ***

			Ver 2.6 Comment Ends */

    	/******************     VER 2.2 ADDITION STARTS   **********************/

    	strcpy(st_ordbook.c_user_id,(char *)v_user_id_bkup.arr);
			if(DEBUG_MSG_LVL_5)
			{
    		fn_userlog(c_ServiceName,"c_user_id_bkup is   :%s:",v_user_id_bkup.arr);
    		fn_userlog(c_ServiceName,"st_ordbook.c_user_id is   :%s:",st_ordbook.c_user_id);
			}

    	/*******************     VER 2.2 ADDITION ENDS     **********************/
                            	
			if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg ) == -1 )
			{
   	 		fn_errlog( c_ServiceName, "S31525", LIBMSG, c_err_msg  );
      	fn_userlog(c_ServiceName," PLEASE CHECK THE THE FORWARDING STOPPED");
      	fn_userlog(c_ServiceName," PLEASE CHECK THE SEQUENCE NO OR INCREASE BY ONE");
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
 				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 3.1 ***/
 	      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
  			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}	
			/*********posting the trigger*************/
			strcpy ( c_fno_dmn_nm, "FNO" );
    	strcpy ( c_fno_trg_nm, "TRG_LOOK_TAB" );
    	strcpy ( c_fno_trg_dat, "TRG_LOOK_TAB" );
    	i_returncode = fn_call_svc_fml ( c_ServiceName,
     	                               	c_err_msg,
      	                              "SFO_FOS_TRG",
        	                            0,
          	                          4,
                                    	0,
                                    	FFO_DMN_NM, (char *)c_fno_dmn_nm,
                                    	FFO_TRG_NM, (char *)c_fno_trg_nm,
                                    	FFO_ABT_TRG_DATA, (char *)c_fno_trg_dat,
                                    	FFO_ABT_FILTER, (char *)st_xchngbook.c_pipe_id);

    	if ( i_returncode != SUCC_BFR )
    	{
      	fn_errlog( c_ServiceName, "S31530", LIBMSG, c_err_msg  );
    	}
			/*********posting the trigger ends*************/
			/*******************************End****************************************/

			if(DEBUG_MSG_LVL_3)
			{
    		fn_userlog(c_ServiceName,"ONE FAILURE ORDER INSERTED");
			}

   		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );

		}
		if(DEBUG_MSG_LVL_5)
		{
			fn_userlog( c_ServiceName, "SFO_UPD_OPT_POS called succesfully");
		}

	} 
	else if (  st_pstn_actn.c_prd_typ == 'I' )  /*** Ver 5.4 ***/
	{
			fn_userlog(c_ServiceName," No service call in case of OptionPLUS..");	
	}

	if ( st_xchngbook.c_spl_flg == '*' )
	{
		st_xchngbook.c_spl_flg = NORMAL_ORDER;
		st_ordbook.c_spl_flg = NORMAL_ORDER;
	}
	
	st_xchngbook.l_ord_seq = l_xchng_seq_num;

	st_xchngbook.c_req_typ = NEW;
	st_xchngbook.c_ex_ordr_typ = ORDINARY_ORDER;

  /*** Addition done for Temporary orders placment during expiry****/
  if ( st_xchngbook.c_spl_flg == TEMPORARY_ORDER )
  {
    strcpy ( st_xchngbook.c_rqst_tm , st_xchngbook.c_ack_tm );
  }
  else
  {
		strcpy ( st_xchngbook.c_rqst_tm , (char *)c_sysdate.arr );
  }

  st_xchngbook.c_plcd_stts = 'R'; /* Request Placed */
		
	/* Ver 2.6 Begins */
    if(c_fcm_mrkt_typ == EXTND_MRKT &&  c_fum_mrkt_typ == EXTND_MRKT )
    {

      st_ordbook.c_mrkt_typ = 'X';
      st_xchngbook.c_mkrt_typ = 'X';

    }
		else
		{
			st_ordbook.c_mrkt_typ = 'N';
      st_xchngbook.c_mkrt_typ = 'N';
		}
  /* Ver 2.6 Ends */

	i_ip_len = sizeof ( struct vw_xchngbook );
	i_op_len = sizeof ( struct vw_xchngbook );

	fn_cpy_ddr ( st_xchngbook.c_rout_crt );
	st_xchngbook.c_oprn_typ = INSERTION_ON_ORDER_MODIFICATION;
	
	/*** Commented in Ver 3.9 ***
	i_returncode = fn_call_svc( c_ServiceName,
                              c_err_msg,
                              &st_xchngbook,
                              &st_xchngbook,
                              "vw_xchngbook",
                              "vw_xchngbook",
                              i_ip_len,
                              i_op_len,
                              0,
                              "SFO_UPD_XCHNGBK" );
	*****************************/

	/*** Added in Ver 3.9 ***/
	i_returncode = fn_upd_xchngbk  ( c_ServiceName,
																	 &st_xchngbook,
																	 c_ip_address,
																	 st_usr_prfl.c_cln_mtch_accnt,		/*** Ver 4.4 ***/
																	 c_err_msg,
																	 l_init_sltp_rt,  /*** Ver 8.4 ****/
                                   l_init_lmt_rt,   /*** Ver 8.4 ****/
                                   l_lTP,           /*** Ver 8.4 ****/
                                   l_lmt_offset,    /*** Ver 8.4 ****/
                                   l_trail_amt,     /*** Ver 8.4 ****/
                                   c_prcimpv_flg,   /*** Ver 8.4 ****/
                                   st_usr_prfl.l_session_id   /** Ver 11.4 **/
																 );
	/************************/

	if( i_returncode != SUCC_BFR ) 
 	{
    fn_errlog( c_ServiceName, "S31535", LIBMSG, c_err_msg  );
		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
 		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 3.1 ***/
 	  Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
  	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}                            	

	st_ordbook.l_clnt_ctgry = l_clnt_ctgry; /** Ver 6.6 **/

		/***************** Commented In ver 6.6 *******************

  EXEC SQL
    SELECT  clm_clnt_ctgry_id
    INTO    :st_ordbook.l_clnt_ctgry
    FROM    clm_clnt_mstr
    WHERE   clm_mtch_accnt = :st_ordbook.c_cln_mtch_accnt;

  if ( SQLCODE != 0 )
  {
    fn_errlog( c_ServiceName, "S31540",SQLMSG,c_err_msg);
    fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );     ***  Ver 3.1 ***
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
	**************** Comment Ends Ver 6.6 *********************/

  EXEC SQL
    SELECT  ccg_pro_cli_ind
    INTO    :st_ordbook.c_pro_cli_ind
    FROM    ccg_clnt_ctgry
    WHERE   ccg_clnt_ctgry_id = :st_ordbook.l_clnt_ctgry;

  if ( SQLCODE != 0 )
  {
    fn_errlog( c_ServiceName, "S31545",SQLMSG,c_err_msg);
    fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 3.1 ***/
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

	strcpy( st_ordbook.c_pipe_id, st_xchngbook.c_pipe_id ); 
	st_ordbook.c_ordr_stts = REQUESTED;
	st_ordbook.c_oprn_typ = INSERT_ON_ORDER_PLACEMENT;
  strcpy ( st_ordbook.c_valid_dt,st_xchngbook.c_valid_dt);

	i_ip_len = sizeof ( struct vw_orderbook );
	i_op_len = sizeof ( struct vw_orderbook );
	
	/***1.7***
  strcpy( st_ordbook.c_channel, c_channel ); * 1.1 *
	***1.7***/

  strcpy( st_ordbook.c_bp_id, c_bp_id );  /* 1.1 */

	if(DEBUG_MSG_LVL_5)
	{
    fn_userlog(c_ServiceName,"The BP id is :%s:", st_ordbook.c_bp_id);
    fn_userlog(c_ServiceName,"The Alias is :%s: ",c_alias);
    fn_userlog(c_ServiceName,"BP channel  is :%s:",st_ordbook.c_channel);
	}

	fn_cpy_ddr ( st_ordbook.c_rout_crt );

  /******************     VER 2.2 ADDITION STARTS   **********************/

  strcpy((char*)v_user_id_bkup.arr,st_ordbook.c_user_id);
  SETLEN(v_user_id_bkup);
  strcpy(st_ordbook.c_user_id,(char *)v_user_id_bkup.arr);

	if ( strcmp(st_usr_prfl.c_user_id,"system") == 0 && (c_bp_id [0] != '*') )      /***  Ver 3.2 ***/
  {
		/************** Commented in Ver 6.6 **********************

  	EXEC SQL
      SELECT  CLM_TRD_FLG
      INTO    :c_trd_flg
      FROM    CLM_CLNT_MSTR
      WHERE   CLM_MTCH_ACCNT  = :st_ordbook.c_cln_mtch_accnt;

    if ( SQLCODE  !=  0 )
    {
      fn_errlog( c_ServiceName, "S31550",SQLMSG,c_err_msg);
      fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

		************** Comment Ends Ver 6.6 ***********************/

    if ( c_trd_flg  !=  'Y' )
    {
      rtrim(c_bp_id);
      strcpy(st_usr_prfl.c_user_id,c_bp_id);
    }
    else
    {
      EXEC SQL
        SELECT  UAC_USR_ID
        INTO    :st_usr_prfl.c_user_id
        FROM    UAC_USR_ACCNTS
        WHERE   UAC_CLM_MTCH_ACCNT  = :st_ordbook.c_cln_mtch_accnt;

      if ( SQLCODE  !=  0 )
      {
        fn_errlog( c_ServiceName, "S31555",SQLMSG,c_err_msg);
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

      rtrim(st_usr_prfl.c_user_id);
    }
 	}  
  else if ( strcmp(st_usr_prfl.c_user_id,"system") == 0 && (c_bp_id [0] == '*') )      /***  Ver 3.2 ***/
  {
    /**** Ver 4.6 Starts ***/
    if( sql_usr_dt_allwd_flg == 'Y')
    {
      strcpy(st_usr_prfl.c_user_id,(char *)v_user_id.arr);
    }
    else
    {
			strcpy(st_usr_prfl.c_user_id,st_ordbook.c_user_id);
    }

    if(DEBUG_MSG_LVL_3)
    {
      fn_userlog(c_ServiceName,"DT ALLOWED FLAG IS  :%c:", sql_usr_dt_allwd_flg);
      fn_userlog(c_ServiceName,"USER ID IS  :%s:", v_user_id.arr);
    }
    /**** Ver 4.6 Ends ***/
  }


	if(DEBUG_MSG_LVL_5)
	{
  	fn_userlog(c_ServiceName,"v_user_id_bkup is   :%s:",v_user_id_bkup.arr);
  	fn_userlog(c_ServiceName,"st_ordbook.c_user_id is   :%s:",st_ordbook.c_user_id);
		fn_userlog(c_ServiceName,"st_ordbook.l_cse_id is :%ld:",st_ordbook.l_cse_id); /* Ver 2.6 */
  	fn_userlog(c_ServiceName,"CALLING SFO_UPD_ORDRBK");
	}

  /*******************     VER 2.2 ADDITION ENDS     **********************/

	/***  Ver 3.1 Starts  ***/

	i_returncode  = fn_chk_dtallwd  ( c_ServiceName,
  	                                &st_usr_prfl,
    	                              c_user_id,
      	                            &st_err_msg
        	                        );

	if ( i_returncode != 0 )
	{
  	fn_userlog(c_ServiceName,"Error While Selecting DL Set Up No. ");
  	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );
  	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
  	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}

	if(DEBUG_MSG_LVL_3)
	{
		fn_userlog(c_ServiceName,"User ID Is :%s:",c_user_id);
	}

	/*** Ver 6.6 Starts ***/
    c_span_flag = 'N';
    if(strcmp(st_ordbook.c_xchng_cd,"NFO") == -1)
    {
      c_span_flag = c_spn_flg;
    }
    else if(strcmp(st_ordbook.c_xchng_cd,"BFO") == -1)
    {
      c_span_flag = c_bse_spn_flg;
    }
    /** Ver 6.6 Ends **/

  i_returncode  = fn_ins_ordrbook (    c_ServiceName,
                                       c_user_id,
														  		  	 c_span_flag,  /** Ver 6.6 */
                                       c_source_flg, /** Ver 7.9 **/
																			 v_pan_no.arr,			/*** Added In Ver 9.0 ***/
																			 c_setlmnt_flg,           /*** Ver 9.4 ***/
		  																 c_ven_id.arr,			 /*** Ver 10.0 ***/
                                       c_algo_id.arr,      /** ver 11.0 **/
                                       c_algo_ord_rmrks.arr, /** ver 11.0 **/
                                       l_sqroff_tm, /* Ver 11.2 */
                                       c_fc_flg,    /* Ver 11.2 */
	                                     &st_ordbook,
                                       &st_err_msg,
                                       c_1clk_flg,            /** Ver 10.8 **/
                                       c_1clk_prtflio_id    /** Ver 10.8 **/
                                    );

   if ( i_returncode != 0 )
   {
     fn_errlog( c_ServiceName, "S31560", LIBMSG, c_err_msg  );
     fn_userlog(c_ServiceName," PLEASE CHECK THE THE FORWARDING STOPPED");
     fn_userlog(c_ServiceName," PLEASE CHECK THE SEQUENCE NO OR INCREASE BY ONE");
     fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
     Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
     Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
     Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
     Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
     tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

	/***	Ver	3.1	Ends	***/


	/*** Ver 5.4 Starts ***/

  if ( st_cntrct.c_prd_typ == 'I' && ( strcmp(c_sys_msg,"EOS") == 0 || strcmp(c_sys_msg,"COVER_OPTPLUS") == 0 || strcmp(c_sys_msg,"OFF") == 0 || strcmp(c_sys_msg,"EXCPT_EOS") == 0  || strcmp(c_sys_msg,"MY_EOS") == 0 ) /*** EXCPT_EOS added in Ver 6.4 ***/  /*** MY_EOS added in Ver 8.2 ***/
     )
  {
    if ( strcmp(c_sys_msg,"OFF") == 0 )
    {
      if(DEBUG_MSG_LVL_3)
      {
        fn_userlog(c_ServiceName,"st_xchngbook.c_ordr_flw is :%c:",st_xchngbook.c_ordr_flw);
        fn_userlog(c_ServiceName,"st_xchngbook.l_ord_tot_qty is :%ld:",st_xchngbook.l_ord_tot_qty);
      }
		
			/*** Excess qty checks starts here ***/

      /**********************************************************************************************************************
*********
      1.
      System shall first check if any Fresh open position exist and match offline order & trade against Fresh open position.
      If multiple open position exists of same order description then system shall map the offline order with any one random
position
      by taking rownum equals one.
      i.e.
      FRESH   BUY   A1  A2  200   |   Offline order
      COVER   SELL  A2  A1  50    |   SELL  150

      Here 150 Fresh BUY open position shall be mapped with 150 SELL Offline order.
      ***********************************************************************************************************************
*********/

      EXEC SQL
        SELECT
                FOD_ORDR_RFRNC
        INTO    :c_fresh_ord_ref
        FROM    FOD_FO_ORDR_DTLS F,
               (
                SELECT DECODE( FOD_FC_FLAG, 'F', FOD_ORDR_RFRNC,FOD_SLTP_ORDR_RFRNC ) FRSH_ORDR_RFRNC,
                       SUM( DECODE( FOD_ORDR_FLW, 'S', -1 * FOD_EXEC_QTY, FOD_EXEC_QTY ) ) OPEN_QTY
                FROM   FOD_FO_ORDR_DTLS
                WHERE  FOD_XCHNG_CD       = :st_cntrct.c_xchng_cd
                AND    FOD_CLM_MTCH_ACCNT = :st_usr_prfl.c_cln_mtch_accnt
                AND    FOD_UNDRLYNG       = :st_cntrct.c_undrlyng
                AND    FOD_PRDCT_TYP      = :st_cntrct.c_prd_typ
                AND    FOD_EXPRY_DT       = :c_expiry_dt
								AND    FOD_STRK_PRC       = :st_cntrct.l_strike_prc
								AND    FOD_OPT_TYP        = :st_cntrct.c_opt_typ
                AND    FOD_INDSTK         = :st_cntrct.c_ctgry_indstk
                AND    FOD_EXER_TYP       = :st_cntrct.c_exrc_typ
                GROUP BY  DECODE(FOD_FC_FLAG, 'F', FOD_ORDR_RFRNC, FOD_SLTP_ORDR_RFRNC )
                HAVING    SUM( DECODE( FOD_ORDR_FLW, 'S', -1 * FOD_EXEC_QTY, FOD_EXEC_QTY ) )  != 0
               ) PSTN
        WHERE   PSTN.FRSH_ORDR_RFRNC = F.FOD_ORDR_RFRNC
        AND     DECODE( F.FOD_ORDR_FLW ,'B', PSTN.OPEN_QTY , PSTN.OPEN_QTY * -1 ) > 0
        AND     F.FOD_ORDR_FLW       = DECODE(:st_xchngbook.c_ordr_flw,'B','S','S','B')
        AND     ABS(PSTN.OPEN_QTY)   = :st_xchngbook.l_ord_tot_qty
        AND     ROWNUM = 1;

      if ( SQLCODE  !=  0 && SQLCODE != NO_DATA_FOUND)
      {
        fn_errlog( c_ServiceName, "S31565",SQLMSG,c_err_msg);
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     }

		 if ( SQLCODE == NO_DATA_FOUND )
     {
      fn_userlog( c_ServiceName, "OFFLINE upload inside cover Excess position");

      /******************************************************************************************************
      2.
      If  there is no further fresh position against which the order or trade can be matched
      then system shall check whether any excess cover position created and treat this as a Fresh position.
      i.e.
      FRESH   BUY   C1  C3  200
      COVER   SELL  C2  C1  200
      COVER   SELL  C3  C1  100

      Cover excess position will be determined i.e C3
      *******************************************************************************************************/

      EXEC SQL
        SELECT  MAX(FOD_ORDR_RFRNC)
        INTO    :c_ordr_ref_to_upd
        FROM    FOD_FO_ORDR_DTLS
        WHERE   FOD_SLTP_ORDR_RFRNC IN
                (SELECT DECODE( FOD_FC_FLAG, 'F', FOD_ORDR_RFRNC,FOD_SLTP_ORDR_RFRNC )
                FROM    FOD_FO_ORDR_DTLS
                WHERE   FOD_XCHNG_CD       = :st_cntrct.c_xchng_cd
                AND     FOD_CLM_MTCH_ACCNT = :st_usr_prfl.c_cln_mtch_accnt
                AND     FOD_UNDRLYNG       = :st_cntrct.c_undrlyng
                AND     FOD_PRDCT_TYP      = :st_cntrct.c_prd_typ
                AND     FOD_EXPRY_DT       = :c_expiry_dt
								AND     FOD_STRK_PRC       = :st_cntrct.l_strike_prc
								AND     FOD_OPT_TYP        = :st_cntrct.c_opt_typ
                AND     FOD_INDSTK         = :st_cntrct.c_ctgry_indstk
                AND     FOD_EXER_TYP       = :st_cntrct.c_exrc_typ
                GROUP BY  DECODE(FOD_FC_FLAG, 'F', FOD_ORDR_RFRNC, FOD_SLTP_ORDR_RFRNC )
                HAVING    SUM( DECODE( FOD_ORDR_FLW, 'S', -1 * FOD_EXEC_QTY, FOD_EXEC_QTY ) )  != 0
               )
        AND     FOD_ORDR_FLW          = decode(:st_xchngbook.c_ordr_flw,'B','S','S','B')
        AND     FOD_EXEC_QTY          = :st_xchngbook.l_ord_tot_qty
        AND     FOD_FC_FLAG = 'C';

      if ( SQLCODE  !=  0 && SQLCODE != NO_DATA_FOUND && SQLCODE != NULL_RETURN )
      {
        fn_errlog( c_ServiceName, "S31570",SQLMSG,c_err_msg);
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/ 
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }	
			
				if (SQLCODE == 0)
      {
        if(DEBUG_MSG_LVL_3)
        {
          fn_userlog(c_ServiceName,"c_ordr_ref_to_upd = :%s:",c_ordr_ref_to_upd);
        }

        /********************************************************
        3. Treat this cover excess position as fresh.
        i.e.
        FRESH   BUY   C1  C3    200
        COVER   SELL  C2  C1    200
        FRESH   SELL  C3  NULL  100
        *********************************************************/

        EXEC SQL
          UPDATE  FOD_FO_ORDR_DTLS
          SET     FOD_FC_FLAG = 'F',
                  FOD_SLTP_ORDR_RFRNC = NULL
          WHERE   FOD_ORDR_RFRNC = :c_ordr_ref_to_upd;

        if ( SQLCODE  !=  0 )
        {
          fn_errlog( c_ServiceName, "S31575",SQLMSG,c_err_msg);
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }

        if(DEBUG_MSG_LVL_3)
        {
          fn_userlog( c_ServiceName,"Updated :%d: record as Fresh due to Excess qty in %s|%s|%s|%c|%s", sqlca.sqlerrd[2], st_cntrct.c_xchng_cd,st_usr_prfl.c_cln_mtch_accnt,st_cntrct.c_undrlyng,st_cntrct.c_prd_typ,c_expiry_dt.arr);
        }

        /************************************************************************************
        4. De-reference the cover excess position, from the previous Fresh order tagged.
        Max is taken in order to handle multiple covers mapped to single fresh.
        i.e.
        FRESH   BUY   C1  C2    200
        COVER   SELL  C2  C1    200
        FRESH   SELL  C3  NULL  100
        *************************************************************************************/

        EXEC SQL
          UPDATE  FOD_FO_ORDR_DTLS
          SET     FOD_SLTP_ORDR_RFRNC = ( SELECT MAX(FOD_ORDR_RFRNC)
                                          FROM   FOD_FO_ORDR_DTLS
                                          WHERE  FOD_SLTP_ORDR_RFRNC IN ( SELECT FOD_ORDR_RFRNC
                                                                          FROM   FOD_FO_ORDR_DTLS
                                                                          WHERE  FOD_SLTP_ORDR_RFRNC = :c_ordr_ref_to_upd
                                                                        )
                                        )
          WHERE   FOD_SLTP_ORDR_RFRNC = :c_ordr_ref_to_upd;

        if ( SQLCODE  !=  0 && SQLCODE != NO_DATA_FOUND )
        {
          fn_errlog( c_ServiceName, "S31580",SQLMSG,c_err_msg);
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      }
	
			/**********************************************************************************************************************
      5.
      System shall then map the offline square off transaction against such excess cover position open in the system.
      i.e.
      FRESH   BUY   C1  C2    200   |   Offline order
      COVER   SELL  C2  C1    200   |   BUY 100
      FRESH   SELL  C3  NULL  100   |

      Here 100 SELL open position shall be mapped with 100 BUY square off Offline order.
      **********************************************************************************************************************/

      EXEC SQL
      SELECT
                FOD_ORDR_RFRNC
        INTO    :c_fresh_ord_ref
        FROM    FOD_FO_ORDR_DTLS F,
               (
                SELECT DECODE( FOD_FC_FLAG, 'F', FOD_ORDR_RFRNC,FOD_SLTP_ORDR_RFRNC ) FRSH_ORDR_RFRNC,
                       SUM( DECODE( FOD_ORDR_FLW, 'S', -1 * FOD_EXEC_QTY, FOD_EXEC_QTY ) ) OPEN_QTY
                FROM   FOD_FO_ORDR_DTLS
                WHERE  FOD_XCHNG_CD       = :st_cntrct.c_xchng_cd
                AND    FOD_CLM_MTCH_ACCNT = :st_usr_prfl.c_cln_mtch_accnt
                AND    FOD_UNDRLYNG       = :st_cntrct.c_undrlyng
                AND    FOD_PRDCT_TYP      = :st_cntrct.c_prd_typ
                AND    FOD_EXPRY_DT       = :c_expiry_dt
							  AND    FOD_STRK_PRC       = :st_cntrct.l_strike_prc
								AND    FOD_OPT_TYP        = :st_cntrct.c_opt_typ
                AND    FOD_INDSTK         = :st_cntrct.c_ctgry_indstk
                AND    FOD_EXER_TYP       = :st_cntrct.c_exrc_typ
                GROUP BY  DECODE(FOD_FC_FLAG, 'F', FOD_ORDR_RFRNC, FOD_SLTP_ORDR_RFRNC )
                HAVING    SUM( DECODE( FOD_ORDR_FLW, 'S', -1 * FOD_EXEC_QTY, FOD_EXEC_QTY ) )  != 0
               ) PSTN
        WHERE   PSTN.FRSH_ORDR_RFRNC = F.FOD_ORDR_RFRNC
        AND     F.FOD_ORDR_FLW       = ( case when DECODE( F.FOD_ORDR_FLW ,'B', PSTN.OPEN_QTY , 'S', PSTN.OPEN_QTY * -1 ) > 0

                                              then decode(:st_xchngbook.c_ordr_flw,'B','S','S','B')
                                         else :st_xchngbook.c_ordr_flw
                                         end
                                       )
        AND     ABS(PSTN.OPEN_QTY)   = :st_xchngbook.l_ord_tot_qty
        AND     ROWNUM = 1;

        if ( SQLCODE  !=  0 )
        {
          fn_errlog( c_ServiceName, "S31585",SQLMSG,c_err_msg);
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
          Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
       }
      }  /*** End of NO_DATA_FOUND ***/

      if(DEBUG_MSG_LVL_3)
      {
        fn_userlog( c_ServiceName, "OFFLINE c_fresh_ord_ref = :%s:", c_fresh_ord_ref );
      }
      /*** Excess qty check ends here ***/		

   	}
   /*** else  *** Else loop commented and taken up in Ver 8.2 to get input order reference and check overlap of EOS process ***
   	{
      	i_err[0]  = Fget32(ptr_fml_Ibuf,FFO_ORDR_RFRNC,0,(char *)c_cover_ord_ref,0);
      	i_ferr [0] = Ferror32;

      if ( i_err[0] == -1 )
      {
        fn_errlog( c_ServiceName, "S31590", FMLMSG, c_err_msg  );
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); ***  Ver 6.9 ***
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); ***  Ver 6.9 ***
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

      if(DEBUG_MSG_LVL_3) *** DEBUG_MSG_LVL_3 Added in Ver 8.1 ***
			{
				fn_userlog( c_ServiceName, "c_cover_ord_ref = :%s:", c_cover_ord_ref );
   		}
		} **/ 

   	if ( strcmp(c_sys_msg,"COVER_OPTPLUS") == 0 )
   	{
    	 	fn_userlog( c_ServiceName, "Inside COVER_OPTPLUS " );
     		i_returncode  = fn_cover_optpls ( c_ServiceName,
                                     		  c_cover_ord_ref,
                                       		&st_ordbook,
                                       		&st_pstn_actn,
                                       		&st_err_msg
                                     		);
   	}
   	else if ( (strcmp(c_sys_msg,"EOS") == 0|| strcmp(c_sys_msg,"MY_EOS") == 0 || strcmp(c_sys_msg,"EXCPT_EOS") == 0) && i_excp_flag == 0 )    /*** strcmp co
ndition added in else loop Ver 6.1 ***/ /*** Added in Ver 8.2 ***/ 
   	{
    	 	fn_userlog( c_ServiceName, "Inside EOS condition" );
     		i_returncode  = fn_eos_optpls ( c_ServiceName,
                                     		c_cover_ord_ref,
                                     		&st_ordbook,
                                     		&st_err_msg
                                   		);
   	}
		else if ( strcmp(c_sys_msg,"OFF") == 0 )    
    {
			if( DEBUG_MSG_LVL_0) /*** DEBUG_MSG_LVL_0 Added in Ver 8.1 ***/
			{
				fn_userlog( c_ServiceName, "Inside OFFLINE" );
			}
			
      /***********************************************************************************
      6.
      Finally, the offline order placed shall be mapped with the cover excess position.
      i.e.
      FRESH   BUY   C1  C2  200
      COVER   SELL  C2  C1  200
      FRESH   SELL  C3  C4  100
      COVER   BUY   C4  C3  100
      ************************************************************************************/

      i_returncode  = fn_off_optpls ( c_ServiceName,
                                      c_fresh_ord_ref,
                                      &st_ordbook,
                                      &st_err_msg
                                    );
    }
		else if ( (strcmp(c_sys_msg,"EXCPT_EOS") == 0 || strcmp(c_sys_msg,"MY_EOS") == 0 || strcmp(c_sys_msg,"EOS") == 0) &&  i_excp_flag == 1 )     /*** Added i
_excp_flag in Ver 8.2 ***/     /*** Ver 6.4 ***/ 
    {
      if( DEBUG_MSG_LVL_0) /*** DEBUG_MSG_LVL_0 Added in Ver 8.1 ***/
			{
				fn_userlog( c_ServiceName, "Inside Exception EOS" );
			}
      i_returncode  = fn_excpt_eos_optpls ( c_ServiceName,
																						c_cover_ord_ref,
																						&st_ordbook,
																						&st_err_msg
																					);
    }

   	if ( i_returncode != 0 )
   	{
      fn_errlog( c_ServiceName, "S31595", LIBMSG, c_err_msg  );
      fn_userlog(c_ServiceName," Error in fun fn_eos_optpls");
      fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
      Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
   	}
  }
  /*** Excess qty checks Ends ***/

	
	/***	Commented In Ver	3.1
	i_returncode = fn_call_svc( c_ServiceName,
                              c_err_msg,
                              &st_ordbook,
                              &st_ordbook,
                              "vw_orderbook",
                              "vw_orderbook",
                              i_ip_len,
                              i_op_len,
                              0,
                              "SFO_UPD_ORDRBK" );

 if( i_returncode != SUCC_BFR )	
 	{
    fn_errlog( c_ServiceName, "S31600", LIBMSG, c_err_msg  );
		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
 		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );     
 		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}
	
	*********************************************************************/

	/* Ver 2.6 Comment Begins 	
  *********************				     Ver 2.5 Starts		           ************************
  **** Code for temporary usage of immediate complience release for extended market  ***
  **** Shall be aligned with order book and exchange book views in next view release ***

	if(c_fcm_mrkt_typ == EXTND_MRKT	&& c_fum_mrkt_typ == EXTND_MRKT  )
	{
		EXEC SQL
			UPDATE	fod_fo_ordr_dtls
			SET			fod_mrkt_typ = 'X'
			WHERE		fod_ordr_rfrnc = :st_ordbook.c_ordr_rfrnc ;

		if(SQLCODE != 0)
		{
			fn_errlog ( c_ServiceName, "S31605", SQLMSG, c_err_msg);
    	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    	tpreturn ( TPFAIL, ERR_BFR, ( char * )ptr_fml_Ibuf, 0, 0 );
  	}

		EXEC SQL
			UPDATE	fxb_fo_xchng_book
			SET			fxb_mrkt_typ = 'X'
			WHERE		fxb_ordr_rfrnc = :st_xchngbook.c_ordr_rfrnc
			AND     fxb_mdfctn_cntr = :st_xchngbook.l_mdfctn_cntr ;
	
		if(SQLCODE != 0)
  	{
   		fn_errlog ( c_ServiceName, "S31610", SQLMSG, c_err_msg);
    	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    	tpreturn ( TPFAIL, ERR_BFR, ( char * )ptr_fml_Ibuf, 0, 0 );
  	}
	}

	*** Ver 2.5 Ends ***

	Ver 2.6 Comment ends */

  /******************     VER 2.2 ADDITION STARTS   **********************

  strcpy(st_ordbook.c_user_id,(char *)v_user_id_bkup.arr);
	if(DEBUG_MSG_LVL_5)
	{
  	fn_userlog(c_ServiceName,"c_user_id_bkup is   :%s:",v_user_id_bkup.arr);
  	fn_userlog(c_ServiceName,"st_ordbook.c_user_id is   :%s:",st_ordbook.c_user_id);
	}

  *******************     VER 2.2 ADDITION ENDS     **********************/


	/**** Ver 11.3 Start ****/
    if ( ( st_cntrct.c_prd_typ == 'O' ) && st_ordbook.c_ordr_flw =='S'
        /*&& (st_xchngbook.c_spl_flg == CLIENT_SQROFF || st_xchngbook.c_spl_flg=='*') */
        && c_source_flg !='F'
        && (!strstr( st_xchngbook.c_xchng_rmrks,"Physical Settlement EOS")) && (st_xchngbook.c_spl_flg !=  PHYSICAL_DLVRY_SQOFF)
        && (st_xchngbook.c_spl_flg != SYSTEM_SQUAREOFF )
        && (st_xchngbook.c_spl_flg != IMTM_SYS_SQUAREOFF)
        && (st_xchngbook.c_spl_flg != LMTNEG_SYS_SQUAREOFF )
       )
    {

		if ( c_popup_flg == 'Y' && i_popup==1 )  /** Ver 11.7  added i_popup**/
    {
      EXEC SQL INSERT INTO FFS_FO_FLASH_DISCRYP
               (
                FFS_CLM_MTCH_ACCNT,FFS_XCHNG_CD,FFS_PRDCT_TYP,FFS_UNDRLYNG,FFS_EXPRY_DT,
                FFS_EXER_TYP,FFS_OPT_TYP,FFS_STRK_PRC,FFS_LMT_MRKT_FLG,FFS_LMT_RT,FFS_ORDR_TOT_QTY,FFS_CLS_TIME,
                FFS_CONF_REQ,FFS_INS_DT,FFS_CONSENT_DATE
                )
                SELECT
                FFS_CLM_MTCH_ACCNT,FFS_XCHNG_CD,FFS_PRDCT_TYP,FFS_UNDRLYNG,FFS_EXPRY_DT,
                FFS_EXER_TYP,FFS_OPT_TYP,FFS_STRK_PRC,FFS_LMT_MRKT_FLG,FFS_LMT_RT,FFS_ORDR_TOT_QTY,FFS_CLS_TIME,
                FFS_CONF_REQ,FFS_INS_DT,sysdate
                FROM FFS_FO_FLASH_SETTING  where FFS_CLM_MTCH_ACCNT = :st_usr_prfl.c_cln_mtch_accnt;

      if( SQLCODE != 0 )
      {
        fn_errlog( c_ServiceName, "S31615",SQLMSG,c_err_msg);
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID , (char *)&i_actn_id , 0 );
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT,(char *)&d_required_amt,0);
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

			EXEC SQL DELETE FROM FFS_FO_FLASH_SETTING  where FFS_CLM_MTCH_ACCNT = :st_usr_prfl.c_cln_mtch_accnt;
      if( SQLCODE != 0 && SQLCODE!=NO_DATA_FOUND )
      {
         fn_errlog( c_ServiceName, "S31620",SQLMSG,c_err_msg);
         Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
         Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID , (char *)&i_actn_id , 0 );
         Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT,(char *)&d_required_amt,0);
         Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0);
         tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
    	}
    }

    /**** Ver 11.3 End ****/
	if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg ) == -1 )
	{
    fn_errlog( c_ServiceName, "S31625", LIBMSG, c_err_msg  );
 		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 3.1 ***/
 	  Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
  	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
	}

	/***Ver 12.0 **calling function to calculate real time margin after successful commit ***/
  i_returncode = fn_upd_nrmlmrgn_reporting( st_usr_prfl.c_cln_mtch_accnt,
                                        st_cntrct.c_xchng_cd,
                                        c_ServiceName,
                                        c_err_msg);

  if ( i_returncode != 0 )
  {
    fn_errlog(c_ServiceName, "S31630", LIBMSG, c_err_msg);
    fn_userlog(c_ServiceName,"Pls check, Nikhil Error while calling function fn_upd_mrgn_reporting..");
  }
  /***Ver 12.0 Ends here ***/

  if ( i_trnsctn == LOCAL_TRNSCTN )
	{
		/********************************************************/
		/****Changes for Tux4 Triggers***************************/
		/********************************************************/
	/*	fn_pst_trg( c_ServiceName, "TRG_LOOK_TAB", "TRG_LOOK_TAB", 
                             	st_xchngbook.c_pipe_id );
	*/


		  /* To post the Trigger in Tux3 Domain Call the service SFO_FOS_TRG */
  	strcpy ( c_fno_dmn_nm, "FNO" );
  	strcpy ( c_fno_trg_nm, "TRG_LOOK_TAB" );
  	strcpy ( c_fno_trg_dat, "TRG_LOOK_TAB" );

  	i_returncode = fn_call_svc_fml ( c_ServiceName,
                                    c_err_msg,
                                    "SFO_FOS_TRG",
                                    0,
                                    4,
                                    0,
                                    FFO_DMN_NM, (char *)c_fno_dmn_nm,
                                    FFO_TRG_NM, (char *)c_fno_trg_nm,
                                    FFO_ABT_TRG_DATA, (char *)c_fno_trg_dat,
                                    FFO_ABT_FILTER, (char *)st_xchngbook.c_pipe_id);

  	if ( i_returncode != SUCC_BFR )
  	{
    	fn_errlog( c_ServiceName, "S31635", LIBMSG, c_err_msg  );
  	}

		/********************************************************/
		/****Changes for Tux4 Triggers***************************/
		/********************************************************/

	}

  ptr_fml_Obuf = (FBFR32 *)tpalloc( "FML32", NULL, MIN_FML_BUF_LEN );

  if ( ptr_fml_Obuf == NULL )
  {
    fn_errlog( c_ServiceName, "S31640", "ORDER PLACED BUT ERROR OCCURRED WHILE SENDING RESPONSE.", c_err_msg  );
/** fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );		*** Ver 2.2 Not Required as commit tran placed before **/
		sprintf( c_err_msg, "ORDER PLACED BUT ERROR OCCURRED WHILE SENDING RESPONSE." );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 3.1 ***/
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
    tpreturn(TPSUCCESS, 0, (char *)ptr_fml_Ibuf, 0, 0 );
  }

	if ( Fadd32 ( ptr_fml_Obuf, FFO_ORDR_RFRNC,
                ( char *)st_ordbook.c_ordr_rfrnc, 0 ) == -1 )
	{
 		fn_errlog( c_ServiceName, "S31645", "ORDER PLACED BUT ERROR OCCURRED WHILE SENDING RESPONSE.", c_err_msg);
/** fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );		*** Ver 2.2 Not Required as commit tran placed before **/
		sprintf( c_err_msg, "ORDER PLACED BUT ERROR OCCURRED WHILE SENDING RESPONSE." );
 		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 3.1 ***/
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
   	tpreturn(TPSUCCESS, 0, (char *)ptr_fml_Ibuf, 0, 0 );
	}

	/*************1.6 Changes for DT removed from here ***************************/
  if ( Fadd32 ( ptr_fml_Obuf, FFO_PIPE_ID,
                ( char *)st_xchngbook.c_pipe_id, 0 ) == -1 )
  {
    fn_errlog( c_ServiceName, "S31650", "ORDER PLACED BUT ERROR OCCURRED WHILE SENDING RESPONSE.", c_err_msg);
/** fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );		*** Ver 2.2 Not Required as commit tran placed before **/
		sprintf( c_err_msg, "ORDER PLACED BUT ERROR OCCURRED WHILE SENDING RESPONSE." );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 3.1 ***/
    Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
    Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
    tpreturn(TPSUCCESS, 0, (char *)ptr_fml_Ibuf, 0, 0 );
  }
  /*************************** 2.2 Addition Starts ****************************/
 
   /**** Ver 6.7 Starts ****/
  if ( strcmp(st_ordbook.c_channel,"SYS") == 0 )
  {
    if ( Fadd32 ( ptr_fml_Obuf, FFO_ERR_MSG,"", 0 ) == -1 )
    {
      fn_errlog( c_ServiceName, "S31655", "ORDER PLACED BUT ERROR OCCURRED WHILE SENDING RESPONSE.", c_err_msg);
      sprintf( c_err_msg, "ORDER PLACED BUT ERROR OCCURRED WHILE SENDING RESPONSE." );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      tpreturn(TPSUCCESS, 0, (char *)ptr_fml_Ibuf, 0, 0 );
    }
  }
  /**** Ver 6.7 Ends ****/
  

 
  if ( strcmp( st_ordbook.c_channel , "APP") == 0 || strcmp( st_ordbook.c_channel , "VSA") == 0 || strncmp( st_ordbook.c_channel , "CN", 2) == 0 || strcmp(st_ordbook.c_channel,"NET") == 0 )  	/*** Ver 5.0  ** condition added for CNT channel ***/
                        /***  Ver 5.2 Condition added for New Trade Racer ***/
  {
    l_can_qty = 0;
    l_open_qty = st_xchngbook.l_ord_tot_qty;
    l_exprd_qty = 0;
    strcpy(c_xchng_ack,"0");
		if(DEBUG_MSG_LVL_3)
		{
    	fn_userlog(c_ServiceName,"INSIDE APP / VSAT / CNT");  /*** Ver 5.0  ***/
		}

    i_err[0] = Fadd32 ( ptr_fml_Obuf, FFO_CANCL_QTY,( char *)&l_can_qty, 0 );
    i_err[1] = Fadd32 ( ptr_fml_Obuf, FFO_CHANNEL, ( char *)st_ordbook.c_channel, 0 );
    i_err[2] = Fadd32 ( ptr_fml_Obuf, FFO_CTGRY_INDSTK,( char *)&(st_cntrct.c_ctgry_indstk), 0 );
    i_err[3] = Fadd32 ( ptr_fml_Obuf, FFO_EBA_MTCH_ACT_NO,( char *)st_usr_prfl.c_cln_mtch_accnt, 0 );
    i_err[4] = Fadd32 ( ptr_fml_Obuf, FFO_DSCLSD_QTY,( char *)&(st_xchngbook.l_dsclsd_qty), 0 );
    i_err[5] = Fadd32 ( ptr_fml_Obuf, FFO_EXEC_QTY,( char *)&(st_pstn_actn.l_exec_qty), 0 );
    i_err[6] = Fadd32 ( ptr_fml_Obuf, FFO_EXER_TYP,( char *)&(st_cntrct.c_exrc_typ), 0 );
    i_err[7] = Fadd32 ( ptr_fml_Obuf, FFO_EXPRD_QTY,( char *)&l_exprd_qty, 0 );
    i_err[8] = Fadd32 ( ptr_fml_Obuf, FFO_EXPRY_DT,( char *)st_cntrct.c_expry_dt, 0 );
    i_err[9] = Fadd32 ( ptr_fml_Obuf, FFO_LMT_MKT_SL_FLG,( char *)&(st_xchngbook.c_slm_flg), 0 );
    i_err[10]= Fadd32 ( ptr_fml_Obuf, FFO_LMT_RT,( char *)&(st_xchngbook.l_ord_lmt_rt), 0 );
    /************ ver 2.2 DLrevamp New FML used for Open Qty **********/
    i_err[11]= Fadd32 ( ptr_fml_Obuf, FFO_C_OPNPSTN_QTY,( char *)&l_open_qty, 0 );
    /************ ver 2.2 DLrevamp Other New FMLs used **********/
    i_err[12]= Fadd32 ( ptr_fml_Obuf, FFO_ACK_NMBR,( char *)c_xchng_ack, 0 );
    i_err[13]= Fadd32 ( ptr_fml_Obuf, FFO_OPT_TYP,( char *)&(st_cntrct.c_opt_typ), 0 );
    i_err[14]= Fadd32 ( ptr_fml_Obuf, FFO_ORD_TOT_QTY,( char *)&(st_xchngbook.l_ord_tot_qty), 0 );
    i_err[15]= Fadd32 ( ptr_fml_Obuf, FFO_ORD_TYP,( char *)&(st_xchngbook.c_ord_typ), 0 );
    i_err[16]= Fadd32 ( ptr_fml_Obuf, FFO_ORD_VALID_DT,( char *)st_xchngbook.c_valid_dt, 0 );
    i_err[17]= Fadd32 ( ptr_fml_Obuf, FFO_ORDR_FLW,( char *)&(st_xchngbook.c_ordr_flw), 0 );
    i_err[18]= Fadd32 ( ptr_fml_Obuf, FFO_ORDR_STTS,( char *)&(st_ordbook.c_ordr_stts), 0 );
    i_err[19]= Fadd32 ( ptr_fml_Obuf, FFO_PRDCT_TYP,( char *)&(st_cntrct.c_prd_typ), 0 );
    i_err[20]= Fadd32 ( ptr_fml_Obuf, FFO_SPL_FLG,( char *)&(st_xchngbook.c_spl_flg), 0 );
    i_err[21]= Fadd32 ( ptr_fml_Obuf, FFO_STP_LSS_TGR,( char *)&(st_xchngbook.l_stp_lss_tgr), 0 );
    i_err[22]= Fadd32 ( ptr_fml_Obuf, FFO_STRK_PRC,( char *)&(st_cntrct.l_strike_prc), 0 );
    i_err[23]= Fadd32 ( ptr_fml_Obuf, FFO_TRD_DT,( char *)st_ordbook.c_trd_dt, 0 );
    i_err[24]= Fadd32 ( ptr_fml_Obuf, FFO_UNDRLYNG,( char *)st_cntrct.c_undrlyng, 0 );
    i_err[25]= Fadd32 ( ptr_fml_Obuf, FFO_XCHNG_CD,( char *)st_cntrct.c_xchng_cd, 0 );

    for( i_cnt = 0; i_cnt < 26; i_cnt++ )
    {
      if( i_err[i_cnt] == -1 )
      {
        fn_errlog( c_ServiceName, "S31660", "ORDER PLACED BUT ERROR OCCURRED WHILE SENDING RESPONSE.", c_err_msg);
				sprintf( c_err_msg, "ORDER PLACED BUT ERROR OCCURRED WHILE SENDING RESPONSE." );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 3.1 ***/
        Fadd32( ptr_fml_Ibuf, FFO_BAL_AMT, (char *)&d_required_amt, 0); /***  Ver 6.9 ***/
        Fadd32( ptr_fml_Ibuf, FFO_MOD_CAN_FLG,(char *)&c_insuff_flg,0); /***  Ver 6.9 ***/
        tpreturn(TPSUCCESS, 0, (char *)ptr_fml_Ibuf, 0, 0 );
      }
    }
  }   
	if(DEBUG_MSG_LVL_5)
	{
    fn_userlog(c_ServiceName,"SFO_OPT_PLC_ORD SERVICE SUCCESSFULLY COMPLETED");
	}

  /*************************** 2.2 Addition Ends ****************************/

	i_actn_id	=	0;			/***	Ver	3.1	***/
  Fadd32( ptr_fml_Obuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 3.1 ***/
 
	tpreturn( TPSUCCESS, 0, (char *)ptr_fml_Obuf, 0 , 0 );
}

int fn_check_inp_opt( char *c_ServiceName,
                  struct vw_xchngbook *ptr_st_xchngbook, 
                  struct vw_cntrct_qt *ptr_st_cntrct_qt, 
									char c_fum_mrkt_typ,                 /* Ver 2.5 */
                  char c_fcm_mrkt_typ,                 /* Ver 2.5 */
                  struct vw_err_msg *ptr_st_err_msg )
{
	int i_dategreater=0;
	int i_returncode;
	char c_exg_crrnt_stts;
	char c_exg_extnd_stts;			/* Ver 2.5 */
	char c_exg_ovrnght_stts ;			/* Ver 4.1 */
	char c_err_msg[256];
	double d_min_ordr_val=0.0;
	double d_dsclsd_prcntg=0.0;
	long long ll_ordr_val;
	long long ll_min_ordr_val;


  EXEC SQL
     SELECT exg_crrnt_stts,
						exg_extnd_mrkt_stts,			/* Ver 2.5 */
						exg_tmp_mkt_stts,					/* Ver 4.1 */
            exg_dsclsd_prcntg
     INTO   :c_exg_crrnt_stts,
						:c_exg_extnd_stts,				/* Ver 2.5 */
						:c_exg_ovrnght_stts,			/* Ver 4.1 */
            :d_dsclsd_prcntg
     FROM   exg_xchng_mstr
     where  exg_xchng_cd = :ptr_st_xchngbook->c_xchng_cd;

	if ( SQLCODE != 0 )
	{
 		fn_errlog( c_ServiceName, "S31665",SQLMSG,ptr_st_err_msg->c_err_msg);
		return FAILURE;
	}

  /** Addition done in the below validation for temporary order  **/
  /** placement during expiry                                    **/

  /** Orders cannnot be placed when the Exchange is under Expiry **/
	  /***  Ver 1.9 for Exchange status for offline channel   *********/
  if ( ( c_exg_crrnt_stts == EXCHANGE_UNDER_EXPIRY ) &&
       ( c_exg_ovrnght_stts !=  EXCHANGE_OPEN ) &&  /*** Ver 4.1 ***/ 
       ( ptr_st_xchngbook->c_spl_flg != TEMPORARY_ORDER ) && 
			 (strncmp(ptr_st_xchngbook->c_xchng_rmrks, "CORP ACTN" , 9)!=0 ) &&			/****Ver 1.9 ****/
       (strncmp(ptr_st_xchngbook->c_xchng_rmrks, "OptionPlus to Options" , 21)!=0 )  /** Ver 7.6 ** OptionPlus**/
     )
  {
		/*** 2.5 Starts ***/

		if( c_exg_extnd_stts == EXCHANGE_UNDER_EXPIRY )
		{
			fn_errlog( c_ServiceName, "B28518",DEFMSG,ptr_st_err_msg->c_err_msg);
			return FAILURE;
		}
		else if (c_fum_mrkt_typ == NORMAL_MRKT && ((ptr_st_xchngbook->c_slm_flg != MARKET) && (ptr_st_xchngbook->c_ord_typ != IMMEDIATE_OR_CANCEL )))		/***	Underlying Level Check	***/				 
		{
			fn_userlog( c_ServiceName,"This Underlying Is Disabled For Extended Market Hours");
			fn_errlog( c_ServiceName, "B66066",DEFMSG,ptr_st_err_msg->c_err_msg);
			return FAILURE;
		}
		else if( c_fcm_mrkt_typ == NORMAL_MRKT  && ((ptr_st_xchngbook->c_slm_flg != MARKET) && (ptr_st_xchngbook->c_ord_typ != IMMEDIATE_OR_CANCEL )))	/***  Contract Level Check	***/
		{
			fn_userlog( c_ServiceName,"This Contract Is Disabled For Extended Market Hours");
			fn_errlog( c_ServiceName, "B66066",DEFMSG,ptr_st_err_msg->c_err_msg);
			return FAILURE;
		}
		/*** Commented In Ver 2.5

    fn_errlog( c_ServiceName, "B28518",DEFMSG,ptr_st_err_msg->c_err_msg);
    return FAILURE;

	  ***/

		/*** Ver 2.5 Ends ***/
  }

  /** Temp Orders can be uploaded only when the Exchange is under Expiry **/
  if ( (( c_exg_crrnt_stts != EXCHANGE_UNDER_EXPIRY ) ||( c_exg_extnd_stts != EXCHANGE_UNDER_EXPIRY )) &&				/* Ver 2.5	*/
       ( ptr_st_xchngbook->c_spl_flg == TEMPORARY_ORDER ) )
  {
    fn_errlog( c_ServiceName, "B28564",DEFMSG,ptr_st_err_msg->c_err_msg);
    return FAILURE;
  }

	if ( ( ptr_st_xchngbook->c_slm_flg == LIMIT ) ||
     ( ptr_st_xchngbook->c_slm_flg == STOP_LOSS ) )
	{

		/** Limit rate cannot be less than or equal to Zero for Limit orders **/
		if ( ptr_st_xchngbook->l_ord_lmt_rt <= 0 )
		{

 			fn_errlog( c_ServiceName, "B28519",DEFMSG,ptr_st_err_msg->c_err_msg);
			return FAILURE;
		}

    /*** 2.2 SL trigger price cannot be Zero for Stop Loss Order. ***/
    if(ptr_st_xchngbook->l_stp_lss_tgr == 0 && ptr_st_xchngbook->c_slm_flg == STOP_LOSS)
    {
      fn_errlog( c_ServiceName,"S31670"
      ,"Stop Loss trigger price cannot be Zero for Stop Loss Order.",ptr_st_err_msg->c_err_msg  );
      return FAILURE;
    }

	}
	else if ( ptr_st_xchngbook->c_slm_flg == MARKET )
	{
		/** Market orders can be placed only when the Exchange is open **/
		if ( c_exg_crrnt_stts != EXCHANGE_OPEN )
		{
			/*** Ver 2.5 Starts	***/

			if( c_exg_extnd_stts != EXCHANGE_OPEN )
			{
				fn_errlog( c_ServiceName, "B28520",DEFMSG,ptr_st_err_msg->c_err_msg);
				return FAILURE;
			}

    	else if (c_fum_mrkt_typ == NORMAL_MRKT )      /***  Underlying Level Check  ***/
    	{
      	fn_userlog( c_ServiceName,"This Underlying Is Disabled For Extended Market Hours");
      	fn_errlog( c_ServiceName, "B28520",DEFMSG,ptr_st_err_msg->c_err_msg);
      	return FAILURE;
    	}
    	else if ( c_fcm_mrkt_typ == NORMAL_MRKT )     /***  Contract Level Check  ***/
    	{
      	fn_userlog( c_ServiceName,"This Contract Is Disabled For Extended Market Hours");
      	fn_errlog( c_ServiceName, "B28520",DEFMSG,ptr_st_err_msg->c_err_msg);
      	return FAILURE;
    	}
			/*** Commented In Ver 2.5

 			fn_errlog( c_ServiceName, "B28520",DEFMSG,ptr_st_err_msg->c_err_msg);
			return FAILURE;

			***/

			/*** Ver 2.5 Ends ***/
		} 

		/** Limit rate should be Zero for Market orders **/
		if ( ptr_st_xchngbook->l_ord_lmt_rt != 0 )
		{
 			fn_errlog( c_ServiceName, "B28521",DEFMSG,ptr_st_err_msg->c_err_msg);
			return FAILURE;
		}

		if ( ptr_st_xchngbook->l_quote == 0 )
		{

 			fn_errlog( c_ServiceName, "B28540",DEFMSG,ptr_st_err_msg->c_err_msg);
			return FAILURE;
		}
	}

  /*** 2.2 SLTP prc shouldn't be present for Market or Limit Orders. ***/
  if((ptr_st_xchngbook->c_slm_flg == MARKET  || ptr_st_xchngbook->c_slm_flg == LIMIT) && ptr_st_xchngbook->l_stp_lss_tgr !=0) 
  {
    fn_errlog( c_ServiceName,"S31675","Cannot enter Stop Loss trigger price for Market and Limit Ordres.",ptr_st_err_msg->c_err_msg);
    return FAILURE;
  }

	if ( ptr_st_xchngbook->c_ord_typ == IMMEDIATE_OR_CANCEL  )
	{
		/** IOC orders can be placed only when the Exchange is open **/
		if ( c_exg_crrnt_stts != EXCHANGE_OPEN )
		{
			 /*** Ver 2.5 Starts ***/

			if( c_exg_extnd_stts != EXCHANGE_OPEN )
      {
        fn_errlog( c_ServiceName, "B28011",DEFMSG,ptr_st_err_msg->c_err_msg);
        return FAILURE;
      }

      else if (c_fum_mrkt_typ == NORMAL_MRKT )      /***  Underlying Level Check  ***/
      {
        fn_userlog( c_ServiceName,"This Underlying Is Disabled For Extended Market Hours");
        fn_errlog( c_ServiceName, "B28011",DEFMSG,ptr_st_err_msg->c_err_msg);
        return FAILURE;
      }
      else if ( c_fcm_mrkt_typ == NORMAL_MRKT )     /***  Contract Level Check  ***/
      {
        fn_userlog( c_ServiceName,"This Contract Is Disabled For Extended Market Hours");
        fn_errlog( c_ServiceName, "B28011",DEFMSG,ptr_st_err_msg->c_err_msg);
        return FAILURE;
      }
      /*** Commented In Ver 2.5

			fn_errlog( c_ServiceName, "B28011",DEFMSG,ptr_st_err_msg->c_err_msg);
			return FAILURE;
	
			***/

			/*** Ver 2.5 Ends ***/
		}
	}
	
	/** Disclosed Quantity cannot be greater than the order qty **/
	if ( ptr_st_xchngbook->l_dsclsd_qty > ptr_st_xchngbook->l_ord_tot_qty )
	{
 			fn_errlog( c_ServiceName, "B28522",DEFMSG,ptr_st_err_msg->c_err_msg);
			return FAILURE;
	}

  if ( ptr_st_xchngbook->l_stp_lss_tgr != 0 )
  {
    if ( ptr_st_xchngbook->c_ordr_flw == BUY )
    {
			/** Stop loss trigger price cannot be greater than limit rate **/
      /** for Buy order                                             **/
      if ( ptr_st_xchngbook->l_stp_lss_tgr > ptr_st_xchngbook->l_ord_lmt_rt )
      {
        fn_errlog( c_ServiceName, "B28524",DEFMSG,ptr_st_err_msg->c_err_msg);
        return FAILURE;
      }

			/** Stop loss trigger price cannot be less than last traded   **/
      /** price for Buy order                                       **/
      if ( ptr_st_xchngbook->l_stp_lss_tgr < ptr_st_cntrct_qt->l_lst_trdd_prc )
      {
        fn_errlog( c_ServiceName, "B22009",DEFMSG,ptr_st_err_msg->c_err_msg);
        return FAILURE;
      }
    }
    if ( ptr_st_xchngbook->c_ordr_flw == SELL )
    {
			/** Stop loss trigger price cannot be less  than limit rate   **/
			/** for Sell order                                            **/
      if ( ptr_st_xchngbook->l_stp_lss_tgr < ptr_st_xchngbook->l_ord_lmt_rt )
      {
        fn_errlog( c_ServiceName, "B28525",DEFMSG,ptr_st_err_msg->c_err_msg);
        return FAILURE;
      }

			/** Stop loss trigger price cannot be greater than last traded **/
			/** price for Sell order                                       **/
      if ( ptr_st_xchngbook->l_stp_lss_tgr > ptr_st_cntrct_qt->l_lst_trdd_prc )
      {
        fn_errlog( c_ServiceName, "B22010",DEFMSG,ptr_st_err_msg->c_err_msg);
        return FAILURE;
      }
    }
  }

	/** Disclosed Quantity cannot be less than  Minimum disclosed      **/
  /** percentage ratio of the order qty                              **/
	if( (ptr_st_xchngbook->l_dsclsd_qty != 0 ) &&
      ( ptr_st_xchngbook->l_dsclsd_qty < 
              ( ( d_dsclsd_prcntg / 100 ) * ptr_st_xchngbook->l_ord_tot_qty )))
	{
 			fn_errlog( c_ServiceName, "B28526",DEFMSG,ptr_st_err_msg->c_err_msg);
			return FAILURE;
	}

	/**********************1.5 Starts*******************************
	if ( ptr_st_xchngbook->c_ord_typ == GOOD_TILL_DATE ) 
	{
		if ( strcmp( ptr_st_xchngbook->c_valid_dt, "*" ) == 0 )
		{
 			fn_errlog( c_ServiceName, "B28527",DEFMSG,ptr_st_err_msg->c_err_msg);
			return FAILURE;
		}
		else
		{
			i_dategreater = 0;

			EXEC SQL
				SELECT	1
				INTO 		:i_dategreater
				FROM		exg_xchng_mstr
				WHERE		exg_xchng_cd = :ptr_st_xchngbook->c_xchng_cd
				AND			exg_nxt_trd_dt < to_date( :ptr_st_xchngbook->c_valid_dt,
																				 'DD-Mon-YYYY' );
			if (( SQLCODE != 0 ) && ( SQLCODE != NO_DATA_FOUND )) 
			{
 				fn_errlog( c_ServiceName, "S31680", SQLMSG, ptr_st_err_msg->c_err_msg );
				return FAILURE;
			}	

			if ( i_dategreater != 1 )
			{
 				fn_errlog( c_ServiceName, "B28528", DEFMSG, ptr_st_err_msg->c_err_msg );
				return FAILURE;
			}

			i_dategreater = 0;

			EXEC SQL
				SELECT	1
				INTO 		:i_dategreater
				FROM		dual
				WHERE		to_date( :ptr_st_cntrct_qt->c_expry_dt, 'DD-Mon-YYYY' )
				 				< to_date( :ptr_st_xchngbook->c_valid_dt, 'DD-Mon-YYYY' );

			if (( SQLCODE != 0 ) && ( SQLCODE != NO_DATA_FOUND )) 
			{
 				fn_errlog( c_ServiceName, "S31685", SQLMSG, ptr_st_err_msg->c_err_msg );
				return FAILURE;
			}	

			if ( i_dategreater == 1 )
			{
 				fn_errlog( c_ServiceName, "B28539", DEFMSG, ptr_st_err_msg->c_err_msg );
				return FAILURE;
			}

		}
	}
	****************1.5 ends *****************/
	return SUCCESS;
}

int fn_check_ord_opt( char *c_ServiceName,
                  struct vw_cntrt_gen_inf *ptr_st_cntrct_gen_inf, 
                  struct vw_xchngbook *ptr_st_xchngbook, 
                  struct vw_orderbook *ptr_st_ordbook,
                  struct vw_err_msg *ptr_st_err_msg ) 
{

	char c_mkt_allwd_flg;
	char c_err_msg[256];
	char c_exg_crrnt_stts ;		/*** Ver 4.1 ***/   
	char c_exg_ovrnght_stts;	/*** Ver 4.1 ***/   
	int i_flg = 0;						/*** Ver 4.1 ***/   



	/** Order quantity should be in Multiples of Contract Lot size.   **/
	if ( ptr_st_xchngbook->l_ord_tot_qty % ptr_st_cntrct_gen_inf->l_min_lot_qty
                                                                != 0 )
	{
 		fn_errlog( c_ServiceName, "B28529", DEFMSG, ptr_st_err_msg->c_err_msg );
		return FAILURE;
	}

	/** Disclosed quantity should be in Multiples of Contract Lot size **/
	if ( ptr_st_xchngbook->l_dsclsd_qty % ptr_st_cntrct_gen_inf->l_min_lot_qty
                                                                != 0 )
	{
 		fn_errlog( c_ServiceName, "B28530", DEFMSG, ptr_st_err_msg->c_err_msg );
		return FAILURE;
	}

	/** Limit rate should be in Multiples of Contract Tick size        **/
  /** Ver 7.6, skip the check tick size incase of OptionPlus to Options conversion ****/
  if(strncmp ( ptr_st_xchngbook->c_xchng_rmrks , "OptionPlus to Options" , 21)!=0)  /**  Ver 7.6 , if condition added**/
  {
	  if ( ptr_st_xchngbook->l_ord_lmt_rt % ptr_st_cntrct_gen_inf->l_tick_sz != 0 )
	  {
 		  fn_errlog( c_ServiceName, "B28531", DEFMSG, ptr_st_err_msg->c_err_msg );
		  return FAILURE;
	  }
  }

	/** Stop loss Trigger Price should be in Multiples of Contract Tick size **/
	if ( ptr_st_xchngbook->l_stp_lss_tgr % ptr_st_cntrct_gen_inf->l_tick_sz != 0 )
	{
 		fn_errlog( c_ServiceName, "B28532", DEFMSG, ptr_st_err_msg->c_err_msg );
		return FAILURE;
	}

	if ( ptr_st_xchngbook->c_ord_typ == IMMEDIATE_OR_CANCEL  )
	{
		if ( ptr_st_xchngbook->l_stp_lss_tgr != 0 )
		{
			fn_errlog( c_ServiceName, "B28012", DEFMSG, ptr_st_err_msg->c_err_msg );
			return FAILURE;
		}
	}

 	if ( ptr_st_xchngbook->c_slm_flg == MARKET )
  {
    EXEC SQL
      SELECT  opm_mkt_allwd
      INTO    :c_mkt_allwd_flg
      FROM    opm_ord_pipe_mstr
      WHERE   opm_pipe_id = :ptr_st_xchngbook->c_pipe_id;

    if ( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31690", SQLMSG, ptr_st_err_msg->c_err_msg );
      return FAILURE;
    }

    if ( c_mkt_allwd_flg == NO )
    {
      if(ptr_st_xchngbook->c_spl_flg != SYSTEM_SQUAREOFF ||
         ptr_st_xchngbook->c_spl_flg != IMTM_SYS_SQUAREOFF || 
         ptr_st_xchngbook->c_spl_flg != PHYSICAL_DLVRY_SQOFF|| /** Ver 9.6 **/ 
         ptr_st_xchngbook->c_spl_flg != LMTNEG_SYS_SQUAREOFF )  /*  1.2  */ /*** Check added for IMTM_SYS_SQUAREOFF and LMTNEG_SYS_SQUAREOFF in Ver 5.7 ***/
      {
        fn_errlog( c_ServiceName, "B28001", DEFMSG, ptr_st_err_msg->c_err_msg );
        return FAILURE;
      }
    }
  }

	/* Ver 2.7 Additional check */

  if( DEBUG_MSG_LVL_5)
  {
    fn_userlog( c_ServiceName,"Exchange code is :%s:", ptr_st_xchngbook->c_xchng_cd );
    fn_userlog( c_ServiceName,"Product type is :%c:", ptr_st_ordbook->c_prd_typ );
    fn_userlog( c_ServiceName,"Underlying is :%s:", ptr_st_ordbook->c_undrlyng );
  }
  EXEC SQL
       SELECT fum_freeze_qty
       INTO   :sql_fum_freeze_qty
       FROM   fum_fo_undrlyng_mstr
       WHERE  fum_xchng_cd = :ptr_st_xchngbook->c_xchng_cd
       /*** AND    fum_prdct_typ = :ptr_st_ordbook->c_prd_typ Commented In Ver 5.4 ***/
       AND    fum_prdct_typ = decode(:ptr_st_ordbook->c_prd_typ,'I','O',:ptr_st_ordbook->c_prd_typ) /* Ver 5.4 */ 
       AND    fum_undrlyng = :ptr_st_ordbook->c_undrlyng;

  if ( SQLCODE != 0 )
  {
     fn_errlog( c_ServiceName, "S31695", SQLMSG, ptr_st_err_msg->c_err_msg );
     return FAILURE;
  }

  if( ptr_st_xchngbook->l_ord_tot_qty > sql_fum_freeze_qty && sql_fum_freeze_qty != 0 )
  {
    fn_errlog( c_ServiceName, "B66071", DEFMSG, ptr_st_err_msg->c_err_msg );
    /* sprintf(ptr_st_err_msg->c_err_msg,"%s:%ld",ptr_st_err_msg->c_err_msg,(sql_fum_freeze_qty-ptr_st_cntrct_gen_inf->l_min_lot_qty)); */
    sprintf(ptr_st_err_msg->c_err_msg,"%s:%ld",ptr_st_err_msg->c_err_msg,sql_fum_freeze_qty); 
    return FAILURE;
  }

  /* Ver 2.7 Ends */

	/*** Ver 4.1 Starts ***/

  EXEC SQL
    SELECT exg_crrnt_stts,
           exg_tmp_mkt_stts
    INTO   :c_exg_crrnt_stts,
           :c_exg_ovrnght_stts
    FROM   exg_xchng_mstr
    where  exg_xchng_cd = :ptr_st_xchngbook->c_xchng_cd;

  if ( SQLCODE != 0 )
  {
    fn_errlog( c_ServiceName, "S31700",SQLMSG,ptr_st_err_msg->c_err_msg);
    return FAILURE;
  }


  if( DEBUG_MSG_LVL_3)
  {
    fn_userlog( c_ServiceName," c_exg_ovrnght_stts  is :%c:", c_exg_ovrnght_stts);
    fn_userlog( c_ServiceName," c_exg_crrnt_stts is :%c:", c_exg_crrnt_stts);
    fn_userlog( c_ServiceName,"ptr_st_ordbook->c_expry_dt is :%s:", ptr_st_ordbook->c_expry_dt );
  }


  if( c_exg_ovrnght_stts == EXCHANGE_OPEN && c_exg_crrnt_stts == EXCHANGE_UNDER_EXPIRY)
  {
		if( DEBUG_MSG_LVL_3)
		{
			fn_userlog( c_ServiceName," ---Inside Comparison of Overnight COndition ---");
		}

    i_flg = 0 ;

    EXEC SQL
    SELECT 1
    INTO   :i_flg
    FROM   dual
    where  to_date(sysdate , 'DD-Mon-YYYY') >= to_date(:ptr_st_ordbook->c_expry_dt, 'DD-Mon-YYYY') ;

    if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
    {
      fn_errlog( c_ServiceName, "S31705",SQLMSG,ptr_st_err_msg->c_err_msg);
      return FAILURE;
    }

		if( DEBUG_MSG_LVL_3)
		{
			fn_userlog( c_ServiceName," i_flg is :%d:", i_flg);
		}


    if (  i_flg == 1 )
    {
        fn_userlog( c_ServiceName," Cannot place an  order expired contract ");
        fn_errlog( c_ServiceName, "B56024",DEFMSG,ptr_st_err_msg->c_err_msg);
        return FAILURE;
    }

  }
	/*** Ver 4.1 Ends ***/


  return SUCCESS;
}

int fn_ins_ordrbook ( char  *c_ServiceName,												/***	Ver	3.1	***/
                      char  *c_user_id,
											char  c_span_flag,                      /** Ver 6.6 **/
                      char  c_source_flg,                     /** Ver 7.9 **/
											char *c_pan_no,												/*** Added In Ver 9.0 ***/
                      char  c_setlmnt_flg,           /*** Ver 9.4 ***/
											char *c_ven_id,									 /*** Ver 10.0 ***/
                      char *c_algo_id,               /*** Ver 11.0 **/
                      char *c_algo_ord_rmrks,        /*** Ver 11.0 **/   
                      long l_sqroff_tm, /* Ver 11.2 */
                      char c_fc_flg,    /* Ver 11.2 */
                      struct vw_orderbook *ptr_st_ordbook,
                      struct vw_err_msg *ptr_st_err_msg,
                      char c_1clk_flg,          /** Ver 10.8  **/
                      char *c_1clk_prtflio_id   /** Ver 10.8  **/
                    )
{
	char c_ucc_cd[13]; /***Ver 12.0 ***/
	
	if(DEBUG_MSG_LVL_3)
	{
  	fn_userlog(c_ServiceName,"User ID Inside Function IS :%s:",c_user_id);
	}

	/***  char c_span_flag  = 'N';	*** Ver 4.4 *** commented in ver 6.6 **/

	/***  Ver 3.5 Starts  ***/

  if( ptr_st_ordbook->c_channel[0] == ' ' || ptr_st_ordbook->c_channel[0]  == '\0' )
  {
    if(DEBUG_MSG_LVL_3) /*** DEBUG_MSG_LVL_3 Added in Ver 8.1 ***/
		{
			fn_userlog(c_ServiceName,"CHANNEL NOT PRESENT.");
			fn_userlog(c_ServiceName,"Channel Is :%s:",ptr_st_ordbook->c_channel);
		}
    ptr_st_ordbook->c_channel[0] = '$';
		if( DEBUG_MSG_LVL_0) /*** DEBUG_MSG_LVL_0 Added in Ver 8.1 ***/
		{
			fn_userlog(c_ServiceName,"Channel Is :%s:",ptr_st_ordbook->c_channel);
		}
  }

  /***  Ver 3.5 Ends  ***/
	
	/******************* Commented in Ver 6.6 ***********************

	*** Ver 4.4 starts ***

	if ( strcmp(ptr_st_ordbook->c_xchng_cd,"NFO") == 0 )
	{
		EXEC  SQL                                               
     SELECT  nvl(CLM_SPAN_ALLWD,'N')
     INTO    :c_span_flag
     FROM    CLM_CLNT_MSTR
     WHERE   CLM_MTCH_ACCNT =:ptr_st_ordbook->c_cln_mtch_accnt;
	}
	if ( strcmp(ptr_st_ordbook->c_xchng_cd,"BFO") == 0 )
	{
		EXEC  SQL                                               
     SELECT  nvl(CLM_BSESPAN_ALLWD,'N')
     INTO    :c_span_flag
     FROM    CLM_CLNT_MSTR
     WHERE   CLM_MTCH_ACCNT =:ptr_st_ordbook->c_cln_mtch_accnt;
	}

	if(SQLCODE !=0 && SQLCODE != NO_DATA_FOUND )
	{
    fn_errlog( c_ServiceName, "S31710", SQLMSG, ptr_st_err_msg->c_err_msg );
    return -1;
	}
	***************** Comment ends in Ver 6.6 *****************************/
	if (c_span_flag == 'Y')
	{
		c_span_flag = 'S';
	}

	if( DEBUG_MSG_LVL_3) /*** DEBUG_MSG_LVL_3 Added in Ver 8.1 ***/
	{
		fn_userlog(c_ServiceName," SPAN FLAG IS :%c:",c_span_flag);            
	}
	/*** Ver 4.4 Ends ***/

	/***Ver 12.0 starts ***/
  MEMSET(c_ucc_cd);

  EXEC SQL
    SELECT  NVL(NVL(RTRIM(CLM_CP_CD),RTRIM( CLM_CLNT_CD )),CLM_MTCH_ACCNT )
     INTO  :c_ucc_cd
     FROM  CLM_CLNT_MSTR
     WHERE CLM_MTCH_ACCNT =:ptr_st_ordbook->c_cln_mtch_accnt;

   if(SQLCODE !=0 && SQLCODE != NO_DATA_FOUND )
  {
    fn_userlog(c_ServiceName," Error while fetching UCC code for :%s:", ptr_st_ordbook->c_cln_mtch_accnt);
    fn_errlog( c_ServiceName, "S31715", SQLMSG, ptr_st_err_msg->c_err_msg );
    return -1;
  }

  rtrim(c_ucc_cd);
  /***Ver 12.0 ends here ***/

  EXEC SQL
    INSERT INTO FOD_FO_ORDR_DTLS
    (
      FOD_CLM_MTCH_ACCNT,
      FOD_CLNT_CTGRY,
      FOD_ORDR_RFRNC,
      FOD_PIPE_ID,
      FOD_XCHNG_CD,
      FOD_PRDCT_TYP,
      FOD_UNDRLYNG,
      FOD_EXPRY_DT,
      FOD_EXER_TYP,
      FOD_OPT_TYP,
      FOD_STRK_PRC,
      FOD_ORDR_FLW,
      FOD_LMT_MRKT_SL_FLG,
      FOD_DSCLSD_QTY,
      FOD_ORDR_TOT_QTY,
      FOD_LMT_RT,
      FOD_STP_LSS_TGR,
      FOD_ORDR_TYPE,
      FOD_ORDR_VALID_DT,
      FOD_TRD_DT,
      FOD_ORDR_STTS,
      FOD_SPRD_ORDR_REF,
      FOD_MDFCTN_CNTR,
      FOD_SETTLOR,
      FOD_SPL_FLAG,
      FOD_INDSTK,
      FOD_PRO_CLI_IND,
      FOD_CHANNEL,
      FOD_BP_ID,
      FOD_CTCL_ID,
			FOD_USR_ID,
      FOD_MRKT_TYP,
      FOD_CSE_ID,
			FOD_SPN_FLG,		/*** Ver 4.4 ***/
      FOD_SOURCE_FLG,    /*** Ver 7.9 ***/
      FOD_EOS_FLG,   /** Ver 8.2 **/
			FOD_PAN_NO,		/*** Added In Ver 9.0 ***/
			FOD_SETLMNT_FLG, /*** Added In Ver 9.4 ***/
			FOD_ESP_ID,			/*** Ver 10.0 ***/
    	FOD_1CLICK_FLG,       /** Ver 10.8  **/
      FOD_1CLICK_PRTFL_ID,   /** Ver 10.8  **/
      FOD_ALGO_ID,           /** Ver 11.0 **/
      FOD_APIREMARKS,         /** Ver 11.0 **/
			FOD_FC_FLAG,	/*** Ver 11.2 ***/
		  FOD_SQROFF_TM, /*** Ver 11.2 ***/
			FOD_UCC_CD /**Added in Ver 12.0 **/
		)
    VALUES
    (
      :ptr_st_ordbook->c_cln_mtch_accnt,
      :ptr_st_ordbook->l_clnt_ctgry,
      :ptr_st_ordbook->c_ordr_rfrnc,
      :ptr_st_ordbook->c_pipe_id,
      :ptr_st_ordbook->c_xchng_cd,
      :ptr_st_ordbook->c_prd_typ,
      :ptr_st_ordbook->c_undrlyng,
      to_date( :ptr_st_ordbook->c_expry_dt, 'dd-mon-yyyy' ),
      :ptr_st_ordbook->c_exrc_typ,
      :ptr_st_ordbook->c_opt_typ,
      :ptr_st_ordbook->l_strike_prc,
      :ptr_st_ordbook->c_ordr_flw,
      :ptr_st_ordbook->c_slm_flg,
      :ptr_st_ordbook->l_dsclsd_qty,
      :ptr_st_ordbook->l_ord_tot_qty,
      :ptr_st_ordbook->l_ord_lmt_rt,
      :ptr_st_ordbook->l_stp_lss_tgr,
      :ptr_st_ordbook->c_ord_typ,
      to_date( :ptr_st_ordbook->c_valid_dt,'dd-mon-yyyy' ),
      to_date( :ptr_st_ordbook->c_trd_dt,'dd-mon-yyyy' ),
      :ptr_st_ordbook->c_ordr_stts,
      :ptr_st_ordbook->c_sprd_ord_rfrnc,
      :ptr_st_ordbook->l_mdfctn_cntr,
      :ptr_st_ordbook->c_settlor,
      :ptr_st_ordbook->c_spl_flg,
      :ptr_st_ordbook->c_ctgry_indstk,
      :ptr_st_ordbook->c_pro_cli_ind,
      :ptr_st_ordbook->c_channel,
      :ptr_st_ordbook->c_bp_id,
      :ptr_st_ordbook->c_ctcl_id,
      :c_user_id,
      :ptr_st_ordbook->c_mrkt_typ,
      :ptr_st_ordbook->l_cse_id,
			:c_span_flag,		/*** Ver 4.4 ***/
      :c_source_flg,   /*** Ver 7.9 ***/
      :ptr_st_ordbook->c_req_typ,   /** Ver 8.2 **/
			:c_pan_no,					/*** Added In Ver 9.0 ***/
			:c_setlmnt_flg, /*** Added In Ver 9.4 ***/
			:c_ven_id,										 /*** Ver 10.0 ***/
    	:c_1clk_flg,        /** Ver 10.8  **/
      :c_1clk_prtflio_id,  /** Ver 10.8  **/
      :c_algo_id,          /** Ver 11.0 **/
      :c_algo_ord_rmrks,    /** Ver 11.0 **/ 
			:c_fc_flg,   /* Ver 11.2 */
			:l_sqroff_tm,  /* Ver 11.2 */
			:c_ucc_cd /***Added in Ver 12.0 ***/
		);

    if ( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31720", SQLMSG, ptr_st_err_msg->c_err_msg );
      return -1;
    }

    return 0;
}

/*** Ver 5.4 Starts *****/
int fn_eos_optpls ( char  *c_ServiceName,
                    char  *c_cover_ord_ref,
                    struct vw_orderbook *ptr_st_ordbook,
                    struct vw_err_msg *ptr_st_err_msg
                   )
{
    char c_fresh_ord_ref[19];

    int   i_returncode;

    if(DEBUG_MSG_LVL_3)
    {
      fn_userlog(c_ServiceName,"c_cover_ord_ref :%s:",c_cover_ord_ref);
    }

    EXEC SQL
    SELECT
          FOD_SLTP_ORDR_RFRNC
    INTO  :c_fresh_ord_ref
    FROM  FOD_FO_ORDR_DTLS
    WHERE FOD_ORDR_RFRNC = :c_cover_ord_ref;

    if( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31725", SQLMSG, ptr_st_err_msg->c_err_msg );
      return FAILURE;
    }

    if(DEBUG_MSG_LVL_3)
    {
      fn_userlog(c_ServiceName,"c_fresh_ord_ref :%s:",c_fresh_ord_ref);
    }

    EXEC SQL
       UPDATE     FOD_FO_ORDR_DTLS
       SET        FOD_SLTP_ORDR_RFRNC = :ptr_st_ordbook->c_ordr_rfrnc
       WHERE      FOD_ORDR_RFRNC = :c_fresh_ord_ref;

      if(SQLCODE != 0)
      {
        fn_errlog( c_ServiceName, "S31730", SQLMSG, ptr_st_err_msg->c_err_msg );
        return FAILURE;
      }

      EXEC SQL
       UPDATE     FOD_FO_ORDR_DTLS
       SET        FOD_SLTP_ORDR_RFRNC = :c_fresh_ord_ref,
                  FOD_FC_FLAG = 'C'
       WHERE      FOD_ORDR_RFRNC = :ptr_st_ordbook->c_ordr_rfrnc;

      if(SQLCODE != 0)
      {
        fn_errlog( c_ServiceName, "S31735", SQLMSG, ptr_st_err_msg->c_err_msg );
        return FAILURE;
      }
}

void fn_avg_price(long *l_arr_qty,long *l_arr_price, double *d_avg_price,int sql_ord_ordr_qty)
{
  int     i_loop;
  long    l_total_qty;
  double  d_total_value;

  l_total_qty = 0;
  d_total_value = 0;

  for(i_loop = 0; i_loop < 5; i_loop++)
  {
    if(sql_ord_ordr_qty == l_total_qty)
      break;
    else if((sql_ord_ordr_qty - l_total_qty) >= l_arr_qty[i_loop])
    {
      d_total_value = d_total_value + (l_arr_qty[i_loop] * l_arr_price[i_loop]);
      l_total_qty += l_arr_qty[i_loop];
    }
    else if((sql_ord_ordr_qty - l_total_qty) < l_arr_qty[i_loop])
    {
      d_total_value = d_total_value + ((sql_ord_ordr_qty - l_total_qty) * l_arr_price[i_loop]);
      l_total_qty += sql_ord_ordr_qty - l_total_qty;
    }
  }
   *d_avg_price = d_total_value/l_total_qty;

  fn_round2(d_avg_price);
}

/***********Function for rounding off to 2 decimal places*************/
void fn_round2(double *d_vl)
{
  char c_temp[30];
  long l_temp;

  *d_vl = (*d_vl + 0.005) * 100;

  sprintf(c_temp, "%lf", *d_vl);
  sscanf(c_temp, "%ld", &l_temp);

  *d_vl = ((double)l_temp)/100;
}

int fn_cover_optpls ( char  *c_ServiceName,
                      char  *c_cover_ord_ref,
                      struct vw_orderbook *ptr_st_ordbook,
                      struct vw_pstn_actn *ptr_st_pstn_actn,
                      struct vw_err_msg *ptr_st_err_msg
                   )
{
    double d_fmm_sltp_prcnt = 0.0;
    double d_amt_to_be_blckd = 0.0;
    double d_lss_amt_to_be_blckd = 0.0;
    double d_amt_blkd = 0.0;
    double d_lss_amt_blkd = 0.0;
    double d_diff_amt_blkd = 0.0;
    double d_diff_lss_amt_blkd = 0.0;
    double d_frsh_exe_val = 0.0;
    double d_balance_amt = 0.0;
    double d_wgt_avrg_price = 0.0;
    double d_diff_amt= 0.0;
    double d_diff_loss= 0.0;
    double d_frm_diffrnc_mrgn = 0.0;
    double d_frsh_lmt_rt= 0.0;          /** Ver 7.5 **/

    char c_ref_rmrks[133] = "\0"; /*** Ver 10.2 ***/
    char c_tmp_rmrks[133] = "\0";  /*** Ver 10.2 ***/

    double d_comp1_mrgn = 0.0;  /*** Ver 10.2 ***/
    double d_comp1_pl = 0.0;    /*** Ver 10.2 ***/
    double d_xchng_amt = 0.0;   /*** Ver 10.2 ***/
    double d_prem_amt = 0.0;    /*** Ver 10.2 ***/
    double d_spn_mrgn = 0.0;    /*** Ver 10.2 ***/
    double d_expr_mrgn = 0.0;   /*** Ver 10.2 ***/

    long  li_tot_exec_qty = 0;
    long  l_open_qty = 0;
    long  l_frsh_xtd_qty = 0;
    long  l_temp_stp_lss_tgr = 0;

    char c_ord_flw = '\0';
    char c_narration_id[4];
    char c_fresh_ord_ref[19];

    int   i_returncode;

    if(DEBUG_MSG_LVL_3)
    {
      fn_userlog(c_ServiceName,"c_cover_ord_ref :%s:",c_cover_ord_ref);
    }

    EXEC SQL
    SELECT
          FOD_SLTP_ORDR_RFRNC,
          FOD_STP_LSS_TGR
    INTO  :c_fresh_ord_ref,
          :l_temp_stp_lss_tgr
    FROM  FOD_FO_ORDR_DTLS
    WHERE FOD_ORDR_RFRNC = :c_cover_ord_ref;

    if( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31740", SQLMSG, ptr_st_err_msg->c_err_msg );
      return FAILURE;
    }

    if(DEBUG_MSG_LVL_3)
    {
      fn_userlog(c_ServiceName,"c_fresh_ord_ref :%s:",c_fresh_ord_ref);
    }

    EXEC SQL
    SELECT
          NVL(FOD_AMT_BLCKD,0),
          NVL(FOD_LSS_AMT_BLCKD,0),
          FOD_ORDR_FLW,
          FOD_LMT_RT                                      /** Ver 7.5 **/
    INTO  :d_amt_blkd,
          :d_lss_amt_blkd,
          :c_ord_flw,
          :d_frsh_lmt_rt                                  /** Ver 7.5 **/
    FROM  FOD_FO_ORDR_DTLS
    WHERE FOD_ORDR_RFRNC = :c_fresh_ord_ref;

    if( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31745", SQLMSG, ptr_st_err_msg->c_err_msg );
      return FAILURE;
    }
		/*** Commented in Ver 7.5      ******************
    *Get the current margin percentage from the database *
    EXEC SQL
     SELECT     FMM_SLTP_PRCNT
     INTO       :d_fmm_sltp_prcnt
     FROM       FMM_FO_MRGN_MSTR
     WHERE      FMM_XCHNG_CD = :ptr_st_ordbook->c_xchng_cd
     AND        FMM_PRDCT_TYP ='O'
     AND        FMM_UNDRLYNG = :ptr_st_ordbook->c_undrlyng
     AND        FMM_UNDRLYNG_BSKT_ID =(SELECT  FCB_UNDRLYNG_BSKT_ID
                                     FROM    FCB_FO_CLN_BSKT_ALLTD
                                     WHERE   FCB_CLN_LVL =(SELECT CLM_CLNT_LVL
                                                           FROM    CLM_CLNT_MSTR
                                                           WHERE   CLM_MTCH_ACCNT =:ptr_st_ordbook->c_cln_mtch_accnt));

    if( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
    {
      fn_userlog(c_ServiceName,"******Invalid Stock Code*******");
      fn_errlog( c_ServiceName, "S31750", SQLMSG, ptr_st_err_msg->c_err_msg );
      return FAILURE;
    }
    else if(SQLCODE != 0)
    {
      fn_errlog( c_ServiceName, "S31755", SQLMSG, ptr_st_err_msg->c_err_msg );
      return FAILURE;
    }

    if(DEBUG_MSG_LVL_0)
    {
      fn_userlog(c_ServiceName,"SLTP Percentage   :%lf:", d_fmm_sltp_prcnt);
    }

    ** Getting the total executed value and quantity of FRESH order. **
     EXEC SQL
      SELECT  NVL(SUM(FTD_EXCTD_QTY * FTD_EXCTD_RT),0),
              NVL(SUM(FTD_EXCTD_QTY),0)
      INTO    :d_frsh_exe_val,
              :li_tot_exec_qty
      FROM    FTD_FO_TRD_DTLS
      WHERE   FTD_ORDR_RFRNC = :c_fresh_ord_ref;

    if( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31760", SQLMSG, ptr_st_err_msg->c_err_msg );
      return FAILURE;
    }

    * Checking if Fresh order value & quantity is equals to zero. *
    if (d_frsh_exe_val == 0 || li_tot_exec_qty == 0)
    {
      fn_errlog( c_ServiceName, "S31765", LIBMSG, ptr_st_err_msg->c_err_msg );
      return FAILURE;
    }

    ** Calculating the Weight Average Price for the executed quantity of FRESH Order. **
    d_wgt_avrg_price = 0;

    if (li_tot_exec_qty != 0 )
    {
      d_wgt_avrg_price = (double) (d_frsh_exe_val / li_tot_exec_qty);
    }

    * Calculate open quantity *
    EXEC SQL
      SELECT  NVL( SUM( DECODE( FOD_FC_FLAG, 'C', -1 * FTD_EXCTD_QTY,
                                                       FTD_EXCTD_QTY ) ), 0 ),
              NVL( SUM( DECODE( FOD_FC_FLAG, 'F', FTD_EXCTD_QTY, 0 ) ), 0 )
      INTO    :l_open_qty,
              :l_frsh_xtd_qty
      FROM    FOD_FO_ORDR_DTLS, FTD_FO_TRD_DTLS
      WHERE   FOD_CLM_MTCH_ACCNT    = :ptr_st_ordbook->c_cln_mtch_accnt
      AND     FOD_TRD_DT            = :ptr_st_ordbook->c_trd_dt
      AND     FOD_PRDCT_TYP         = :ptr_st_ordbook->c_prd_typ
      AND     FTD_ORDR_RFRNC        = FOD_ORDR_RFRNC
      AND     DECODE( FOD_FC_FLAG, 'F', FOD_ORDR_RFRNC, FOD_SLTP_ORDR_RFRNC ) = :c_fresh_ord_ref;

    if( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31770", SQLMSG, ptr_st_err_msg->c_err_msg );
      return FAILURE;
    }

    if(l_open_qty <0 )
    {
      l_open_qty=0;
    }

		EXEC SQL
        SELECT nvl(FRM_DIFFRNC_MRGN,0)
        INTO   :d_frm_diffrnc_mrgn
        FROM   FRM_FO_RANGE_MSTR
        WHERE  FRM_XCHNG_CD  = TRIM(:ptr_st_ordbook->c_xchng_cd)
        AND    TRIM(FRM_UNDRLYNG ) = TRIM( :ptr_st_ordbook->c_undrlyng)
        AND    FRM_ORDR_FLOW = :c_ord_flw                  *** This is fresh order flw ***
				AND    FRM_FROM_RANGE <= :l_temp_stp_lss_tgr
        AND    :l_temp_stp_lss_tgr   < FRM_TO_RANGE
        AND    (:l_temp_stp_lss_tgr > 0 ) ;  *** Modified sltp trggr price is used ***

    if ( SQLCODE  !=  0  && SQLCODE != NO_DATA_FOUND)
    {
      fn_errlog( c_ServiceName, "S31775", SQLMSG, ptr_st_err_msg->c_err_msg );
      return FAILURE;
    }


    if(DEBUG_MSG_LVL_3)
    {
        fn_userlog(c_ServiceName,"d_frm_diffrnc_mrgn = :%lf:", d_frm_diffrnc_mrgn);
        fn_userlog(c_ServiceName,"l_temp_stp_lss_tgr = :%ld:", l_temp_stp_lss_tgr);
    }

    * Calculate Margin amount to be blocked *
    d_amt_to_be_blckd = ((double)(l_open_qty * d_wgt_avrg_price) * d_fmm_sltp_prcnt / 100.0);

    * Calculate Loss amount to be blocked *
    if ( c_ord_flw == BUY )
    {
			if( d_frm_diffrnc_mrgn < 100 && d_frm_diffrnc_mrgn != -1 )
      {
      	d_lss_amt_to_be_blckd = (double) (l_open_qty * (ptr_st_ordbook->l_ord_lmt_rt - d_wgt_avrg_price) );
			}
      else if ( d_frm_diffrnc_mrgn == 100 )
      {
        d_lss_amt_to_be_blckd = (double) (l_open_qty * d_wgt_avrg_price) ;
      }
      else if( d_frm_diffrnc_mrgn == -1 )
      {
          fn_userlog(c_ServiceName,"Entered SLTP is OutOff Range");
          strcpy (ptr_st_err_msg->c_err_msg , "Please Enter SLTP in Proper Range");
          fn_errlog( c_ServiceName, "S31780","Please Enter SLTP in Proper Range",ptr_st_err_msg->c_err_msg);
          return FAILURE;
      }
    }
    else if ( c_ord_flw == SELL )
    {
      d_lss_amt_to_be_blckd = (double) (l_open_qty * (d_wgt_avrg_price - ptr_st_ordbook->l_ord_lmt_rt) );
    }
				comment end in Ver 7.5 *******/

		/**** Ver 7.5 starts from here ****/
		
         i_returncode = fn_cal_mrgn_sltp_op ( c_ServiceName,
                                              c_fresh_ord_ref,
                                              d_frsh_lmt_rt,
                                              ptr_st_ordbook->l_ord_lmt_rt,
                                              &d_amt_to_be_blckd,
                                              &d_lss_amt_to_be_blckd,
                                       		    c_ref_rmrks,  /*** Ver 10.2***/
                                              &d_comp1_mrgn,/*** Ver 10.2***/
                                              &d_comp1_pl,  /*** Ver 10.2***/
                                              &d_xchng_amt, /*** Ver 10.2***/
                                              &d_prem_amt,  /*** Ver 10.2***/
                                              &d_spn_mrgn,  /*** Ver 10.2***/
                                              &d_expr_mrgn, /*** Ver 10.2***/
                                              'U',
                                              c_err_msg
                                            );
    if ( i_returncode == -1 )
    {
      fn_errlog( c_ServiceName, "S31785", LIBMSG, c_err_msg );
      return FAILURE;
    }
    /*** ver 10.2 starts ***/
    if(DEBUG_MSG_LVL_0)
    {
      fn_userlog(c_ServiceName,"fn_cal_mrgn_sltp_op :%lf: :%lf: :%lf: :%lf :%lf: :%lf:",d_comp1_mrgn,d_comp1_pl,d_xchng_amt,d_prem_amt,d_spn_mrgn,d_expr_mrgn);
    }
    d_lss_amt_to_be_blckd = d_lss_amt_to_be_blckd* (-1);
    /*** ver 10.2 ends ***/
		/**** Ver 7.5 Ends here ****/
	

    /* Difference margin & loss */
    d_diff_amt  = d_amt_blkd - d_amt_to_be_blckd;
    d_diff_loss = d_lss_amt_blkd + d_lss_amt_to_be_blckd;


    if(DEBUG_MSG_LVL_3)
    {
      fn_userlog(c_ServiceName,"ptr_st_ordbook->l_ord_lmt_rt :%ld:",ptr_st_ordbook->l_ord_lmt_rt);
      fn_userlog(c_ServiceName,"l_open_qty = :%ld",l_open_qty);
      fn_userlog(c_ServiceName,"d_wgt_avrg_price = :%lf:",d_wgt_avrg_price);
      fn_userlog(c_ServiceName,"d_amt_blkd = :%lf:", d_amt_blkd);
      fn_userlog(c_ServiceName,"d_amt_to_be_blckd = :%lf:", d_amt_to_be_blckd);
      fn_userlog(c_ServiceName,"d_lss_amt_blkd = :%lf:", d_lss_amt_blkd);
      fn_userlog(c_ServiceName,"d_lss_amt_to_be_blckd = :%lf:", d_lss_amt_to_be_blckd);
      fn_userlog(c_ServiceName,"d_diff_amt = :%lf:",d_diff_amt);
      fn_userlog(c_ServiceName,"d_diff_loss = :%lf:",d_diff_loss);
    }

    /* Block the margin amount */
    strcpy( c_narration_id , ON_ORDER_PLACEMENT);
    if(d_diff_amt != 0)
    {

        d_balance_amt  = 0.0;

        if(DEBUG_MSG_LVL_3)
        {
          fn_userlog(c_ServiceName,"Block the margin amount");
        }
        i_returncode = fn_upd_limits( c_ServiceName,
                          ptr_st_pstn_actn,
                          ptr_st_err_msg,
                          c_narration_id,
                          DEBIT_TILL_LIMIT,
                          d_diff_amt,
                          &d_balance_amt);


        if ( i_returncode != 0 )
        {
          fn_errlog( c_ServiceName, "S31790", LIBMSG, ptr_st_err_msg->c_err_msg );
          return FAILURE;
        }

        d_amt_to_be_blckd = d_amt_to_be_blckd + d_balance_amt ;
      }

    /* Block the loss amount */
      strcpy( c_narration_id , ON_ORDER_PLACEMENT);

     /*** Ver 10.2 started ***/
      MEMSET(c_tmp_rmrks);
      strcpy ( c_tmp_rmrks, (char *)ptr_st_pstn_actn->c_ref_rmrks );
      sprintf((char *)ptr_st_pstn_actn->c_ref_rmrks,"%s%s",c_ref_rmrks,c_tmp_rmrks);
      /*** Ver 10.2 ends ***/


    if( d_lss_amt_to_be_blckd <= 0 )
    {
      if(d_diff_loss != 0)
      {
        d_balance_amt  = 0.0;

        if(DEBUG_MSG_LVL_3)
        {
          fn_userlog(c_ServiceName,"Block the loss amount");
        }
        i_returncode = fn_upd_limits( c_ServiceName,
                          ptr_st_pstn_actn,
                          ptr_st_err_msg,
                          c_narration_id,
                          DEBIT_TILL_LIMIT,
                          d_diff_loss,
                          &d_balance_amt);


        if ( i_returncode != 0 )
        {
          fn_errlog( c_ServiceName, "S31795", LIBMSG, ptr_st_err_msg->c_err_msg );
          return FAILURE;
        }
         d_lss_amt_to_be_blckd = d_lss_amt_to_be_blckd - d_balance_amt ;
      }
    }
    else if(d_lss_amt_to_be_blckd > 0)
    {
      if(d_lss_amt_blkd != 0)
      {
        d_balance_amt  = 0.0;

        if(DEBUG_MSG_LVL_3)
        {
          fn_userlog(c_ServiceName,"Release old loss amount in case or profit");
        }
        i_returncode = fn_upd_limits( c_ServiceName,
                          ptr_st_pstn_actn,
                          ptr_st_err_msg,
                          c_narration_id,
                          DEBIT_TILL_LIMIT,
                          d_lss_amt_blkd,
                          &d_balance_amt);


        if ( i_returncode != 0 )
        {
          fn_errlog( c_ServiceName, "S31800", LIBMSG, ptr_st_err_msg->c_err_msg );
          return FAILURE;
        }
      }
       d_lss_amt_to_be_blckd = 0;
    }
      strcpy ( ptr_st_pstn_actn->c_ref_rmrks, c_tmp_rmrks);    /**** Ver 10.2 ***/
      MEMSET(c_tmp_rmrks);                                     /**** Ver 10.2 ***/


		if( DEBUG_MSG_LVL_0) /*** DEBUG_MSG_LVL_0 Added in Ver 8.1 ***/
		{
			fn_userlog(c_ServiceName,"d_amt_blkd :%lf:",d_amt_blkd);
			fn_userlog(c_ServiceName,"d_diff_amt :%lf:",d_diff_amt);
			fn_userlog(c_ServiceName,"d_lss_amt_to_be_blckd :%lf:",d_lss_amt_to_be_blckd);
			fn_userlog(c_ServiceName,"d_diff_loss :%lf:",d_diff_loss);
		}
    EXEC SQL
       UPDATE     FOD_FO_ORDR_DTLS
       SET        FOD_SLTP_ORDR_RFRNC = :ptr_st_ordbook->c_ordr_rfrnc,
                  FOD_AMT_BLCKD = :d_amt_to_be_blckd,
                  FOD_LSS_AMT_BLCKD = abs(:d_lss_amt_to_be_blckd),
     		          FOD_SLTP_MRGN = :d_comp1_mrgn,     /*** Ver 10.2 ***/
                  FOD_SLTP_PL   = :d_comp1_pl,       /*** Ver 10.2 ***/
                  FOD_SLTP_SEBI_MRGN = :d_xchng_amt, /*** Ver 10.2 ***/
                  FOD_OPLUS_PREMIUM  = :d_prem_amt,  /*** Ver 10.2 ***/
                  FOD_SPAN_MRGN = :d_spn_mrgn,       /*** Ver 10.2 ***/
                  FOD_EXPR_MRGN = :d_expr_mrgn       /*** Ver 10.2 ***/
       WHERE      FOD_ORDR_RFRNC = :c_fresh_ord_ref;

      if(SQLCODE != 0)
      {
        fn_errlog( c_ServiceName, "S31805", SQLMSG, ptr_st_err_msg->c_err_msg );
        return FAILURE;
      }

      EXEC SQL
       UPDATE     FOD_FO_ORDR_DTLS
       SET        FOD_SLTP_ORDR_RFRNC = :c_fresh_ord_ref,
                  FOD_FC_FLAG = 'C'
       WHERE      FOD_ORDR_RFRNC = :ptr_st_ordbook->c_ordr_rfrnc;

      if(SQLCODE != 0)
      {
        fn_errlog( c_ServiceName, "S31810", SQLMSG, ptr_st_err_msg->c_err_msg );
        return FAILURE;
      }
}
int fn_off_optpls ( char  *c_ServiceName,
                    char  *c_fresh_ord_ref,
                    struct vw_orderbook *ptr_st_ordbook,
                    struct vw_err_msg *ptr_st_err_msg
                   )
{
    if(DEBUG_MSG_LVL_3)
    {
      fn_userlog(c_ServiceName,"c_fresh_ord_ref :%s:",c_fresh_ord_ref);
    }

    EXEC SQL
       UPDATE     FOD_FO_ORDR_DTLS
       SET        FOD_SLTP_ORDR_RFRNC = :ptr_st_ordbook->c_ordr_rfrnc
       WHERE      FOD_ORDR_RFRNC = :c_fresh_ord_ref;

      if(SQLCODE != 0)
      {
        fn_errlog( c_ServiceName, "S31815", SQLMSG, ptr_st_err_msg->c_err_msg );
        return FAILURE;
      }

      EXEC SQL
       UPDATE     FOD_FO_ORDR_DTLS
       SET        FOD_SLTP_ORDR_RFRNC = :c_fresh_ord_ref,
                  FOD_FC_FLAG = 'C'
       WHERE      FOD_ORDR_RFRNC = :ptr_st_ordbook->c_ordr_rfrnc;

      if(SQLCODE != 0)
      {
        fn_errlog( c_ServiceName, "S31820", SQLMSG, ptr_st_err_msg->c_err_msg );
        return FAILURE;
      }
}

/*** Ver 5.4 Ends *****/

/*** Ver 6.4 starts *****/
int fn_excpt_eos_optpls ( char  *c_ServiceName,
																char  *c_cover_ord_ref,
																struct vw_orderbook *ptr_st_ordbook,
																struct vw_err_msg *ptr_st_err_msg
														 )
{
    char c_fresh_ord_ref[19];

    int   i_returncode;

    if(DEBUG_MSG_LVL_3)
    {
      fn_userlog(c_ServiceName,"c_cover_ord_ref :%s:",c_cover_ord_ref);
    }

    EXEC SQL
    SELECT
          FOD_SLTP_ORDR_RFRNC
    INTO  :c_fresh_ord_ref
    FROM  FOD_FO_ORDR_DTLS
    WHERE FOD_ORDR_RFRNC = :c_cover_ord_ref;

    if( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31825", SQLMSG, ptr_st_err_msg->c_err_msg );
      return FAILURE;
    }

    if(DEBUG_MSG_LVL_3)
    {
      fn_userlog(c_ServiceName,"c_fresh_ord_ref :%s:",c_fresh_ord_ref);
    }

    EXEC SQL
       UPDATE     FOD_FO_ORDR_DTLS
       SET        FOD_SLTP_ORDR_RFRNC = :ptr_st_ordbook->c_ordr_rfrnc
       WHERE      FOD_ORDR_RFRNC = :c_fresh_ord_ref;

      if(SQLCODE != 0)
      {
        fn_errlog( c_ServiceName, "S31830", SQLMSG, ptr_st_err_msg->c_err_msg );
        return FAILURE;
      }

      EXEC SQL
       UPDATE     FOD_FO_ORDR_DTLS
       SET        FOD_SLTP_ORDR_RFRNC = :c_fresh_ord_ref,
                  FOD_FC_FLAG = 'E'
       WHERE      FOD_ORDR_RFRNC = :ptr_st_ordbook->c_ordr_rfrnc;

      if(SQLCODE != 0)
      {
        fn_errlog( c_ServiceName, "S31835", SQLMSG, ptr_st_err_msg->c_err_msg );
        return FAILURE;
      }
}
/*** Ver 6.4 Ends *****/

/*** Ver 9.5 Starts ***/
int fn_get_quote_zero ( char *c_ServiceName, char c_ord_flw, long l_best_bid_price, long l_best_offer_price, long l_previous_close_price, long *l_quote_zero)
{
	if(DEBUG_MSG_LVL_5)
  {
    fn_userlog(c_ServiceName,"Inside function fn_get_quote_zero");
    fn_userlog(c_ServiceName,"Inside fn_get_quote_zero l_best_bid_price is :%ld:",l_best_bid_price);
    fn_userlog(c_ServiceName,"Inside fn_get_quote_zero l_best_offer_price is :%ld:",l_best_offer_price);
    fn_userlog(c_ServiceName,"Inside fn_get_quote_zero l_previous_close_price is :%ld:",l_previous_close_price);
  }
  if(c_ord_flw == 'B')
  {
    if(l_best_offer_price == 0)
    {
      *l_quote_zero = l_previous_close_price;
    }
    else
    {
      *l_quote_zero = l_best_offer_price;
    }
  }
  else if (c_ord_flw == 'S')
  {
    if(l_best_bid_price == 0)
    {
      *l_quote_zero = l_previous_close_price;
    }
    else
    {
      *l_quote_zero = l_best_bid_price;
    }
  }
  else
  {
    return -1;
  }
	if(DEBUG_MSG_LVL_5)
  {
    fn_userlog(c_ServiceName,"Inside fn_get_quote_zero l_quote_zero is :%ld:",*l_quote_zero);
  }
  return 1;
}
/*** Ver 9.5 Ends ***/
