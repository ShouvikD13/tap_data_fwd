/******************************************************************************/
/*  Program           : SFO_PLG_POS                                 					*/
/*                                                                            */
/*  Input             : FFO_USR_ID																						*/
/*											FFO_SSSN_ID																						*/	
/*											FFO_EBA_MTCH_ACT_NO																		*/
/*										  FFO_OPT_TYP																						*/
/*                                                                            */
/*  Output            : FFO_ERR_MSG																						*/
/*											FFO_ACTN_ID																						*/	
/*											FFO_EBA_MTCH_ACT_NO																		*/
/*											FFO_DP_CLNT_ID 																				*/
/*											FFO_DPID																							*/
/*											FFO_STCK_CD 																					*/
/*											FFO_PLG_REQ_QTY																				*/
/*											FFO_PLG_QTY 																					*/
/*											FFO_CLS_PRC																						*/
/*											FFO_HAIRCUT 																				  */			
/*											FFO_PLG_BLOCK 																				*/
/*											FFO_AVL_QTY 																					*/
/*											FFO_NEW_QTY																						*/
/*											FFO_TIFP_QTY																					*/
/*											FFO_TOTAL_PL																					*/
/*											FFO_THRS_VAR_PRCNT																		*/
/*                      FFO_HGH_PRC                                           */
/*																																						*/
/*  Description       :  This serviece will be called by Front-end (ASP/DL)		*/
/*											 to get positon of a client.This service will select  */
/*										   data from DBD_DP_BLCK_DTLS table				 							*/
/*																																						*/
/*  Log               : 1.0		13-Sep-2004		Infotech|Himanshu Ahire						*/
/*	Reviewed By				:	1.0   26-Oct-2004	  Infotech|Sangeet Sinha            */
/*                      1.1 	13-Mar-2007		Infotech|Sushil Sharma            */
/*                    : 1.2   17-Dec-2007   Infotech|Vidyayini Krish,Shamili  */
/*                    :	1.3		11-May-2008		Infotech|ROhit 		                */
/*                    : 1.4   02-Sep-2009   Infotech|Vidyayini Krish          */
/*                    : 1.5   08-Feb-2011   Infotech|Swati Bharankar          */
/*                    : 1.6   04-Feb-2011   Infotech|Diwakar                  */
/*                    : 1.7   21-Sep-2012   Infotech|Swati A.B                */
/*										:	1.8		17-Jul-2013		Infotech|Bhushan Sonwane/Samip M  */
/*										:	1.9		28-Oct-2013		Infotech|Samip M  								*/
/*										:	2.0		25-Jul-2014		Infotech|Swati A.B  							*/
/*										: 2.1		26-Sep-2014		Infotech:Tanmay Warkhade					*/
/*                    : 2.2   09-Oct-2014   Infotech:Sachin Birje             */
/*                    : VQC  	24-Jun-2016   Infotech|Ritesh Deolekar          */
/*                    : 2.3   12-Jun-2020   Infotech|Anand Dhopte             */
/*                    : 2.4   06-Jul-2020   Infotech|Tanmay Patel             */
/*                    : 2.5   28-Dec-2020   Infotech|Anand Dhopte             */
/*                    : 2.6   10-Feb-2021   Infotech|Chaitanya Kulkarni				*/
/*										: 2.7   16-Aug-2021		Infotech|Sanjay Kriplani					*/
/*                    : 2.8   15-Jun-2022   Infotech|Remon Pereira            */
/*                    : 3.0   30-Nov-2022   Tanmay Patel                      */
/******************************************************************************/
/*   1.0  -  New release	                                                    */
/*   1.1	-	 DL revamp                                                        */
/*   1.2  -  IBM Changes                                                      */
/*	 1.3	-  Change for Reallocation																					*/
/*   1.4  -  CRCSN35839 disable spot in NSE and enable in BSE                 */
/*   1.5  -  Silverlight Changes (Auto-Refresh Requirement)                   */
/*   1.6  -  EQUITY SAM changes                                               */
/*   1.7  -  Bug Fix  (Trim added )																						*/
/*	 1.8	-	 Changes to display free quantity	to withdraw on front end				*/
/*	 1.9  -  Bug fix for Negative Limit 																			*/
/*	 2.0  -  FML Type mismatch chng  ( For FNO DL Site ) 											*/
/*	 2.1	-	 SAM Block/Unblock																								*/
/*   2.2  -  View to FML Changes                                              */
/*	 VQC  -  VERSION QUALITY CONTROL																					*/
/*   2.3  -  Function call introduced to update SAM free limits               */ 
/*   2.4  -  CR-ISEC14-138293 Margin Pledge                                   */
/*   2.5  -  CR-ISEC14-142905_ Simplification of Shares as Margin Pages       */
/*	 2.6  -  CR-ISEC03-143285:Trading and securities settlement for clients having DP accounts*/
/*					 with Federal Bank																								*/
/*	 2.7  -	 CR-ISEC03-152803 IDFC Demat - Transaction & Settlement IDFC First bank */ 
/*   2.8  -  MINOR CHANGES:MTF & SAM error message change for other bank users*/
/*   3.0  - SAM for Currency & Commodity*/
/******************************************************************************/

#include <stdio.h>
#include <stdlib.h>     
#include <sqlca.h>
#include <atmi.h>
#include <userlog.h>
#include <fml32.h>
#include <Usysflds.h>   
#include <fo_fml_def.h> 
/** #include <fo_view_def.h> ** Ver 2.2 **/
/* COMMENTED IN VER TOL : TUX on LINUX (Ravindra) * #include <fo_view_def.h> ** Ver 2.2 ** */
#include <fml_rout.h>    /*** Ver 2.2 **/
#include <fo.h>
#include <fn_tuxlib.h>
#include <fn_log.h> /* Ver 1.2 */
#include <string.h> /* Ver 1.2 */
#include <fn_ddr.h> /* Ver 1.2 */
#include <fn_session.h> /* Ver 1.2 */
#include <fn_read_debug_lvl.h>      /* ver 1.2 -- debug level handling */
#include <fn_eqsam.h> /* Ver 1.6 */
#include <fn_pos.h> /* Ver 2.2 */
#include <fn_cod_pos.h> /* Ver 3.0 */ 

#define	 BUF_MULTIPLY 3
#define  HOMEPAGE 'S'
#define  DEPOSIT  'D'
/*** #define  NULLCHAR(A) memset(A,0,sizeof(A)) *** Commented in VQC ***/

/** #define MIN(x,y)  ( (x < y) ? x : y ); * Ver 1.8 ** Commented in Ver 3.0 **/
#define MIN(x,y)  ( (x) < (y) ? (x) : (y) ); /* Ver 3.0 **/

/*** #define MAX(x,y)  ( (x > y) ? x : y ); * Ver 1.8 ** Commented in VQC ***/

/** ver 3.0 Start **/
int fn_cdx_get_trd_limit(char *c_ServiceName,
                     char *c_mtch_id,
                     char *c_trd_dt,
                     char *c_xchng_cd,
                     long l_grp_id,
                     double *d_trd_limit,
                     char *c_err_msg
                    );

/** ver 3.0 Ends **/

void SFO_PLG_POS( TPSVCINFO *rqst )
{
	int i_returncode = 0;				/*** Variable Initialized in VQC ***/ 
  int i_trnsctn = 0;
	/***int i_err[16];       	*** Ver 1.8 ** Changed to 16 from 15 ***/
  /***int i_ferr[16];				*** Ver 1.8 ** Changed to 16 from 15 ***/
	int i_err[17];       	/*** Ver 1.8 ** Changed to 16 from 15 ***//** Changed from 16 to 17 for 2.1 ***/
  int i_ferr[17];				/*** Ver 1.8 ** Changed to 16 from 15 ***//** Changed from 16 to 17 for 2.1 ***/
	int i_cnt = 0;							/*** Variable Initialized in VQC ***/
	int i_counter =1;
	int  i_cld_count = 0;  /*** Ver 2.6 ***/

	/***	long li_sssn_id;			*** Commented in VQC ***/
/**	long l_acnt_id;						** Ver 1.1 : Commented	***/
	long l_tot_avl_qty = 0;    /*** Variable Initialized in VQC ***/
	long l_qty_plg = 0;				 /*** Variable Initialized in VQC ***/
	long l_plg = 0;						 /*	Ver 1.1 DL revamp		*/ /*** Variable Initialized in VQC ***/
	long l_tot_qty_dep = 0;	   /*  Ver 1.1 DL revamp   */ /*** Variable Initialized in VQC ***/
  long l_pod_cnt = 0;        /** Ver 2.4 **/

	double d_sec_dep = 0.0;						/*  Ver 1.1 DL revamp **  Variable Initialized in VQC */
	double d_sec_after_hc = 0.0;			/*  Ver 1.1 DL revamp **  Variable Initialized in VQC */
  double d_free_limit_val = 0.00;   /***  Ver 2.3  ***/

	char c_ServiceName [ 33 ];
  /***	char c_err_msg[256 + 1];	 *** Data type changed from char to varchar in VQC ***/
  varchar c_err_msg[256 + 1];				/*** Data type changed from char to varchar in VQC ***/						
  /**		char c_msg      [256];				*** Commented in VQC ***/
	/***	char c_usr_id   [8+1];				*** Commented in VQC ***/
	/***	char c_mtch_accnt_no[11];			** Ver 1.6 changed 15 to 11 ** Commented in VQC ***/
	char c_acc_ref [40];
	char c_opt_typ = '\0';			/**  Variable Initialized in VQC */
	char  c_ip_stck_cd[7];      /**  Ver 1.5  **/
	char c_flag = 'Y';          /** ver 1.5 --set default to 'Y' **/
	char c_null_msg [ 18 ];			/*** Ver 1.8 ***/

  FBFR32  *ptr_fml_ibuf;     								/* Pointer to FML Input buffer    			*/
  FBFR32  *ptr_fml_obuf;     								/* Pointer to FML Output buffer   	 		*/
  /*** FBFR32  *ptr_fml_temp;     								* Pointer to FML Output buffer  Commented in VQC	 		*/
  TPINIT *ptr_tpinfo;
	struct vw_usr_prfl st_usr_prfl;
	struct vw_err_msg st_err_msg;
	struct vw_gt_lmt_dtls st_gt_lmt;	/***** Ver 1.8 *****/

	/*** Ver 1.8 ***/
	double d_eq_sam_limit	=0.0;
	double d_free_sam_limit=0.0;
	double sql_fab_plg_amt = 0.0;
	double sql_fab_nwb_amt = 0.0;
	double sql_free_qty_val = 0.0;

	/*** Ver 1.8 ***/
  double d_cab_cdx_plg_amt =0.0; /** Ver 3.0 **/
  double d_cab_cod_plg_amt =0.0; /** Ver 3.0 **/
  double d_cdx_limit = 0.0; /** Ver 3.0 **/
  double d_mco_limit = 0.0; /** Ver 3.0 **/

  double  d_fab_min_lmt=0.0; /** Ver 3.0 **/
  double  d_cdx_min_lmt=0.0; /** Ver 3.0 **/
  double  d_mco_min_lmt=0.0; /** Ver 3.0 **/

	EXEC SQL BEGIN DECLARE SECTION;

	/*** int		i_no_rows; *** Commented in VQC ***/
	char	c_stck_cd[7];
	char	c_dp_id[9];
	char  c_dp_clnt_id[9];
  char  c_mrgn_plg_allwd = 'N';  /** Ver 2.4 **/
  char  c_plg_mode = 'P';        /** Ver 2.4 **/
	char c_rqst_type = 'Y';					/** Ver 2.4 **/
  /** long  l_blok_for_sale =0;       ** Ver 2.4 **/

	long	l_tot_qty = 0;			/**  Variable Initialized in VQC */
	long	l_qty_blckd = 0;  	/**  Variable Initialized in VQC */
	long	l_plg_req_qty = 0;	/********** 0 defaulted for Ver 2.1 *****/
	long	l_rev_req_qty = 0;			/********** 0 defaulted for Ver 2.1 *****/
	long	l_rev_cov_qty = 0;			/********** 0 defaulted for Ver 2.1 *****/
	/**		long	l_plg_req_qty;						ver 2.1 **
				long	l_tifp_qty;								ver 2.1	**
				long	l_rev_req_qty;						ver 2.1	**
				long	l_rev_cov_qty;						ver 2.1 **	
				long	l_inv_req_qty;						ver 2.1 **
				long	l_inv_cov_qty;						ver 2.1 **/
	long 	l_sam_blk_qty	= 0;		/**  Variable Initialized in VQC */
	long	l_blk_for_sale = 0;   /**  Variable Initialized in VQC */
	long 	l_plg_haircut = 0;				/*  Ver 1.1 DL revamp   */ /**  Variable Initialized in VQC */
	long 	l_tot_blck_qty 	= 0;				/*** Ver 1.8 ***/
	long  l_free_qty 			= 0;				/*** Ver 1.8 ***/
	long l_ip_len  = 0;			/*** Ver 1.8 ***/
	long l_free_qty_val = 0;


	double d_plg_rt = 0.0;				/**  Variable Initialized in VQC */
	double d_plg_haircut = 0.0;		/**  Variable Initialized in VQC */
/**  double d_outstndg_amnt = 0.0; ** Ver 2.4 **/
	
	/*** 1.8 Start ***/
	
	double d_nfo_limit=0.0;
	double d_bfo_limit=0.0;
	double d_net_fno_limit=0.0;
	varchar sql_nxt_trd_dt[13];		

	/*** 1.8 End ***/

  varchar v_sam_upd_tm[23]; /* Ver 2.3 */

	EXEC SQL END DECLARE SECTION;


	/******************* calculate size of buffer for later use **********************/

	const long l_bufferlength =   (  sizeof(long)   * 8      )		/*	Ver 1.1 long changed from 5 to 8	*/
                         			+ (  sizeof(double) * 4      )		/*  Ver 1.1 double changed from 2 to 4	*/
                         			+ (  sizeof(c_err_msg)       )
              /***       			+ (  sizeof(c_mtch_accnt_no)  )		** Commented in VQC **/
                         			+ (  sizeof(st_usr_prfl.c_cln_mtch_accnt)  )		/** Added in VQC **/
                         			+ (  sizeof(c_dp_clnt_id)    )
                         			+ (  sizeof(c_dp_id)         )
                         			+ (  sizeof(c_stck_cd)       )
												    	 + (  sizeof(c_ip_stck_cd)    )     /** ver 1.5 **/
															+	200;														/*  Ver 1.1 DL revamp   */

	
	/************************* Take Input From FML Buffer ***************************/

  ptr_fml_ibuf = (FBFR32 *)rqst->data;
  strcpy(c_ServiceName, rqst->name);

	INITDBGLVL(c_ServiceName);		/*** Ver 2.1 ***/
	memset(c_acc_ref , 0 , sizeof(c_acc_ref));
  memset(c_dp_id,0,sizeof(c_dp_id));
  memset(c_dp_clnt_id,0,sizeof(c_dp_clnt_id));
/***  memset(c_mtch_accnt_no,0,sizeof(c_mtch_accnt_no));		** Commented in VQC **/
  memset(st_usr_prfl.c_cln_mtch_accnt,0,sizeof(st_usr_prfl.c_cln_mtch_accnt)); 	/** Added in VQC **/
  memset(c_ip_stck_cd,0,sizeof(c_ip_stck_cd));      /** ver 1.5 **/
	strcpy(c_null_msg,"\0");			/*** Ver 1.8 ***/
	MEMSET(c_stck_cd);						/*** added in VQC ***/

	/***	i_err  [0] = Fget32( ptr_fml_ibuf,FFO_USR_ID, 0,c_usr_id,0 );							*** Commented in VQC ***/
	i_err  [0] = Fget32( ptr_fml_ibuf,FFO_USR_ID, 0,st_usr_prfl.c_user_id,0 );			/*** Added in VQC ***/
  i_ferr [0] = Ferror32;
  /***	i_err  [1] = Fget32( ptr_fml_ibuf, FFO_SSSN_ID,0,(char *)&li_sssn_id,0 );	** Commented in VQC **/
  i_err  [1] = Fget32( ptr_fml_ibuf, FFO_SSSN_ID,0,(char *)&st_usr_prfl.l_session_id,0 );	/** Added in VQC **/
  i_ferr [1] = Ferror32;
/**  i_err  [2] = Fget32( ptr_fml_ibuf,FFO_EBA_MTCH_ACT_NO,0,c_mtch_accnt_no,0);		** Commented in VQC **/
  i_err  [2] = Fget32( ptr_fml_ibuf,FFO_EBA_MTCH_ACT_NO,0,st_usr_prfl.c_cln_mtch_accnt,0); /** Added in VQC **/
  i_ferr [2] = Ferror32;
  i_err  [3] = Fget32( ptr_fml_ibuf,FFO_OPT_TYP,0,(char*)&c_opt_typ,0);
  i_ferr [3] = Ferror32;
	i_err	 [4] = Fget32( ptr_fml_ibuf,FFO_DPID,0,c_dp_id,0);
  i_ferr [4] = Ferror32;
  i_err  [5] = Fget32( ptr_fml_ibuf,FFO_DP_CLNT_ID,0,c_dp_clnt_id,0);
  i_ferr [5] = Ferror32;
	

  for ( i_cnt=0; i_cnt < 6; i_cnt++ )
  {
    if ( i_err[ i_cnt ] == -1 )
    {
      fn_errlog( c_ServiceName, "S31005", Fstrerror32(i_ferr[i_cnt]), c_err_msg.arr  ); /* .arr added in VQC */
			fn_userlog(c_ServiceName, "Error at Field number %d",i_cnt);
      Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );	/** .arr added in VQC **/
/**  	l_acnt_id = -1;
    	Fadd32( ptr_fml_ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**	Ver 1.1 : Commented	***/
      tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
    }
  }

	 /** ver 1.5 starts **/ 
  if (Fget32( ptr_fml_ibuf,FFO_STCK_CD,0,c_ip_stck_cd,0)== -1 )
  {   if(Ferror32 == FNOTPRES)
    {
    fn_userlog(c_ServiceName, "Normal Service Call");
    c_flag = 'N';
    fn_userlog(c_ServiceName, "For Normal Service Call flag is set to N");
    }
    else
    {
    fn_errlog( c_ServiceName, "S31010", FMLMSG, c_err_msg.arr  );		/** .arr added in VQC **/
    Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );					/** .arr added in VQC **/
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_ibuf, 0, 0 );
    }
  }

	if(strcmp(c_ip_stck_cd,"*") ==0)
	{ c_flag='N';}

   /** ver 1.5 ends **/

	if(DEBUG_MSG_LVL_0){
  /***	fn_userlog( c_ServiceName, "c_usr_id :%s:"		,c_usr_id);		*** Commented in VQC ***/
  	fn_userlog( c_ServiceName, "st_usr_prfl.c_user_id :%s:"		,st_usr_prfl.c_user_id);	/** Added in VQC ***/
 	/*** 	fn_userlog( c_ServiceName, "li_sssn_id :%ld:"	,li_sssn_id);	*** Commented in VQC ***/
 		fn_userlog( c_ServiceName, "st_usr_prfl.l_session_id :%ld:"	,st_usr_prfl.l_session_id);	/** Added in VQC **/
  	fn_userlog( c_ServiceName, "c_opt_typ :%c:"		,c_opt_typ);
  	fn_userlog( c_ServiceName, "l_bufferlength :%ld:"	,l_bufferlength);
	/**		fn_userlog( c_ServiceName, "c_mtch_accnt_no :%s:"		,c_mtch_accnt_no);	** Commented in VQC **/
		fn_userlog( c_ServiceName, "st_usr_prfl.c_cln_mtch_accnt :%s:",st_usr_prfl.c_cln_mtch_accnt);	/** Added in VQC **/
		fn_userlog( c_ServiceName, "c_dp_clnt_id :%s:"			  ,c_dp_clnt_id);
		fn_userlog( c_ServiceName, "c_dp_id :%s:"						,c_dp_id);
		fn_userlog( c_ServiceName, "c_ip_stck_cd:%s:"        ,c_ip_stck_cd); /** ver 1.5 **/
		fn_userlog( c_ServiceName, " c_flag :%c:"   ,c_flag);                /** ver 1.5 **/
	}

	/********* Get the Match and Dp ID *********************

	if(strcmp(c_acc_ref , "*") != 0)
	{
			int i_return =0;

			i_return = split_mtch( c_acc_ref, c_dp_id,c_dp_clnt_id,c_mtch_accnt_no);

			if(i_return == 0)
			{
				fn_userlog( c_ServiceName, "Spliting Mtch Accnt String Fail ...");
				strcpy(c_err_msg, "System Error Please Contact System Support.");
				Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				l_acnt_id = -1;
				Fadd32( ptr_fml_ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );	
				tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
			}

	}
	else
	{
		strcpy(c_mtch_accnt_no , "*");
	}

	*******************/

	/**************************** Check Session of User ****************************/

  /***  strcpy( st_usr_prfl.c_user_id, c_usr_id );								*** Commented in VQC ***/
  /***  st_usr_prfl.l_session_id = li_sssn_id;										*** Commented in VQC ***/
  /***  strcpy( st_usr_prfl.c_cln_mtch_accnt,c_mtch_accnt_no);		*** Commented in VQC ***/
    fn_cpy_ddr ( st_usr_prfl.c_rout_crt );			 /*** Added for Order Routing ***/

	
    i_returncode = fn_chk_sssn( c_ServiceName, &st_usr_prfl, &st_err_msg );

    if ( i_returncode == -1 )
    {
		fn_errlog( c_ServiceName,"S31015",LIBMSG , st_err_msg.c_err_msg  );
      Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg,0);
/**  	l_acnt_id = -1;
    	Fadd32( ptr_fml_ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			**  Ver 1.1 : Commented ***/
      tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
    }

	/***Ver 2.6 Starts***/
  EXEC SQL
    SELECT count(CLD_CLM_MTCH_ACCNT)
    INTO :i_cld_count
    FROM CLD_DP_ACCTS
    WHERE CLD_CLM_MTCH_ACCNT = :st_usr_prfl.c_cln_mtch_accnt
    AND CLD_DP_ID = :c_dp_id
    AND CLD_DP_CLNT_ID = :c_dp_clnt_id
    /***AND NVL(CLD_BNK_NM,'ICICI') = 'FEDRAL' **********Commented in Ver 2.7**/
		AND NVL(CLD_BNK_NM,'ICICI') != 'ICICI';  /****Added in Ver 2.7*****/

  if(SQLCODE != 0)
  {
    fn_errlog( c_ServiceName, "S31020", SQLMSG, c_err_msg.arr  );
    Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    tpreturn( TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
  }

  if(i_cld_count > 0)
  {
    /***fn_userlog( c_ServiceName, "Shares as Margin Facility is Not available for FEDRAL DEMAT User");**Commented in Ver 2.7****/

		fn_userlog( c_ServiceName, "Shares as Margin Facility is Not available for NON ICICI DEMAT User"); /**Added in Ver 2.7 *****/
    fn_errlog( c_ServiceName, "S31025", LIBMSG, c_err_msg.arr);
		/*strcpy(c_err_msg.arr,"Shares as Margin Facility is Not available for FEDERAL DEMAT User");**Commented in Ver 2.8**/
    strcpy(c_err_msg.arr,"Hi, this feature is coming soon !");/*Added in Ver 2.8*/
    Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    tpreturn( TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
  }
  /***Ver 2.6 Ends***/

	/****************** IF There are Multiple Match A/c **************************/

  	ptr_fml_obuf = (FBFR32 *)tpalloc( "FML32", NULL, MIN_FML_BUF_LEN * BUF_MULTIPLY );

		if ( ptr_fml_obuf == NULL )
  	{
       fn_errlog( c_ServiceName, "S31030", TPMSG, c_err_msg.arr  );		/** .arr added in VQC **/
       Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );					/** .arr added in VQC **/
/**    l_acnt_id = -1;
       Fadd32( ptr_fml_ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.1 : Commented ***/
 /**   tpfree ( ( char * )ptr_fml_obuf);											***  Commented in VQC ***/
       tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
  	}

	/***	if(strcmp(c_mtch_accnt_no,"*") == 0)									*** Commented in VQC **/
	if(strcmp(st_usr_prfl.c_cln_mtch_accnt,"*") == 0)						/** Added in VQC **/
	{

		/**************************** Begain Transaction ***************************/

		if(DEBUG_MSG_LVL_3){
    	fn_userlog(c_ServiceName,"Inside Match account is *   ");
		}

		i_trnsctn  = fn_begintran( c_ServiceName, c_err_msg.arr );	/** .arr added in VQC **/
  	if ( i_trnsctn == -1 )
  	{
   		fn_errlog( c_ServiceName, "S31035", LIBMSG, c_err_msg.arr  ); /*** Changed TPMSG to LIBMSG in VQC ***/
			Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );				/** .arr added in VQC **/
/**  	l_acnt_id = -1;
    	Fadd32( ptr_fml_ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			**  Ver 1.1 : Commented ***/
			tpfree ( ( char * )ptr_fml_obuf);
    	tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
  	}	

	
		/******************* Put Match Accounts to FDM table **********************/


    if ( (st_usr_prfl.c_user_id[0] == BPID) )
    {
			if(DEBUG_MSG_LVL_3){
      	fn_userlog(c_ServiceName,"Selecting match accounts linked to the BP user [%s]",
                  st_usr_prfl.c_user_id);
			}

      EXEC SQL
      INSERT  INTO  FDM_DT_MTCH
      SELECT  CLM_MTCH_ACCNT
			FROM 		CLM_CLNT_MSTR
      WHERE   CLM_BP_ID = :st_usr_prfl.c_user_id ;

      if ( SQLCODE != 0 )
      {
        fn_errlog( c_ServiceName, "S31040", SQLMSG, c_err_msg.arr  );		/** .arr added in VQC **/
        Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );					/** .arr added in VQC **/
/**			l_acnt_id = -1; 
				if(SQLCODE == NO_DATA_FOUND)
					l_acnt_id = 1;
    		Fadd32( ptr_fml_ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			**  Ver 1.1 : Commented ***/
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );				/** .arr added in VQC **/
				tpfree ( ( char * )ptr_fml_obuf);
        tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
      }
    }
    else
    {
      EXEC SQL
      INSERT  INTO  FDM_DT_MTCH
      SELECT  UAC_CLM_MTCH_ACCNT
			FROM 		uac_usr_accnts
      WHERE   UAC_USR_ID = :st_usr_prfl.c_user_id ;

      if ( SQLCODE != 0 )
      {
        fn_errlog( c_ServiceName, "S31045", SQLMSG, c_err_msg.arr  );			/** .arr added in VQC **/
        Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );						/** .arr added in VQC **/
/**			l_acnt_id = -1; 

				if(SQLCODE == NO_DATA_FOUND)
					l_acnt_id = 1;

    		Fadd32( ptr_fml_ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			**  Ver 1.1 : Commented ***/
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );				/** .arr added in VQC **/
				tpfree ( ( char * )ptr_fml_obuf);
        tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
      }
    }		

		/***	Ver 1.1 : Comment Starts	***
		if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg ) == -1 )
  	{
     	fn_errlog( c_ServiceName, "S31050",TPMSG,c_err_msg);
     	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
		 	Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			l_acnt_id = -1;
		 	Fadd32( ptr_fml_ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );
			tpfree ( ( char * )ptr_fml_obuf);
			tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
  	}		***  Ver 1.1 : Comment Ends  ***/

		/**************** Get each Position of each Match Account **********************/
			if(c_flag=='Y') /** Ver 1.5 **/ 
			{
			fn_userlog(c_ServiceName,"The Service is called for Auto-refresh in Silverlight");
			fn_userlog(c_ServiceName,"The Stock passed is : %s",c_ip_stck_cd);
			}
		


		  EXEC SQL
      DECLARE pos_cursor CURSOR FOR
				SELECT  DBD_CLM_MTCH_ACCNT,
								DBD_STCK_CD,
								DBD_DP_ID,
								DBD_DP_CLNT_ID,
								NVL(DBD_TOT_QTY			,0),
								NVL(DBD_QTY_BLCKD		,0),
								NVL(DBD_PLG_REQ_QTY	,0),				/**	 Commented in ver 2.1  ** uncommented in Ver 2.4 **/
		  /*							NVL(DBD_TIFP_QTY		,0),					 Commented in ver 2.1 **/
											NVL(DBD_REV_REQ_QTY	,0),
											NVL(DBD_REV_COV_QTY	,0),
									/**		NVL(DBD_INV_REQ_QTY	,0),					 Commented in ver 2.1
											NVL(DBD_INV_COV_QTY	,0),					 Commented in ver 2.1*/
								NVL(DBD_SAM_BLCKD_QTY,0),
								NVL(DBD_BLOCK_FOR_SALE,0)
				FROM		FDM_DT_MTCH,
								DBD_DP_BLCK_DTLS 
				WHERE		DBD_CLM_MTCH_ACCNT	= FDM_CLM_MTCH_ACCNT
				AND trim(DBD_STCK_CD) 			= DECODE(:c_flag,'Y',TRIM(:c_ip_stck_cd),trim(DBD_STCK_CD))  		/** ver 1.5 **/ /** TRIM added for Ver 2.1 ***/
				AND trim(DBD_DP_ID) 				= DECODE(:c_flag,'Y',:c_dp_id,trim(DBD_DP_ID))  					/** ver 1.5 **/
				AND trim(DBD_DP_CLNT_ID) 		= DECODE(:c_flag,'Y',:c_dp_clnt_id,trim(DBD_DP_CLNT_ID))  /** ver 1.5 **/
				ORDER BY DBD_STCK_CD,DBD_DP_CLNT_ID;
      EXEC SQL OPEN pos_cursor;

			if ( SQLCODE != 0 )
      {
        fn_errlog( c_ServiceName, "S31055", SQLMSG, c_err_msg.arr  );			/** .arr added in VQC **/
				EXEC SQL CLOSE pos_cursor;
        Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );						/** .arr added in VQC **/
/**			l_acnt_id = -1;
				if(SQLCODE == NO_DATA_FOUND)
					l_acnt_id = 1;
								
        Fadd32( ptr_fml_ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			**  Ver 1.1 : Commented ***/
				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); /**	Ver 1.1 : Added	*** .arr added in VQC **/
				tpfree ( ( char * )ptr_fml_obuf);
        tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
      }
			

		
		/**************** For Each Position of Match Account Loop **********************/
			i_counter = 1;	
			while(1)
			{
				if(DEBUG_MSG_LVL_3){
					fn_userlog( c_ServiceName, "For Each Position of Match Account" );
				}

				EXEC SQL FETCH pos_cursor
	/***			INTO	:c_mtch_accnt_no,				** Commented in VQC **/	
				INTO	:st_usr_prfl.c_cln_mtch_accnt,						/** Added in VQC **/	
							:c_stck_cd,
							:c_dp_id,
							:c_dp_clnt_id,
							:l_tot_qty,
							:l_qty_blckd,
              :l_plg_req_qty, 		/** 	ver 2.1	** uncommented in Ver 2.4 **/ 
              /**	:l_tifp_qty,					ver 2.1	**/
              		:l_rev_req_qty,
              		:l_rev_cov_qty,
              /**		:l_inv_req_qty,				ver 2.1 **
              		:l_inv_cov_qty,				ver 2.1 **/
              :l_sam_blk_qty,
							:l_blk_for_sale;

				if ( SQLCODE != 0 )
        {
        	if ( SQLCODE == NO_DATA_FOUND )
          {
              EXEC SQL CLOSE pos_cursor;
              break;
          }
          else
          {
						fn_errlog( c_ServiceName, "S31060", SQLMSG, c_err_msg.arr  );	/** .arr added in VQC **/
        		Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );				/** .arr added in VQC **/
/**      		l_acnt_id = -1;
						Fadd32( ptr_fml_ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			**  Ver 1.1 : Commented ***/
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); /**  Ver 1.1 : Added ** .arr added in VQC **/
						EXEC SQL CLOSE  pos_cursor;
						tpfree ( ( char * )ptr_fml_obuf);
        		tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
          }
				}		

				if(DEBUG_MSG_LVL_3){
			/**	fn_userlog(c_ServiceName,"c_mtch_accnt_no :%s:",c_mtch_accnt_no);		** Commented in VQC **/
					fn_userlog(c_ServiceName,"st_usr_prfl.c_cln_mtch_accnt :%s:",st_usr_prfl.c_cln_mtch_accnt);	/** Added in VQC **/
					fn_userlog(c_ServiceName,"c_dp_id :%s:",c_dp_id);
					fn_userlog(c_ServiceName,"c_dp_clnt_id :%s:",c_dp_clnt_id);
				}

			/*****************************************************************
			
					We don't consider Invoke request and invoke cover qty while 
			calculating Qty pledge as these quantities are already moved 
			from tifp qty to block for sale by spot sell order.
			
			*****************************************************************/

        /**	l_qty_plg     =   l_tifp_qty    
                        - l_rev_req_qty - l_rev_cov_qty;		ver 2.1 **/
                        /* - l_inv_req_qty - l_inv_cov_qty; */

							/** l_qty_plg	= l_sam_blk_qty; *** Commented by Samip **/
							l_qty_plg	= l_sam_blk_qty - l_rev_req_qty - l_rev_cov_qty; /** Added by Samip **/

        l_tot_avl_qty =  l_tot_qty - l_qty_blckd ;

				/*** Ver 1.8 ** Starts ***/

        /** l_tot_blck_qty = l_rev_req_qty + l_rev_cov_qty+ l_inv_req_qty + l_inv_cov_qty ;	ver 2.1 **/

        /** l_free_qty = 	l_tifp_qty +	l_tot_blck_qty ; Commented in ver 2.1 ***/
			
					/** l_free_qty  = l_sam_blk_qty + l_tot_blck_qty; *** Added in ver 2.1 **/ /** Comment for Ver 2.4 **/
					l_free_qty  = l_qty_plg ;
					

	if(DEBUG_MSG_LVL_3){
        fn_userlog( c_ServiceName, "l_tot_blck_qty :%ld:", l_tot_blck_qty);
        fn_userlog( c_ServiceName, "l_free_qty  :%ld:", l_free_qty);
	}

				/*** Ver 1.8 ** Ends ***/


     /***   if(  (c_opt_typ == HOMEPAGE )  &&  ((l_plg_req_qty + l_qty_plg ) <= 0)  ) ** Commented in ver 2.1 **** Uncommented for Ver 2.4 ** Commented in Ver 2.5 ***/
				/** if(  (c_opt_typ == HOMEPAGE )  &&  (l_qty_plg <= 0)  ) ** Added in ver 2.1 **/ /** Commented for Ver 2.4 **/
        if(  (c_opt_typ == HOMEPAGE )  && (l_qty_plg+l_blk_for_sale) <= 0 )   /*** Added in Ver 2.5 ***/ 
        {
					fn_userlog( c_ServiceName, "skipping %s as total deposit is zero",c_stck_cd);
          continue;
        }
        else if ((c_opt_typ == DEPOSIT ) && (l_tot_avl_qty <= 0))
        {
          fn_userlog( c_ServiceName,"skipping %s as avilable quantity is zero",c_stck_cd);
          continue;
        }
	
				/******************** Get Pledge Rate from LTQ table ***********************/

				EXEC SQL
				SELECT		NVL(round(LTQ_PLG_RT,2),0)
				INTO			:d_plg_rt
				FROM			LTQ_TRD_QT
				WHERE			LTQ_STCK_CD	= :c_stck_cd
				AND				LTQ_XCHNG_CD= 'BSE'; /* ver 1.4 */
			
				if ( SQLCODE != 0 )
      	{
        	fn_errlog( c_ServiceName, "S31065", SQLMSG, c_err_msg.arr  );		/** .arr added in VQC **/
/**      	l_acnt_id = -1;			**  Ver 1.1 : Commented ***/

					if(SQLCODE == NO_DATA_FOUND)
          {
            fn_userlog( c_ServiceName,"Skipping %s as no Pledge rate in LTQ Table ",c_stck_cd);
            continue;
          }

        	Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );	/** .arr added in VQC **/
/**      	Fadd32( ptr_fml_ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			**  Ver 1.1 : Commented ***/
					fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  /*  Ver 1.1 : Added ** .arr added in VQC */
					EXEC SQL CLOSE  pos_cursor;
					tpfree ( ( char * )ptr_fml_obuf);
        	tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
      	}

				/********************** Get Haircut from stk mstr table ********************
				******* Commented in 1.6 Equity SAM changes ******************************	
				EXEC SQL
				SELECT	NVL(STK_PLG_HAIRCUT,0)
				INTO		:d_plg_haircut
				FROM		STK_STK_MSTR
				WHERE		STK_STCK_CD =:c_stck_cd;
	
				if ( SQLCODE != 0 )
        {
          fn_errlog( c_ServiceName, "S31070", SQLMSG, c_err_msg  );
**       l_acnt_id = -1;		**  Ver 1.1 : Commented ***
					
					if(SQLCODE == NO_DATA_FOUND)
          {
            fn_userlog( c_ServiceName,"Skipping %s as no Haircut found ",c_stck_cd);
            continue;
          }

          Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg, 0 );
**       Fadd32( ptr_fml_ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.1 : Commented ***
					fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );          ***  Ver 1.1 : Added ***
					EXEC SQL CLOSE  pos_cursor;
					tpfree ( ( char * )ptr_fml_obuf);
          tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
        }
				*************** Comment Ends ***********************************************/

				/** Ver 1.6 EQ SAM  Get haircut percentage  **/

        i_returncode = fn_get_haircut(c_ServiceName ,
                                 /**    c_mtch_accnt_no,										** Commented in VQC **/
                                        st_usr_prfl.c_cln_mtch_accnt,				/** Added in VQC **/
                                        c_stck_cd,
                                        &l_plg_haircut,
                                        c_err_msg.arr);		/** .arr added in VQC **/
        if ( SQLCODE != 0 )
        {
          fn_errlog( c_ServiceName, "S31075", LIBMSG, c_err_msg.arr  ); /** Changed SQLMSG to LIBMSG in VQC **/
          if(SQLCODE == NO_DATA_FOUND)
          {
            fn_userlog( c_ServiceName,"Skipping %s as no Haircut found ",c_stck_cd);
            continue;
          }

          Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );		/** .arr added in VQC **/
					fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  /*** Added in VQC ***/
          EXEC SQL CLOSE  pos_cursor;
          tpfree ( ( char * )ptr_fml_obuf);
          tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
        }

        /********** Ver 1.6 ends **********************/

				/*****************	VER 1.1 ADDITION BEGIN	*********************/
				l_plg = l_qty_plg + l_blk_for_sale;

				/*** l_tot_qty_dep = l_plg_req_qty	+ l_qty_plg + l_blk_for_sale; Commented in ver 2.1 ***/

				l_tot_qty_dep = l_qty_plg + l_blk_for_sale; /** Added in ver 2.1 **/
	
				d_sec_dep = (double) l_tot_qty_dep * d_plg_rt;
		
				d_sec_after_hc = d_sec_dep - ( d_sec_dep * l_plg_haircut / 100.00 ); 
	
																				/** Ver 1.6 d_plg_haircut changed to l_plg_haircut **/
				/**l_plg_haircut = (long)d_plg_haircut; ** V1.6*/

				d_plg_haircut = l_plg_haircut ; /*V1.6*/

				if(DEBUG_MSG_LVL_3){
	/**			fn_userlog( c_ServiceName,"c_mtch_accnt_no1:%s:" ,c_mtch_accnt_no );	** Commented in VQC **/
					fn_userlog( c_ServiceName,"st_usr_prfl.c_cln_mtch_accnt1:%s:" ,st_usr_prfl.c_cln_mtch_accnt );	/** Added in VQC **/
					fn_userlog( c_ServiceName,"l_qty_plg is   :%ld:", l_qty_plg );
					fn_userlog( c_ServiceName,"l_blk_for_sale :%ld:", l_blk_for_sale );
					fn_userlog( c_ServiceName,"l_plg_req_qty  :%ld:", l_plg_req_qty );		/**	ver 2.1** Uncommented in Ver 2.4 **/
					fn_userlog( c_ServiceName,"d_plg_rt       :%lf:", d_plg_rt );
					fn_userlog( c_ServiceName,"l_plg is       :%ld:", l_plg );
					fn_userlog( c_ServiceName,"l_tot_qty_dep  :%ld:", l_tot_qty_dep );
					fn_userlog( c_ServiceName,"d_sec_dep      :%lf:", d_sec_dep );
					fn_userlog( c_ServiceName,"d_sec_after_hc :%lf:", d_sec_after_hc );
					fn_userlog( c_ServiceName,"d_plg_haircut  :%lf:", d_plg_haircut );
					fn_userlog( c_ServiceName,"l_plg_haircut  :%ld:", l_plg_haircut );
					fn_userlog( c_ServiceName,"Space needed		:%ld:", Fneeded32( 1, l_bufferlength ) ); 
					fn_userlog( c_ServiceName,"Space Available:%ld:", Funused32( ptr_fml_obuf ) );
				}

				/*****************  VER 1.1 ADDITION ENDS   *********************/
			
				/*************** Allocate Memory and add to buffer ************************/

		
				if ( Fneeded32( 1, l_bufferlength ) > Funused32( ptr_fml_obuf ) ) 
				{
						i_counter++;

				/* Ver 1.3	starts  */
					
      			/*ptr_fml_obuf = ( FBFR32 *)tprealloc( (char *)ptr_fml_obuf,
                       		 (i_counter * MIN_FML_BUF_LEN * BUF_MULTIPLY)); */

						  ptr_fml_obuf = ( FBFR32 *)tprealloc( (char *)ptr_fml_obuf,
													 (Fsizeof32(ptr_fml_obuf) +(i_counter * MIN_FML_BUF_LEN )));  

						/* Ver 1.3 Ends */
				
      			if ( ptr_fml_obuf == NULL )
      			{
        				fn_errlog( c_ServiceName, "S31080", TPMSG, c_err_msg.arr  );  /*** .arr added in VQC ***/
        				EXEC SQL CLOSE	pos_cursor;
								fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr ); /*** Ver 1.1 : Added *** .arr added in VQC ***/
        				Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );  /*** .arr added in VQC ***/
        				tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
      			}
				}		


				/******************** Fill Output Buffer with Output  *********************/


	/***	i_err[0] =	Fadd32( ptr_fml_obuf	,FFO_EBA_MTCH_ACT_NO	,c_mtch_accnt_no				,0); ** Commented in VQC **/
				i_err[0] =	Fadd32( ptr_fml_obuf	,FFO_EBA_MTCH_ACT_NO	,st_usr_prfl.c_cln_mtch_accnt				,0);	/** Added in VQC **/
				i_ferr[0] = Ferror32;
				i_err[1] =	Fadd32( ptr_fml_obuf	,FFO_DP_CLNT_ID 			,c_dp_clnt_id						,0);
				i_ferr[1] = Ferror32;
				i_err[2] =	Fadd32( ptr_fml_obuf	,FFO_DPID 						,c_dp_id								,0);
				i_ferr[2] = Ferror32;
				i_err[3] =	Fadd32( ptr_fml_obuf	,FFO_STCK_CD  				,c_stck_cd							,0);
				i_ferr[3] = Ferror32;
		/*		i_err[4] =	Fadd32( ptr_fml_obuf	,FFO_PLG_REQ_QTY			,(char*)&l_plg_req_qty	,0); **	ver 2.1**/
				i_err[4] =	Fadd32( ptr_fml_obuf	,FFO_PLG_REQ_QTY			,(char*)&l_plg_req_qty	,0);
				i_ferr[4] = Ferror32;
				i_err[5] =	Fadd32( ptr_fml_obuf	,FFO_PLG_QTY		 			,(char*)&l_qty_plg			,0);
				i_ferr[5] = Ferror32;
				i_err[6] =	Fadd32( ptr_fml_obuf	,FFO_PLG_RT 		 			,(char*)&d_plg_rt				,0); 
		 		i_ferr[6] = Ferror32;		
				/*** i_err[7] =	Fadd32( ptr_fml_obuf	,FFO_HAIRCUT 		 			,(char*)&d_plg_haircut	,0); Commented In Ver 2.0 ***/
				i_err[7] =	Fadd32( ptr_fml_obuf	,FFO_HAIRCUT 		 			,(char*)&l_plg_haircut  ,0);   /*** Ver 2.0 ***/
				i_ferr[7] = Ferror32;
				i_err[8] =	Fadd32( ptr_fml_obuf	,FFO_PLG_BLOCK	 			,(char*)&l_blk_for_sale	,0);
				i_ferr[8] = Ferror32;
				i_err[9] =	Fadd32( ptr_fml_obuf	,FFO_AVL_QTY 	 				,(char*)&l_tot_avl_qty	,0);
				i_ferr[9] = Ferror32;
				/*************************	VER 1.1 ADDITION BEGIN		*******************************/
				i_err[10]	=	Fadd32( ptr_fml_obuf  ,FFO_NEW_QTY					,(char*)&l_plg					,0);
				i_ferr[10]=	Ferror32;
				i_err[11]	=	Fadd32( ptr_fml_obuf  ,FFO_TIFP_QTY					,(char*)&l_tot_qty_dep	,0);
				i_ferr[11]= Ferror32;
				i_err[12]	=	Fadd32( ptr_fml_obuf  ,FFO_TOTAL_PL					,(char*)&d_sec_dep			,0);
				i_ferr[12]= Ferror32;
				i_err[13]	=	Fadd32( ptr_fml_obuf  ,FFO_THRS_VAR_PRCNT		,(char*)&d_sec_after_hc	,0);
				i_ferr[13]=	Ferror32;
				i_err[14] = Fadd32( ptr_fml_obuf  ,FFO_HGH_PRC					,(char*)&l_plg_haircut  ,0);
        i_ferr[14]= Ferror32;				/*** Added for synchronization between DL & ASP w.r.t. FML type	***/
				/*************************  VER 1.1 ADDITION ENDS     *******************************/
        /*** Ver 1.8 ** Starts ***/ 
        i_err[15] = Fadd32( ptr_fml_obuf  ,FFO_ORD_TOT_QTY      ,(char*)&l_free_qty     ,0);
        i_ferr[15]= Ferror32;
        /*** Ver 1.8 ** Ends ***/

        for ( i_cnt=0; i_cnt < 16; i_cnt++ )    /*** Ver 1.8 ** Changed to 16 from 14 ***/
  			{
    			if ( i_err[ i_cnt ] == -1 )
    			{
      			fn_errlog( c_ServiceName, "S31085", Fstrerror32(i_ferr[i_cnt]), c_err_msg.arr  ); /** .arr added in VQC **/
      			Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );	/** .arr added in VQC **/
/**    			l_acnt_id = -1;
      			Fadd32( ptr_fml_ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.1 : Commented ***/
						fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );  /***  Ver 1.1 : Added ***//** .arr added in VQC **/
						EXEC SQL CLOSE  pos_cursor;
						tpfree ( ( char * )ptr_fml_obuf);	
      			tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
    			}
  			}	

		}/* while Loop */

       /** Ver 2.4 ** Starts ***/

        EXEC SQL
        SELECT NVL(CLM_PLG_MODE,'P')
        INTO   :c_plg_mode
        FROM   CLM_CLNT_MSTR
        WHERE  CLM_MTCH_ACCNT =:st_usr_prfl.c_cln_mtch_accnt;

	if ( SQLCODE != 0 )
        {
          fn_errlog( c_ServiceName, "S31090", SQLMSG, c_err_msg.arr  );
          Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
          tpfree ( ( char * )ptr_fml_obuf);
          tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
        }

        if ( c_plg_mode != 'P')
        {

/************************************************
          EXEC SQL
          SELECT  NVL(SUM(AMOUNT),0)  * This amount is sum of NSE,BSE and FNO Outstanding amount *
          INTO    :d_outstndg_amnt
          FROM
          (  **** Select NSE net amount *
          SELECT  SUM(decode (BDC_DB_CR_FLG,'D',BDC_BAL_AMNT ,-1 * BDC_BAL_AMNT))*100 AMOUNT
          FROM    BDC_BNK_DBCR,FAB_FO_ALC_BFT_SMRY,EAB_EQ_ALC_BFT_SMRY,ESM_XCHNG_SGMNT_MSTR
          WHERE   BDC_CLNT_MTCH_ACCNT = EAB_CLM_MTCH_ACCNT
          AND     EAB_CLM_MTCH_ACCNT  = FAB_CLM_MTCH_ACCNT
          AND     EAB_CLM_MTCH_ACCNT  = :st_usr_prfl.c_cln_mtch_accnt
          AND     BDC_XCHNG_CD        = ESM_XCHNG_CD
          AND     BDC_XCHNG_CD        = 'NSE'
          AND     BDC_SGMNT_CD        = ESM_SGMNT_CD
          AND     BDC_PRCCSD_FLG      != 'F'
          AND     BDC_BAL_AMNT        > 0
          AND     (nvl(EAB_PLG_AMT,0) <>0 OR nvl(FAB_PLG_AMT,0)<> 0)
          UNION ALL
	    *** Select BSE Net amount *
          SELECT  SUM(decode(BDC_DB_CR_FLG,'D',BDC_BAL_AMNT, -1 * BDC_BAL_AMNT))*100 AMOUNT
          FROM    BDC_BNK_DBCR,FAB_FO_ALC_BFT_SMRY,EAB_EQ_ALC_BFT_SMRY,ESM_XCHNG_SGMNT_MSTR
          WHERE   BDC_CLNT_MTCH_ACCNT = EAB_CLM_MTCH_ACCNT
          AND     EAB_CLM_MTCH_ACCNT  = FAB_CLM_MTCH_ACCNT
          AND     EAB_CLM_MTCH_ACCNT  = :st_usr_prfl.c_cln_mtch_accnt
          AND     BDC_XCHNG_CD        = ESM_XCHNG_CD
          AND     BDC_XCHNG_CD        = 'BSE'
          AND     BDC_SGMNT_CD        = ESM_SGMNT_CD
          AND     BDC_PRCCSD_FLG      != 'F'
          AND     BDC_BAL_AMNT        >  0
          AND     (nvl(EAB_PLG_AMT,0) <>0 OR nvl(FAB_PLG_AMT,0)<> 0)
          UNION ALL
         *** Select FNO Amount ***
          SELECT  NVL(-1 * SUM (FBD_DC_AMT- FBD_PI_PO_AMT-FBD_INT_ADJ_AMT),0) AMOUNT
          FROM   FBD_FO_BNK_DRCR , FAB_FO_ALC_BFT_SMRY,EAB_EQ_ALC_BFT_SMRY
          WHERE  FBD_PAYIN_DT <= trunc(sysdate)
          and    FAB_CLM_MTCH_ACCNT = EAB_CLM_MTCH_ACCNT
          and    FAB_CLM_MTCH_ACCNT = FBD_CLM_MTCH_ACCNT
          and    FAB_CLM_MTCH_ACCNT = :st_usr_prfl.c_cln_mtch_accnt
          and    FBD_CLM_MTCH_ACCNT not in
          (SELECT  FBM_CLM_MTCH_ACCNT FROM    FBM_FO_BNK_FLR_MSG WHERE   FBM_STTS = 'N' AND FBM_PRDCT_CD IS NULL )
          and    (FAB_PLG_AMT + EAB_PLG_AMT <> 0)
          and    FBD_DC_FLG = 'D'
          );

  	  if ( SQLCODE != 0 )
      {
         fn_errlog( c_ServiceName, "S31095", SQLMSG, c_err_msg.arr  );
         Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
         fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
         tpfree ( ( char * )ptr_fml_obuf);
         tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
      }

      EXEC SQL
      SELECT NVL(sum(DBD_BLOCK_FOR_SALE),0)
      INTO   :l_blok_for_sale
      FROM   DBD_DP_BLCK_DTLS
      WHERE  DBD_CLM_MTCH_ACCNT = :st_usr_prfl.c_cln_mtch_accnt ;

     if ( SQLCODE != 0 )
     {
       fn_errlog( c_ServiceName, "S31100", SQLMSG, c_err_msg.arr  );
       Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
       fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
       tpfree ( ( char * )ptr_fml_obuf);
       tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
     }

     if ( d_outstndg_amnt <= 0 && l_blok_for_sale == 0 )
     {
       c_mrgn_plg_allwd = 'Y';
     }
**********************************************************************/
      c_mrgn_plg_allwd = 'Y';
   }

   fn_userlog( c_ServiceName,"c_mrgn_plg_allwd:%c:", c_mrgn_plg_allwd);

   if((Fadd32(ptr_fml_obuf,FFO_PLG_TYP, (char *)&c_mrgn_plg_allwd, 0))==-1)
   {
    fn_userlog(c_ServiceName,"Error while adding plg_allwd flag to o/p buffer.");
    fn_errlog( c_ServiceName, "S31105", FMLMSG, c_err_msg.arr  );
    Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    tpfree ( ( char * )ptr_fml_obuf);
    tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
   }

	/** Ver 2.4 ** Ends ***/
    /***  Ver. 1.1 : Addition Starts  ***/
    if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg.arr ) == -1 )  /** .arr added in VQC **/
    {
      fn_errlog( c_ServiceName, "S31110", LIBMSG,c_err_msg.arr); /*** Chaged TPMSG to LIBMSG in VQC ***/
      fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );	/** .arr added in VQC **/
      Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );		/** .arr added in VQC **/
      tpfree ( ( char * )ptr_fml_obuf);
      tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
    }

    if(DEBUG_MSG_LVL_3){
      fn_userlog( c_ServiceName,"Service Completed Successfully");
    }
    /***  Ver. 1.1 : Addition Ends  ***/

		tpreturn( TPSUCCESS, 0, (char *)ptr_fml_obuf, 0 , 0 );

	}/* End if match A/c == * */

	
	/************************* There is Single Match Account ************************/

	if(DEBUG_MSG_LVL_3){
	/***	fn_userlog( c_ServiceName,"INSIDE SINGLE MATCH A/C		:%s:" ,c_mtch_accnt_no );	** Commented in VQC **/
		fn_userlog( c_ServiceName,"INSIDE SINGLE MATCH A/C		:%s:" ,st_usr_prfl.c_cln_mtch_accnt );	/** Added in VQC **/
		fn_userlog( c_ServiceName,"The flag set is :%c:" ,c_flag); /** ver 1.5 **/
	/***	fn_userlog( c_ServiceName, "c_mtch_accnt_no :%s:"   ,c_mtch_accnt_no);	*** Commented in VQC double printed ***/
    fn_userlog( c_ServiceName, "c_dp_clnt_id :%s:"        ,c_dp_clnt_id);
    fn_userlog( c_ServiceName, "c_dp_id :%s:"           ,c_dp_id);
		fn_userlog( c_ServiceName, "c_ip_stck_cd:%s:"        ,c_ip_stck_cd); /** ver 1.5 **/
	}

		if(DEBUG_MSG_LVL_0) /** ver 1.5 **/
    {
		if(c_flag == 'Y')    /** ver 1.5 **/
		{ 

		fn_userlog( c_ServiceName,"The Service is called for Auto-Refresh in Silverlight"); 
/**	fn_userlog( c_ServiceName,"INSIDE SINGLE MATCH A/C    :%s:" ,c_mtch_accnt_no );	** Commented in VQC **/
		fn_userlog( c_ServiceName,"INSIDE SINGLE MATCH A/C  :%s:" ,st_usr_prfl.c_cln_mtch_accnt ); /** Added in VQC **/
    fn_userlog( c_ServiceName,"The flag set is :%c:" ,c_flag);
/**	fn_userlog( c_ServiceName, "c_mtch_accnt_no :%s:"  ,c_mtch_accnt_no); ** Commented in VQC double printed **/
    fn_userlog( c_ServiceName, "c_dp_clnt_id :%s:"        ,c_dp_clnt_id);
    fn_userlog( c_ServiceName, "c_dp_id :%s:"           ,c_dp_id);
    fn_userlog( c_ServiceName, "c_ip_stck_cd:%s:"        ,c_ip_stck_cd);

		}
		}

		/**** Ver 1.8 Starts ****/

		EXEC SQL 
		SELECT 	nvl(FAB_PLG_AMT,0),
						nvl(FAB_NWB_AMT,0)
		INTO 		:sql_fab_plg_amt ,
						:sql_fab_nwb_amt	
		FROM FAB_FO_ALC_BFT_SMRY
/**	WHERE FAB_CLM_MTCH_ACCNT = :c_mtch_accnt_no;		** Commented in VQC **/
		WHERE FAB_CLM_MTCH_ACCNT = :st_usr_prfl.c_cln_mtch_accnt;		/** Added in VQC **/
	
	if(( SQLCODE !=0 ) && (SQLCODE != NO_DATA_FOUND))
  {
    fn_errlog( c_ServiceName, "S31115", SQLMSG, c_err_msg.arr  );		/** .arr added in VQC **/
    Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );					/** .arr added in VQC **/
		tpfree ( ( char * )ptr_fml_obuf);
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_ibuf, 0, 0 );
  }

	if(SQLCODE == NO_DATA_FOUND)
	{
		sql_fab_plg_amt = 0;
		sql_fab_nwb_amt = 0;
	}


	if(DEBUG_MSG_LVL_3){
		fn_userlog(c_ServiceName, "The value of plg is [%lf]",sql_fab_plg_amt);
	}


		/*****The following portion gets the Limits avaliable for the user***/

		memset(&st_gt_lmt,'\0' , sizeof( struct vw_gt_lmt_dtls) );
		strcpy(st_gt_lmt.c_xchng_cd , "NFO" );

		MEMSET(sql_nxt_trd_dt);

		EXEC SQL 
		SELECT EXG_NXT_TRD_DT 
		INTO :sql_nxt_trd_dt 
		FROM EXG_XCHNG_MSTR
		WHERE EXG_XCHNG_CD = 'NFO';

			if (SQLCODE != 0)
			{
				fn_errlog( c_ServiceName, "S31120", SQLMSG, c_err_msg.arr  );		/** .arr added in VQC **/
				Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );					/** .arr added in VQC **/
				tpfree ( ( char * )ptr_fml_obuf);
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_ibuf, 0, 0 );
			}
		
			SETNULL(sql_nxt_trd_dt);
	
			strcpy(st_gt_lmt.c_trd_dt, sql_nxt_trd_dt.arr );
	/**		strcpy(st_gt_lmt.c_cln_mtch_accnt, c_mtch_accnt_no);		** Commented in VQC **/
			strcpy(st_gt_lmt.c_cln_mtch_accnt, st_usr_prfl.c_cln_mtch_accnt);			/** Added in VQC **/
			l_ip_len = (long) sizeof ( struct vw_gt_lmt_dtls);
			st_gt_lmt.c_rqst_typ = LIMIT_X;
			fn_cpy_ddr ( st_gt_lmt.c_rout_crt );

      /*** Commented in Ver 2.2 *****************************************************
			i_returncode = fn_call_svc( c_ServiceName, c_err_msg, &st_gt_lmt, &st_gt_lmt,
																		"vw_gt_lmt_dtls", "vw_gt_lmt_dtls", l_ip_len,
																		l_ip_len, 0, "SFO_GET_LIMITS" );

			if ( i_returncode == -1 )
			{
				fn_errlog( c_ServiceName, "S31125", LIBMSG, c_err_msg );
				fn_userlog(c_ServiceName,"SFO_GET_LIMITS FAIL  ");
				Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg, 0 );
				Fadd32( ptr_fml_ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
				tpfree ( ( char * )ptr_fml_obuf);
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_ibuf, 0, 0 );
			}
      *************** Ver 2.2 *******************************************************/

      /**** Ver 2.2 Starts Here ****/
      i_returncode = fo_get_trd_limit(c_ServiceName,
                                    st_gt_lmt.c_cln_mtch_accnt,
                                    st_gt_lmt.c_trd_dt,
                                    st_gt_lmt.c_rqst_typ,
                                    st_gt_lmt.c_xchng_cd,
                                    st_gt_lmt.l_gid,
                                    &st_gt_lmt.d_amt,
                                    c_err_msg.arr				/** .arr added in VQC **/
                                    );
      if ( i_returncode != SUCC_BFR  )
      {
        fn_errlog( c_ServiceName, "S31130", LIBMSG, c_err_msg.arr  ); /** Changed SQLMSG to LIBMSG in VQC **/
        Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );				/** .arr added in VQC **/
        tpfree ( ( char * )ptr_fml_obuf);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_ibuf, 0, 0 );
      }
      /**** Ver 2.2 Ends Here ****/


			if(DEBUG_MSG_LVL_3){
				fn_userlog( c_ServiceName,"NFO Limit Calculated :%lf:",st_gt_lmt.d_amt); 
			}

			d_nfo_limit = st_gt_lmt.d_amt;

      memset(&st_gt_lmt,'\0' , sizeof( struct vw_gt_lmt_dtls) );
      strcpy(st_gt_lmt.c_xchng_cd , "BFO" );

      MEMSET(sql_nxt_trd_dt);

      EXEC SQL
      SELECT EXG_NXT_TRD_DT
      INTO :sql_nxt_trd_dt
      FROM EXG_XCHNG_MSTR
      WHERE EXG_XCHNG_CD = 'BFO';

      if (SQLCODE != 0)
      {
        fn_errlog( c_ServiceName, "S31135", SQLMSG, c_err_msg.arr  );		/** .arr added in VQC **/
        Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );					/** .arr added in VQC **/
        tpfree ( ( char * )ptr_fml_obuf);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_ibuf, 0, 0 );
      }

      SETNULL(sql_nxt_trd_dt);

      strcpy(st_gt_lmt.c_trd_dt, sql_nxt_trd_dt.arr );
  /**  strcpy(st_gt_lmt.c_cln_mtch_accnt, c_mtch_accnt_no);		** Commented in VQC **/
      strcpy(st_gt_lmt.c_cln_mtch_accnt, st_usr_prfl.c_cln_mtch_accnt);		/** Added in VQC **/
      l_ip_len = (long) sizeof ( struct vw_gt_lmt_dtls);
      st_gt_lmt.c_rqst_typ = LIMIT_X;
      fn_cpy_ddr ( st_gt_lmt.c_rout_crt );

      /******* Commented in Ver 2.2 Starts Here ************************************
      i_returncode = fn_call_svc( c_ServiceName, c_err_msg, &st_gt_lmt, &st_gt_lmt,
                                    "vw_gt_lmt_dtls", "vw_gt_lmt_dtls", l_ip_len,
                                    l_ip_len, 0, "SFO_GET_LIMITS" );

      if ( i_returncode == -1 )
      {
        fn_errlog( c_ServiceName, "S31140", LIBMSG, c_err_msg );
        fn_userlog(c_ServiceName,"SFO_GET_LIMITS FAIL  ");
        Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_ibuf, FFO_PLG_ORDR_RFRNC ,c_null_msg, 0 );
        tpfree ( ( char * )ptr_fml_obuf);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_ibuf, 0, 0 );
      }
      ********** Ver 2.2 Ends here ************************************************/

      /**** Ver 2.2 Starts Here ***************************/
      i_returncode = fo_get_trd_limit(c_ServiceName,
                                    st_gt_lmt.c_cln_mtch_accnt,
                                    st_gt_lmt.c_trd_dt,
                                    st_gt_lmt.c_rqst_typ,
                                    st_gt_lmt.c_xchng_cd,
                                    st_gt_lmt.l_gid,
                                    &st_gt_lmt.d_amt,
                                    c_err_msg.arr			/** .arr added in VQC **/
                                    );
      if ( i_returncode != SUCC_BFR  )
      {
        fn_errlog( c_ServiceName, "S31145", LIBMSG, c_err_msg.arr  ); /** Changed SQLMSG to LIBMSG in VQC **/
        Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );				/** .arr added in VQC **/
        tpfree ( ( char * )ptr_fml_obuf);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_ibuf, 0, 0 );
      }
      /*********** Ver 2.2 Ends Here **************/

			d_bfo_limit = st_gt_lmt.d_amt;

			d_net_fno_limit =  MIN(d_nfo_limit,d_bfo_limit);

      if(DEBUG_MSG_LVL_3){
        fn_userlog( c_ServiceName,"BFO Limit Calculated :%lf:",st_gt_lmt.d_amt);
        fn_userlog( c_ServiceName,"Net FNO limit        :%lf:",d_net_fno_limit);
      }

	 		/** check if limit is available for withdrawal **/
			/** calculate the free sam limit available to withdraw **/
			/** Free SAM limit is Net withdrawable balance + min(fno limit , fno sam allocation) + equity sam limit **/

			i_returncode = fn_get_eqsam_limit ( c_ServiceName,
                                /**       c_mtch_accnt_no,						** Commented in VQC **/
                                          st_usr_prfl.c_cln_mtch_accnt,	/** Added in VQC **/
                                          &d_eq_sam_limit,
                                /***      c_usr_id,										*** Commented in VQC ***/
                                          st_usr_prfl.c_user_id,			/** Added in VQC ***/
                                /***      li_sssn_id,									*** Commented in VQC ***/
                                          st_usr_prfl.l_session_id,		/** Added in VQC ***/
                                          c_err_msg.arr								/** .arr added in VQC **/
                                        );

			if(i_returncode == -1)
      {
				fn_errlog( c_ServiceName, "S31150", LIBMSG, c_err_msg.arr  );		/** .arr added in VQC **/
				Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );					/** .arr added in VQC **/
				tpfree ( ( char * )ptr_fml_obuf);
				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_ibuf, 0, 0 );
      }

      /***** Ver 3.0 Starts *****/

      EXEC SQL
      SELECT  nvl(CAB_PLG_AMT,0)*100
      INTO    :d_cab_cdx_plg_amt
      FROM    CAB_CDX_ALC_BFT_SMRY
      WHERE   CAB_CLM_MTCH_ACCNT = :st_usr_prfl.c_cln_mtch_accnt;  

      if(( SQLCODE !=0 ) && (SQLCODE != NO_DATA_FOUND))
      {
        fn_errlog( c_ServiceName, "S31155", SQLMSG, c_err_msg.arr  );   
        Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );         
        tpfree ( ( char * )ptr_fml_obuf);
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_ibuf, 0, 0 );
      }

      if(SQLCODE == NO_DATA_FOUND)
      {
        d_cab_cdx_plg_amt = 0;
      }

      if(DEBUG_MSG_LVL_3)
      {
        fn_userlog(c_ServiceName, "The value of plg is [%lf]",d_cab_cdx_plg_amt);
      }

       memset(&st_gt_lmt,'\0' , sizeof( struct vw_gt_lmt_dtls) );
       strcpy(st_gt_lmt.c_xchng_cd , "NDX" );

       MEMSET(sql_nxt_trd_dt);

       EXEC SQL
       SELECT EXG_NXT_TRD_DT
       INTO :sql_nxt_trd_dt
       FROM EXG_XCHNG_MSTR
       WHERE EXG_XCHNG_CD = 'NDX';

       if (SQLCODE != 0)
       {
         fn_errlog( c_ServiceName, "S31160", SQLMSG, c_err_msg.arr  );   
         Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );          
         tpfree ( ( char * )ptr_fml_obuf);
         tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_ibuf, 0, 0 );
       }

       SETNULL(sql_nxt_trd_dt);

       strcpy(st_gt_lmt.c_trd_dt, sql_nxt_trd_dt.arr );
       strcpy(st_gt_lmt.c_cln_mtch_accnt, st_usr_prfl.c_cln_mtch_accnt);
       l_ip_len = (long) sizeof ( struct vw_gt_lmt_dtls);
       fn_cpy_ddr ( st_gt_lmt.c_rout_crt );
       st_gt_lmt.l_gid =1;
 
       i_returncode = fn_cdx_get_trd_limit(c_ServiceName,
                                    st_gt_lmt.c_cln_mtch_accnt,
                                    st_gt_lmt.c_trd_dt,
                                    st_gt_lmt.c_xchng_cd,
                                    st_gt_lmt.l_gid,
                                    &st_gt_lmt.d_amt,
                                    c_err_msg.arr
                                    );

       if ( i_returncode != SUCC_BFR  )
       {
         fn_errlog( c_ServiceName, "S31165", LIBMSG, c_err_msg.arr  ); 
         Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );        
         tpfree ( ( char * )ptr_fml_obuf);
         tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_ibuf, 0, 0 );
       } 

       if(DEBUG_MSG_LVL_3)
       {
         fn_userlog( c_ServiceName,"NDX Limit Calculated :%lf:",st_gt_lmt.d_amt);
       }

       d_cdx_limit = st_gt_lmt.d_amt*100;

       EXEC SQL
       SELECT  nvl(CAB_PLG_AMT,0)
       INTO    :d_cab_cod_plg_amt 
       FROM    CAB_COD_ALC_BFT_SMRY
       WHERE   CAB_CLM_MTCH_ACCNT = :st_usr_prfl.c_cln_mtch_accnt;  

       if(( SQLCODE !=0 ) && (SQLCODE != NO_DATA_FOUND))
       {
         fn_errlog( c_ServiceName, "S31170", SQLMSG, c_err_msg.arr  );   
         Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );         
         tpfree ( ( char * )ptr_fml_obuf);
         tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_ibuf, 0, 0 );
       }

       if(SQLCODE == NO_DATA_FOUND)
       {
         d_cab_cod_plg_amt  = 0;
       }

       if(DEBUG_MSG_LVL_3)
       {
         fn_userlog(c_ServiceName, "The value of plg is [%lf]",d_cab_cod_plg_amt );
       }

       memset(&st_gt_lmt,'\0' , sizeof( struct vw_gt_lmt_dtls) );
       strcpy(st_gt_lmt.c_xchng_cd , "MCO" );

       MEMSET(sql_nxt_trd_dt);

       EXEC SQL
       SELECT EXG_NXT_TRD_DT
       INTO :sql_nxt_trd_dt
       FROM EXG_XCHNG_MSTR
       WHERE EXG_XCHNG_CD = 'MCO';

       if (SQLCODE != 0)
       {
         fn_errlog( c_ServiceName, "S31175", SQLMSG, c_err_msg.arr  );   
         Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );          
         tpfree ( ( char * )ptr_fml_obuf);
         tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_ibuf, 0, 0 );
       }

       SETNULL(sql_nxt_trd_dt);

       strcpy(st_gt_lmt.c_trd_dt, sql_nxt_trd_dt.arr );
       strcpy(st_gt_lmt.c_cln_mtch_accnt, st_usr_prfl.c_cln_mtch_accnt);
       l_ip_len = (long) sizeof ( struct vw_gt_lmt_dtls);
       st_gt_lmt.c_rqst_typ = LIMIT_X;
       fn_cpy_ddr ( st_gt_lmt.c_rout_crt );
 
       i_returncode = fo_cod_get_trd_limit(c_ServiceName,
                                    st_gt_lmt.c_cln_mtch_accnt,
                                    st_gt_lmt.c_trd_dt,
                                    st_gt_lmt.c_rqst_typ,
                                    st_gt_lmt.c_xchng_cd,
                                    st_gt_lmt.l_gid,
                                    &st_gt_lmt.d_amt,
                                    c_err_msg.arr
                                    );

       if ( i_returncode != SUCC_BFR  )
       {
         fn_errlog( c_ServiceName, "S31180", LIBMSG, c_err_msg.arr  ); 
         Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );        
         tpfree ( ( char * )ptr_fml_obuf);
         tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_ibuf, 0, 0 );
       } 

       if(DEBUG_MSG_LVL_3)
       {
         fn_userlog( c_ServiceName,"MCO Limit Calculated :%lf:",st_gt_lmt.d_amt);
       }

       d_mco_limit = st_gt_lmt.d_amt;

      if(DEBUG_MSG_LVL_3)
      {
        fn_userlog(c_ServiceName,"d_cash_lmt      = :%lf:",d_eq_sam_limit);
        fn_userlog(c_ServiceName,"d_net_fno_limit = :%lf:",d_net_fno_limit);
        fn_userlog(c_ServiceName,"sql_fab_plg_amt = :%lf:",sql_fab_plg_amt);
        fn_userlog(c_ServiceName,"sql_fab_nwb_amt = :%lf:",sql_fab_nwb_amt);
        fn_userlog(c_ServiceName,"d_cab_cdx_plg_amt = :%lf:", d_cab_cdx_plg_amt); 
        fn_userlog(c_ServiceName,"d_cab_cod_plg_amt = :%lf:", d_cab_cod_plg_amt);
        fn_userlog(c_ServiceName,"d_cdx_limit = :%lf:", d_cdx_limit); 
        fn_userlog(c_ServiceName,"d_mco_limit = :%lf:", d_mco_limit);
        fn_userlog(c_ServiceName,"d_free_sam_limit= :%lf:",d_free_sam_limit);
      }

     fn_userlog(c_ServiceName,"d_mco_limit = :%lf:", d_mco_limit); 


     d_fab_min_lmt = MIN(sql_fab_plg_amt , d_net_fno_limit );
     d_cdx_min_lmt = MIN(d_cab_cdx_plg_amt,d_cdx_limit);
     d_mco_min_lmt = MIN(d_cab_cod_plg_amt,d_mco_limit);

     d_free_sam_limit = sql_fab_nwb_amt + d_eq_sam_limit + d_fab_min_lmt + d_cdx_min_lmt + d_mco_min_lmt;

      /** d_free_sam_limit =  sql_fab_nwb_amt + d_eq_sam_limit + MIN(sql_fab_plg_amt , d_net_fno_limit ) 
                                                            + MIN(d_cab_cdx_plg_amt,d_cdx_limit)
                                                            + MIN(d_cab_cod_plg_amt,d_mco_limit) ;  **/

 /**      d_free_sam_limit =  sql_fab_nwb_amt + d_eq_sam_limit + MIN(sql_fab_plg_amt , d_net_fno_limit ) + MIN(d_cab_cdx_plg_amt,d_cdx_limit) + MIN(d_cab_cod_plg_amt,d_mco_limit) ; **/



      /***** Ver 3.0 Ends ***/			

    	/**		d_free_sam_limit = 	sql_fab_nwb_amt + d_eq_sam_limit + MIN(sql_fab_plg_amt , d_net_fno_limit ) ; ** Ver 3.0 **/ 

			if(DEBUG_MSG_LVL_3)
      {
        fn_userlog(c_ServiceName,"d_cash_lmt 			= :%lf:",d_eq_sam_limit);
        fn_userlog(c_ServiceName,"d_net_fno_limit = :%lf:",d_net_fno_limit);
        fn_userlog(c_ServiceName,"sql_fab_plg_amt = :%lf:",sql_fab_plg_amt); 
        fn_userlog(c_ServiceName,"sql_fab_nwb_amt = :%lf:",sql_fab_nwb_amt);
        fn_userlog(c_ServiceName,"d_cab_cdx_plg_amt = :%lf:", d_cab_cdx_plg_amt); /** Ver  3.0 **/
        fn_userlog(c_ServiceName,"d_cab_cod_plg_amt = :%lf:", d_cab_cod_plg_amt); /** Ver  3.0 **/
        fn_userlog(c_ServiceName,"d_cdx_limit = :%lf:", d_cdx_limit); /** Ver  3.0 **/
        fn_userlog(c_ServiceName,"d_mco_limit = :%lf:", d_mco_limit); /** Ver  3.0 **/
        fn_userlog(c_ServiceName,"d_free_sam_limit= :%lf:",d_free_sam_limit);
      }


	/**** Ver 1.8 Ends ****/
	
   EXEC SQL
   DECLARE sys_cursor CURSOR FOR
   SELECT  DBD_STCK_CD,
           NVL(DBD_TOT_QTY     ,0),
           NVL(DBD_QTY_BLCKD   ,0),
             		NVL(DBD_PLG_REQ_QTY ,0),			/**	Commented in ver 2.1 ** Uncommented in Ver 2.4 **/
           /**	NVL(DBD_TIFP_QTY    ,0),				Commented in ver 2.1 */
           			NVL(DBD_REV_REQ_QTY ,0),
           			NVL(DBD_REV_COV_QTY ,0),
           /**			NVL(DBD_INV_REQ_QTY ,0),				Commented in ver 2.1
           			NVL(DBD_INV_COV_QTY ,0),				Commented in ver 2.1*/
					 NVL(DBD_SAM_BLCKD_QTY,0),
           NVL(DBD_BLOCK_FOR_SALE,0)
    FROM   DBD_DP_BLCK_DTLS
  /**  WHERE  DBD_CLM_MTCH_ACCNT 	=	:c_mtch_accnt_no							** Commented in VQC **/
    WHERE  DBD_CLM_MTCH_ACCNT 	=	:st_usr_prfl.c_cln_mtch_accnt		/** Added in VQC **/
    AND		 DBD_DP_ID  					=	:c_dp_id
    AND 	 DBD_DP_CLNT_ID  			=	:c_dp_clnt_id
		AND TRIM(DBD_STCK_CD) = DECODE(:c_flag,'Y',TRIM(:c_ip_stck_cd),TRIM(DBD_STCK_CD))  /** ver 1.5 **//* Ver 1.7 -Trim addded */ /*** TRIM added for Ver 2.1 ***/
		ORDER BY DBD_STCK_CD;

    EXEC SQL OPEN sys_cursor;	

		if ( SQLCODE != 0 )
    {
       fn_errlog( c_ServiceName, "S31185", SQLMSG, c_err_msg.arr );		/** .arr added in VQC **/
       EXEC SQL CLOSE sys_cursor;

       Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );					/** .arr added in VQC **/
/**    l_acnt_id = -1;

       if(SQLCODE == NO_DATA_FOUND)
         l_acnt_id = 1;

       Fadd32( ptr_fml_ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.1 : Commented ***/
			 tpfree ( ( char * )ptr_fml_obuf);
       tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
    }	

		i_counter = 1;

    while(1)
    {
        EXEC SQL FETCH sys_cursor
        INTO  :c_stck_cd,
              :l_tot_qty,
              :l_qty_blckd,
             	:l_plg_req_qty,		/** ver 2.1	** Uncommented in Ver 2.4 **/
              /**	:l_tifp_qty,			ver 2.1 **/
              		:l_rev_req_qty,
              		:l_rev_cov_qty,
              /**		:l_inv_req_qty,		ver 2.1 **
              		:l_inv_cov_qty,		ver 2.1 **/
							:l_sam_blk_qty,
              :l_blk_for_sale;

        if ( SQLCODE != 0 )
        {
          if ( SQLCODE == NO_DATA_FOUND )
          {
              EXEC SQL CLOSE sys_cursor;
              break;
          }
					else
          {
            fn_errlog( c_ServiceName, "S31190", SQLMSG, c_err_msg.arr  );	/** .arr added in VQC **/
            Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );				/** .arr added in VQC **/
/**         l_acnt_id = -1;
            Fadd32( ptr_fml_ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );			**  Ver 1.1 : Commented ***/
            EXEC SQL CLOSE  sys_cursor;
            tpfree ( ( char * )ptr_fml_obuf);
            tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
          }
				}

				if(DEBUG_MSG_LVL_3){
			/**	fn_userlog( c_ServiceName, "MATCH A/C    		:%s: ", c_mtch_accnt_no );		** Commented in VQC **/
					fn_userlog( c_ServiceName, "MATCH A/C  	:%s: ", st_usr_prfl.c_cln_mtch_accnt );	/** Added in VQC **/
					fn_userlog( c_ServiceName, "c_stck_cd				:%s: ", c_stck_cd );
					fn_userlog( c_ServiceName, "l_tot_qty 			:%ld:", l_tot_qty );
          fn_userlog( c_ServiceName, "l_qty_blckd  		:%ld:", l_qty_blckd );
         /**	 fn_userlog( c_ServiceName, "l_tifp_qty  		:%ld:", l_tifp_qty );				ver 2.1 **
          		 fn_userlog( c_ServiceName, "l_rev_req_qty  	:%ld:", l_rev_req_qty );	ver 2.1 **
         			 fn_userlog( c_ServiceName, "l_rev_cov_qty  	:%ld:", l_rev_cov_qty );	ver 2.1 **
          		 fn_userlog( c_ServiceName, "l_inv_req_qty  	:%ld:", l_inv_req_qty );	ver 2.1 **
          		 fn_userlog( c_ServiceName, "l_inv_cov_qty  	:%ld:", l_inv_cov_qty );	ver 2.1 **/
  			}


			/*****************************************************************
			
					We don't consider Invoke request and invoke cover qty while 
			calculating Qty pledge as these quantities are already moved 
			from tifp qty to block for sale by spot sell order.
			
			*****************************************************************/
				
		/**		l_qty_plg     =   l_tifp_qty    
                        - l_rev_req_qty - l_rev_cov_qty;				ver 2.1 **/
                        /*- l_inv_req_qty - l_inv_cov_qty;*/

						/** l_qty_plg	= l_sam_blk_qty;  **/
						l_qty_plg	= l_sam_blk_qty - l_rev_req_qty - l_rev_cov_qty;  /** By Samip **/

        l_tot_avl_qty =  l_tot_qty       - l_qty_blckd;

				/*** Ver 1.8 ** Starts ***/
				
				/** l_tot_blck_qty =l_rev_req_qty + l_rev_cov_qty + l_inv_req_qty + l_inv_cov_qty ; 		ver 2.1 **/

				/** l_free_qty = l_tifp_qty	+ l_tot_blck_qty ; Commented in ver 2.1 **/
			
					 /** l_free_qty  = l_sam_blk_qty + l_tot_blck_qty ; ** added in ver 2.1 **//** Comment for Ver 2.4 **/
					 l_free_qty  = l_qty_plg ; /** added in ver 2.4 **/



		if(DEBUG_MSG_LVL_3){
				fn_userlog( c_ServiceName, "l_tot_blck_qty :%ld:", l_tot_blck_qty);
				fn_userlog( c_ServiceName, "l_free_qty	:%ld:", l_free_qty);		 
				fn_userlog( c_ServiceName, "l_plg_req_qty	:%ld:", l_plg_req_qty);		 
				fn_userlog( c_ServiceName, "l_qty_plg	:%ld:", l_qty_plg);		 
				fn_userlog( c_ServiceName, "l_blk_for_sale	:%ld:", l_blk_for_sale);		 
		}

				/*** Ver 1.8 ** Ends ***/
				
			/***	if((c_opt_typ == HOMEPAGE) && ((l_plg_req_qty + l_qty_plg + l_blk_for_sale) <= 0)) * Commented in ver 2.1 **** Uncommented for Ver 2.4 ** Commented in Ver 2.5 ***/
				/** if((c_opt_typ == HOMEPAGE) && ((l_qty_plg + l_blk_for_sale) <= 0)) ** added in ver 2.1 **/ /** Commented for Ver 2.4 **/
        if((c_opt_typ == HOMEPAGE) && (l_qty_plg + l_blk_for_sale ) <= 0 ) /*** Added in Ver 2.5 ***/
				{
							fn_userlog( c_ServiceName, "skipping %s as total deposit is zero",c_stck_cd);
							continue;
				}
				else if ((c_opt_typ == DEPOSIT) && (l_tot_avl_qty <= 0))
				{
							fn_userlog( c_ServiceName, "skipping %s as avilable quantity is zero",c_stck_cd);
							continue;
				}

				/****************** Get Haircut from stk mstr table *****************
				*************** Ve 1.6 *** Commented *****************
        EXEC SQL
        SELECT  NVL(STK_PLG_HAIRCUT,0)
        INTO    :d_plg_haircut
        FROM    STK_STK_MSTR
        WHERE   STK_STCK_CD =:c_stck_cd;

        if ( SQLCODE != 0 )
        {
**       l_acnt_id = -1;		**  Ver 1.1 : Commented ***

					if(SQLCODE == NO_DATA_FOUND)
					{
     				fn_userlog( c_ServiceName,"Skipping Stock %s as no haircut found ",c_stck_cd);
						continue;	
					}
          fn_errlog( c_ServiceName, "S31195", SQLMSG, c_err_msg  );
          Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg, 0 );
**       Fadd32( ptr_fml_ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.1 : Commented ***
          EXEC SQL CLOSE  sys_cursor;
          tpfree ( ( char * )ptr_fml_obuf);
          tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
        }
				************** Comment 1.6 ends ***********************/

        /** Ver 1.6 EQ SAM  Get haircut percentage  **/

        i_returncode = fn_get_haircut(c_ServiceName ,
                                   /**  c_mtch_accnt_no,								** Commented in VQC **/
                                        st_usr_prfl.c_cln_mtch_accnt,		/** Added in VQC **/
                                        c_stck_cd,
                                        &l_plg_haircut,
                                        c_err_msg.arr);			/** .arr added in VQC **/
        if ( SQLCODE != 0 )
        {
          fn_errlog( c_ServiceName, "S31200", LIBMSG, c_err_msg.arr ); /** Changed SQLMSG to LIBMSG in VQC **/
          if(SQLCODE == NO_DATA_FOUND)
          {
            fn_userlog( c_ServiceName,"Skipping %s as no Haircut found ",c_stck_cd);
            continue;
          }

          Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );		/** .arr added in VQC **/
          /*** EXEC SQL CLOSE  pos_cursor; *** Commented in VQC ***/
					EXEC SQL CLOSE  sys_cursor;			 /*** Added in VQC ***/
          tpfree ( ( char * )ptr_fml_obuf);
          tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
        }

        /********** Ver 1.6 ends **********************/

				/****************** Get Pledge Rate from LTQ table *****************/

        EXEC SQL
        SELECT    NVL(LTQ_PLG_RT,0)
        INTO      :d_plg_rt
        FROM      LTQ_TRD_QT
        WHERE     LTQ_STCK_CD = :c_stck_cd
        AND       LTQ_XCHNG_CD= 'BSE'; /* ver 1.4 */

        if ( SQLCODE != 0 )
        {
/**       l_acnt_id = -1;			**  Ver 1.1 : Commented ***/
					if(SQLCODE == NO_DATA_FOUND)
					{
     				fn_userlog( c_ServiceName,"Skipping %s as no pledge Rate Found",c_stck_cd);
						continue;	
					}

          fn_errlog( c_ServiceName, "S31205", SQLMSG, c_err_msg.arr  );		/** .arr added in VQC **/
          Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );					/** .arr added in VQC **/
/**       Fadd32( ptr_fml_ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.1 : Commented ***/
          EXEC SQL CLOSE  sys_cursor;
          tpfree ( ( char * )ptr_fml_obuf);
          tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
        }

        /*****************  VER 1.1 ADDITION BEGIN  *********************/
        l_plg = l_qty_plg + l_blk_for_sale;
        /*** l_tot_qty_dep = l_plg_req_qty + l_qty_plg + l_blk_for_sale; Commented in ver 2.1 **/
				
				 l_tot_qty_dep = l_qty_plg + l_blk_for_sale ; /** Added in ver 2.1 ****/ 
		
        d_sec_dep = (double)l_tot_qty_dep * d_plg_rt;
        d_sec_after_hc = d_sec_dep - ( d_sec_dep * l_plg_haircut / 100.00 );/* V1.6 d_plg_haircut to l_plg_haircut */
				/**l_plg_haircut = d_plg_haircut; ** Ver 1.6*/
				d_plg_haircut = l_plg_haircut ; /*V1.6*/


				/*** Ver 1.8 Starts ***/

				sql_free_qty_val = (l_free_qty * (d_plg_rt *(1 - ((double)(l_plg_haircut)/100))))*100; 

				if((long long)(sql_free_qty_val * 100)%100 > 50)
				{
					sql_free_qty_val = sql_free_qty_val + 1.0;

					if(DEBUG_MSG_LVL_3){
						fn_userlog( c_ServiceName, "The rounded off amount for qty is [%lf]",sql_free_qty_val);
					}
				}
					
				l_free_qty_val = (long long) sql_free_qty_val;
				sql_free_qty_val = (double) l_free_qty_val;
		
				if(DEBUG_MSG_LVL_0){
					fn_userlog(c_ServiceName,"The withdraw val before limit is [%ld] for rate [%lf]",l_free_qty_val,d_plg_rt);
					fn_userlog(c_ServiceName,"The d_free_sam_limit is [%lf] ",d_free_sam_limit);	/*** Added for Ver 1.9 ***/
				}


				if(d_free_sam_limit < sql_free_qty_val)
				{
						if(DEBUG_MSG_LVL_0){
						fn_userlog(c_ServiceName,"Inside d_free_sam_limit condition");
						}
	
						/*** Added for Ver 1.9 ***/	
						if(l_plg_haircut == 100)
							l_free_qty = (long)(d_free_sam_limit/100) / (d_plg_rt);
						else
						/*** End for Ver 1.9 ***/
							l_free_qty = (long)(d_free_sam_limit/100) / (d_plg_rt * (1 - (double)(l_plg_haircut)/100));

            /*** Added for Ver 1.9 ***/
						if(l_free_qty < 0)
							l_free_qty = 0;
            /*** Added for Ver 1.9 ***/

						sql_free_qty_val = (l_free_qty * (d_plg_rt *(1 - ((double)(l_plg_haircut)/100))))*100;

        		if((long long)(sql_free_qty_val * 100)%100 > 50)
        		{
          		sql_free_qty_val = sql_free_qty_val + 1.0;

          		if(DEBUG_MSG_LVL_3){
            			fn_userlog( c_ServiceName, "The rounded off amount for qty is [%lf]",sql_free_qty_val);
          		}
        		}

        		l_free_qty_val = (long long) sql_free_qty_val;
        		sql_free_qty_val = (double) l_free_qty_val;	

						if(DEBUG_MSG_LVL_0){
						fn_userlog(c_ServiceName," sql_free_qty_val === :%lf:",sql_free_qty_val);
						}
				}

				if(DEBUG_MSG_LVL_0){
					fn_userlog(c_ServiceName,"The withdraw val after limit is [%ld] for rate [%lf]",l_free_qty_val,d_plg_rt);
					fn_userlog(c_ServiceName,"Free qty available after limit is [%ld]",l_free_qty);
				}


				/*** Ver 1.8 Ends ***/

				if(DEBUG_MSG_LVL_3){
	/**			fn_userlog( c_ServiceName,"c_mtch_accnt_no2:%s:", c_mtch_accnt_no );	** Commented in VQC **/	
					fn_userlog( c_ServiceName,"st_usr_prfl.c_cln_mtch_accnt2 :%s:", st_usr_prfl.c_cln_mtch_accnt );	/** Added in VQC **/
					fn_userlog( c_ServiceName,"l_qty_plg is 	:%ld:", l_qty_plg );
					fn_userlog( c_ServiceName,"l_blk_for_sale :%ld:", l_blk_for_sale );
					
					fn_userlog( c_ServiceName,"l_plg_req_qty	:%ld:", l_plg_req_qty ); /** Commented in ver 2.1 ** Uncommented in Ver 2.4 **/
					
					fn_userlog( c_ServiceName,"d_plg_rt				:%lf:", d_plg_rt );
        	fn_userlog( c_ServiceName,"l_plg is       :%ld:", l_plg );
        	fn_userlog( c_ServiceName,"l_tot_qty_dep	:%ld:", l_tot_qty_dep );
        	fn_userlog( c_ServiceName,"d_sec_dep      :%lf:", d_sec_dep );
        	fn_userlog( c_ServiceName,"d_sec_after_hc	:%lf:", d_sec_after_hc );
					fn_userlog( c_ServiceName,"d_plg_haircut	:%lf:", d_plg_haircut );
					fn_userlog( c_ServiceName,"l_plg_haircut  :%ld:", l_plg_haircut );
       }

        /*****************  VER 1.1 ADDITION ENDS   *********************/

				/*************** Allocate Memory and add to buffer ****************/

         if ( Fneeded32( 1, l_bufferlength ) > Funused32( ptr_fml_obuf ) ) 
        {
            i_counter++;
			
						/* Ver 1.3 Starts */

            /*ptr_fml_obuf = ( FBFR32 *)tprealloc( (char *)ptr_fml_obuf,
                           (i_counter * MIN_FML_BUF_LEN * BUF_MULTIPLY)); */
	
						 ptr_fml_obuf = ( FBFR32 *)tprealloc( (char *)ptr_fml_obuf,
													(Fsizeof32(ptr_fml_obuf) +(i_counter * MIN_FML_BUF_LEN )));
							/* Ver 1.3 Ends */
													
					

            if ( ptr_fml_obuf == NULL )
            {
                fn_errlog( c_ServiceName, "S31210", TPMSG, c_err_msg.arr  );		/** .arr added in VQC **/
                EXEC SQL CLOSE  sys_cursor;
                Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );					/** .arr added in VQC **/
			 					/*** tpfree ( ( char * )ptr_fml_obuf); *** Commented in VQC ***/
                tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
            }
        }		

				
				/******************** Fill Output Buffer with Output  *********************/

  /***  i_err[0] =  Fadd32( ptr_fml_obuf  ,FFO_EBA_MTCH_ACT_NO  ,c_mtch_accnt_no				,0);	** Commented in VQC **/
        i_err[0] =  Fadd32( ptr_fml_obuf  ,FFO_EBA_MTCH_ACT_NO  ,st_usr_prfl.c_cln_mtch_accnt	,0);	/** Added in VQC **/
        i_ferr[0] = Ferror32;
        i_err[1] =  Fadd32( ptr_fml_obuf  ,FFO_DPID             ,c_dp_id        				,0);
        i_ferr[1] = Ferror32;
        i_err[2] =  Fadd32( ptr_fml_obuf  ,FFO_DP_CLNT_ID       ,c_dp_clnt_id   				,0);
        i_ferr[2] = Ferror32;
        i_err[3] =  Fadd32( ptr_fml_obuf  ,FFO_STCK_CD          ,c_stck_cd      				,0);
        i_ferr[3] = Ferror32;
        /** i_err[4] =  Fadd32( ptr_fml_obuf  ,FFO_PLG_REQ_QTY      ,(char*)&l_plg_req_qty  ,0);
        i_ferr[4] = Ferror32; * Comented in ver 2.1 **/
        i_err[4] =  Fadd32( ptr_fml_obuf  ,FFO_PLG_QTY          ,(char*)&l_qty_plg      ,0); 
        i_ferr[4] = Ferror32; 
        i_err[5] =  Fadd32( ptr_fml_obuf  ,FFO_PLG_RT        		,(char*)&d_plg_rt       ,0);
        i_ferr[5] = Ferror32;	
        /*** i_err[7] =  Fadd32( ptr_fml_obuf  ,FFO_HAIRCUT          ,(char*)&d_plg_haircut  ,0); Commented In Ver 2.0 ***/
        i_err[6] =  Fadd32( ptr_fml_obuf  ,FFO_HAIRCUT          ,(char*)&l_plg_haircut  ,0); /*** Ver 2.0 ***/
        i_ferr[6] = Ferror32;
        i_err[7] =  Fadd32( ptr_fml_obuf  ,FFO_PLG_BLOCK        ,(char*)&l_blk_for_sale ,0);
        i_ferr[7] = Ferror32;
        i_err[8] =  Fadd32( ptr_fml_obuf  ,FFO_AVL_QTY          ,(char*)&l_tot_avl_qty  ,0);
        i_ferr[8] = Ferror32;
        /*************************  VER 1.1 ADDITION BEGIN    *******************************/
        i_err[10] = Fadd32( ptr_fml_obuf  ,FFO_NEW_QTY					,(char*)&l_plg          ,0);
        i_ferr[10]= Ferror32;
        i_err[11] = Fadd32( ptr_fml_obuf  ,FFO_TIFP_QTY         ,(char*)&l_tot_qty_dep	,0);
        i_ferr[11]= Ferror32;
        i_err[12] = Fadd32( ptr_fml_obuf  ,FFO_TOTAL_PL         ,(char*)&d_sec_dep      ,0);
        i_ferr[12]= Ferror32;
        i_err[13] = Fadd32( ptr_fml_obuf  ,FFO_THRS_VAR_PRCNT   ,(char*)&d_sec_after_hc	,0);
        i_ferr[13]= Ferror32;
        i_err[14] = Fadd32( ptr_fml_obuf  ,FFO_HGH_PRC					,(char*)&l_plg_haircut  ,0);
        i_ferr[14]= Ferror32;				/*** Added for synchronization between DL & ASP w.r.t. FML type ***/
        /*************************  VER 1.1 ADDITION ENDS     *******************************/
				/*** Ver 1.8 ** Starts ***/
        i_err[15] = Fadd32( ptr_fml_obuf  ,FFO_ORD_TOT_QTY      ,(char*)&l_free_qty     ,0);
        i_ferr[15]= Ferror32;
				/*** Ver 1.8 ** Ends ***/
				/******* below added for Ver 2.1 *******/
        i_err[16] =  Fadd32( ptr_fml_obuf  ,FFO_PLG_REQ_QTY      ,(char*)&l_plg_req_qty  ,0);
        i_ferr[16] = Ferror32;

        for ( i_cnt=0; i_cnt < 17; i_cnt++ )		/*** Ver 1.8 ** Changed to 16 from 14 ***//** Changed from 16 to 17 for Ver 2.1 ***/
        {
          if ( i_err[ i_cnt ] == -1 )
          {
            fn_errlog( c_ServiceName, "S31215", Fstrerror32(i_ferr[i_cnt]), c_err_msg.arr  );	/** .arr added in VQC **/
            Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );		/** .arr added in VQC **/
/**         l_acnt_id = -1;
            Fadd32( ptr_fml_ibuf, FFO_ACTN_ID, (char *)&l_acnt_id, 0 );		**  Ver 1.1 : Commented ***/
            EXEC SQL CLOSE  sys_cursor;
            tpfree ( ( char * )ptr_fml_obuf);
            tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
          }
        }
				
		}	 /* End of While Loop  */

    /*** Ver 2.3 Starts ***/

    MEMSET(v_sam_upd_tm);

    i_returncode =  fn_upd_sam_dtls(c_ServiceName, c_err_msg.arr ,st_usr_prfl.c_cln_mtch_accnt, &d_free_limit_val, v_sam_upd_tm.arr);
   
    if ( i_returncode == -1 ) 
     {
       fn_errlog( c_ServiceName, "S31220", LIBMSG, c_err_msg.arr ); 
       Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );    
       EXEC SQL CLOSE  sys_cursor;     
       tpfree ( ( char * )ptr_fml_obuf);
       tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
      }
         
    fn_userlog(c_ServiceName,"Free SAM Limit Value is :%lf:",d_free_limit_val);

   SETLEN(v_sam_upd_tm);
   SETNULL(v_sam_upd_tm); 
   fn_userlog( c_ServiceName, "v_sam_upd_tm is :%s:",v_sam_upd_tm.arr);
 
   if((Fadd32(ptr_fml_obuf,FFO_EXPRY_DT, (char *)v_sam_upd_tm.arr, 0))==-1)
   {
    fn_userlog(c_ServiceName,"Error while adding Limit price to o/p buffer.");
    fn_errlog( c_ServiceName, "S31225", FMLMSG, c_err_msg.arr  );
    Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 ); 
    EXEC SQL CLOSE  sys_cursor;
    tpfree ( ( char * )ptr_fml_obuf);
    tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
   }
 
    /*** Ver 2.3 Ends ***/  


   /*** Ver 2.4 Starts ***/

   EXEC SQL
   SELECT NVL(CLM_PLG_MODE,'P')
   INTO   :c_plg_mode
   FROM   CLM_CLNT_MSTR
   WHERE  CLM_MTCH_ACCNT =:st_usr_prfl.c_cln_mtch_accnt;

   if ( SQLCODE != 0 )
   {
     fn_errlog( c_ServiceName, "S31230", SQLMSG, c_err_msg.arr  );
     Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
     fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
     tpfree ( ( char * )ptr_fml_obuf);
     tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
   }

		fn_userlog(c_ServiceName,"Value of c_plg_mode from CLM table :%c:",c_plg_mode);

   if ( c_plg_mode != 'P')
   {
/***********************************************************************888
      EXEC SQL
      SELECT  NVL(SUM(AMOUNT),0)  * This amount is sum of NSE,BSE and FNO Outstanding amount *
      INTO    :d_outstndg_amnt
      FROM
      (  **** Select NSE net amount *
       SELECT  SUM(decode (BDC_DB_CR_FLG,'D',BDC_BAL_AMNT ,-1 * BDC_BAL_AMNT))*100 AMOUNT
       FROM    BDC_BNK_DBCR,FAB_FO_ALC_BFT_SMRY,EAB_EQ_ALC_BFT_SMRY,ESM_XCHNG_SGMNT_MSTR
       WHERE   BDC_CLNT_MTCH_ACCNT = EAB_CLM_MTCH_ACCNT
       AND     EAB_CLM_MTCH_ACCNT  = FAB_CLM_MTCH_ACCNT
       AND     EAB_CLM_MTCH_ACCNT  = :st_usr_prfl.c_cln_mtch_accnt
       AND     BDC_XCHNG_CD        = ESM_XCHNG_CD
       AND     BDC_XCHNG_CD        = 'NSE'
       AND     BDC_SGMNT_CD        = ESM_SGMNT_CD
       AND     BDC_PRCCSD_FLG      != 'F'
       AND     BDC_BAL_AMNT        > 0
       AND     (nvl(EAB_PLG_AMT,0) <>0 OR nvl(FAB_PLG_AMT,0)<> 0)
       UNION ALL
	    *** Select BSE Net amount *
       SELECT  SUM(decode(BDC_DB_CR_FLG,'D',BDC_BAL_AMNT, -1 * BDC_BAL_AMNT))*100 AMOUNT
       FROM    BDC_BNK_DBCR,FAB_FO_ALC_BFT_SMRY,EAB_EQ_ALC_BFT_SMRY,ESM_XCHNG_SGMNT_MSTR
       WHERE   BDC_CLNT_MTCH_ACCNT = EAB_CLM_MTCH_ACCNT
       AND     EAB_CLM_MTCH_ACCNT  = FAB_CLM_MTCH_ACCNT
       AND     EAB_CLM_MTCH_ACCNT  = :st_usr_prfl.c_cln_mtch_accnt
       AND     BDC_XCHNG_CD        = ESM_XCHNG_CD
       AND     BDC_XCHNG_CD        = 'BSE'
       AND     BDC_SGMNT_CD        = ESM_SGMNT_CD
       AND     BDC_PRCCSD_FLG      != 'F'
       AND     BDC_BAL_AMNT        >  0
       AND     (nvl(EAB_PLG_AMT,0) <>0 OR nvl(FAB_PLG_AMT,0)<> 0)
       UNION ALL
       *** Select FNO Amount ***
       SELECT  NVL(-1 * SUM (FBD_DC_AMT- FBD_PI_PO_AMT-FBD_INT_ADJ_AMT),0) AMOUNT
       FROM   FBD_FO_BNK_DRCR , FAB_FO_ALC_BFT_SMRY,EAB_EQ_ALC_BFT_SMRY
       WHERE  FBD_PAYIN_DT <= trunc(sysdate)
       and    FAB_CLM_MTCH_ACCNT = EAB_CLM_MTCH_ACCNT
       and    FAB_CLM_MTCH_ACCNT = FBD_CLM_MTCH_ACCNT
       and    FAB_CLM_MTCH_ACCNT = :st_usr_prfl.c_cln_mtch_accnt
       and    FBD_CLM_MTCH_ACCNT not in
       (SELECT  FBM_CLM_MTCH_ACCNT FROM    FBM_FO_BNK_FLR_MSG WHERE   FBM_STTS = 'N' AND FBM_PRDCT_CD IS NULL )
        and    (FAB_PLG_AMT + EAB_PLG_AMT <> 0)
        and    FBD_DC_FLG = 'D'
        );

  	  if ( SQLCODE != 0 )
      {
         fn_errlog( c_ServiceName, "S31235", SQLMSG, c_err_msg.arr  );
         Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
         fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
         tpfree ( ( char * )ptr_fml_obuf);
         tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
      }

			fn_userlog(c_ServiceName,"Value of d_outstndg_amnt :%lf",d_outstndg_amnt);

      EXEC SQL
      SELECT NVL(sum(DBD_BLOCK_FOR_SALE),0)
      INTO   :l_blok_for_sale
      FROM   DBD_DP_BLCK_DTLS
      WHERE  DBD_CLM_MTCH_ACCNT = :st_usr_prfl.c_cln_mtch_accnt ;

      if ( SQLCODE != 0 )
      {
         fn_errlog( c_ServiceName, "S31240", SQLMSG, c_err_msg.arr  );
         Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
         fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
         tpfree ( ( char * )ptr_fml_obuf);
         tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
      }
			fn_userlog(c_ServiceName,"Value of l_blok_for_sale :%ld",l_blok_for_sale);

      if ( d_outstndg_amnt <= 0 && l_blok_for_sale == 0 )
      {
         c_mrgn_plg_allwd = 'Y';
      }
*****************************************************************************************/
         c_mrgn_plg_allwd = 'Y';
   }

      EXEC SQL
   SELECT COUNT(1)
   INTO   :l_pod_cnt
   FROM   POD_PLG_ORDR_DTLS_CNV
   WHERE  POD_PLG_REV_TYP = 'P'
   AND    POD_CLNT_MTCH_ACCNT = :st_usr_prfl.c_cln_mtch_accnt
   AND    POD_ORDR_STTS in ('R','I')
   AND    POD_ORDR_QTY  > 0;

   if ( SQLCODE != 0 )
   {
      fn_errlog( c_ServiceName, "S31245", SQLMSG, c_err_msg.arr  );
      Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
      fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg.arr );
      tpfree ( ( char * )ptr_fml_obuf);
      tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
   }

   if ( l_pod_cnt > 0)
   {
      c_rqst_type ='N';
   }

   c_mrgn_plg_allwd ='N';

   fn_userlog( c_ServiceName,"c_mrgn_plg_allwd:%c:", c_mrgn_plg_allwd);

   if((Fadd32(ptr_fml_obuf,FFO_PLG_TYP, (char *)&c_mrgn_plg_allwd, 0))==-1)
   {
    fn_userlog(c_ServiceName,"Error while adding plg_allwd flag to o/p buffer.");
    fn_errlog( c_ServiceName, "S31250", FMLMSG, c_err_msg.arr  );
    Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    EXEC SQL CLOSE  sys_cursor;
    tpfree ( ( char * )ptr_fml_obuf);
    tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
   }   

   if((Fadd32(ptr_fml_obuf,FFO_RQST_TYP, (char *)&c_rqst_type, 0))==-1)
   {
    fn_userlog(c_ServiceName,"Error while adding plg_allwd flag to o/p buffer.");
    fn_errlog( c_ServiceName, "S31255", FMLMSG, c_err_msg.arr  );
    Fadd32( ptr_fml_ibuf, FFO_ERR_MSG, c_err_msg.arr, 0 );
    EXEC SQL CLOSE  sys_cursor;
    tpfree ( ( char * )ptr_fml_obuf);
    tpreturn(TPFAIL, 0L, (char *)ptr_fml_ibuf, 0, 0 );
   }   


   /*** Ver 2.4 Ends ***/		
		if(DEBUG_MSG_LVL_3)					/*** VQC ***/
		{	
   		fn_userlog( c_ServiceName, "ALL DONE");
		}
		tpreturn( TPSUCCESS, 0, (char *)ptr_fml_obuf, 0 , 0 );
}
