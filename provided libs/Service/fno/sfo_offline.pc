/******************************************************************************/
/*	Program	    			:	SFO_OFFLINE    		                                    */
/*                                                                            */
/*  Input             : Offline order record from the batch prog              */
/*                                                                            */
/*  Output            : err/success message                                   */
/*                                                                            */
/*  Description       : To place an offline order based on the input and      */
/*                      put a tconf							                              */
/*                                                                            */
/*  Log               : 1.0   18-Dec-2002   Sapan Saxena	                    */
/*  Log               : 1.1   Changes for ctcl by Vikas|Vidya									*/
/*  Log               : 1.2   Changes for IBM by Vidyayini Krish              */
/*  Log								: 1.3		FUTUREPLUS|Shamili															*/	
/*	Log								:	1.4		07-May-2010		Sandeep Patil											*/
/*	Log								:	1.5		25-May-2010		Sandeep Patil											*/
/*	Log								:	1.6		29-Nov-2011		Navina D.   											*/
/*	Log								:	1.7		24-Feb-2012   Sandip T   											  */
/*  Log               : 1.8   15-Jan-2013   Navina D.                         */
/*  Log               : 1.9   10-May-2013   Navina D.                         */
/*  Log               : 2.0   19-Sep-2013   Swati A.B                         */
/*	Log								: 2.1		16-Oct-2017		Bhushan Harekar										*/
/*  Log								: 2.2		31-Jul-2018		Parag Kanojia                     */
/******************************************************************************/
/*  1.0  -  New release                                                       */
/*  1.1  -  CTCL changes                                                      */
/*  1.2  -  IBM Changes                                                       */
/*	1.3	 -  FP																																*/
/*	1.4	 -	NNF DownLoad Changes																							*/
/*	1.5	 -  To Fix Junk User ID Issue																					*/
/*  1.6  -  Span Changes                                                      */
/*  1.7  -  BSE Changes                                                       */
/*  1.8  -  SPAN FuturePLUS Handling                                          */
/*  1.9  -  SLTP FuturePlus                                                   */
/*  2.0  -  OptionPLUS handling                                               */
/*	2.1  -  Order Flow handling																								*/
/*	2.2	 -	Core Fix																													*/
/******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <atmi.h>
#include <sqlca.h>
#include <fml32.h>
#include <fo.h>
#include <fo_fml_def.h>
#include <fo_view_def.h>
#include <fn_tuxlib.h>
#include <fn_ddr.h>
#include <eba_to_ors.h>
#include <fn_log.h> /* Ver 1.2 */
#include <fml_rout.h> /* Ver 1.2 */
#include <fn_read_debug_lvl.h> /* Ver 1.2 */
#include <fn_span_lib.h>  /*** ver 1.6 ***/

#define DONT_ABORT	'N'
#define ABORT_TRN		'Y'
#define RETURN			'R'
#define DONT_RETURN 'N'

EXEC SQL INCLUDE "table/exg_xchng_mstr.h";
EXEC SQL INCLUDE "table/foo_fo_ofln_orders.h";
EXEC SQL INCLUDE "table/fot_fo_ofln_trades.h";

int fn_plc_ord(char* c_svc_err_msg, char* eba_ordr_ref);

int fn_ord_ack(char* c_svc_err_msg, char* eba_ordr_ref);

int fn_spnord_ack(char* c_svc_err_msg, char* eba_ordr_ref);		/*** Ver 1.6 ***/

/*** int fn_tconf(char* c_svc_err_msg, char* eba_trd_ref); ** Commented in Ver 2.1 ***/

int fn_tconf (char* c_err_msg,char* eba_trd_ref,char c_ordr_flw);  /*** Ver 2.1 ***/

int fn_spntconf(char* c_svc_err_msg, char* eba_trd_ref);			/*** Ver 1.6 ***/

void fn_on_err( char *c_ServiceName, char* c_err_msg, char abort_trn_flg, char return_flg );

/* global variables */

char lm_mkt_flg;
char ord_typ = 'T';
char svc_name[20];
char c_channel[4];
char c_user_id[10];
long session_id;
long li_len_tobuf;
char c_err_msg[256];
char c_svc_err_msg[256];
int i_err[27]; /*** Changed from 26 to 27 for Ver 1.6 ***/
long stop_loss_trp_prc = 0L;
long disclosed_qty = 0L;
char c_ServiceName[33];
char c_errmsg[256];
char c_msg[256];
char c_pipe_id[4];
char c_ddr[5];

struct st_err_msg st_errmsg;	/*** Ver 1.6 ***/


EXEC SQL BEGIN DECLARE SECTION;
  varchar c_trd_dt[11 + 1];
  varchar c_trd_ref[10];
EXEC SQL END DECLARE SECTION;

FBFR32* ptr_fml_Ibuf;
FBFR32* ptr_fml_Obuf;
FBFR32* ptr_fml_Sbuf;
FBFR32* ptr_fml_Rbuf;

void SFO_OFFLINE( TPSVCINFO *rqst )
{
	char eba_ordr_ref[20];
	char eba_trd_ref[20];
	int i_trnsctn=0;
	int i;
	int i_trnsctn_main = 0;
	int ord_val =0;
	int ret_val = 0;
	int ret_trd  = 0;
	char ret_msg[256];
	int trd_cnt=0;
	long tot_trd_qty=0;
	int match_exist  = 0;
	char c_span_flag = '\0';		/*** Ver 1.6 ***/
	char c_bse_span_flag = 'N';		/*** Ver 1.7 ***/
	char c_sys_msg[4] = "\0";	/*** Ver 1.9 ***/
	char c_spl_flg = '\0';		/*** Ver 1.9 ***/

	ptr_fml_Ibuf = (FBFR32 *)rqst->data;
	strcpy( c_ServiceName, rqst->name );
	INITDBGLVL(c_ServiceName);

	ptr_fml_Obuf = (FBFR32*)tpalloc("FML32",NULL,MIN_FML_BUF_LEN);
	ptr_fml_Sbuf = (FBFR32*)tpalloc("FML32",NULL,MIN_FML_BUF_LEN);
	ptr_fml_Rbuf = (FBFR32*)tpalloc("FML32",NULL,MIN_FML_BUF_LEN);

  if(ptr_fml_Obuf == NULL )
  {
    fn_errlog( c_ServiceName, "S31005", TPMSG, c_err_msg  );
		fn_on_err( c_ServiceName, c_err_msg,DONT_ABORT, RETURN);
  }

  if( ptr_fml_Sbuf == NULL )
  {
    fn_errlog( c_ServiceName, "S31010", TPMSG, c_err_msg  );
		tpfree((char*)ptr_fml_Obuf);
		fn_on_err( c_ServiceName, c_err_msg,DONT_ABORT, RETURN);
  }

  if(ptr_fml_Rbuf == NULL)
  {
    fn_errlog( c_ServiceName, "S31015", TPMSG, c_err_msg  );
		tpfree((char*)ptr_fml_Obuf);
		tpfree((char*)ptr_fml_Sbuf);
		fn_on_err( c_ServiceName, c_err_msg,DONT_ABORT, RETURN);
  }

	fn_userlog(c_ServiceName,"********SFO_OFFLINE********");	

	i_err[0] = Fget32(ptr_fml_Ibuf,FFO_USR_ID,0,(char *)c_user_id,0) ;
  i_err[1] = Fget32(ptr_fml_Ibuf,FFO_SSSN_ID,0,(char *)&session_id,0) ;
  i_err[2] = Fget32(ptr_fml_Ibuf,FFO_EBA_MTCH_ACT_NO,0,(char *)sql_foo_clm_mtch_accnt,0) ;
  i_err[3] = Fget32(ptr_fml_Ibuf,FFO_XCHNG_CD,0,(char *)sql_foo_xchng_cd,0) ;
  i_err[4] = Fget32(ptr_fml_Ibuf,FFO_PRDCT_TYP,0,(char *)&sql_foo_prdct_typ,0) ;
  i_err[5] = Fget32(ptr_fml_Ibuf,FFO_UNDRLYNG,0,(char *)sql_foo_undrlyng,0) ;
  i_err[6] = Fget32(ptr_fml_Ibuf,FFO_EXPRY_DT,0,(char *)sql_foo_expry_dt.arr,0) ;
  i_err[7] = Fget32(ptr_fml_Ibuf,FFO_EXER_TYP,0,(char *)&sql_foo_exer_typ,0) ;
  i_err[8] = Fget32(ptr_fml_Ibuf,FFO_OPT_TYP,0,(char *)&sql_foo_opt_typ,0) ;
  i_err[9] = Fget32(ptr_fml_Ibuf,FFO_STRK_PRC,0,(char *)&sql_foo_strike_prc,0) ;
  i_err[10] = Fget32(ptr_fml_Ibuf,FFO_CTGRY_INDSTK,0,(char *)&sql_foo_indstk,0) ;
  i_err[11] = Fget32(ptr_fml_Ibuf,FFO_ORDR_FLW,0,(char *)&sql_foo_ordr_flw,0) ;
  i_err[12] = Fget32(ptr_fml_Ibuf,FFO_LMT_MKT_SL_FLG,0,(char *)&lm_mkt_flg,0) ;
  i_err[13] = Fget32(ptr_fml_Ibuf,FFO_LMT_RT,0,(char *)&sql_foo_exec_rate,0) ;
  i_err[14] = Fget32(ptr_fml_Ibuf,FFO_ORD_TYP,0,(char *)&ord_typ,0) ;
  i_err[15] = Fget32(ptr_fml_Ibuf,FFO_ORD_TOT_QTY,0,(char *)&sql_foo_exec_qty,0) ;
  i_err[16] = Fget32(ptr_fml_Ibuf,FFO_ORD_VALID_DT,0,(char *)sql_foo_ordr_dt.arr,0) ;
  i_err[17] = Fget32(ptr_fml_Ibuf,FFO_SVC_NAME,0,(char *)svc_name,0) ;
  i_err[18] = Fget32(ptr_fml_Ibuf,FFO_CHANNEL,0,(char *)c_channel,0) ;
  i_err[19] = Fget32(ptr_fml_Ibuf,FFO_STP_LSS_TGR,0,(char *)&stop_loss_trp_prc,0) ;
  i_err[20] = Fget32(ptr_fml_Ibuf,FFO_DSCLSD_QTY,0,(char *)&disclosed_qty,0) ;
  i_err[21] = Fget32(ptr_fml_Ibuf,FFO_ACK_NMBR,0,(char *)sql_foo_xchng_ack,0) ;
  i_err[22] = Fget32(ptr_fml_Ibuf,FFO_REMARKS,0,(char *)sql_foo_xchng_remarks.arr,0) ;
  i_err[23] = Fget32(ptr_fml_Ibuf,FFO_ACK_TM,0,(char *)sql_foo_exchng_ack_tm.arr,0) ;
  i_err[24] = Fget32(ptr_fml_Ibuf,FFO_PIPE_ID,0,(char *)c_pipe_id,0) ;
  i_err[25] = Fget32(ptr_fml_Ibuf,FFO_DPID,0,(char *)c_ddr,0) ;
	i_err[26] = Fget32(ptr_fml_Ibuf,FFO_SOURCE_FLG,0,(char *)&c_span_flag,0) ;  /*** Ver 1.6 ***/

	for(i=0;i<27;i++)  /*** Changed from 26 to 27 for Ver 1.6 ***/ 
	{
		if(i_err[i] == -1)
		{
			fn_userlog(c_ServiceName,"Error in Fget for i [%d]",i);
			fn_errlog( c_ServiceName, "S31020", FMLMSG, c_err_msg  );
			fn_on_err( c_ServiceName, c_err_msg,DONT_ABORT, RETURN);
  	}
	}
	rtrim(sql_foo_undrlyng);	/** Ver 2.1 **/

	/*** Ver 1.7 new code starts **/
	if( Fget32(ptr_fml_Ibuf,FFO_STATUS_FLG,0,(char *)&c_bse_span_flag,0) == -1 )
	{
			fn_userlog(c_ServiceName,"Error in Fget for BSE SPAN FLAG ");
			fn_errlog( c_ServiceName, "S31025", FMLMSG, c_err_msg  );
			fn_on_err( c_ServiceName, c_err_msg,DONT_ABORT, RETURN);
	}
	/*** Ver 1.7 new code ends ***/

	/*** Ver 1.9 starts here **/
	/*** if ( sql_foo_prdct_typ == 'U' ) Commented In Ver 2.0 ***/
	if ( sql_foo_prdct_typ == 'U' || sql_foo_prdct_typ == 'I' )  /*** Ver 2.0 ***/
	{
		if( Fget32(ptr_fml_Ibuf,FFO_STATUS_FLG,0,(char *)c_sys_msg,0) == -1 )
		{
				if ( sql_foo_prdct_typ == 'U' ) /*** Ver 2.0 if condition added ***/
				{
					fn_userlog(c_ServiceName,"Error in Fget for SYS MSG for SLTP F+");
				}
				else if ( sql_foo_prdct_typ == 'I' ) /*** Ver 2.0 ***/
				{
					fn_userlog(c_ServiceName,"Error in Fget for SYS MSG for OptionPLUS ");
				} 
				fn_errlog( c_ServiceName, "S31030", FMLMSG, c_err_msg  );
				fn_on_err( c_ServiceName, c_err_msg,DONT_ABORT, RETURN);
		}

		if( Fget32(ptr_fml_Ibuf,FFO_SPL_FLG,0,(char *)&c_spl_flg,0) == -1 )
		{
				if ( sql_foo_prdct_typ == 'U' ) /*** Ver 2.0 if condition added ***/
				{
					fn_userlog(c_ServiceName,"Error in Fget for SPL FLAG for SLTP F+");
				}
				else if ( sql_foo_prdct_typ == 'I' ) /*** Ver 2.0 ***/
				{
					fn_userlog(c_ServiceName,"Error in Fget for  SPL FLAG for OptionPLUS ");
				} 
				fn_errlog( c_ServiceName, "S31035", FMLMSG, c_err_msg  );
				fn_on_err( c_ServiceName, c_err_msg,DONT_ABORT, RETURN);
		}
	}
	/*** Ver 1.9 ends here ***/


	SETLEN(sql_foo_expry_dt);
	SETLEN(sql_foo_ordr_dt);
	SETLEN(sql_foo_xchng_remarks);
	SETLEN(sql_foo_exchng_ack_tm);

	if(DEBUG_MSG_LVL_3)
	{
	fn_userlog(c_ServiceName,"INPUT for SFO_OFFLINE..for sql_foo_xchng_ack [%s]",sql_foo_xchng_ack);
	fn_userlog(c_ServiceName,"c_user_id [%s]",c_user_id);
	fn_userlog(c_ServiceName,"session_id [%ld]",session_id);
	fn_userlog(c_ServiceName,"sql_foo_clm_mtch_accnt [%s]",sql_foo_clm_mtch_accnt) ;
	fn_userlog(c_ServiceName,"sql_foo_xchng_cd [%s]",sql_foo_xchng_cd);
	fn_userlog(c_ServiceName,"*******sql_foo_prdct_typ [%c]",sql_foo_prdct_typ) ;      /*1.3*/
	fn_userlog(c_ServiceName,"sql_foo_prdct_typ [%c]",sql_foo_prdct_typ) ;
	fn_userlog(c_ServiceName,"sql_foo_undrlyng [%s]",sql_foo_undrlyng);
	fn_userlog(c_ServiceName,"sql_foo_expry_dt.arr [%s]",sql_foo_expry_dt.arr);
	fn_userlog(c_ServiceName,"sql_foo_exer_typ [%c]",sql_foo_exer_typ) ;
	fn_userlog(c_ServiceName,"sql_foo_opt_typ [%c]",sql_foo_opt_typ) ;
	fn_userlog(c_ServiceName,"sql_foo_strike_prc [%ld]",sql_foo_strike_prc) ;
	fn_userlog(c_ServiceName,"sql_foo_indstk [%c]",sql_foo_indstk) ;
	fn_userlog(c_ServiceName,"sql_foo_ordr_flw [%c]",sql_foo_ordr_flw) ;
	fn_userlog(c_ServiceName,"lm_mkt_flg [%c]",lm_mkt_flg) ;
	fn_userlog(c_ServiceName,"sql_foo_exec_rate [%ld]",sql_foo_exec_rate) ;
	fn_userlog(c_ServiceName,"ord_typ [%c]",ord_typ) ;
	fn_userlog(c_ServiceName,"sql_foo_exec_qty [%ld]",sql_foo_exec_qty) ;
	fn_userlog(c_ServiceName,"sql_foo_ordr_dt.arr [%s]",sql_foo_ordr_dt.arr) ;
	fn_userlog(c_ServiceName,"svc_name [%s]",svc_name) ;
	fn_userlog(c_ServiceName,"c_channel [%s]",c_channel) ;
	fn_userlog(c_ServiceName,"stop_loss_trp_prc [%ld]",stop_loss_trp_prc) ;
	fn_userlog(c_ServiceName,"disclosed_qty [%ld]",disclosed_qty) ;
	fn_userlog(c_ServiceName,"sql_foo_xchng_remarks [%s]",sql_foo_xchng_remarks.arr) ;
	fn_userlog(c_ServiceName,"sql_foo_exchng_ack_tm [%s]",sql_foo_exchng_ack_tm.arr) ;
	fn_userlog(c_ServiceName,"c_pipe_id [%s]",c_pipe_id) ;
	fn_userlog(c_ServiceName,"c_ddr [%s]",c_ddr) ;
	fn_userlog(c_ServiceName,"c_span_flag [%c]",c_span_flag);
	fn_userlog(c_ServiceName,"c_bse_span_flag [%c]",c_bse_span_flag);	/** Ver 1.7 **/
	/*** Ver 2.0 Commented 
	fn_userlog(c_ServiceName,"c_bse_span_flag [%c]",c_sys_msg);	** Ver 1.9 **
	fn_userlog(c_ServiceName,"c_bse_span_flag [%c]",c_spl_flg);	** Ver 1.9 **
	Commented In Ver 2.0 Ends ***/
	fn_userlog(c_ServiceName,"c_sys_msg [%c]",c_sys_msg);	/** Ver 2.0 **/
	fn_userlog(c_ServiceName,"c_spl_flg [%c]",c_spl_flg);	/** Ver 2.0 **/
	}


	EXEC SQL
  SELECT to_char ( exg_nxt_trd_dt, 'yyyymmdd' ),
         to_char ( exg_nxt_trd_dt, 'DD-Mon-yyyy' )
  INTO :c_trd_ref,
       :c_trd_dt
  FROM exg_xchng_mstr, opm_ord_pipe_mstr
  WHERE opm_pipe_id =  :c_pipe_id
  AND exg_xchng_cd = opm_xchng_cd;

  if ( SQLCODE != 0 )
  {
    fn_errlog(c_ServiceName,"S31040", SQLMSG, c_err_msg);
    fn_on_err(c_ServiceName,"Database Error exiting..",DONT_ABORT, RETURN);
  }
  SETNULL ( c_trd_ref );
  SETNULL ( c_trd_dt );

  fn_userlog( c_ServiceName, "********c_trd_ref = [%s]",c_trd_ref.arr);
  fn_userlog( c_ServiceName, "********c_trd_dt = [%s]",c_trd_dt.arr);
  fn_userlog( c_ServiceName, "********sql_foo_prdct_typ= [%c]",sql_foo_prdct_typ);

	/*** if(sql_foo_prdct_typ == 'F' || sql_foo_prdct_typ == 'P')           *1.3*			Commented in ver 1.9 ***/
	 if(sql_foo_prdct_typ == 'F' || sql_foo_prdct_typ == 'P' || sql_foo_prdct_typ == 'U')			/*** Ver 1.9 ***/
		fn_init_ddr_pop ( c_pipe_id,TRADING_SECTION,F_CS);

	/*** if(sql_foo_prdct_typ == 'O') Commented In Ver 2.0 ***/
	if(sql_foo_prdct_typ == 'O' || sql_foo_prdct_typ == 'I')  /*** Ver 2.0 ***/
		fn_init_ddr_pop ( c_pipe_id,TRADING_SECTION,O_CS);

	/* perform order level validations before placing the order */

	/* check the validity of the user */
  match_exist = 0;
  EXEC SQL
  SELECT  1
  INTO    :match_exist
  FROM
  CLM_CLNT_MSTR
  WHERE
  CLM_MTCH_ACCNT = :sql_foo_clm_mtch_accnt;

  if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
  {
    fn_errlog(c_ServiceName,"S31045",SQLMSG,c_err_msg);
		fn_on_err( c_ServiceName, c_err_msg,DONT_ABORT, RETURN);
  }

	if(match_exist == 0)
  {
		fn_userlog(c_ServiceName," 1111 ");
    sprintf(ret_msg,"Match Account [%s] not found in EBA for Exg ack [%s]",sql_foo_clm_mtch_accnt,sql_foo_xchng_ack);
    i_trnsctn = fn_begintran( c_ServiceName, c_errmsg );
    if(i_trnsctn == -1)
    {
			fn_errlog(c_ServiceName,"S31050",SQLMSG,c_err_msg);
      fn_userlog(c_ServiceName,"Error in tpbegin [%s] exiting the SFO_OFFLINE process...",c_errmsg);
			fn_on_err( c_ServiceName, c_err_msg,DONT_ABORT, RETURN);
    }

    EXEC SQL
    UPDATE FOO_FO_OFLN_ORDERS
    SET FOO_PLCD_STTS = 'J',              /* reject the order as match does not exist */
       FOO_REMARKS   = :ret_msg
    WHERE
			 FOO_XCHNG_CD  = :sql_foo_xchng_cd AND    /*** Ver 1.6 BSE***/
			 FOO_ORDR_FLW  = :sql_foo_ordr_flw AND    /*** Ver 2.1 ***/
       FOO_XCHNG_ACK = :sql_foo_xchng_ack;

		if ( SQLCODE != 0 )
    {
      fn_errlog(c_ServiceName,"S31055",SQLMSG,c_err_msg);
			fn_on_err( c_ServiceName, c_err_msg,ABORT_TRN, RETURN);
    }

		EXEC SQL
    UPDATE FOT_FO_OFLN_TRADES
    SET FOT_PLCD_STTS = 'J',              /* reject the trades as match does not exist */
       FOT_REMARKS   = :ret_msg
    WHERE
			 FOT_XCHNG_CD  = :sql_foo_xchng_cd AND    /*** Ver 1.6 BSE***/
			 FOT_ORDR_FLW  = :sql_foo_ordr_flw AND    /*** Ver 2.1 ***/
       FOT_XCHNG_ACK = :sql_foo_xchng_ack;

    if ( SQLCODE != 0 )
    {
      fn_errlog(c_ServiceName,"S31060",SQLMSG,c_err_msg);
      fn_on_err( c_ServiceName, c_err_msg,ABORT_TRN, RETURN);
    }

    if( fn_committran( c_ServiceName, i_trnsctn, c_errmsg ) == -1 )
    {
			fn_errlog(c_ServiceName,"S31065",SQLMSG,c_err_msg);
      fn_userlog(c_ServiceName,"Error in commit [%s] exiting the SFO_OFFLINE process...",c_errmsg);
      fn_on_err( c_ServiceName, c_err_msg,ABORT_TRN, RETURN);
    }
    strcat(ret_msg,"...continuing with another record");
		fn_on_err( c_ServiceName, ret_msg,DONT_ABORT, RETURN);
  }

	/* check if any trades are available in the offline trade table */

  trd_cnt = 0;

		fn_userlog(c_ServiceName," 2222");

  EXEC SQL
  SELECT count(*)
  INTO   :trd_cnt
  FROM   FOT_FO_OFLN_TRADES
  WHERE  FOT_XCHNG_CD = :sql_foo_xchng_cd     /*** Ver 1.6 BSE***/
	AND		 FOT_XCHNG_ACK = :sql_foo_xchng_ack
  AND    trunc(FOT_TRD_DT) = trunc(to_date(:sql_foo_ordr_dt,'dd-Mon-yyyy hh24:mi:ss'))
  AND    FOT_PLCD_STTS <> 'U';         

  if ( SQLCODE != 0 )
  {
  	fn_errlog(c_ServiceName,"S31070",SQLMSG,c_err_msg);
		fn_on_err( c_ServiceName, c_err_msg,DONT_ABORT, RETURN);
  }

  fn_userlog( c_ServiceName, "trade count=[%ld]",trd_cnt);
  if(trd_cnt == 0)    /* No trades found in the offline trade table */
  {
    sprintf(ret_msg,"No trades found for Exg Ack [%s]",sql_foo_xchng_ack);
		i_trnsctn = fn_begintran( c_ServiceName, c_errmsg );
    if(i_trnsctn == -1)
    {
			fn_errlog(c_ServiceName,"S31075",SQLMSG,c_err_msg);
     	fn_userlog(c_ServiceName,"Error in tpbegin [%s] exiting the BAT_FO_UPLOFLN process...",c_errmsg);
			fn_on_err( c_ServiceName, c_errmsg,DONT_ABORT, RETURN);
    }

    EXEC SQL
    UPDATE FOO_FO_OFLN_ORDERS
    SET FOO_PLCD_STTS = 'F',
        FOO_REMARKS   = :ret_msg
    WHERE
				FOO_XCHNG_CD = :sql_foo_xchng_cd AND    /*** Ver 1.6 BSE ***/
				FOO_ORDR_FLW = :sql_foo_ordr_flw AND		/*** Ver 2.1 ***/
        FOO_XCHNG_ACK = :sql_foo_xchng_ack;

    if ( SQLCODE != 0 )
    {
      fn_errlog(c_ServiceName,"S31080",SQLMSG,c_err_msg);
			fn_on_err( c_ServiceName, c_errmsg,ABORT_TRN, RETURN);
    }

		if( fn_committran( c_ServiceName, i_trnsctn, c_errmsg ) == -1 )
    {
      fn_userlog(c_ServiceName,"Error in tpbegin [%s] exiting the BAT_FO_UPLOFLN process...",c_errmsg);
			fn_on_err( c_ServiceName, c_errmsg,ABORT_TRN, RETURN);
      fn_errlog( c_ServiceName, "S31085", FMLMSG, c_err_msg  );
    }
    strcat(ret_msg,"...continue with another record");
		fn_on_err( c_ServiceName, ret_msg,DONT_ABORT, RETURN);
  }

  /* trades exist ..compare the sum of trades with the order executed qty for a xchng ack */

  EXEC SQL
  SELECT sum(FOT_EXCTD_QTY)
  INTO   :tot_trd_qty
  FROM   fot_fo_ofln_trades
  WHERE  FOT_XCHNG_CD = :sql_foo_xchng_cd     /*** Ver 1.6 BSE ***/
	AND 	 FOT_XCHNG_ACK = :sql_foo_xchng_ack
  AND    trunc(FOT_TRD_DT) = trunc(to_date(:sql_foo_ordr_dt,'dd-Mon-yyyy hh24:mi:ss')) 
  AND    FOT_ORDR_FLW = :sql_foo_ordr_flw     /*** Ver 2.1 ***/
  AND    FOT_PLCD_STTS <> 'U'
  GROUP BY FOT_XCHNG_ACK,trunc(FOT_TRD_DT);

	if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
  {
    fn_errlog(c_ServiceName,"S31090",SQLMSG,c_err_msg);
		fn_on_err( c_ServiceName, c_err_msg,DONT_ABORT, RETURN);
  }

  fn_userlog( c_ServiceName, "Tot_Trd_Qty = %ld",tot_trd_qty);

  if(sql_foo_exec_qty != tot_trd_qty)
  {
    sprintf(ret_msg,"sum of trades not equal to exec qty ..Cannnot upload Order for Exg Ack [%s]..",sql_foo_xchng_ack);
		i_trnsctn = fn_begintran( c_ServiceName, c_errmsg );
    if(i_trnsctn == -1)
    {
      fn_userlog(c_ServiceName,"Error in tpbegin [%s] exiting the BAT_FO_UPLOFLN process...",c_errmsg);
      fn_errlog( c_ServiceName, "S31095", FMLMSG, c_err_msg  );
			fn_on_err( c_ServiceName, c_errmsg,DONT_ABORT, RETURN);
    }

			fn_userlog(c_ServiceName," 4444 ");
			fn_userlog(c_ServiceName,"******* ret_msg :<%s>:",ret_msg);

    EXEC SQL
    UPDATE FOO_FO_OFLN_ORDERS
    SET FOO_PLCD_STTS = 'F',    /* not uploaded */
   	    FOO_REMARKS   = :ret_msg
    WHERE
				FOO_XCHNG_CD = :sql_foo_xchng_cd AND    /*** Ver 1.6 BSE***/
				FOO_ORDR_FLW = :sql_foo_ordr_flw AND		/*** Ver 2.1 ***/       
        FOO_XCHNG_ACK = :sql_foo_xchng_ack;

    if ( SQLCODE != 0 )
    {
      fn_errlog(c_ServiceName,"S31100",SQLMSG,c_err_msg);
			fn_on_err( c_ServiceName, c_err_msg,ABORT_TRN, RETURN);
    }
	 fn_userlog(c_ServiceName," 5555 ");


		EXEC SQL
    UPDATE FOT_FO_OFLN_TRADES
    SET FOT_PLCD_STTS = 'F',    /* upload failed */
        FOT_REMARKS   = 'Sum of trades does not match the executed qty for the order ack'
    WHERE
				FOT_XCHNG_CD = :sql_foo_xchng_cd AND    /*** Ver 1.6 BSE***/
				FOT_ORDR_FLW = :sql_foo_ordr_flw AND    /*** Ver 2.1 ***/
        FOT_XCHNG_ACK = :sql_foo_xchng_ack;

    if ( SQLCODE != 0 )
    {
   	  fn_errlog(c_ServiceName,"S31105",SQLMSG,c_err_msg);
			fn_on_err( c_ServiceName, c_err_msg,ABORT_TRN, RETURN);
    }

    if( fn_committran( c_ServiceName, i_trnsctn, c_errmsg ) == -1 )
    {
      fn_userlog(c_ServiceName,"Error in tpbegin [%s] exiting the BAT_FO_UPLOFLN process...",c_errmsg);
      fn_errlog( c_ServiceName, "S31110", FMLMSG, c_err_msg  );
			fn_on_err( c_ServiceName, c_err_msg,ABORT_TRN, RETURN);
    }
    strcat(ret_msg,"..continuing with next record.");
		fn_on_err( c_ServiceName, ret_msg,DONT_ABORT, RETURN);
  }
	fn_userlog( c_ServiceName, "All validations done..place the order ");

	/**** order level transactions begins here ****/
  i_trnsctn_main = fn_begintran( c_ServiceName, c_err_msg );
  if(i_trnsctn_main == -1)
  {
		fn_errlog(c_ServiceName,"S31115",TPMSG,c_errmsg);
		fn_on_err( c_ServiceName, c_err_msg,DONT_ABORT, RETURN);
  }
	
	fn_userlog( c_ServiceName, " 6666");

	ord_val = fn_plc_ord(c_svc_err_msg,eba_ordr_ref);				
	
	fn_userlog( c_ServiceName, "Return val from fn_plc_ord = %d c_svc_err_msg[%s]",ord_val,c_svc_err_msg);

  if(ord_val == -1) /* order upload failed */
 	{
		fn_userlog( c_ServiceName, " 7777 "); 
		fn_on_err( c_ServiceName, (char*)0, ABORT_TRN, DONT_RETURN);
/***		strcpy(ret_msg,"Place order failed ..ERROR");		*** Commented in Ver 2.2 ***/
		strcpy(ret_msg,"Place order failed");		/*** Added In Ver 2.2 ***/
		sprintf(ret_msg,"%s[%s]",ret_msg,c_svc_err_msg);
   	fn_userlog( c_ServiceName, "inside ord_val= -1");
    i_trnsctn = fn_begintran( c_ServiceName, c_err_msg );
    if(i_trnsctn == -1)
    {
			fn_errlog(c_ServiceName,"S31120",TPMSG,c_errmsg);
			fn_on_err( c_ServiceName, c_err_msg,DONT_ABORT, RETURN);
    }

    EXEC SQL
    UPDATE FOO_FO_OFLN_ORDERS
    SET FOO_PLCD_STTS = 'F',
      FOO_REMARKS   = :ret_msg
    WHERE
			FOO_XCHNG_CD = :sql_foo_xchng_cd AND    /*** Ver 1.6 BSE***/
			FOO_ORDR_FLW = :sql_foo_ordr_flw AND		/*** Ver 2.1 ***/
      FOO_XCHNG_ACK = :sql_foo_xchng_ack;
		
    if ( SQLCODE != 0 )
    {
      fn_errlog(c_ServiceName,"S31125",SQLMSG,c_err_msg);
			fn_on_err( c_ServiceName, c_err_msg,ABORT_TRN, RETURN);
    }

		/* update the corresponding orders for this order ack */

		EXEC SQL
    UPDATE FOT_FO_OFLN_TRADES
    SET FOT_PLCD_STTS = 'F',
      FOT_REMARKS   = :c_svc_err_msg
    WHERE
			FOT_XCHNG_CD = :sql_foo_xchng_cd AND    /*** Ver 1.6 BSE***/
			FOT_ORDR_FLW = :sql_foo_ordr_flw AND    /*** Ver 2.1 ***/
      FOT_XCHNG_ACK = :sql_foo_xchng_ack;

    if ( SQLCODE != 0 )
    {
      fn_errlog(c_ServiceName,"S31130",SQLMSG,c_err_msg);
      fn_on_err( c_ServiceName, c_err_msg,ABORT_TRN, RETURN);
    }

    if( fn_committran( c_ServiceName, i_trnsctn, c_err_msg ) == -1 )
    {
			fn_errlog(c_ServiceName,"S31135",TPMSG,c_errmsg);
			fn_on_err( c_ServiceName, c_err_msg,ABORT_TRN, RETURN);
    }
		fn_on_err( c_ServiceName, ret_msg, DONT_ABORT, RETURN);
  }
	else    /* order upload successful */
  {
    eba_ordr_ref[strlen(eba_ordr_ref)] = '\0';
    fn_userlog(c_ServiceName,"Ord ref being updt [%s] ",eba_ordr_ref);

    EXEC SQL
    UPDATE FOO_FO_OFLN_ORDERS
      SET FOO_PLCD_STTS = 'U',		/* uploaded */
    	    FOO_ORDR_RFRNC   = :eba_ordr_ref
      WHERE
					FOO_XCHNG_CD = :sql_foo_xchng_cd AND    /*** Ver 1.6 BSE***/
					FOO_ORDR_FLW = :sql_foo_ordr_flw AND		/*** Ver 2.1 ***/
          FOO_XCHNG_ACK = :sql_foo_xchng_ack;

		if ( SQLCODE != 0 )
    {
			fn_errlog(c_ServiceName,"S31140",SQLMSG,c_err_msg);
			fn_on_err( c_ServiceName, c_err_msg,ABORT_TRN, RETURN);
    }
	}

	/* order placed ...get the ack */
	/*** Ver 1.6 ***/
/*	if (c_span_flag == 'Y')  *** Ver 1.7 comment ***/

	fn_userlog(c_ServiceName,"sql_foo_prdct_typ=:%c:",sql_foo_prdct_typ); /*** TESTING Ver 1.8 ***/
  fn_userlog(c_ServiceName,"c_span_flag=:%c:",c_span_flag); /*** TESTING Ver 1.8 ***/
  fn_userlog(c_ServiceName,"c_bse_span_flag=:%c:",c_bse_span_flag); /*** TESTING Ver 1.8 ***/
  fn_userlog(c_ServiceName,"sql_foo_xchng_cd=:%s:",sql_foo_xchng_cd); /*** TESTING Ver 1.8 ***/

	if( ( ( c_span_flag == 'Y' 		 && strcmp(sql_foo_xchng_cd,"NFO") == 0 ) ||
				  ( c_bse_span_flag == 'Y' && strcmp(sql_foo_xchng_cd,"BFO") == 0) ) &&
					( sql_foo_prdct_typ != 'P' )		/*** Ver 1.8 ***/
		)
		ret_val = fn_spnord_ack(c_svc_err_msg,eba_ordr_ref);

	/***	else  *** 
	*** Ver 1.6 ***/					/*** ver 1.7 comment ***/

	else if( ( c_span_flag == 'N' 		 && strcmp(sql_foo_xchng_cd,"NFO") == 0 ) ||
				   ( c_bse_span_flag == 'N' && strcmp(sql_foo_xchng_cd,"BFO") == 0) ||
					 ( sql_foo_prdct_typ == 'P' )		/*** Ver 1.8 ***/
				 )
		ret_val = fn_ord_ack(c_svc_err_msg,eba_ordr_ref);

  if(ret_val == -1)
  {
		fn_on_err( c_ServiceName, (char*)0, ABORT_TRN, DONT_RETURN);
		strcpy(ret_msg,"Order acpt failed..ERROR");
		sprintf(ret_msg,"%s[%s]",ret_msg,c_svc_err_msg);
    i_trnsctn = fn_begintran( c_ServiceName, c_err_msg );
    if(i_trnsctn == -1)
    {
			fn_errlog(c_ServiceName,"S31145",TPMSG,c_errmsg);
			fn_on_err( c_ServiceName, c_err_msg, DONT_ABORT, RETURN);
    }

    EXEC SQL
    UPDATE FOO_FO_OFLN_ORDERS
      SET FOO_PLCD_STTS = 'F',
         FOO_REMARKS   = :c_svc_err_msg
      WHERE
				 FOO_XCHNG_CD = :sql_foo_xchng_cd AND   /*** Ver 1.6 BSE***/
				 FOO_ORDR_FLW = :sql_foo_ordr_flw AND    /*** Ver 2.1 ***/
         FOO_XCHNG_ACK = :sql_foo_xchng_ack;

    if ( SQLCODE != 0 )
    {
			fn_errlog(c_ServiceName,"S31150",SQLMSG,c_err_msg);
			fn_on_err( c_ServiceName, c_err_msg, ABORT_TRN, RETURN);
    } 

		EXEC SQL
    UPDATE FOT_FO_OFLN_TRADES
      SET FOT_PLCD_STTS = 'F',
         FOT_REMARKS   = :ret_msg
      WHERE
				 FOT_XCHNG_CD = :sql_foo_xchng_cd AND   /*** Ver 1.6 BSE***/
				 FOT_ORDR_FLW = :sql_foo_ordr_flw AND		/*** Ver 2.1 ***/
         FOT_XCHNG_ACK = :sql_foo_xchng_ack;

    if ( SQLCODE != 0 )
    {
      fn_errlog(c_ServiceName,"S31155",SQLMSG,c_err_msg);
      fn_on_err( c_ServiceName, c_err_msg, ABORT_TRN, RETURN);
    }
		

		if( fn_committran( c_ServiceName, i_trnsctn, c_err_msg ) == -1 )
    {
			fn_errlog(c_ServiceName,"S31160",TPMSG,c_errmsg);
			fn_on_err( c_ServiceName, c_err_msg, ABORT_TRN, RETURN);
    }
		fn_on_err( c_ServiceName, ret_msg, DONT_ABORT, RETURN);
	}
	else
	{
		/* select the trades against this order ack */
    EXEC SQL
    DECLARE trd_cur CURSOR FOR
    SELECT
       FOT_XCHNG_TRD_RFRNC,
       FOT_XCHNG_ACK,
       FOT_CLM_MTCH_ACCNT,
       FOT_EXCTD_RT,
       FOT_EXCTD_QTY,
       to_char(FOT_TRD_DT,'dd-mon-yyyy hh24:mi:ss'),
       FOT_PLCD_STTS
    FROM
       FOT_FO_OFLN_TRADES
    WHERE
			 FOT_XCHNG_CD = :sql_foo_xchng_cd AND   /*** Ver 1.6 BSE ***/
       FOT_XCHNG_ACK = :sql_foo_xchng_ack  AND
       FOT_ORDR_FLW  = :sql_foo_ordr_flw AND  /*** Ver 2.1 ***/
       FOT_PLCD_STTS <>'U' ;

    EXEC SQL
       OPEN trd_cur;
	
   	for( ; ; )
   	{
     	EXEC SQL
     	FETCH trd_cur
     	INTO
        :sql_fot_xchng_trd_rfrnc,
        :sql_fot_xchng_ack,
        :sql_fot_clm_mtch_accnt,
        :sql_fot_exctd_rt,
        :sql_fot_exctd_qty,
        :sql_fot_trd_dt,
        :sql_fot_plcd_stts;

     	if( SQLCODE == NO_DATA_FOUND )
     	{
       	EXEC SQL CLOSE trd_cur;
       	break;
      }

			if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
      {
        EXEC SQL CLOSE trd_cur;
				fn_errlog(c_ServiceName,"S31165",SQLMSG,c_err_msg);
				fn_on_err( c_ServiceName, c_err_msg, ABORT_TRN, RETURN);
      }

			SETNULL(sql_fot_trd_dt);

      fn_userlog(c_ServiceName,"sql_fot_xchng_trd_rfrnc = [%ld],sql_fot_xchng_ack = [%s]",sql_fot_xchng_trd_rfrnc,sql_fot_xchng_ack);
			ret_trd = 0;

			/*** Ver 1.6 ***/
			/**if (c_span_flag == 'Y') *** Ver 1.7 comment **/
			if( ( ( c_span_flag == 'Y' 		 && strcmp(sql_foo_xchng_cd,"NFO") == 0 ) ||
				  ( c_bse_span_flag == 'Y' && strcmp(sql_foo_xchng_cd,"BFO") == 0) ) &&
					( sql_foo_prdct_typ != 'P' )		/*** Ver 1.8 ***/
				)			/* Ver 1.7 **/
				ret_trd = fn_spntconf(c_svc_err_msg,eba_trd_ref);
			/*else  *** 
			*** Ver 1.6 ***/			/*** Ver 1.7 Comment as  else changed to else if **/

			else if ( ( c_span_flag == 'N' 		 && strcmp(sql_foo_xchng_cd,"NFO") == 0 ) ||
				  	   ( c_bse_span_flag == 'N' && strcmp(sql_foo_xchng_cd,"BFO") == 0) ||
							 ( sql_foo_prdct_typ == 'P' )		/*** Ver 1.8 ***/
						  )														/** Ver 1.7 ***/
			/*** 	ret_trd = fn_tconf(c_svc_err_msg,eba_trd_ref); **Commented in Ver 2.1 ***/
            ret_trd = fn_tconf(c_svc_err_msg,eba_trd_ref,sql_foo_ordr_flw);  /*** Ver 2.1 ***/

      if(ret_trd == -1)
      {
				EXEC SQL CLOSE trd_cur;
				break;
			}
			else
			{
				eba_trd_ref[strlen(eba_trd_ref)] = '\0';
      	fn_userlog(c_ServiceName,"EBA trd ref [%s] ",eba_trd_ref);

      	EXEC SQL
      	UPDATE FOT_FO_OFLN_TRADES
        	SET FOT_PLCD_STTS = 'U',
        	FOT_EBA_TRD_REF   = :eba_trd_ref,
        	FOT_ORDR_RFRNC    = :eba_ordr_ref,
        	FOT_REMARKS       = 'Trade uploaded'
      	WHERE
					FOT_XCHNG_CD = :sql_foo_xchng_cd AND    /*** Ver 1.6 BSE***/
        	FOT_XCHNG_ACK = :sql_foo_xchng_ack AND
					FOT_XCHNG_TRD_RFRNC = :sql_fot_xchng_trd_rfrnc;

      	if ( SQLCODE != 0 )
      	{
        	fn_errlog(c_ServiceName,"S31170",SQLMSG,c_err_msg);
        	fn_on_err( c_ServiceName, c_err_msg, ABORT_TRN, RETURN);
      	}
			}
		}

		if(ret_trd == -1)
		{
			strcpy(ret_msg,"Trade confirmation failed..ERROR");
			sprintf(ret_msg,"%s[%s]",ret_msg,c_svc_err_msg);
			fn_on_err( c_ServiceName, (char*)0, ABORT_TRN, DONT_RETURN);
      i_trnsctn = fn_begintran( c_ServiceName, c_err_msg );
      if(i_trnsctn == -1)
      {
				fn_errlog(c_ServiceName,"S31175",TPMSG,c_errmsg);
				fn_on_err( c_ServiceName, c_err_msg, DONT_ABORT, RETURN);
      }
			/* change */
			EXEC SQL
      UPDATE FOO_FO_OFLN_ORDERS
     	SET FOO_PLCD_STTS = 'F',
          FOO_REMARKS   = :ret_msg	
      WHERE
					FOO_XCHNG_CD = :sql_foo_xchng_cd AND    /*** Ver 1.6 BSE***/
				  FOO_ORDR_FLW = :sql_foo_ordr_flw AND    /*** Ver 2.1 ***/
          FOO_XCHNG_ACK = :sql_foo_xchng_ack;

      if ( SQLCODE != 0 )
      {
				fn_errlog(c_ServiceName,"S31180",SQLMSG,c_err_msg);
				fn_on_err( c_ServiceName, c_err_msg, ABORT_TRN, RETURN);
      }

      EXEC SQL
      UPDATE FOT_FO_OFLN_TRADES
      SET FOT_PLCD_STTS = 'F',
        FOT_REMARKS   = :c_svc_err_msg
      WHERE
				FOT_XCHNG_CD = :sql_foo_xchng_cd AND    /*** Ver 1.6 BSE***/
        FOT_XCHNG_ACK = :sql_foo_xchng_ack  AND
        FOT_XCHNG_TRD_RFRNC = :sql_fot_xchng_trd_rfrnc;

			if ( SQLCODE != 0 )
      {
				fn_errlog(c_ServiceName,"S31185",SQLMSG,c_err_msg);
				fn_on_err( c_ServiceName, c_err_msg, ABORT_TRN, RETURN);
      } 

      if( fn_committran( c_ServiceName, i_trnsctn, c_errmsg ) == -1 )
      {
				fn_errlog(c_ServiceName,"S31190",TPMSG,c_errmsg);
				fn_on_err( c_ServiceName, c_err_msg, ABORT_TRN, RETURN);
      }
			fn_on_err( c_ServiceName, ret_msg, DONT_ABORT, RETURN);
    }
		else    
    {
			EXEC SQL
  			UPDATE FOO_FO_OFLN_ORDERS
  		SET FOO_PLCD_STTS = 'U',
				FOO_REMARKS   = 'Order & trades uploaded'
  		WHERE
				FOO_XCHNG_CD = :sql_foo_xchng_cd AND    /*** Ver 1.6 BSE***/
      	FOO_XCHNG_ACK = :sql_foo_xchng_ack	AND
				FOO_ORDR_RFRNC = :eba_ordr_ref; 

  		if ( SQLCODE != 0 )
  		{
    		fn_errlog(c_ServiceName,"S31195",SQLMSG,c_err_msg);
    		fn_on_err( c_ServiceName, c_err_msg, ABORT_TRN, RETURN);
  		}
		}
	}		/* close of the else */

	if( fn_committran( c_ServiceName, i_trnsctn_main, c_errmsg ) == -1 )	/* commit the main trn */
  {
		fn_errlog(c_ServiceName,"S31200",TPMSG,c_errmsg);
    fn_on_err( c_ServiceName, c_errmsg, ABORT_TRN, RETURN);
  }
	fn_userlog(c_ServiceName,"****Order and trade upload successful for Exchange Ack [%s]****",sql_foo_xchng_ack);
	ret_val = 1;
  Fadd32( ptr_fml_Obuf, FFO_ACTN_ID ,(char*)&ret_val, 0 );
  Fadd32( ptr_fml_Obuf, FFO_ORDR_RFRNC ,(char*)eba_ordr_ref, 0 );
  tpreturn(TPSUCCESS, SUCC_BFR, (char *)ptr_fml_Obuf, 0, 0 );
	/* success */
}

int fn_plc_ord(char* c_err_msg, char* eba_ordr_ref)
{
	int ret_val;
	long li_len_tobuf;
	char err_msg[256];

	fn_userlog( c_ServiceName, "Inside fn_plc_ord");


	fn_userlog( c_ServiceName, " ********** inside function ********");
	/* call the place order service */
	ret_val = tpcall("SFO_ORD_ROUT",(char*)ptr_fml_Ibuf,0,(char **)&ptr_fml_Rbuf,&li_len_tobuf,0);

  if(ret_val == -1) /* error in placing the order */
  {
    if(Fget32(ptr_fml_Rbuf,FFO_ERR_MSG,0,(char *)err_msg,0) == -1)
    {
      fn_errlog( c_ServiceName, "S31205", FMLMSG, c_err_msg  );
      sprintf(c_err_msg,"Place order failed for Exc_ack:[%s] ..,Please Contact Customer Support",sql_foo_xchng_ack);
			return -1;
    }
    else
    {
/***      sprintf(c_err_msg,"Place order failed for Exc_ack:[%s]..ERR MSG:[%s]",sql_foo_xchng_ack,err_msg);		*** Commented in Ver 2.2 ***/
			strcpy(c_err_msg,err_msg);	/*** Added In ver 2.2 ***/
			fn_userlog(c_ServiceName,"[Error msg from SFO_ORD_ROUT [%s]",err_msg);
			fn_userlog(c_ServiceName,"[Error msg created  [%s]",c_err_msg);
      return -1;
    }
  }
	else  /* order placed successfully..get the order reference */
	{
    if(Fget32(ptr_fml_Rbuf,FFO_ORDR_RFRNC,0,(char *)eba_ordr_ref,0) == -1)
    {
      fn_errlog( c_ServiceName, "S31210", FMLMSG, c_err_msg  );
      sprintf(c_err_msg,"Unable to get order ref..Upload for Exc_ack:[%s] failed..,Please Contact Customer Support",sql_foo_xchng_ack);
      return -1;
    }
    else
    {
			/* update the request placed time */
			EXEC SQL
			UPDATE 	fxb_fo_xchng_book
			SET 		fxb_rqst_tm = to_date(:sql_foo_ordr_dt,'dd-mon-yyyy hh24:mi:ss')
			WHERE 	fxb_ordr_rfrnc = :eba_ordr_ref
			AND			fxb_mdfctn_cntr= 1;

			if ( SQLCODE != 0 )
  		{
    		fn_errlog(c_ServiceName,"S31215",SQLMSG,c_err_msg);
    		return -1;
  		}

      fn_userlog(c_ServiceName,"Order upload success..ordr ref from EBA recd...[%s]",eba_ordr_ref);
    }
  	fn_userlog( c_ServiceName, "going out of  fn_plc_ord");
    return 1;
  }
}

int fn_ord_ack(char* c_err_msg,char* eba_ordr_ref)
{
	struct vw_xchngbook st_i_xchngbk;
  struct vw_orderbook st_i_ordrbk;

  char c_svc_name [15+1];

  int i_ch_val;
  int i_trnsctn;

  fn_userlog( c_ServiceName, "inside fn_ord_ack");

  strcpy ( st_i_ordrbk.c_ordr_rfrnc , eba_ordr_ref);
	fn_cpy_ddr(st_i_ordrbk.c_rout_crt);
  st_i_ordrbk.c_oprn_typ = FOR_VIEW;
	fn_userlog(c_ServiceName,"*****************st_i_ordrbk.c_oprn_typ =:%c:",st_i_ordrbk.c_oprn_typ);
  i_ch_val = fn_call_svc ( c_ServiceName,
                              c_err_msg,
                             &st_i_ordrbk,
                             &st_i_ordrbk,
                             "vw_orderbook",
                             "vw_orderbook",
                             sizeof ( st_i_ordrbk ),
                             sizeof ( st_i_ordrbk ),
                             0,
                             "SFO_REF_TO_ORD" );
  if ( i_ch_val != SUCC_BFR )
  {
    fn_errlog(c_ServiceName,"S31220", LIBMSG, c_err_msg);
    return -1;
  }
	strcpy ( st_i_xchngbk.c_ordr_rfrnc, st_i_ordrbk.c_ordr_rfrnc );
  st_i_xchngbk.l_mdfctn_cntr = st_i_ordrbk.l_mdfctn_cntr;
  strcpy ( st_i_xchngbk.c_xchng_cd, st_i_ordrbk.c_xchng_cd );
  strcpy ( st_i_xchngbk.c_pipe_id, st_i_ordrbk.c_pipe_id );

  /*** if ( st_i_ordrbk.c_prd_typ == FUTURES || st_i_ordrbk.c_prd_typ == FUTURE_PLUS )  *1.3*		Commented in Ver 1.9 ***/
	if ( st_i_ordrbk.c_prd_typ == FUTURES || st_i_ordrbk.c_prd_typ == FUTURE_PLUS || st_i_ordrbk.c_prd_typ == SLTP_FUTUREPLUS )		/*** Ver 1.9 ***/
  {
    strcpy( c_svc_name , "SFO_FUT_ACK" );
  }
  else
  {
    strcpy( c_svc_name , "SFO_OPT_ACK" );
  }

  st_i_xchngbk.c_plcd_stts = ACCEPT;
  st_i_xchngbk.c_rms_prcsd_flg = NOT_PROCESSED;
  st_i_xchngbk.l_ors_msg_typ = ORS_NEW_ORD_ACPT;
	strcpy ( st_i_xchngbk.c_ack_tm , (char*) sql_foo_exchng_ack_tm.arr );

  strcpy ( st_i_xchngbk.c_xchng_rmrks ,(char*) sql_foo_xchng_remarks.arr );
  st_i_xchngbk.d_jiffy = (double)0;
  st_i_xchngbk.l_dwnld_flg = NOT_DOWNLOAD;
  strcpy ( st_i_xchngbk.c_entry_dt_tm, (char*) sql_foo_exchng_ack_tm.arr ); /* same as exg ack time */
	fn_cpy_ddr(st_i_xchngbk.c_rout_crt);
  st_i_xchngbk.c_oprn_typ = UPDATION_ON_EXCHANGE_RESPONSE;
	st_i_xchngbk.l_bit_flg	=	99;			/***	Ver	1.3	***/

	fn_userlog(c_ServiceName,"Inputs to exchange book...");
	fn_userlog(c_ServiceName,"c_plcd_stts[%ld]",st_i_xchngbk.c_plcd_stts);
	fn_userlog(c_ServiceName,"c_rms_prcsd_flg[%c]",st_i_xchngbk.c_rms_prcsd_flg);
	fn_userlog(c_ServiceName,"l_ors_msg_typ[%ld]",st_i_xchngbk.l_ors_msg_typ);
	fn_userlog(c_ServiceName,"c_ack_tm[%s]",st_i_xchngbk.c_ack_tm);
	fn_userlog(c_ServiceName,"c_xchng_rmrks[%s]",st_i_xchngbk.c_xchng_rmrks);
	fn_userlog(c_ServiceName,"d_jiffy[%lf]",st_i_xchngbk.d_jiffy);	

  i_ch_val = fn_call_svc ( c_ServiceName,
                            c_err_msg,
                            &st_i_xchngbk,
                            &st_i_xchngbk,
                            "vw_xchngbook",
                            "vw_xchngbook",
                            sizeof ( st_i_xchngbk ),
                            sizeof ( st_i_xchngbk ),
                            0,
                            "SFO_UPD_XCHNGBK" );
  if(( i_ch_val != SUCC_BFR ) &&
       ( i_ch_val != RECORD_ALREADY_PRCSD ) )
  {
    fn_errlog(c_ServiceName,"S31225", LIBMSG, c_err_msg);
    return -1;
  }
	else if ( i_ch_val == RECORD_ALREADY_PRCSD )
  {
    fn_userlog ( c_ServiceName, "Record already processed" );
    strcpy(c_err_msg,"Record already processed");
    return -1;
  }

  strcpy ( st_i_ordrbk.c_xchng_ack, sql_foo_xchng_ack );
	fn_userlog(c_ServiceName,"Exc Ack to be updated in ordr bk[%s]Ref[%s]",st_i_ordrbk.c_xchng_ack,st_i_ordrbk.c_ordr_rfrnc);
	fn_cpy_ddr(st_i_ordrbk.c_rout_crt);
  st_i_ordrbk.c_oprn_typ = UPDATE_XCHNG_RESPONSE;

  i_ch_val = fn_call_svc ( c_ServiceName,
                             c_err_msg,
                             &st_i_ordrbk,
                             &st_i_ordrbk,
                             "vw_orderbook",
                             "vw_orderbook",
                             sizeof ( st_i_ordrbk ),
                             sizeof ( st_i_ordrbk ),
                             0,
                             "SFO_UPD_ORDRBK" );
  if ( i_ch_val != SUCC_BFR )
  {
    fn_errlog(c_ServiceName,"S31230", LIBMSG, c_err_msg);
    return -1;
  }
	EXEC SQL
  UPDATE FOD_FO_ORDR_DTLS
  SET FOD_ORDR_STTS = 'Q'
  WHERE FOD_ORDR_RFRNC = :eba_ordr_ref;

  if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
  {
    fn_errlog(c_ServiceName,"S31235",SQLMSG,c_err_msg);
    return -1;
  }

	fn_cpy_ddr(st_i_xchngbk.c_rout_crt);
	fn_userlog(c_ServiceName,"Before call to SFO_FUT_ACK or SFO_OPT_ACK...st_i_xchngbk.c_rout_crt[%s]",st_i_xchngbk.c_rout_crt);

  i_ch_val = fn_call_svc ( c_ServiceName,
                             c_err_msg,
                             &st_i_xchngbk,
                             &st_i_xchngbk,
                             "vw_xchngbook",
                             "vw_xchngbook",
                             sizeof ( st_i_xchngbk ),
                             sizeof ( st_i_xchngbk ),
                             0,
                             c_svc_name );
	if ( i_ch_val != 0 )
  {
    fn_errlog(c_ServiceName,"S31240", LIBMSG, c_err_msg);
    return -1;
  }
  fn_userlog( c_ServiceName, "going out of fn_ord_ack");
  return 1;
}


/*** int fn_tconf (char* c_err_msg,char* eba_trd_ref) ***Commented in Ver 2.1 ***/
int fn_tconf (char* c_err_msg,char* eba_trd_ref,char c_ordr_flw)  /*** Ver 2.1 ***/
{
	int i_trnsctn;
  int i_ch_val;

  struct vw_orderbook st_i_ordbk;
  struct vw_tradebook st_i_trdbk;
  struct vw_sequence st_seq;
  struct vw_contract st_cntrct;

  char c_svc_name [ 16 ];

  fn_userlog( c_ServiceName, "inside fn_tconf....");

	i_err[0] = Fget32(ptr_fml_Rbuf,FFO_PIPE_ID,0,(char *)st_i_ordbk.c_pipe_id,0); /*1.1*/
	if ( i_err[0] == -1 )
 	{
 		fn_errlog(c_ServiceName,"S31245",FMLMSG,c_err_msg);
   	return -1;
 	}

  strcpy ( st_i_ordbk.c_xchng_ack , sql_foo_xchng_ack );
	fn_cpy_ddr(st_i_ordbk.c_rout_crt);
  st_i_ordbk.c_oprn_typ = FOR_VIEW;
  fn_userlog( c_ServiceName, "The Fget pipe id is :%s:",st_i_ordbk.c_pipe_id);
  fn_userlog( c_ServiceName, "The Old pipe id is :%s:",c_pipe_id);

	EXEC SQL
  	SELECT  fod_clm_mtch_accnt,
            fod_clnt_ctgry,
            fod_ordr_rfrnc,
   	        fod_xchng_cd,
            fod_prdct_typ,
            fod_undrlyng,
            to_char ( fod_expry_dt, 'dd-Mon-yyyy' ),
            fod_exer_typ,
            fod_opt_typ,
            fod_strk_prc,
            fod_ordr_flw,
            fod_lmt_mrkt_sl_flg,
            NVL( fod_dsclsd_qty, 0 ),
            NVL ( fod_ordr_tot_qty, 0 ),
            NVL( fod_lmt_rt, 0 ),
            fod_stp_lss_tgr,
            fod_ordr_type,
            to_char ( fod_ordr_valid_dt, 'dd-Mon-yyyy' ),
            to_char ( fod_trd_dt, 'dd-Mon-yyyy' ),
            fod_ordr_stts,
            NVL( fod_exec_qty, 0 ),
            NVL( fod_exec_qty_day, 0 ),
            NVL( fod_cncl_qty, 0 ),
            NVL( fod_exprd_qty, 0 ),
            NVL(fod_sprd_ordr_ref,' '),
            fod_mdfctn_cntr,
            NVL(fod_settlor,' '),
						fod_spl_flag,
            fod_indstk,
            NVL(to_char ( fod_ord_ack_tm, 'dd-Mon-yyyy hh24:mi:ss' ),' '),
            NVL(to_char ( fod_lst_rqst_ack_tm, 'dd-Mon-yyyy hh24:mi:ss' ),' ')
   	INTO    :st_i_ordbk.c_cln_mtch_accnt,
            :st_i_ordbk.l_clnt_ctgry,
            :st_i_ordbk.c_ordr_rfrnc,
            :st_i_ordbk.c_xchng_cd,
            :st_i_ordbk.c_prd_typ,
            :st_i_ordbk.c_undrlyng,
            :st_i_ordbk.c_expry_dt,
            :st_i_ordbk.c_exrc_typ,
            :st_i_ordbk.c_opt_typ,
            :st_i_ordbk.l_strike_prc,
            :st_i_ordbk.c_ordr_flw,
            :st_i_ordbk.c_slm_flg,
            :st_i_ordbk.l_dsclsd_qty,
            :st_i_ordbk.l_ord_tot_qty,
            :st_i_ordbk.l_ord_lmt_rt,
            :st_i_ordbk.l_stp_lss_tgr,
            :st_i_ordbk.c_ord_typ,
            :st_i_ordbk.c_valid_dt,
            :st_i_ordbk.c_trd_dt,
            :st_i_ordbk.c_ordr_stts,
            :st_i_ordbk.l_exctd_qty,
            :st_i_ordbk.l_exctd_qty_day,
        	  :st_i_ordbk.l_can_qty,
            :st_i_ordbk.l_exprd_qty,
            :st_i_ordbk.c_sprd_ord_rfrnc,
						:st_i_ordbk.l_mdfctn_cntr,
            :st_i_ordbk.c_settlor ,
            :st_i_ordbk.c_req_typ,
            :st_i_ordbk.c_ctgry_indstk,
            :st_i_ordbk.c_ack_tm ,
            :st_i_ordbk.c_prev_ack_tm 
   	FROM fod_fo_ordr_dtls
    WHERE   fod_ack_nmbr = :st_i_ordbk.c_xchng_ack
    AND     fod_pipe_id  = :st_i_ordbk.c_pipe_id
    AND     fod_ordr_flw = :c_ordr_flw;     /*** Ver 2.1 ***/
	
	if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
 	{
 		fn_errlog(c_ServiceName,"S31250",SQLMSG,c_err_msg);
   	return -1;
 	}

	strcpy ( st_seq.c_pipe_id, st_i_ordbk.c_pipe_id );
  strcpy ( st_seq.c_trd_dt, ( char * )c_trd_dt.arr );
	fn_cpy_ddr(st_seq.c_rout_crt);
  st_seq.c_rqst_typ = GET_TRD_SEQ;
  i_ch_val = fn_call_svc ( c_ServiceName,
                           c_err_msg,
                           &st_seq,
                           &st_seq,
                           "vw_sequence",
                           "vw_sequence",
                           sizeof ( st_seq ),
                           sizeof ( st_seq ),
                           0,
                           "SFO_GET_SEQ" );

  if ( i_ch_val != SUCC_BFR )
  {
    fn_errlog(c_ServiceName,"S31255", LIBMSG, c_err_msg);
    return -1;
  }
	sprintf ( st_i_trdbk.c_trd_rfrnc, "%s%s%08ld",
            ( char * )c_trd_ref.arr, st_i_ordbk.c_pipe_id, st_seq.l_seq_num );
  strcpy ( st_i_trdbk.c_cln_mtch_accnt , st_i_ordbk.c_cln_mtch_accnt );
  strcpy ( st_i_trdbk.c_xchng_cd , st_i_ordbk.c_xchng_cd );
  st_i_trdbk.c_prd_typ = st_i_ordbk.c_prd_typ;
  strcpy ( st_i_trdbk.c_undrlyng , st_i_ordbk.c_undrlyng );
  strcpy ( st_i_trdbk.c_expry_dt , st_i_ordbk.c_expry_dt );
  st_i_trdbk.c_exrc_typ = st_i_ordbk.c_exrc_typ;
  st_i_trdbk.c_opt_typ = st_i_ordbk.c_opt_typ;
  st_i_trdbk.l_strike_prc = st_i_ordbk.l_strike_prc;
  st_i_trdbk.c_ctgry_indstk = st_i_ordbk.c_ctgry_indstk;
  strcpy ( st_i_trdbk.c_ordr_rfrnc , st_i_ordbk.c_ordr_rfrnc );
  strcpy ( st_i_trdbk.c_xchng_ack , st_i_ordbk.c_xchng_ack );
  st_i_trdbk.l_xchng_trd_no = ( long )sql_fot_xchng_trd_rfrnc;
  strcpy ( st_i_trdbk.c_trd_dt ,(char*)sql_fot_trd_dt.arr );
	fn_userlog(c_ServiceName,"before insert trade sql_fot_trd_dt.arr [%s]",sql_fot_trd_dt.arr);
  st_i_trdbk.c_trd_flw = st_i_ordbk.c_ordr_flw;
  st_i_trdbk.l_exctd_qty = sql_fot_exctd_qty;
  st_i_trdbk.l_exctd_rt = sql_fot_exctd_rt;
  st_i_trdbk.d_jiffy = (double)0 ;
  st_i_trdbk.l_dwnld_flg = NOT_DOWNLOAD;
	fn_cpy_ddr(st_i_trdbk.c_rout_crt);
  st_i_trdbk.c_oprn_typ = INSERT_TRADE_CONF;
	st_i_trdbk.l_ca_lvl	=	99;			/***	Ver	1.4	***/
	strcpy(st_i_trdbk.c_user_id,"system");					/***	Ver	1.5	***/

	fn_userlog(c_ServiceName,"Stream No. Is :%ld:",st_i_trdbk.l_ca_lvl);

	fn_userlog ( c_ServiceName, "*************** calling SFO_UPD_TRDBK*************");
	i_ch_val = fn_call_svc ( c_ServiceName,
                            c_err_msg,
                            &st_i_trdbk,
                            &st_i_trdbk,
                            "vw_tradebook",
                            "vw_tradebook",
                            sizeof ( st_i_trdbk ),
                            sizeof ( st_i_trdbk ),
                            0,
                            "SFO_UPD_TRDBK" );
  if ( ( i_ch_val != SUCC_BFR ) &&
       ( i_ch_val != RECORD_ALREADY_PRCSD ) )
  {
    fn_errlog(c_ServiceName,"S31260", LIBMSG, c_err_msg);
    return -1;
  }
  else if ( i_ch_val == RECORD_ALREADY_PRCSD )
  {
    fn_userlog ( c_ServiceName, "Record already processed" );
    return -1;
  }
	
  /*** if ( st_i_trdbk.c_prd_typ == OPTIONS ) Commented In Ver 2.0 ***/
  if ( st_i_trdbk.c_prd_typ == OPTIONS || st_i_trdbk.c_prd_typ == OPTIONPLUS ) /*** Ver 2.0 ***/
  {
    strcpy ( c_svc_name , "SFO_OPT_TCONF" );
  }
  /*** else if ( st_i_trdbk.c_prd_typ == FUTURES|| st_i_trdbk.c_prd_typ == FUTURE_PLUS )		Commented in Ver 1.9 ***/
	else if ( st_i_trdbk.c_prd_typ == FUTURES || st_i_trdbk.c_prd_typ == FUTURE_PLUS || st_i_trdbk.c_prd_typ == SLTP_FUTUREPLUS )		/*** Ver 1.9 ***/
  {
    strcpy ( c_svc_name , "SFO_FUT_TCONF" );
  }
	fn_cpy_ddr(st_i_trdbk.c_rout_crt);
  i_ch_val = fn_call_svc ( c_ServiceName,
                            c_err_msg,
                            &st_i_trdbk,
                            &st_i_trdbk,
                            "vw_tradebook",
                            "vw_tradebook",
                            sizeof ( st_i_trdbk ),
                            sizeof ( st_i_trdbk ),
                            0,
                            c_svc_name );

  if ( i_ch_val != 0 )
  {
    fn_errlog(c_ServiceName,"S31265", LIBMSG, c_err_msg);
    return -1;
  }
	strcpy(eba_trd_ref,(char*)st_i_trdbk.c_trd_rfrnc);
	fn_userlog( c_ServiceName, "Eba_trd_ref generated [%s]...going out of fn_tconf",eba_trd_ref);
  return 1;
}


void fn_on_err( char *c_ServiceName, char* c_err_msg, char abort_trn_flg, char return_flg )
{
		int ret_val=0;
    if( abort_trn_flg == ABORT_TRN )
      tpabort(0);
		
		if(return_flg == RETURN)
		{
			fn_userlog(c_ServiceName,"Error Msg returned [%s]",c_err_msg);
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    	ret_val = -1;
    	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID ,(char*)&ret_val, 0 );
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
    return;
}

/*** Ver 1.6 starts ***/
int fn_spnord_ack(char* c_err_msg,char* eba_ordr_ref)
{
	struct st_xchngbook st_i_xchngbk;
  struct st_orderbook st_i_ordrbk;

  int i_ch_val;

  fn_userlog( c_ServiceName, "inside fn_spnord_ack");

  strcpy ( st_i_ordrbk.c_ordr_rfrnc , eba_ordr_ref);
	fn_cpy_ddr(st_i_ordrbk.c_rout_crt);
  st_i_ordrbk.c_oprn_typ = FOR_VIEW;
	fn_userlog(c_ServiceName,"*****************st_i_ordrbk.c_oprn_typ =:%c:",st_i_ordrbk.c_oprn_typ);

	i_ch_val = fn_spnref_to_ord (&st_i_ordrbk,
															 &st_i_ordrbk,
															 c_ServiceName,
												       c_err_msg
			                        );

  if ( i_ch_val != SUCC_BFR )
  {
    fn_errlog(c_ServiceName,"S31270", LIBMSG, c_err_msg);
    return -1;
  }
	strcpy ( st_i_xchngbk.c_ordr_rfrnc, st_i_ordrbk.c_ordr_rfrnc );
  st_i_xchngbk.l_mdfctn_cntr = st_i_ordrbk.l_mdfctn_cntr;
  strcpy ( st_i_xchngbk.c_xchng_cd, st_i_ordrbk.c_xchng_cd );
  strcpy ( st_i_xchngbk.c_pipe_id, st_i_ordrbk.c_pipe_id );

  st_i_xchngbk.c_plcd_stts = ACCEPT;
  st_i_xchngbk.c_rms_prcsd_flg = NOT_PROCESSED;
  st_i_xchngbk.l_ors_msg_typ = ORS_NEW_ORD_ACPT;
	strcpy ( st_i_xchngbk.c_ack_tm , (char*) sql_foo_exchng_ack_tm.arr );

  strcpy ( st_i_xchngbk.c_xchng_rmrks ,(char*) sql_foo_xchng_remarks.arr );
  st_i_xchngbk.d_jiffy = (double)0;
  st_i_xchngbk.l_dwnld_flg = NOT_DOWNLOAD;
  strcpy ( st_i_xchngbk.c_entry_dt_tm, (char*) sql_foo_exchng_ack_tm.arr ); /* same as exg ack time */
	fn_cpy_ddr(st_i_xchngbk.c_rout_crt);
  st_i_xchngbk.c_oprn_typ = UPDATION_ON_EXCHANGE_RESPONSE;
	st_i_xchngbk.l_bit_flg	=	99;			/***	Ver	1.3	***/

	fn_userlog(c_ServiceName,"Inputs to exchange book...");
	fn_userlog(c_ServiceName,"c_plcd_stts[%ld]",st_i_xchngbk.c_plcd_stts);
	fn_userlog(c_ServiceName,"c_rms_prcsd_flg[%c]",st_i_xchngbk.c_rms_prcsd_flg);
	fn_userlog(c_ServiceName,"l_ors_msg_typ[%ld]",st_i_xchngbk.l_ors_msg_typ);
	fn_userlog(c_ServiceName,"c_ack_tm[%s]",st_i_xchngbk.c_ack_tm);
	fn_userlog(c_ServiceName,"c_xchng_rmrks[%s]",st_i_xchngbk.c_xchng_rmrks);
	fn_userlog(c_ServiceName,"d_jiffy[%lf]",st_i_xchngbk.d_jiffy);	

	i_ch_val = fn_spnupd_xchngbk (c_ServiceName,
															  &st_i_xchngbk,
																c_err_msg);

  if(( i_ch_val != SUCC_BFR ) &&
       ( i_ch_val != RECORD_ALREADY_PRCSD ) )
  {
    fn_errlog(c_ServiceName,"S31275", LIBMSG, c_err_msg);
    return -1;
  }
	else if ( i_ch_val == RECORD_ALREADY_PRCSD )
  {
    fn_userlog ( c_ServiceName, "Record already processed" );
    strcpy(c_err_msg,"Record already processed");
    return -1;
  }

  strcpy ( st_i_ordrbk.c_xchng_ack, sql_foo_xchng_ack );
	fn_userlog(c_ServiceName,"Exc Ack to be updated in ordr bk[%s]Ref[%s]",st_i_ordrbk.c_xchng_ack,st_i_ordrbk.c_ordr_rfrnc);
	fn_cpy_ddr(st_i_ordrbk.c_rout_crt);
  st_i_ordrbk.c_oprn_typ = UPDATE_XCHNG_RESPONSE;

  i_ch_val = fn_spnupd_ordrbook ( c_ServiceName,
																	 &st_i_ordrbk,
																   &st_errmsg);


  if ( i_ch_val != SUCC_BFR )
  {
    fn_errlog(c_ServiceName,"S31280", LIBMSG, c_err_msg);
    return -1;
  }
	EXEC SQL
  UPDATE FOD_FO_ORDR_DTLS
  SET FOD_ORDR_STTS = 'Q'
  WHERE FOD_ORDR_RFRNC = :eba_ordr_ref;

  if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
  {
    fn_errlog(c_ServiceName,"S31285",SQLMSG,c_err_msg);
    return -1;
  }

	fn_cpy_ddr(st_i_xchngbk.c_rout_crt);
	fn_userlog(c_ServiceName,"Before call to SFO_PRCS_RSP...st_i_xchngbk.c_rout_crt[%s]",st_i_xchngbk.c_rout_crt);

	i_ch_val = fn_call_svc_fml ( c_ServiceName,
																 c_err_msg,
																 "SFO_PRCS_RSP",
																 0,
																 6,
																 0,
																 FFO_ROUT_CRT, (char *)st_i_xchngbk.c_rout_crt,
																 FFO_ORDR_RFRNC, (char *)st_i_xchngbk.c_ordr_rfrnc,
																 FFO_ORS_MSG_TYP, (char *)&st_i_xchngbk.l_ors_msg_typ,
																 FFO_MDFCTN_CNTR, (char *)&st_i_xchngbk.l_mdfctn_cntr,
																 FFO_ACK_TM, (char *)st_i_xchngbk.c_ack_tm,
																 FFO_PREV_ACK_TM, (char *)st_i_xchngbk.c_entry_dt_tm
															 );
	if ( i_ch_val != 0 )
  {
    fn_errlog(c_ServiceName,"S31290", LIBMSG, c_err_msg);
    return -1;
  }
  fn_userlog( c_ServiceName, "going out of fn_spnord_ack");
  return 1;
}

int fn_spntconf (char* c_err_msg,char* eba_trd_ref)
{
	int i_trnsctn;
  int i_ch_val;

  struct st_orderbook st_i_ordbk;
  struct st_tradebook st_i_trdbk;
	struct st_sequence st_seq;

	char 	c_user_id[15];
	
  fn_userlog( c_ServiceName, "inside fn_spntconf....");

	i_err[0] = Fget32(ptr_fml_Rbuf,FFO_PIPE_ID,0,(char *)st_i_ordbk.c_pipe_id,0); 
	if ( i_err[0] == -1 )
 	{
 		fn_errlog(c_ServiceName,"S31295",FMLMSG,c_err_msg);
   	return -1;
 	}

  strcpy ( st_i_ordbk.c_xchng_ack , sql_foo_xchng_ack );
	fn_cpy_ddr(st_i_ordbk.c_rout_crt);
  st_i_ordbk.c_oprn_typ = FOR_VIEW;
  fn_userlog( c_ServiceName, "The Fget pipe id is :%s:",st_i_ordbk.c_pipe_id);
  fn_userlog( c_ServiceName, "The Old pipe id is :%s:",c_pipe_id);

	EXEC SQL
  	SELECT  fod_clm_mtch_accnt,
            fod_clnt_ctgry,
            fod_ordr_rfrnc,
   	        fod_xchng_cd,
            fod_prdct_typ,
            fod_undrlyng,
            to_char ( fod_expry_dt, 'dd-Mon-yyyy' ),
            fod_exer_typ,
            fod_opt_typ,
            fod_strk_prc,
            fod_ordr_flw,
            fod_lmt_mrkt_sl_flg,
            NVL( fod_dsclsd_qty, 0 ),
            NVL ( fod_ordr_tot_qty, 0 ),
            NVL( fod_lmt_rt, 0 ),
            fod_stp_lss_tgr,
            fod_ordr_type,
            to_char ( fod_ordr_valid_dt, 'dd-Mon-yyyy' ),
            to_char ( fod_trd_dt, 'dd-Mon-yyyy' ),
            fod_ordr_stts,
            NVL( fod_exec_qty, 0 ),
            NVL( fod_exec_qty_day, 0 ),
            NVL( fod_cncl_qty, 0 ),
            NVL( fod_exprd_qty, 0 ),
            NVL(fod_sprd_ordr_ref,' '),
            fod_mdfctn_cntr,
            NVL(fod_settlor,' '),
						fod_spl_flag,
            fod_indstk,
            NVL(to_char ( fod_ord_ack_tm, 'dd-Mon-yyyy hh24:mi:ss' ),' '),
            NVL(to_char ( fod_lst_rqst_ack_tm, 'dd-Mon-yyyy hh24:mi:ss' ),' ')
   	INTO    :st_i_ordbk.c_cln_mtch_accnt,
            :st_i_ordbk.l_clnt_ctgry,
            :st_i_ordbk.c_ordr_rfrnc,
            :st_i_ordbk.c_xchng_cd,
            :st_i_ordbk.c_prd_typ,
            :st_i_ordbk.c_undrlyng,
            :st_i_ordbk.c_expry_dt,
            :st_i_ordbk.c_exrc_typ,
            :st_i_ordbk.c_opt_typ,
            :st_i_ordbk.l_strike_prc,
            :st_i_ordbk.c_ordr_flw,
            :st_i_ordbk.c_slm_flg,
            :st_i_ordbk.l_dsclsd_qty,
            :st_i_ordbk.l_ord_tot_qty,
            :st_i_ordbk.l_ord_lmt_rt,
            :st_i_ordbk.l_stp_lss_tgr,
            :st_i_ordbk.c_ord_typ,
            :st_i_ordbk.c_valid_dt,
            :st_i_ordbk.c_trd_dt,
            :st_i_ordbk.c_ordr_stts,
            :st_i_ordbk.l_exctd_qty,
            :st_i_ordbk.l_exctd_qty_day,
        	  :st_i_ordbk.l_can_qty,
            :st_i_ordbk.l_exprd_qty,
            :st_i_ordbk.c_sprd_ord_rfrnc,
						:st_i_ordbk.l_mdfctn_cntr,
            :st_i_ordbk.c_settlor,
            :st_i_ordbk.c_req_typ,
            :st_i_ordbk.c_ctgry_indstk,
            :st_i_ordbk.c_ack_tm,
            :st_i_ordbk.c_prev_ack_tm
   	FROM fod_fo_ordr_dtls
    WHERE   fod_ack_nmbr = :st_i_ordbk.c_xchng_ack
    AND     fod_pipe_id  = :st_i_ordbk.c_pipe_id;
	
	if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
 	{
 		fn_errlog(c_ServiceName,"S31300",SQLMSG,c_err_msg);
   	return -1;
 	}

	strcpy ( st_seq.c_pipe_id, st_i_ordbk.c_pipe_id );
  strcpy ( st_seq.c_trd_dt, ( char * )c_trd_dt.arr );
	fn_cpy_ddr(st_seq.c_rout_crt);
  st_seq.c_rqst_typ = GET_TRD_SEQ;

	i_ch_val = fn_get_fno_seq ( c_ServiceName,
														  &st_seq,
															c_err_msg);

  if ( i_ch_val != SUCC_BFR )
  {
    fn_errlog(c_ServiceName,"S31305", LIBMSG, c_err_msg);
    return -1;
  }
	sprintf ( st_i_trdbk.c_trd_rfrnc, "%s%s%08ld",
            ( char * )c_trd_ref.arr, st_i_ordbk.c_pipe_id, st_seq.l_seq_num );
  strcpy ( st_i_trdbk.c_cln_mtch_accnt , st_i_ordbk.c_cln_mtch_accnt );
  strcpy ( st_i_trdbk.c_xchng_cd , st_i_ordbk.c_xchng_cd );
  st_i_trdbk.c_prd_typ = st_i_ordbk.c_prd_typ;
  strcpy ( st_i_trdbk.c_undrlyng , st_i_ordbk.c_undrlyng );
  strcpy ( st_i_trdbk.c_expry_dt , st_i_ordbk.c_expry_dt );
  st_i_trdbk.c_exrc_typ = st_i_ordbk.c_exrc_typ;
  st_i_trdbk.c_opt_typ = st_i_ordbk.c_opt_typ;
  st_i_trdbk.l_strike_prc = st_i_ordbk.l_strike_prc;
  st_i_trdbk.c_ctgry_indstk = st_i_ordbk.c_ctgry_indstk;
  strcpy ( st_i_trdbk.c_ordr_rfrnc , st_i_ordbk.c_ordr_rfrnc );
  strcpy ( st_i_trdbk.c_xchng_ack , st_i_ordbk.c_xchng_ack );
  st_i_trdbk.l_xchng_trd_no = ( long )sql_fot_xchng_trd_rfrnc;
  strcpy ( st_i_trdbk.c_trd_dt ,(char*)sql_fot_trd_dt.arr );
	fn_userlog(c_ServiceName,"before insert trade sql_fot_trd_dt.arr [%s]",sql_fot_trd_dt.arr);
  st_i_trdbk.c_trd_flw = st_i_ordbk.c_ordr_flw;
  st_i_trdbk.l_exctd_qty = sql_fot_exctd_qty;
  st_i_trdbk.l_exctd_rt = sql_fot_exctd_rt;
  st_i_trdbk.d_jiffy = (double)0 ;
  st_i_trdbk.l_dwnld_flg = NOT_DOWNLOAD;
	fn_cpy_ddr(st_i_trdbk.c_rout_crt);
  st_i_trdbk.c_oprn_typ = INSERT_TRADE_CONF;
	st_i_trdbk.l_ca_lvl	=	99;			/***	Ver	1.4	***/
	strcpy(st_i_trdbk.c_user_id,"system");					/***	Ver	1.5	***/

	fn_userlog(c_ServiceName,"Stream No. Is :%ld:",st_i_trdbk.l_ca_lvl);

	fn_userlog ( c_ServiceName, "*************** calling fn_spnupd_trdbook*************");

	i_ch_val = fn_spnupd_trdbook ( c_ServiceName,
		                             c_user_id,
		                             &st_i_trdbk,
																 &st_errmsg);

  if ( ( i_ch_val != SUCC_BFR ) &&
       ( i_ch_val != RECORD_ALREADY_PRCSD ) )
  {
    fn_errlog(c_ServiceName,"S31310", LIBMSG, c_err_msg);
    return -1;
  }
  else if ( i_ch_val == RECORD_ALREADY_PRCSD )
  {
    fn_userlog ( c_ServiceName, "Record already processed" );
    return -1;
  }
	
	fn_cpy_ddr(st_i_trdbk.c_rout_crt);

	i_ch_val = fn_call_svc_fml ( c_ServiceName,
																 c_err_msg,
																 "SFO_PRCS_TRD",
																 0,
																 18,
																 0,
																 FFO_ROUT_CRT, (char *)st_i_trdbk.c_rout_crt,  
																 FFO_ORDR_RFRNC, (char *)st_i_trdbk.c_ordr_rfrnc,
																 FFO_TRD_RFRNC, (char *)st_i_trdbk.c_trd_rfrnc,
																 FFO_EBA_MTCH_ACT_NO, (char *)st_i_trdbk.c_cln_mtch_accnt,
																 FFO_EBA_CNTRCT_ID, (char *)&st_i_trdbk.l_eba_cntrct_id,
																 FFO_XCHNG_CD, (char *)st_i_trdbk.c_xchng_cd,
																 FFO_PRDCT_TYP, (char *)&st_i_trdbk.c_prd_typ,
																 FFO_UNDRLYNG, (char *)st_i_trdbk.c_undrlyng,
																 FFO_EXPRY_DT, (char *)st_i_trdbk.c_expry_dt,
																 FFO_EXER_TYP, (char *)&st_i_trdbk.c_exrc_typ,
																 FFO_OPT_TYP, (char *)&st_i_trdbk.c_opt_typ,
																 FFO_STRK_PRC, (char *)&st_i_trdbk.l_strike_prc,
																 FFO_CTGRY_INDSTK, (char *)&st_i_trdbk.c_ctgry_indstk,
																 FFO_CA_LVL, (char *)&st_i_trdbk.l_ca_lvl,   
																 FFO_TRD_FLW, (char *)&st_i_trdbk.c_trd_flw,
																 FFO_EXEC_QTY, (char *)&st_i_trdbk.l_exctd_qty,
																 FFO_EXCTD_RT, (char *)&st_i_trdbk.l_exctd_rt,
																 FFO_TRD_DT, (char *)st_i_trdbk.c_trd_dt
															 );

  fn_userlog ( c_ServiceName, "i_ch_val Returned is = :%d:",i_ch_val );

  if ( i_ch_val != 0 )
  {
    fn_errlog(c_ServiceName,"S31315", LIBMSG, c_err_msg);
    return -1;
  }
	strcpy(eba_trd_ref,(char*)st_i_trdbk.c_trd_rfrnc);
	fn_userlog( c_ServiceName, "Eba_trd_ref generated [%s]...going out of fn_spntconf",eba_trd_ref);
  return 1;
}
/*** Ver 1.6 Ends ***/



