/******************************************************************************/
/*	Program	    			:	SFO_PLC_2L3LORD                                       */
/*                                                                            */
/*  Input             : FFO_USR_ID                                            */
/*                      FFO_SSSN_ID                                           */
/*                      FFO_EBA_MTCH_ACT_NO                                   */
/*                      FFO_PIPE_ID                                           */
/*                      FFO_TRD_PSSWD                                         */
/*                      FFO_OPERATION_TYP                                     */
/*                      FFO_XCHNG_CD [2]                                      */
/*                      FFO_PRDCT_TYP [2]                                     */
/*                      FFO_UNDRLYNG [2]                                      */
/*                      FFO_EXPRY_DT [2]                                      */
/*                      FFO_EXER_TYP [2]                                      */
/*                      FFO_OPT_TYP  [2]                                      */
/*                      FFO_STRK_PRC [2]                                      */
/*                      FFO_CTGRY_INDSTK [2]                                  */
/*                      FFO_ORDR_FLW [2]                                      */
/*                      FFO_LMT_MKT_SL_FLG [2]                                */
/*                      FFO_ORD_TOT_QTY [2]                                   */
/*                      FFO_LMT_RT [2]                                        */
/*                      FFO_OI_INDICTR                                        */
/*                                                                            */
/*  Optional          : FFO_SETTLOR                                           */
/*                                                                            */
/*  Output            : FFO_ORDR_RFRNC [2]                                    */
/*                                                                            */
/*  Description       : This service is used to place a 2 leg/ 3 leg order    */
/*                                                                            */
/*  Log               : 1.0   19-Feb-2002   Vinod Banjan                      */
/*  Log               : 1.1   17-Jul-2002   Infotec|sangeet                   */
/*										: 1.2   27-Sep-2007   Infotech|Vidyayini Krish					*/
/*  Log								: 1.3   17-Nov-2008   Infotech|Shailesh Hinge						*/
/*  Log								: 1.4   24-Apr-2009		Infotech|Vidyayini Krish					*/
/*  Log               : 1.5   12-Aug-2009   Infotech|Vidyayini Krish          */
/*  Log               : 1.6   27-Oct-2009   Infotech|Indrajit Bhadange        */
/*  Log               : 1.7   17-Feb-2010   Infotech|Shailesh Hinge						*/
/*	Log								:	1.8		10-Mar-2011		Infotech|Sandeep Patil						*/
/*	Log								:	1.9		30-Jan-2013		Infotech|Mahesh  Shinde 					*/
/*	Log								:	2.0		18-Apr-2013		Infotech|Sandeep Patil						*/
/*  Log               : 2.1   03-Jun-2013   Infotech|Shamili Dalvi						*/
/*  Log               : 2.2   08-Dec-2014   Infotech|Sachin Birje 						*/
/*  Log								: 2.3		07-Aug-2015		Infotech|Kishor Borkar	          */
/*  Log								: 2.4		13-Aug-2015  	Infotech|Ritesh Deolekar          */
/*  Log								: 2.6		04-Jul-2016  	Infotech|Navina D									*/
/*  Log               : 2.7   03-Mar-2017   Infotech|Kishor B                 */
/*  Log               : 2.8   23-Oct-2019   Infotech|Tanmay Patel             */
/*  Log               : 2.9   01-Mar-2021   Infotech|Sachin Birje             */
/*  Log               : 3.0   18-May-2021   Infotech|Sandip Tambe             */
/*  Log               : 3.1   18-May-2021   Infotech|Sandip Tambe             */
/*  Log               : 3.2   																	           		*/
/*  Log               : 3.3   06-Mar-2023   ISec|Ravi Malla               		*/
/******************************************************************************/
/*  1.0  -  New release                                                       */
/*  1.1  -  BP Changes                                                        */
/*  1.2  -  IBM changes																												*/
/*  1.3  -  The error condition added which got removed in IBM changes				*/
/*  1.4  -  Changes for Derivative strategies																	*/
/*  1.5  -  Enabled CNT to place Derivative Strategy orders                   */
/*  1.6  -  Code change for to skip password validation fo Super User Id's    */
/*  1.7  -  SilverLight Code Changes for Action ID														*/
/*	1.8	 -	SPAN																															*/
/*	1.9	 -	Multi leg order for NIFTY(should allow in same instrument only)		*/
/*	2.0	 -	Removal of second level trading password (CR-ISEC14-37738)        */
/*  2.1  -  Trading not allowed to Customers under DBC                        */
/*  2.2  -  View to FML CHanges                                               */
/*	2.3	 -  Include changes for Insider trading check													*/					
/*	2.4	 -  Contract Master and Trade Quote Table Merger Changes              */
/*  2.6  -  Check Session ip common function changes                          */
/*  2.7  -  Optimization                                                      */
/*  2.8  -  Ipv6 Format                                                       */
/*  2.9  -  Minor Change: Multileg Orders in single pipe id                   */
/*  3.0  -  Derivative_trd_restrict_CR_ISEC04_152948                          */
/*  3.1  -  CR-ISEC14-170898  System validation for placement of 2L and 3L market orders */
/*  3.2  -  unique device identifier                                         */
/*  3.3  -  changing fn_lock_usr to fn_lock_fno																*/
/******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <atmi.h>

#include <fml32.h>
#include <sqlca.h>
/*Add header files here */
#include <fo.h>
#include <fo_fml_def.h>
/** #include <fo_view_def.h> ** Ver 2.2 **/
#include <fo_view_def.h>  /** Ver 2.2 **/  
#include <fml_rout.h>       /** Ver 2.2 **/
#include <fn_session.h>
#include <fn_tuxlib.h>
#include <fn_ddr.h>
#include <fn_log.h> /* Ver 1.2 */
#include <fn_val_ord.h> /* Ver 1.2 */
#include <fml_rout.h> /* Ver 1.2 */
#include <fn_read_debug_lvl.h> /* 1.2 */
#include <fn_pos.h> /* 1.4 */
EXEC SQL INCLUDE "table/ffp_fo_futures_pstn.h"; /* 1.4 */
EXEC SQL INCLUDE "table/fop_fo_options_pstn.h"; /* 1.4 */

void SFO_PLC_2L3LORD ( TPSVCINFO *rqst )
{
  char 	c_ServiceName[33];
  char 	c_err_msg[256];
	char  c_regonize_error[256];  /* 1.4 */
	char	c_trdng_psswrd_flg = YES;
  char  c_temp_psswrd[LEN_USR_TRDNG_PSSWRD];
	char	c_settlor_flg;
	char	c_spl_flg;
  char 	c_srvc_nm[33];
  char 	c_pipe_id[3];
  char 	c_channel[4];/* 1.1*/
  char 	c_bp_id[9];/* 1.1*/
  char 	c_alias[9];/* 1.1*/
  char c_seq_num[9];
  char c_sprdordr_rfrnc[19];
  char 	c_sprd_ord_ind;
  char 	c_opn_typ;
	char  c_is_flg; /* Ver 1.4 */
	char  c_warn_msg='N'; /* Ver 1.4 */
  char c_fno_dmn_nm [ 16 ];
  char c_fno_trg_nm [ 16 ];
  char c_fno_trg_dat [ 256 ];
	char c_ds_channel[4]; /* Ver 1.5 */
	char c_spn_allwd_flg;								/***	Ver	1.8	***/
	char c_undrlyng_tmp[7];			/*** Ver 1.9 ***/
	char c_prd_typ_tmp = '\0';	/*** Ver 1.9 ***/
	char c_undrlyng_code[3][8];	/*** Ver 1.9 ***/
  char c_txn_flg='Y';										/*** Ver 2.6 ***/
 	char c_ip_address[45+1]="\0"; /** Changed from 15 to 45 in Ver 2.8 **/	/*** Ver 2.6 ***/

  char  c_mleg_pipe_id[3];  /** Ver 2.9 **/

	int		i_err[ 20 ]; 		
	int		i_ferr[ 20 ]; 
	int		i_returncode;
  int 	i_trnsctn;
  int 	i_cnt;
	int		i_pswrd_cnt=0;			/***	Ver	2.0	***/
	int		i;
	int		i_ip_len;
	int		i_op_len;
	int		i_tot_rec;
	int		i_ch_val	=	0;				/***	Ver	2.0 Initialised by 0	***/
	int   i_counter; /* 1.4 */
	int 	i_count = 0;		/*** Ver 1.9 ***/
	int 	i_result = 0;		/*** Ver 1.9 ***/
	int 	insider_exist = 0;    /*** Ver 2.3 ***/

	long    l_recvbuff;
	long    l_first_ord_qty;
	long    l_second_ord_qty;
	long    l_sprdord_seq_num;
	long    l_no_of_calls; /* 1.4 */
	long    l_lot_size = 0; /* 1.4 */

  int i_actn_id = -1;     /***  Ver 2.0 ***/
  int i_is_dbc_cust = 0 ;      /*** Ver 2.1 ***/ /** Ver 2.0 Variable initialised **/

	double d_limit_amt = 0.0; /* 1.4 */

  FBFR32 *ptr_fml_Ibuf;
  FBFR32 *ptr_fml_Obuf;
  FBFR32 *ptr_fml_Rbuf;
  FBFR32 *ptr_fml_Sbuf;

  EXEC SQL BEGIN DECLARE SECTION;
    struct vw_usr_prfl st_usr_prfl;
  	struct vw_orderbook st_ordbook;
		struct vw_gt_lmt_dtls st_gt_lmt_dtls; /* 1.4 */
		varchar c_exp_dt[ LEN_DATE ];
    varchar c_usr_usr_psswrd[50+1];
		long int li_opn_qty;
    varchar c_trd_dt[LEN_DATE];
		varchar c_trade_dt[LEN_DATE]; /* 1.4 */
    varchar c_date[LEN_DATE];
		char	c_exg_stts;
  EXEC SQL END DECLARE SECTION;

  struct vw_orderbook st_first_ordbk;
  struct vw_orderbook st_next_ordbk;
	struct vw_orderbook st_temp_ordbook; /* 1.4 */
  struct vw_err_msg 	st_err_msg;
  struct vw_sequence st_s_sequence;
  struct vw_sequence st_r_sequence;
  struct vw_spdordbk st_spd_ordbk;

  ptr_fml_Ibuf = (FBFR32 *)rqst->data;
  strcpy(c_ServiceName, rqst->name);
	INITDBGLVL(c_ServiceName);

	MEMSET(st_usr_prfl);		/** Ver 2.6 **/
	MEMSET(st_err_msg);			/** Ver 2.6 **/


  /**** COmmented in Ver 2.2 *************
  i_returncode = Fvftos32( ptr_fml_Ibuf,
                           (char *) &st_usr_prfl,
                           "vw_usr_prfl" );
  if ( i_returncode == -1 )
  {
    fn_errlog( c_ServiceName, "S31005", FMLMSG, c_err_msg  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
  *********** Ver 2.2 ********************/

  /***** Ver 2.2 Starts Here *****/
  i_returncode = fn_unpack_fmltovar_dflt ( c_ServiceName,
                                      c_err_msg,
                                      ptr_fml_Ibuf,
                                      5,
                                      FFO_USR_ID,(char *)st_usr_prfl.c_user_id, "NULL",
                                      FFO_SSSN_ID,(char*)&st_usr_prfl.l_session_id, "NULL",
                                      FFO_EBA_MTCH_ACT_NO,(char*)st_usr_prfl.c_cln_mtch_accnt, "NULL",
                                      FFO_PIPE_ID,(char*)st_usr_prfl.c_pipe_id, "*",
                                      FFO_ROUT_CRT,(char*)st_usr_prfl.c_rout_crt, "***" );
  if ( i_returncode == -1 )
  {
    fn_errlog( c_ServiceName, "S31010", FMLMSG, c_err_msg  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
  /***** Ver 2.2 Ends Here *******/

  MEMSET(st_first_ordbk);  /* 1.4 */
	MEMSET(st_next_ordbk);   /* 1.4 */
	MEMSET(st_temp_ordbook); /* 1.4 */	
	MEMSET(c_usr_usr_psswrd);			/***	Ver	2.0	***/

  if(DEBUG_MSG_LVL_5)
	{
    fn_userlog( c_ServiceName, "User id       :%s:",
                                  st_usr_prfl.c_user_id );
    fn_userlog( c_ServiceName, "Session id    :%ld:",
                                  st_usr_prfl.l_session_id );
    fn_userlog( c_ServiceName, "Match Account :%s:",
                                  st_usr_prfl.c_cln_mtch_accnt );
    fn_userlog( c_ServiceName, "Pipe id :%s:",
                                  st_usr_prfl.c_pipe_id );
  }

	/***  Ver 2.1 Starts  ***/

  if(st_usr_prfl.c_user_id[0] != BPID)
  {
    i_is_dbc_cust = 0;

    EXEC SQL
        SELECT 1
            INTO :i_is_dbc_cust
        FROM  CLM_CLNT_MSTR
        WHERE CLM_MTCH_ACCNT = :st_usr_prfl.c_cln_mtch_accnt
        AND   CLM_TRD_FLG = 'N'
        AND   CLM_BP_ID IS NOT NULL;

    if( (SQLCODE != NO_DATA_FOUND) && (SQLCODE != 0))
    {
      fn_errlog( c_ServiceName, "S31015",SQLMSG,c_err_msg);
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
    if ( i_is_dbc_cust == 1 )
    {
    	fn_userlog(c_ServiceName,"Since you are Attached to a Direct Business Catalyst, this facility has been Disabled");
      fn_errlog( c_ServiceName, "B35018", "", c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
  }

  /***  Ver 2.1  Ends  ***/

	/** Product is chosen as NA since this service is common for **/
	/** both Futures & Options.                                  **/

  fn_init_ddr_pop ( st_usr_prfl.c_pipe_id,TRADING_SECTION,COMMON);

	/************Commented in ver 2.0 *****************************
	*********** Trading password is a mandatory input ************

 	i_ch_val = fn_unpack_fmltovar ( c_ServiceName,
                                 	c_err_msg,
                                 	ptr_fml_Ibuf,
                                 	3,
                            			FFO_TRD_PSSWD, ( char * )c_usr_usr_psswrd.arr, NULL,
                            			FFO_XCHNG_CD,( char * )st_ordbook.c_xchng_cd, NULL,
                            			FFO_OPERATION_TYP,( char * )&c_opn_typ, NULL);

  if( i_ch_val != 0 )
  {
    fn_errlog( c_ServiceName, "S31020", FMLMSG , c_err_msg );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      ***  Ver 1.7 ***
    tpreturn( TPFAIL, ERR_BFR, ( char * )ptr_fml_Ibuf, 0, 0 );
  }

	************** Comment Ends ver 2.0 ***************************/

	/******************* Ver 2.0 Starts ***************************/

	if(Fget32(ptr_fml_Ibuf,FFO_XCHNG_CD,0,(char *)&st_ordbook.c_xchng_cd,0) == -1)
  {
		fn_errlog( c_ServiceName, "S31025", FMLMSG, c_err_msg  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 ); 
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

	if(Fget32(ptr_fml_Ibuf,FFO_OPERATION_TYP,0,(char *)&c_opn_typ,0) == -1)
  {
    fn_errlog( c_ServiceName, "S31030", FMLMSG, c_err_msg  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

	if(Fget32(ptr_fml_Ibuf,FFO_TRD_PSSWD,0,(char *)&c_usr_usr_psswrd.arr,0) == -1)
  {

    if(Ferror32 != FNOTPRES)
    {
      fn_errlog( c_ServiceName, "S31035", FMLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );   
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

    if(Ferror32 == FNOTPRES)
    {
      if(DEBUG_MSG_LVL_3)
      {
        fn_userlog(c_ServiceName,"Trading password FML not present.");
      }
      c_trdng_psswrd_flg = NO; 
    }
  }
	
	if(DEBUG_MSG_LVL_3)
  {
    fn_userlog(c_ServiceName,"Trading password flag is |%c|.",c_trdng_psswrd_flg);
  }

	/*********************** Ver 2.0 Ends ********************************/

	if(Fget32(ptr_fml_Ibuf,FFO_IS_FLG,0,(char *)&c_is_flg,0) == -1)
	{

		if(Ferror32 != FNOTPRES)
    {
      fn_errlog( c_ServiceName, "S31040", FMLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );

    }

    if(Ferror32 == FNOTPRES)
    {
			if(DEBUG_MSG_LVL_5)
			{
				fn_userlog(c_ServiceName,"FML NOT FOUND");
			}
			c_is_flg = 'N'; /* When called from normal 2l3l placement screen */
    }

	}

	/*** Ver 1.9 Started ***/ 

	if(DEBUG_MSG_LVL_3)
  {
    fn_userlog( c_ServiceName, "Operation type :%c:",c_opn_typ );
	}

	if ( c_opn_typ == '2' )
  {
    i_count = 2;
	}
	else if ( c_opn_typ == '3' )
  {
    i_count = 3;
  }
	else
	{
		strcpy( c_err_msg, "Invalid operation type");
    fn_userlog( c_ServiceName, "Invalid operation type :%c:",c_opn_typ);
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );	
	}
	
	for( i_cnt=0; i_cnt < i_count; i_cnt++)
  {
		MEMSET(c_undrlyng_tmp);
		c_prd_typ_tmp = '\0';

    i_err[0]= Fget32(ptr_fml_Ibuf, FFO_PRDCT_TYP,i_cnt, (char *)&c_prd_typ_tmp, 0);
    i_ferr [ 0 ] = Ferror32;

    i_err[1]= Fget32(ptr_fml_Ibuf, FFO_UNDRLYNG,i_cnt, (char *)c_undrlyng_tmp, 0);
    i_ferr [ 1 ] = Ferror32;

		for(i=0; i < 2; i++)
  	{
    	if ( (i_err[ i ] == -1 ) )
    	{
       	fn_errlog( c_ServiceName, "S31045", Fstrerror32(i_ferr[i]),c_err_msg);
       	fn_userlog(c_ServiceName,"Error in field %d in record no %d",i,i_cnt );
       	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    	 	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );  
       	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    	}
  	}

		if(DEBUG_MSG_LVL_3)
		{
			fn_userlog(c_ServiceName," %d record Product type  is 	|%c|",i_cnt,c_prd_typ_tmp );	
			fn_userlog(c_ServiceName," %d record Underlying code is |%s|",i_cnt,c_undrlyng_tmp );	
		}
		
		rtrim(c_undrlyng_tmp); 
	
		strcpy(c_undrlyng_code[i_cnt],c_undrlyng_tmp);
		sprintf(c_undrlyng_code[i_cnt],"%s%c",c_undrlyng_code[i_cnt],c_prd_typ_tmp);
		
		rtrim(c_undrlyng_code[i]); 

		if(DEBUG_MSG_LVL_3)
		{
			fn_userlog(c_ServiceName,"Underlying code with product type is |%s|",c_undrlyng_code[i_cnt]);	
		}
	}

	for ( i=0 ; i<i_count ; i++)
  {
		if(DEBUG_MSG_LVL_3)
		{
			fn_userlog(c_ServiceName,"Inside for Loop Underlying code with product type is |%s|",c_undrlyng_code[i]);	
		}

    if (strstr(c_undrlyng_code[i],"NIFTY"))
    {
      if(i_count == 2)
      {
        if(strcmp(c_undrlyng_code[i_count - 2],c_undrlyng_code[i_count - 1]) == 0)
        {
          i_result = 1;
          break;
        }
        else
        {
          i_result = 0;
          break;
        }
      }
      if(i_count == 3)
      {
        if((strcmp(c_undrlyng_code[i_count-3],c_undrlyng_code[i_count-2]) == 0) && (strcmp(c_undrlyng_code[i_count-3],c_undrlyng_code[i_count-1]) == 0) )
        {
          i_result = 1;
          break;
        }
        else
        {
          i_result = 0;
          break;
        }
      }
    }
    else
    {
      i_result = 2;
    }
  }

	if(DEBUG_MSG_LVL_3)
	{
		fn_userlog(c_ServiceName,"Result is |%d|",i_result);
	}

  if (i_result == 1 || i_result == 2)
  {
		if(DEBUG_MSG_LVL_3)
		{
			fn_userlog(c_ServiceName,"You can place the order");
		}
  }
  else if (i_result == 0 )
  {
		if(DEBUG_MSG_LVL_3)
		{
			fn_userlog(c_ServiceName,"Invalid combination of orders");
		}
		strcpy( c_err_msg,"Please place all orders in 2L/3L under NIFTY in the same product either all Futures or all Options.");
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
  else
  {
		if(DEBUG_MSG_LVL_3)
		{
			fn_userlog(c_ServiceName,"Invalid condition");
		}
  }	

	/*** Ver 1.9 Ends ***/

	if(Fget32(ptr_fml_Ibuf,FFO_CHANNEL,0,(char *)c_ds_channel,0) == -1) /* VER 1.5 Addition */
  {

    if(Ferror32 != FNOTPRES)
    {
      fn_errlog( c_ServiceName, "S31050", FMLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );

    }

	}

	if( c_is_flg == 'D' )  /* This if condition was introduced for Ver 1.4 */
	{
  	i_ch_val = fn_unpack_fmltovar ( c_ServiceName,
                                  	c_err_msg,
                                  	ptr_fml_Ibuf,
                                  	1,
                            			  FFO_NEW_CNTRCT_TAG,(char *)&c_warn_msg, NULL); 
  	if( i_ch_val != 0 )
  	{
    	fn_errlog( c_ServiceName, "S31055", LIBMSG , c_err_msg );
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			i_actn_id	=	1;
    	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
    	tpreturn( TPFAIL, ERR_BFR, ( char * )ptr_fml_Ibuf, 0, 0 );
  	}	

	}

	/***	Ver	2.0	Starts	***/

	if( strcmp(c_ds_channel,"WEB") != 0 )
	{
		fn_userlog(c_ServiceName," Inside Silver Light Check.");

		i_returncode	=	fn_lmt_excd_qty_rt	(	c_ServiceName,
																					ptr_fml_Ibuf,
																					&c_trdng_psswrd_flg,
																					&st_usr_prfl,
																					i_count,
																					c_err_msg
																				);

		if ( i_returncode	!=	0	)
		{
			fn_errlog( c_ServiceName, "S31060", LIBMSG , c_err_msg );
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
			tpreturn( TPFAIL, ERR_BFR, ( char * )ptr_fml_Ibuf, 0, 0 );
		}
	}

	/***	Ver	2.0	Ends	***/

	SETLEN ( c_usr_usr_psswrd );
  if(DEBUG_MSG_LVL_5)
	{
    fn_userlog( c_ServiceName, "Operation type :%c:",c_opn_typ );
		fn_userlog( c_ServiceName, "Channel is :%s:",c_ds_channel );
  }

	fn_userlog(c_ServiceName,"Trading Password Flag Is :%c:",c_trdng_psswrd_flg);

	if ( c_trdng_psswrd_flg == YES )			/***	Ver	2.0 If Condition Added 	***/
	{
 		strcpy( c_temp_psswrd, (char *)c_usr_usr_psswrd.arr );
	}

	/*** c_trdng_psswrd_flg = YES; ** Commented in ver 2.0 ***/


	if( c_warn_msg != 'Y' )
	{

		/* Below if added in Ver 1.5. fn_check_user was directly under if(c_warn_msg != 'Y') condition until Ver 1.4 */
		if( (strcmp(c_ds_channel,"CNT") != 0 && strcmp(c_ds_channel,"CN1") != 0) || c_is_flg != 'D' )  /* Ver 1.6 Added new condition for "CN1" check */ 
		{

    	fn_userlog( c_ServiceName, "C_DS_CHANNEL is :%s: C_IS_FLG is :%c:",c_ds_channel,c_is_flg);

			/*** Commented in Ver 2.6 ***
  		i_returncode =  fn_check_user ( c_ServiceName,
                                  		&st_usr_prfl ,
                                  		c_temp_psswrd,
                                  		c_trdng_psswrd_flg,
                                  		&st_err_msg );
			*** Ver 2.6 ***/

			/*** Ver 2.6 starts ***/
			i_returncode =  fn_check_user_ip ( c_ServiceName,
                                  		&st_usr_prfl ,
                                  		c_temp_psswrd,
                                  		c_trdng_psswrd_flg,
																			c_ip_address,
																			c_txn_flg,                
                                  		&st_err_msg );
  		/*** Ver 2.6 ends ***/

  		if ( i_returncode == -1 )
  		{
   			fn_errlog( c_ServiceName, "S31065", LIBMSG , c_err_msg );
    		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );
				i_actn_id = 1;
    		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
    		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  		}
		}
	}

	if( c_is_flg != 'D' )
	{
		if(DEBUG_MSG_LVL_5)
    {
    fn_userlog(c_ServiceName,"c_ip_address :%s:",c_ip_address);         
    fn_userlog(c_ServiceName,"INSIDE 2L AREA");
    }

  	i_trnsctn = fn_begintran( c_ServiceName, c_err_msg );
  	if ( i_trnsctn == -1 )
  	{
   		fn_errlog( c_ServiceName, "S31070", LIBMSG , c_err_msg );
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	}

  	/* i_returncode = fn_lock_usr( c_ServiceName,
                                st_usr_prfl.c_cln_mtch_accnt ); commented in Ver 3.3 */
  	i_returncode = fn_lock_fno( c_ServiceName, st_usr_prfl.c_cln_mtch_accnt ); /* added in  Ver 3.3 */
  	if ( i_returncode == -1 )
  	{
   		fn_errlog( c_ServiceName, "S31075", LIBMSG , c_err_msg );
    	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	}

  	EXEC SQL
    		 SELECT to_char( exg_nxt_trd_dt, 'DD-Mon-YYYY' ),
           			to_char( exg_nxt_trd_dt, 'YYYYMMDD' ),
					 			exg_crrnt_stts
    		 INTO   :c_trd_dt,
           			:c_date,
					 			:c_exg_stts
    		 FROM   exg_xchng_mstr
    		 WHERE  exg_xchng_cd = :st_ordbook.c_xchng_cd
    		 AND    exg_mkt_typ  = 'D';

  	if ( SQLCODE != 0 )
  	{
    	fn_errlog( c_ServiceName, "S31080",SQLMSG,c_err_msg);
 			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	}

  	SETNULL ( c_trd_dt );
  	SETNULL ( c_date );

		if( c_exg_stts != EXCHANGE_OPEN )
		{
    	fn_errlog( c_ServiceName, "B28010",DEFMSG,c_err_msg);
 			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
    /***** Ver 2.9, Comment start here ****************************
  	strcpy( st_s_sequence.c_pipe_id, st_usr_prfl.c_pipe_id );
  	strcpy( st_s_sequence.c_trd_dt, (char *) c_trd_dt.arr );
  	st_s_sequence.c_rqst_typ = GET_SPRDORD_SEQ;

  	i_ip_len = sizeof ( struct vw_sequence );
  	i_op_len = sizeof ( struct vw_sequence );
  	fn_cpy_ddr ( st_s_sequence.c_rout_crt );
    ********* Ver 2.9, Comment ends here  *************************/

		/*********** Commented in Ver 2.7 **********
  	i_returncode = fn_call_svc( c_ServiceName,
                              	c_err_msg,
                              	&st_s_sequence,
                              	&st_r_sequence,
                              	"vw_sequence",
                              	"vw_sequence",
                              	i_ip_len,
                              	i_op_len,
                              	0,
                              	"SFO_GET_SEQ" );
		********** Comment End in Ver 2.7  **********/
		/*** Added in Ver 2.7 ***/
    /********* Ver 2.9 *****************
  	if(DEBUG_MSG_LVL_5)
  	{
    	fn_userlog(c_ServiceName,"Before Calling function fn_get_seq **********");
  	}
  	i_returncode = fn_get_seq(c_ServiceName,c_err_msg,st_s_sequence.c_pipe_id,&st_r_sequence.l_seq_num,st_s_sequence.c_rqst_typ);
		*** Add ended in Ver 2.7 ***
  	if ( i_returncode != 0 )
  	{
    	fn_errlog( c_ServiceName, "S31085", LIBMSG, c_err_msg  );
    	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      ***  Ver 1.7 ***
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	}

  	l_sprdord_seq_num = st_r_sequence.l_seq_num;
  	sprintf( c_seq_num, "%08d", l_sprdord_seq_num );
  	strcpy( c_sprdordr_rfrnc, (char *)c_date.arr );
  	strcat( c_sprdordr_rfrnc, st_usr_prfl.c_pipe_id );
  	strcat( c_sprdordr_rfrnc, c_seq_num );
    *********** Ver 2.9, comment end here ******************/	
		if ( c_opn_typ == '2' )
		{
			i_tot_rec = 2;
			c_spl_flg = L2_ORDER;
			c_sprd_ord_ind = L2_ORDER;
		}
		else if ( c_opn_typ == '3' )
		{
			i_tot_rec = 3;
			c_spl_flg = L3_ORDER;
			c_sprd_ord_ind = L3_ORDER;
		}
		else
		{
			strcpy( c_err_msg, "Invalid operation type");
			if(DEBUG_MSG_LVL_5)
			{
				fn_userlog( c_ServiceName, "Invalid operation type :%c:",c_opn_typ);
			}
   		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
   		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
   		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}

  	ptr_fml_Sbuf = (FBFR32 *)tpalloc( "FML32", NULL, MIN_FML_BUF_LEN*3 );
  	if ( ptr_fml_Sbuf == NULL )
  	{
    	fn_errlog( c_ServiceName, "S31090", TPMSG, c_err_msg  );
    	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	}

  	i_returncode = Fvstof32( ptr_fml_Sbuf, (char *) &st_usr_prfl,
                              FUPDATE, "vw_usr_prfl" );
  	if ( i_returncode == -1 )
  	{
    	fn_errlog( c_ServiceName, "S31095", FMLMSG, c_err_msg  );
    	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	}

  	ptr_fml_Rbuf = (FBFR32 *)tpalloc( "FML32", NULL, MIN_FML_BUF_LEN*3 );

  	if ( ptr_fml_Rbuf == NULL )
  	{
    	fn_errlog( c_ServiceName, "S31100", TPMSG, c_err_msg  );
    	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
  		tpfree ( ( char * ) ptr_fml_Sbuf );
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	}

  	ptr_fml_Obuf = (FBFR32 *)tpalloc( "FML32", NULL, MIN_FML_BUF_LEN*3 );

  	if ( ptr_fml_Obuf == NULL )
  	{
    	fn_errlog( c_ServiceName, "S31105", TPMSG, c_err_msg  );
    	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
  		tpfree ( ( char * ) ptr_fml_Sbuf );
  		tpfree ( ( char * ) ptr_fml_Rbuf );
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	}

  	for( i_cnt=0; i_cnt < i_tot_rec; i_cnt++)
  	{
    	i_err[0]= Fget32(ptr_fml_Ibuf, FFO_XCHNG_CD,i_cnt,
                  										(char *)st_ordbook.c_xchng_cd, 0);
    	i_ferr [ 0 ] = Ferror32;

    	i_err[1]= Fget32(ptr_fml_Ibuf, FFO_PRDCT_TYP,i_cnt,
                  										(char *)&st_ordbook.c_prd_typ, 0);
    	i_ferr [ 1 ] = Ferror32;

    	i_err[2]= Fget32(ptr_fml_Ibuf, FFO_UNDRLYNG,i_cnt,
                  										(char *)st_ordbook.c_undrlyng, 0);
    	i_ferr [ 2 ] = Ferror32;

    	i_err[3]= Fget32(ptr_fml_Ibuf, FFO_EXPRY_DT,i_cnt,
                  										(char *)c_exp_dt.arr, 0);
    	i_ferr [ 3 ] = Ferror32;

    	i_err[4]= Fget32(ptr_fml_Ibuf, FFO_EXER_TYP,i_cnt,
                  										(char *)&st_ordbook.c_exrc_typ, 0);
    	i_ferr [ 4 ] = Ferror32;

    	i_err[5]= Fget32(ptr_fml_Ibuf, FFO_OPT_TYP,i_cnt,
                  										(char *)&st_ordbook.c_opt_typ, 0);
    	i_ferr [ 5 ] = Ferror32;

    	i_err[6]= Fget32(ptr_fml_Ibuf, FFO_STRK_PRC,i_cnt,
                  										(char *)&st_ordbook.l_strike_prc, 0);
    	i_ferr [ 6 ] = Ferror32;

    	i_err[7]= Fget32(ptr_fml_Ibuf, FFO_CTGRY_INDSTK,i_cnt,
                  										(char *)&st_ordbook.c_ctgry_indstk, 0);
    	i_ferr [ 7 ] = Ferror32;

    	i_err[8]= Fget32(ptr_fml_Ibuf, FFO_ORDR_FLW,i_cnt,
                  										(char *)&st_ordbook.c_ordr_flw, 0);
    	i_ferr [ 8 ] = Ferror32;

    	i_err[9]= Fget32(ptr_fml_Ibuf, FFO_LMT_MKT_SL_FLG,i_cnt,
                  										(char *)&st_ordbook.c_slm_flg, 0);
    	i_ferr [ 9 ] = Ferror32;

    	i_err[10]= Fget32(ptr_fml_Ibuf, FFO_ORD_TOT_QTY,i_cnt,
                  										(char *)&st_ordbook.l_ord_tot_qty, 0);
    	i_ferr [ 10 ] = Ferror32;

    	i_err[11]= Fget32(ptr_fml_Ibuf, FFO_LMT_RT,i_cnt,
                  										(char *)&st_ordbook.l_ord_lmt_rt, 0);
    	i_ferr [ 11 ] = Ferror32;

    	i_err[12]= Fget32(ptr_fml_Ibuf, FFO_CHANNEL,i_cnt,
                  										(char *)st_ordbook.c_channel, 0); /*1.1*/
    	i_ferr [ 12 ] = Ferror32;

    	for(i=0; i < 14; i++)
    	{
   			if ( (i_err[ i ] == -1 ) )
				{
					fn_errlog( c_ServiceName, "S31110",
                                 Fstrerror32(i_ferr[i]),c_err_msg);
					fn_userlog(c_ServiceName,"Error in field %d in record no %d",i,i_cnt );
   				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
   				tpfree ( ( char * ) ptr_fml_Sbuf );
   				tpfree ( ( char * ) ptr_fml_Rbuf );
   				tpfree ( ( char * ) ptr_fml_Obuf );
   				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
   				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
			}

    	/***1.1 start ***/

    	if(st_usr_prfl.c_user_id[0] == BPID)
    	{
      	if(Fget32(ptr_fml_Ibuf,FFO_ALIAS,i_cnt,(char *)c_alias,0) == -1)
      	{
        	fn_errlog( c_ServiceName, "S31115", FMLMSG, c_err_msg  );
   				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
   				tpfree ( ( char * ) ptr_fml_Sbuf );
   				tpfree ( ( char * ) ptr_fml_Rbuf );
   				tpfree ( ( char * ) ptr_fml_Obuf );
   				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
   				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      	}
			}
			/***1.1 Ends ***/

			SETLEN(c_exp_dt);

			strcpy ( st_ordbook.c_expry_dt, ( char * ) c_exp_dt.arr );

			if(DEBUG_MSG_LVL_5)
			{
				fn_userlog( c_ServiceName, "Input Data for order no :%d:",i_cnt);
				fn_userlog( c_ServiceName, "Exchange code :%s:",
                                st_ordbook.c_xchng_cd );
  			fn_userlog( c_ServiceName, "Product Type  :%c:",
                                st_ordbook.c_prd_typ );
  			fn_userlog( c_ServiceName, "Underlyng     :%s:",
                                st_ordbook.c_undrlyng );
  			fn_userlog( c_ServiceName, "Expiry date   :%s:",
                                st_ordbook.c_expry_dt);
  			fn_userlog( c_ServiceName, "Excercise Type:%c:",
                               st_ordbook.c_exrc_typ );
  			fn_userlog( c_ServiceName, "Option type   :%c:",
                               st_ordbook.c_opt_typ );
  			fn_userlog( c_ServiceName, "Strike price  :%ld:",
                               st_ordbook.l_strike_prc );
  			fn_userlog( c_ServiceName, "Category      :%c:",
                               st_ordbook.c_ctgry_indstk );
  			fn_userlog( c_ServiceName, "Order flow B/S:%c:",
                               st_ordbook.c_ordr_flw );
  			fn_userlog( c_ServiceName, "Lmt/Mkt/StpLss:%c:",
                               st_ordbook.c_slm_flg );
  			fn_userlog( c_ServiceName, "Order Qty     :%ld:",
                               st_ordbook.l_ord_tot_qty );
  			fn_userlog( c_ServiceName, "Limit rate    :%ld:",
                               st_ordbook.l_ord_lmt_rt );
  			fn_userlog( c_ServiceName, "CHANNEL   :%s:",
                                st_ordbook.c_channel);
  			fn_userlog( c_ServiceName, "ALIAS   :%s:",
                                c_alias);
			}

			st_ordbook.l_dsclsd_qty = 0 ;
			st_ordbook.l_stp_lss_tgr = 0 ;
			st_ordbook.c_ord_typ = IMMEDIATE_OR_CANCEL ;

      /** ver 3.1 starts ***/
      if( st_ordbook.c_slm_flg == 'M' )
      {
            MEMSET( c_err_msg);
            strcpy(c_err_msg,"2L/3L Market orders not allowd.Pls try placing limit orders.");  
            rtrim(c_err_msg);
            fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
            tpfree ( ( char * ) ptr_fml_Sbuf );
            tpfree ( ( char * ) ptr_fml_Rbuf );
            tpfree ( ( char * ) ptr_fml_Obuf );
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
            Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );    
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
      /** ver 3.1 ends **/
			if(i_cnt == 0 )
			{
	  		st_first_ordbk.l_ord_tot_qty = st_ordbook.l_ord_tot_qty;	
				strcpy(st_first_ordbk.c_xchng_cd ,st_ordbook.c_xchng_cd);
				st_first_ordbk.c_prd_typ = st_ordbook.c_prd_typ;
				strcpy(st_first_ordbk.c_undrlyng ,st_ordbook.c_undrlyng);
				strcpy(st_first_ordbk.c_expry_dt ,st_ordbook.c_expry_dt);
	  		st_first_ordbk.c_exrc_typ = st_ordbook.c_exrc_typ;	
				st_first_ordbk.c_opt_typ = st_ordbook.c_opt_typ;
				st_first_ordbk.l_strike_prc = st_ordbook.l_strike_prc;
			}
			else
			{
	  		st_next_ordbk.l_ord_tot_qty = st_ordbook.l_ord_tot_qty;	
				strcpy(st_next_ordbk.c_xchng_cd ,st_ordbook.c_xchng_cd);
				st_next_ordbk.c_prd_typ = st_ordbook.c_prd_typ;
				strcpy(st_next_ordbk.c_undrlyng ,st_ordbook.c_undrlyng);
				strcpy(st_next_ordbk.c_expry_dt ,st_ordbook.c_expry_dt);
	  		st_next_ordbk.c_exrc_typ = st_ordbook.c_exrc_typ;	
				st_next_ordbk.c_opt_typ = st_ordbook.c_opt_typ;
				st_next_ordbk.l_strike_prc = st_ordbook.l_strike_prc;

			/*******************************fo_plc_1clkord.pc
			Commented as order quantity need not be same order underlying need not be same

			if(st_first_ordbk.l_ord_tot_qty != st_next_ordbk.l_ord_tot_qty)
			{
      	fn_errlog( c_ServiceName, "B28549",DEFMSG,c_err_msg);
      	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    		tpfree ( ( char * ) ptr_fml_Sbuf );
    		tpfree ( ( char * ) ptr_fml_Rbuf );
    		tpfree ( ( char * ) ptr_fml_Obuf );
      	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}

			if( ( strcmp(st_first_ordbk.c_xchng_cd,st_next_ordbk.c_xchng_cd)!=0) ||
					(st_first_ordbk.c_prd_typ != st_next_ordbk.c_prd_typ) ||
			    ( strcmp(st_first_ordbk.c_undrlyng,st_next_ordbk.c_undrlyng)!=0) ) 
			{
      	fn_errlog( c_ServiceName, "B28550",DEFMSG,c_err_msg);
      	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    		tpfree ( ( char * ) ptr_fml_Sbuf );
    		tpfree ( ( char * ) ptr_fml_Rbuf );
    		tpfree ( ( char * ) ptr_fml_Obuf );
      	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			} 
			****************************************/

			if( ( strcmp(st_first_ordbk.c_xchng_cd,st_next_ordbk.c_xchng_cd)==0) &&
					(st_first_ordbk.c_prd_typ == st_next_ordbk.c_prd_typ)            &&
			    ( strcmp(st_first_ordbk.c_undrlyng,st_next_ordbk.c_undrlyng)==0) && 
			    ( strcmp(st_first_ordbk.c_expry_dt,st_next_ordbk.c_expry_dt)==0) && 
					(st_first_ordbk.c_exrc_typ == st_next_ordbk.c_exrc_typ)          &&
					(st_first_ordbk.c_opt_typ == st_next_ordbk.c_opt_typ)            &&
					(st_first_ordbk.l_strike_prc == st_next_ordbk.l_strike_prc)        )
					{
      			fn_errlog( c_ServiceName, "B28551",DEFMSG,c_err_msg);
      			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    				tpfree ( ( char * ) ptr_fml_Sbuf );
    				tpfree ( ( char * ) ptr_fml_Rbuf );
    				tpfree ( ( char * ) ptr_fml_Obuf );
      			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
      			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					} 
			}

			/***	Ver	1.8	Starts	***/

			EXEC SQL
				SELECT	NVL(CLM_SPAN_ALLWD,'N')
				INTO		:c_spn_allwd_flg
				FROM		CLM_CLNT_MSTR
				WHERE		CLM_MTCH_ACCNT	=	:st_usr_prfl.c_cln_mtch_accnt;

			if ( SQLCODE	!=	0	)
			{
				fn_errlog( c_ServiceName, "S31120",SQLMSG,c_err_msg);
      	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
      	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 ); 
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}

			fn_userlog(c_ServiceName,"SPAN ALLWD FLAG IS :%c:",c_spn_allwd_flg);

			if ( c_spn_allwd_flg == 'Y' )
			{
      	strcpy(c_srvc_nm,"SFO_SPN_PLC_ORD");
			}
			else if ( c_spn_allwd_flg == 'N' )
			{
				if( st_ordbook.c_prd_typ == 'F')
				{
					strcpy(c_srvc_nm,"SFO_FUT_PLC_ORD");
				}
				else if( st_ordbook.c_prd_typ == 'O')
				{
					strcpy(c_srvc_nm,"SFO_OPT_PLC_ORD");
				}
			}			/***	Ver	1.8	Ends	***/
			else
			{
				strcpy( c_err_msg, "Invalid product type");
				if(DEBUG_MSG_LVL_5)
				{
					fn_userlog( c_ServiceName, "Invalid product type :%c:",
																							st_ordbook.c_prd_typ);
				}
   			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
   			tpfree ( ( char * ) ptr_fml_Sbuf );
   			tpfree ( ( char * ) ptr_fml_Rbuf );
   			tpfree ( ( char * ) ptr_fml_Obuf );
   			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
   			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}

			/*** Ver 2.3  Starts ******/
			/* Ver 3.0 comment *** same will be called in individual product order placement **
  		i_returncode = fn_chk_und_insider(c_ServiceName,
       		                              st_usr_prfl,
          		                          st_ordbook.c_undrlyng,
              		                      &insider_exist);
  		if (i_returncode == -1)
  		{
      	fn_errlog( c_ServiceName, "S31125", "Error in Function fn_chk_und_insider", c_err_msg);
      	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	  }

  		if (insider_exist == 1)
  		{
      	fn_errlog( c_ServiceName, "B21042", DEFMSG, c_err_msg  );
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
      	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	  }
			*** Ver 3.0 comment end**/
  	/*** End of Ver 2.3 ***/


  		i_err[0] = Fchg32 ( ptr_fml_Sbuf, FFO_XCHNG_CD, 0,
                  										(char *)st_ordbook.c_xchng_cd, 0);
  		i_ferr [ 0 ] = Ferror32;

  		i_err[1] = Fchg32 ( ptr_fml_Sbuf, FFO_PRDCT_TYP, 0,
                  										(char *)&st_ordbook.c_prd_typ, 0);
  		i_ferr [ 1 ] = Ferror32;

  		i_err[2] = Fchg32 ( ptr_fml_Sbuf, FFO_UNDRLYNG, 0,
                  										(char *)st_ordbook.c_undrlyng, 0);
  		i_ferr [ 2 ] = Ferror32;

  		i_err[3] = Fchg32 ( ptr_fml_Sbuf, FFO_EXPRY_DT, 0,
                  										(char *)c_exp_dt.arr, 0);
  		i_ferr [ 3 ] = Ferror32;

  		i_err[4] = Fchg32 ( ptr_fml_Sbuf, FFO_EXER_TYP, 0,
                  										(char *)&st_ordbook.c_exrc_typ, 0);
  		i_ferr [ 4 ] = Ferror32;

  		i_err[5] = Fchg32 ( ptr_fml_Sbuf, FFO_OPT_TYP, 0,
                  										(char *)&st_ordbook.c_opt_typ, 0);
  		i_ferr [ 5 ] = Ferror32;

  		i_err[6] = Fchg32 ( ptr_fml_Sbuf, FFO_STRK_PRC, 0,
                  										(char *)&st_ordbook.l_strike_prc, 0);
  		i_ferr [ 6 ] = Ferror32;

  		i_err[7] = Fchg32 ( ptr_fml_Sbuf, FFO_CTGRY_INDSTK, 0,
                  										(char *)&st_ordbook.c_ctgry_indstk, 0);
  		i_ferr [ 7 ] = Ferror32;

  		i_err[8] = Fchg32 ( ptr_fml_Sbuf, FFO_ORDR_FLW, 0,
                  										(char *)&st_ordbook.c_ordr_flw, 0);
  		i_ferr [ 8 ] = Ferror32;

  		i_err[9] = Fchg32 ( ptr_fml_Sbuf, FFO_LMT_MKT_SL_FLG, 0,
                  										(char *)&st_ordbook.c_slm_flg, 0);
  		i_ferr [ 9 ] = Ferror32;

  		i_err[10] = Fchg32 ( ptr_fml_Sbuf, FFO_ORD_TYP, 0,
                  										(char *)&st_ordbook.c_ord_typ, 0);
  		i_ferr [ 10 ] = Ferror32;

  		i_err[11] = Fchg32 ( ptr_fml_Sbuf, FFO_ORD_TOT_QTY, 0,
                  										(char *)&st_ordbook.l_ord_tot_qty, 0);
  		i_ferr [ 11 ] = Ferror32;

  		i_err[12] = Fchg32 ( ptr_fml_Sbuf, FFO_LMT_RT, 0,
                  										(char *)&st_ordbook.l_ord_lmt_rt, 0);
  		i_ferr [ 12 ] = Ferror32;

  		i_err[13] = Fchg32 ( ptr_fml_Sbuf, FFO_DSCLSD_QTY, 0,
                  										(char *)&st_ordbook.l_dsclsd_qty, 0);
  		i_ferr [ 13 ] = Ferror32;

  		i_err[14] = Fchg32 ( ptr_fml_Sbuf, FFO_STP_LSS_TGR, 0,
                  										(char *)&st_ordbook.l_stp_lss_tgr, 0);
  		i_ferr [ 14 ] = Ferror32;

  		i_err[15] = Fchg32 ( ptr_fml_Sbuf, FFO_CHANNEL, 0,
                  										(char *)st_ordbook.c_channel, 0); /*1.1*/
  		i_ferr [ 15 ] = Ferror32;

  		i_err[16] = Fchg32 ( ptr_fml_Sbuf, FFO_ALIAS, 0,
                  										(char *)c_alias, 0); /*1.1*/
  		i_ferr [ 16 ] = Ferror32;

  		i_err[17] = Fchg32 ( ptr_fml_Sbuf, FFO_SPL_FLG, 0,
                  										(char *)&c_spl_flg, 0);
  		i_ferr [ 17 ] = Ferror32;

  		i_err[18] = Fchg32 ( ptr_fml_Sbuf, FFO_SVC_NAME, 0,
                  										(char *)c_srvc_nm, 0);
  		i_ferr [ 18 ] = Ferror32;

  		i_err[19] = Fchg32 ( ptr_fml_Sbuf, FFO_SPRD_ORD_IND, 0,
                  										(char *)&c_sprd_ord_ind, 0);
  		i_ferr [ 19 ] = Ferror32;

  		for(i=0; i < 20; i++)
  		{
  			if ( (i_err[ i ] == -1 ) )
				{
					fn_errlog( c_ServiceName, "S31130",
                                Fstrerror32(i_ferr[i]),c_err_msg);
   				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
   				tpfree ( ( char * ) ptr_fml_Sbuf );
   				tpfree ( ( char * ) ptr_fml_Rbuf );
   				tpfree ( ( char * ) ptr_fml_Obuf );
   				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
   				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
			}
      i_err[0]  = Fchg32 ( ptr_fml_Sbuf, FFO_OI_INDCTR, 0, (char *)c_ip_address, 0);/*ver 3.2 starts*/
      i_ferr [ 0 ] = Ferror32;

      if ( (i_err[ 0 ]  == -1 ) )
      {
          fn_errlog( c_ServiceName, "S31135", Fstrerror32(i_ferr[i]),c_err_msg);
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
          tpfree ( ( char * ) ptr_fml_Sbuf );
          tpfree ( ( char * ) ptr_fml_Rbuf );
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );    
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); 
      }                                                                               /*ver 3.2 end */
  		i_err[0]= Fget32(ptr_fml_Ibuf, FFO_SETTLOR,i_cnt,
                  											(char *)st_ordbook.c_settlor, 0);
  		i_ferr [ 0 ] = Ferror32;

 			if (( i_err[0] == -1 ) && ( i_ferr[0] != FNOTPRES ))
 			{
   			fn_errlog( c_ServiceName, "S31140", Fstrerror32(i_ferr[0]),c_err_msg);
   			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
   			tpfree ( ( char * ) ptr_fml_Sbuf );
   			tpfree ( ( char * ) ptr_fml_Rbuf );
   			tpfree ( ( char * ) ptr_fml_Obuf );
   			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
   			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
 			}
 			else if ( i_ferr[0] == FNOTPRES )
 			{
    		c_settlor_flg = NO;
 			}
			else
			{
    		c_settlor_flg = YES;
   			i_returncode = Fchg32 ( ptr_fml_Sbuf, FFO_SETTLOR, 0,
                  									(char *)st_ordbook.c_settlor, 0);
   			if ( i_returncode == -1 )
				{
					fn_errlog( c_ServiceName, "S31145",FMLMSG,c_err_msg);
   				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
   				tpfree ( ( char * ) ptr_fml_Sbuf );
   				tpfree ( ( char * ) ptr_fml_Rbuf );
   				tpfree ( ( char * ) ptr_fml_Obuf );
   				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
   				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
			}
  
      /**** Ver 2.9 Starts heree ****/
      MEMSET(c_mleg_pipe_id);
      if( i_cnt == 0 )
      {
        strcpy(c_mleg_pipe_id,"NA");
      }
      else
      {
        strcpy(c_mleg_pipe_id,c_pipe_id);
      }

      fn_userlog(c_ServiceName,"c_mleg_pipe_id :%s:",c_mleg_pipe_id);

      i_returncode = Fchg32 ( ptr_fml_Sbuf, FFO_INDX_CD, 0, (char *)c_mleg_pipe_id, 0);

      if ( i_returncode == -1 )
      {
        fn_errlog( c_ServiceName, "S31150",FMLMSG,c_err_msg);
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
        tpfree ( ( char * ) ptr_fml_Sbuf );
        tpfree ( ( char * ) ptr_fml_Rbuf );
        tpfree ( ( char * ) ptr_fml_Obuf );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); 
      }
      /**** Ver 2.9 Ends Here ****/
       

  		i_returncode = tpcall("SFO_ORD_ROUT", (char *)ptr_fml_Sbuf, 0,
                    	(char **)&ptr_fml_Rbuf, &l_recvbuff, 0);

  		if (i_returncode == -1)
  		{
    		if (TPCODE != TPESVCFAIL)
    		{
					fn_errlog( c_ServiceName, "S31155",TPMSG,c_err_msg);
    		}
    		else
    		{
      		i_returncode = Fget32(ptr_fml_Rbuf, FFO_ERR_MSG, 0, c_err_msg, 0);
      		if (i_returncode == -1)
      		{
						fn_errlog( c_ServiceName, "S31160",FMLMSG,c_err_msg);
    				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    				tpfree ( ( char * ) ptr_fml_Sbuf );
    				tpfree ( ( char * ) ptr_fml_Rbuf );
    				tpfree ( ( char * ) ptr_fml_Obuf );
    				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
    				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      		}
    		}
   			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
   			tpfree ( ( char * ) ptr_fml_Sbuf );
   			tpfree ( ( char * ) ptr_fml_Rbuf );
   			tpfree ( ( char * ) ptr_fml_Obuf );

			  /*-------------------------------------------------------------------------------------------------------*/
        /* Code below is added to show correct values of current limit in case a customer has insufficient limit */
        /* while placing 2L order. Here both orders are placed in a single transaction, if the customer has      */
        /* sufficient limit for the first then it gets blocked , and he doesn't have for the second order the    */
        /* limit we show should be the original limit and not the one after placement of first order.            */
        /* So only in case of insufficient limit for the second order we will call SFO_GET_LIMITS to show exact  */
        /* current limit.                                                                                        */

        if( strstr( c_err_msg,"Available Limits##" ) != NULL && i_cnt == 1 )
        {

          strcpy( c_regonize_error,c_err_msg );
          fn_userlog( c_ServiceName,"ERROR IS :%s:",c_err_msg );
          strtok( c_regonize_error,"#");
          fn_userlog( c_ServiceName,"ERROR is :%s:",c_regonize_error );

          fn_userlog( c_ServiceName," i_cnt is :%d:",i_cnt );
          fn_userlog( c_ServiceName," We Need to call service get limits " );

          EXEC SQL
               SELECT to_char(sysdate, 'DD-Mon-YYYY')
               INTO   :c_trade_dt
               FROM   DUAL;

          if( SQLCODE != 0 )
          {
            fn_errlog( c_ServiceName, "S31165", SQLMSG, c_err_msg);
            tpfree ( ( char * ) ptr_fml_Sbuf );
            tpfree ( ( char * ) ptr_fml_Rbuf );
            tpfree ( ( char * ) ptr_fml_Obuf );
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          }

          SETNULL(c_trade_dt);
          strcpy(st_gt_lmt_dtls.c_trd_dt,(char *) c_trade_dt.arr);
          strcpy( st_gt_lmt_dtls.c_cln_mtch_accnt,st_usr_prfl.c_cln_mtch_accnt);
          st_gt_lmt_dtls.c_rqst_typ = LIMIT_X_GID;
					st_gt_lmt_dtls.l_gid = 1;
          strcpy(st_gt_lmt_dtls.c_xchng_cd,"NFO");

          i_ip_len = sizeof ( struct vw_gt_lmt_dtls);

          fn_cpy_ddr(st_gt_lmt_dtls.c_rout_crt);

          /*** Commented in Ver 2.2 ******************** 	
				  i_returncode = fn_call_svc( c_ServiceName,
                                        c_err_msg,
                                        &st_gt_lmt_dtls,
                                        &st_gt_lmt_dtls,
                                        "vw_gt_lmt_dtls",
                                        "vw_gt_lmt_dtls",
                                        i_ip_len,
                                        i_ip_len,
                                        0,
                                        "SFO_GET_LIMITS" );
           ********* Ver 2.2 ***************************/

           /******** Ver 2.2 Starts Here ***************/

  					i_returncode = fo_get_trd_limit(c_ServiceName,
                                    				st_gt_lmt_dtls.c_cln_mtch_accnt,
                                    				st_gt_lmt_dtls.c_trd_dt,
                                    				st_gt_lmt_dtls.c_rqst_typ,
                                    				st_gt_lmt_dtls.c_xchng_cd,
                                    				st_gt_lmt_dtls.l_gid,
                                    				&st_gt_lmt_dtls.d_amt,
                                    				c_err_msg
                                    				);

           /******** Ver 2.2 Ends Here *****************/

           if ( i_returncode == -1 )
           {
             tpfree ( ( char * ) ptr_fml_Sbuf );
             tpfree ( ( char * ) ptr_fml_Rbuf );
             tpfree ( ( char * ) ptr_fml_Obuf );
             Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        		 Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
             tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
           }


					 d_limit_amt = st_gt_lmt_dtls.d_amt;

           fn_userlog( c_ServiceName,"Limit available is :%lf",d_limit_amt );

           strcat( c_regonize_error,"##");
           sprintf( c_err_msg,"%s:%0.2lf",c_regonize_error,d_limit_amt/100 );

         }

          /*----------------------Insuficient condition change for 2nd leg ends here-------------------------------*/
   			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
       	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
   			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  		}

  		i_returncode= Fget32(ptr_fml_Rbuf, FFO_ORDR_RFRNC,0,
     	           										(char *)st_ordbook.c_ordr_rfrnc, 0);

  		if (i_returncode == -1)
  		{
				fn_errlog( c_ServiceName, "S31170",FMLMSG,c_err_msg);
   			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
 				tpfree ( ( char * ) ptr_fml_Sbuf );
   			tpfree ( ( char * ) ptr_fml_Rbuf );
   			tpfree ( ( char * ) ptr_fml_Obuf );
 				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
       	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
 				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  		}

  		i_returncode= Fget32(ptr_fml_Rbuf, FFO_PIPE_ID,0,
                										(char *)c_pipe_id, 0);

  		if (i_returncode == -1)
  		{
				fn_errlog( c_ServiceName, "S31175",FMLMSG,c_err_msg);
   			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
 				tpfree ( ( char * ) ptr_fml_Sbuf );
   			tpfree ( ( char * ) ptr_fml_Rbuf );
   			tpfree ( ( char * ) ptr_fml_Obuf );
 				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
       	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
 				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}

			i_returncode = Fadd32 ( ptr_fml_Obuf, FFO_ORDR_RFRNC,
                										( char *)st_ordbook.c_ordr_rfrnc, 0 ); 
			if( i_returncode == -1)
  		{
   			fn_errlog( c_ServiceName, "S31180",FMLMSG,c_err_msg);
   			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
   			tpfree ( ( char * ) ptr_fml_Sbuf );
   			tpfree ( ( char * ) ptr_fml_Rbuf );
   			tpfree ( ( char * ) ptr_fml_Obuf );
   			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
       	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
   			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  		}

			i_err[0] = 0 ;
			i_ferr[0] = 0 ;

 			if ( Finit32 ( ptr_fml_Rbuf, 
									( FLDLEN32 ) Fsizeof32 ( ptr_fml_Rbuf ) ) == -1 )  

			/**Ver 1.3 starts **/
			{
      	fn_errlog( c_ServiceName, "S31185",FMLMSG,c_err_msg);
      	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
      	tpfree ( ( char * ) ptr_fml_Sbuf );
      	tpfree ( ( char * ) ptr_fml_Rbuf );
      	tpfree ( ( char * ) ptr_fml_Obuf );
     	 	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
       	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    	}
			/**Ver 1.3 ends **/

      /**** Ver 2.9 Starts Here *******/
      if( i_cnt == 0 )
      {
        strcpy( st_s_sequence.c_pipe_id, c_pipe_id);
        st_s_sequence.c_rqst_typ = GET_SPRDORD_SEQ;
        i_ip_len = sizeof ( struct vw_sequence );
        i_op_len = sizeof ( struct vw_sequence );
        fn_cpy_ddr ( st_s_sequence.c_rout_crt );

        i_returncode = fn_get_seq(c_ServiceName,c_err_msg,st_s_sequence.c_pipe_id,&st_r_sequence.l_seq_num,st_s_sequence.c_rqst_typ);
        if ( i_returncode != 0 )
        {
          fn_errlog( c_ServiceName, "S31190",FMLMSG,c_err_msg);
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
          tpfree ( ( char * ) ptr_fml_Sbuf );
          tpfree ( ( char * ) ptr_fml_Rbuf );
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 ); 
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); 
        }

        l_sprdord_seq_num = st_r_sequence.l_seq_num;
        sprintf( c_seq_num, "%08d", l_sprdord_seq_num );
        strcpy( c_sprdordr_rfrnc, (char *)c_date.arr );
        strcat( c_sprdordr_rfrnc, c_pipe_id );
        strcat( c_sprdordr_rfrnc, c_seq_num );
      }
      /**** Ver 2.9 Ends Here ********/ 

			strcpy( st_spd_ordbk.c_sprd_ord_rfrnc[i_cnt],c_sprdordr_rfrnc );
			strcpy( st_spd_ordbk.c_ordr_rfrnc[i_cnt],st_ordbook.c_ordr_rfrnc );
			st_spd_ordbk.c_sprd_ord_ind[i_cnt] = c_sprd_ord_ind;
			strcpy( st_spd_ordbk.c_pipe_id[i_cnt],c_pipe_id );
			st_spd_ordbk.l_mdfctn_cntr[i_cnt] = 1;
			st_spd_ordbk.l_ord_tot_qty[i_cnt] = st_ordbook.l_ord_tot_qty;
			st_spd_ordbk.c_rqst_typ[i_cnt] = INSERT_ON_ORDER_PLACEMENT;

			if(DEBUG_MSG_LVL_5)
			{
				fn_userlog(c_ServiceName,"Printing Values for Instance:%d:",i_cnt);
				fn_userlog(c_ServiceName,"st_spd_ordbk.c_sprd_ord_rfrnc:%s:",st_spd_ordbk.c_sprd_ord_rfrnc[i_cnt]);
				fn_userlog(c_ServiceName,"st_spd_ordbk.c_ordr_rfrnc[i_cnt]:%s:",st_spd_ordbk.c_ordr_rfrnc[i_cnt]);
				fn_userlog(c_ServiceName,"st_spd_ordbk.c_sprd_ord_ind[i_cnt]:%d:",st_spd_ordbk.c_sprd_ord_ind[i_cnt]);
				fn_userlog(c_ServiceName,"st_spd_ordbk.c_pipe_id[i_cnt]:%s:",st_spd_ordbk.c_pipe_id[i_cnt]);
				fn_userlog(c_ServiceName,"st_spd_ordbk.l_mdfctn_cntr[i_cnt]:%ld:",st_spd_ordbk.l_mdfctn_cntr[i_cnt]);
				fn_userlog(c_ServiceName,"st_spd_ordbk.l_ord_tot_qty[i_cnt]:%ld:",st_spd_ordbk.l_ord_tot_qty[i_cnt]);
			}
		}

  	tpfree ( ( char * ) ptr_fml_Rbuf );
  	tpfree ( ( char * ) ptr_fml_Sbuf );

  	i_ip_len = sizeof ( struct vw_spdordbk );
  	i_op_len = sizeof ( struct vw_spdordbk );

  	fn_cpy_ddr ( st_spd_ordbk.c_rout_crt );
  	i_returncode = fn_call_svc( c_ServiceName,
                              	c_err_msg,
                              	&st_spd_ordbk,
                              	&st_spd_ordbk,
                              	"vw_spdordbk",
                              	"vw_spdordbk",
                              	i_ip_len,
                              	i_op_len,
                              	0,
                              	"SFO_UPD_SPDBK" );
  	if ( i_returncode != 0 )
  	{
    	fn_errlog( c_ServiceName, "S31195", LIBMSG, c_err_msg  );
    	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    	tpfree ( ( char * ) ptr_fml_Obuf );
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	}


  	if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg ) == -1 )
  	{
    	tpfree ( ( char * ) ptr_fml_Obuf );
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	}

	} 
	else if( c_is_flg == 'D' ) /* Introduced c_is_flg in Ver 1.4 for Investment Strategy & separated the code into 2 parts */
	{

		if(DEBUG_MSG_LVL_5)
		{
			fn_userlog(c_ServiceName,"INSIDE DS AREA");
		}

  	i_trnsctn = fn_begintran( c_ServiceName, c_err_msg );
  	if ( i_trnsctn == -1 )
  	{
   		fn_errlog( c_ServiceName, "S31200", LIBMSG , c_err_msg );
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	}
		
  	/* i_returncode = fn_lock_usr( c_ServiceName,
                                st_usr_prfl.c_cln_mtch_accnt ); commented in Ver 3.3 */
  	i_returncode = fn_lock_fno( c_ServiceName, st_usr_prfl.c_cln_mtch_accnt ); /* added in Ver 3.3 */
  	if ( i_returncode == -1 )
  	{
   		fn_errlog( c_ServiceName, "S31205", LIBMSG , c_err_msg );
    	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	}

  	EXEC SQL
    		 SELECT to_char( exg_nxt_trd_dt, 'DD-Mon-YYYY' ),
           			to_char( exg_nxt_trd_dt, 'YYYYMMDD' ),
					 			exg_crrnt_stts
    		 INTO   :c_trd_dt,
           			:c_date,
					 			:c_exg_stts
    		 FROM   exg_xchng_mstr
    		 WHERE  exg_xchng_cd = :st_ordbook.c_xchng_cd
    		 AND    exg_mkt_typ  = 'D';

  	if ( SQLCODE != 0 )
  	{
    	fn_errlog( c_ServiceName, "S31210",SQLMSG,c_err_msg);
 			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	}

  	SETNULL ( c_trd_dt );
  	SETNULL ( c_date );

		if( c_exg_stts != EXCHANGE_OPEN )
		{
			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    	fn_errlog( c_ServiceName, "B28010",DEFMSG,c_err_msg);
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}

		if ( c_opn_typ == '2' )
    {
      i_tot_rec = 2;
      c_spl_flg = L2_ORDER;
      c_sprd_ord_ind = L2_ORDER;
    }

  	for( i_cnt=0; i_cnt < i_tot_rec; i_cnt++)
  	{
    	i_err[0]= Fget32(ptr_fml_Ibuf, FFO_XCHNG_CD,i_cnt,
                  									 (char *)st_temp_ordbook.c_xchng_cd, 0);
    	i_ferr [ 0 ] = Ferror32;

    	i_err[1]= Fget32(ptr_fml_Ibuf, FFO_PRDCT_TYP,i_cnt,
                  									 (char *)&st_temp_ordbook.c_prd_typ, 0);
    	i_ferr [ 1 ] = Ferror32;

    	i_err[2]= Fget32(ptr_fml_Ibuf, FFO_UNDRLYNG,i_cnt,
                  									 (char *)st_temp_ordbook.c_undrlyng, 0);
    	i_ferr [ 2 ] = Ferror32;

    	i_err[3]= Fget32(ptr_fml_Ibuf, FFO_EXPRY_DT,i_cnt,
                  									 (char *)c_exp_dt.arr, 0);
    	i_ferr [ 3 ] = Ferror32;

    	i_err[4]= Fget32(ptr_fml_Ibuf, FFO_EXER_TYP,i_cnt,
                  									 (char *)&st_temp_ordbook.c_exrc_typ, 0);
    	i_ferr [ 4 ] = Ferror32;

    	i_err[5]= Fget32(ptr_fml_Ibuf, FFO_OPT_TYP,i_cnt,
                  									 (char *)&st_temp_ordbook.c_opt_typ, 0);
    	i_ferr [ 5 ] = Ferror32;

    	i_err[6]= Fget32(ptr_fml_Ibuf, FFO_STRK_PRC,i_cnt,
                  									 (char *)&st_temp_ordbook.l_strike_prc, 0);
    	i_ferr [ 6 ] = Ferror32;

    	i_err[7]= Fget32(ptr_fml_Ibuf, FFO_CTGRY_INDSTK,i_cnt,
                  									 (char *)&st_temp_ordbook.c_ctgry_indstk, 0);
    	i_ferr [ 7 ] = Ferror32;

    	i_err[8]= Fget32(ptr_fml_Ibuf, FFO_ORDR_FLW,i_cnt,
                  									 (char *)&st_temp_ordbook.c_ordr_flw, 0);
    	i_ferr [ 8 ] = Ferror32;

    	i_err[9]= Fget32(ptr_fml_Ibuf, FFO_LMT_MKT_SL_FLG,i_cnt,
                  									 (char *)&st_temp_ordbook.c_slm_flg, 0);
    	i_ferr [ 9 ] = Ferror32;

    	i_err[10]= Fget32(ptr_fml_Ibuf, FFO_LMT_RT,i_cnt,
                  										(char *)&st_temp_ordbook.l_ord_lmt_rt, 0);
    	i_ferr [ 10 ] = Ferror32;

    	i_err[11]= Fget32(ptr_fml_Ibuf, FFO_CHANNEL,i_cnt,
                  										(char *)st_temp_ordbook.c_channel, 0); /*1.1*/
    	i_ferr [ 11 ] = Ferror32;

			i_err[12]= Fget32(ptr_fml_Ibuf, FFO_ORD_TOT_QTY,i_cnt,
                                      (char *)&st_temp_ordbook.l_ord_tot_qty, 0);
      i_ferr [ 12 ] = Ferror32;
		
			i_err[13]= Fget32(ptr_fml_Ibuf, FFO_LMT_RT,i_cnt,
                                      (char *)&st_ordbook.l_ord_lmt_rt, 0);
			i_ferr [ 13 ] = Ferror32;


    	for(i=0; i < 14; i++)
    	{
   			if ( (i_err[ i ] == -1 ) )
				{
					fn_errlog( c_ServiceName, "S31215",
                                 Fstrerror32(i_ferr[i]),c_err_msg);
					fn_userlog(c_ServiceName,"Error in field %d in record no %d",i,i_cnt );
   				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
   				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
   				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}
			}

			SETLEN(c_exp_dt);

			i_err[0]= Fget32(ptr_fml_Ibuf, FFO_SETTLOR,i_cnt,
                                     (char *)st_temp_ordbook.c_settlor, 0);
    	i_ferr [ 0 ] = Ferror32;

    	if (( i_err[0] == -1 ) && ( i_ferr[0] != FNOTPRES ))
    	{
      	fn_errlog( c_ServiceName, "S31220", Fstrerror32(i_ferr[0]),c_err_msg);
      	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
      	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
      	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    	}
    	else if ( i_ferr[0] == FNOTPRES )
    	{
      	c_settlor_flg = NO;
    	}
    	else
    	{
      	c_settlor_flg = YES;
    	}

			if(i_cnt == 0 )
      {
        st_first_ordbk.l_ord_tot_qty = st_temp_ordbook.l_ord_tot_qty;
        strcpy(st_first_ordbk.c_xchng_cd ,st_temp_ordbook.c_xchng_cd);
        st_first_ordbk.c_prd_typ = st_temp_ordbook.c_prd_typ;
        strcpy(st_first_ordbk.c_undrlyng ,st_temp_ordbook.c_undrlyng);
        strcpy(st_first_ordbk.c_expry_dt ,st_temp_ordbook.c_expry_dt);
        st_first_ordbk.c_exrc_typ = st_temp_ordbook.c_exrc_typ;
        st_first_ordbk.c_opt_typ = st_temp_ordbook.c_opt_typ;
				st_first_ordbk.c_ctgry_indstk = st_temp_ordbook.c_ctgry_indstk;
        st_first_ordbk.l_strike_prc = st_temp_ordbook.l_strike_prc;
				st_first_ordbk.c_ordr_flw = st_temp_ordbook.c_ordr_flw;
				st_first_ordbk.c_slm_flg = st_temp_ordbook.c_slm_flg;
				strcpy(st_first_ordbk.c_channel,st_temp_ordbook.c_channel);
				st_first_ordbk.l_ord_lmt_rt = st_ordbook.l_ord_lmt_rt;
				if( c_settlor_flg == YES )
				{
				strcpy(st_first_ordbk.c_settlor,st_temp_ordbook.c_settlor);
				}
      }
      else
      {
        st_next_ordbk.l_ord_tot_qty = st_temp_ordbook.l_ord_tot_qty;
        strcpy(st_next_ordbk.c_xchng_cd ,st_temp_ordbook.c_xchng_cd);
        st_next_ordbk.c_prd_typ = st_temp_ordbook.c_prd_typ;
        strcpy(st_next_ordbk.c_undrlyng ,st_temp_ordbook.c_undrlyng);
        strcpy(st_next_ordbk.c_expry_dt ,st_temp_ordbook.c_expry_dt);
        st_next_ordbk.c_exrc_typ = st_temp_ordbook.c_exrc_typ;
        st_next_ordbk.c_opt_typ = st_temp_ordbook.c_opt_typ;
				st_next_ordbk.c_ctgry_indstk = st_temp_ordbook.c_ctgry_indstk;
        st_next_ordbk.l_strike_prc = st_temp_ordbook.l_strike_prc;
				st_next_ordbk.c_ordr_flw = st_temp_ordbook.c_ordr_flw;
				st_next_ordbk.c_slm_flg = st_temp_ordbook.c_slm_flg;
				strcpy(st_next_ordbk.c_channel,st_temp_ordbook.c_channel);
				st_next_ordbk.l_ord_lmt_rt = st_ordbook.l_ord_lmt_rt;
				if( c_settlor_flg == YES )
				{
				strcpy(st_first_ordbk.c_settlor,st_temp_ordbook.c_settlor);
				}
			}

		} /* End of loop using i_cnt for getting details of both orders */

		if(DEBUG_MSG_LVL_5)
		{
			fn_userlog( c_ServiceName, "Total qty 1 is :%ld:",st_first_ordbk.l_ord_tot_qty );
			fn_userlog( c_ServiceName, "Exchange code is :%s:",st_first_ordbk.c_xchng_cd );
			fn_userlog( c_ServiceName, "Product type is :%c:",st_first_ordbk.c_prd_typ );
			fn_userlog( c_ServiceName, "Undrlyng is :%s:",st_first_ordbk.c_undrlyng );
			fn_userlog( c_ServiceName, "Expry dt is :%s:",c_exp_dt.arr );
			fn_userlog( c_ServiceName, "Exer typ is :%c:",st_first_ordbk.c_exrc_typ );
			fn_userlog( c_ServiceName, "Opt type is :%c:",st_first_ordbk.c_opt_typ );
			fn_userlog( c_ServiceName, "Strike Price is :%ld:",st_first_ordbk.l_strike_prc );
			fn_userlog( c_ServiceName, "Index/Stock is :%c:",st_first_ordbk.c_ctgry_indstk );
			fn_userlog( c_ServiceName, "Order Flow is :%c:",st_first_ordbk.c_ordr_flw );
			fn_userlog( c_ServiceName, "SLM Flag is :%c:",st_first_ordbk.c_slm_flg );
			
			fn_userlog( c_ServiceName, "Total qty 1 is :%ld:",st_next_ordbk.l_ord_tot_qty );
      fn_userlog( c_ServiceName, "Exchange code is :%s:",st_next_ordbk.c_xchng_cd );
      fn_userlog( c_ServiceName, "Product type is :%c:",st_next_ordbk.c_prd_typ );
      fn_userlog( c_ServiceName, "Undrlyng is :%s:",st_next_ordbk.c_undrlyng );
      fn_userlog( c_ServiceName, "Expry dt is :%s:",c_exp_dt.arr );
      fn_userlog( c_ServiceName, "Exer typ is :%c:",st_next_ordbk.c_exrc_typ );
      fn_userlog( c_ServiceName, "Opt type is :%c:",st_next_ordbk.c_opt_typ );
      fn_userlog( c_ServiceName, "Strike Price is :%ld:",st_next_ordbk.l_strike_prc );
      fn_userlog( c_ServiceName, "Index/Stock is :%c:",st_next_ordbk.c_ctgry_indstk );
			fn_userlog( c_ServiceName, "Order Flow is :%c:",st_next_ordbk.c_ordr_flw );
      fn_userlog( c_ServiceName, "SLM Flag is :%c:",st_next_ordbk.c_slm_flg );
		}
		
	/*** Commented in Ver 2.4  ***
	
		EXEC SQL
         SELECT fcm_lot_sz
         INTO   :l_lot_size
         FROM   fcm_fo_cntrct_mstr
         WHERE  fcm_xchng_cd  = :st_first_ordbk.c_xchng_cd
         AND    fcm_prdct_typ = :st_first_ordbk.c_prd_typ
         AND    fcm_indstk    = :st_first_ordbk.c_ctgry_indstk
         AND    fcm_undrlyng  = :st_first_ordbk.c_undrlyng
         AND    fcm_expry_dt  = :c_exp_dt
         AND    fcm_exer_typ  = :st_first_ordbk.c_exrc_typ
         AND    fcm_opt_typ   = :st_first_ordbk.c_opt_typ
         AND    fcm_strk_prc  = :st_first_ordbk.l_strike_prc;

	*** Ver 2.4 comment Ends ***/

	/*** Ver 2.4 Starts ***/

		EXEC SQL
         SELECT ftq_min_lot_qty
         INTO   :l_lot_size
         FROM   ftq_fo_trd_qt
         WHERE  ftq_xchng_cd  = :st_first_ordbk.c_xchng_cd
         AND    ftq_prdct_typ = :st_first_ordbk.c_prd_typ
         AND    ftq_indstk    = :st_first_ordbk.c_ctgry_indstk
         AND    ftq_undrlyng  = :st_first_ordbk.c_undrlyng
         AND    ftq_expry_dt  = :c_exp_dt
         AND    ftq_exer_typ  = :st_first_ordbk.c_exrc_typ
         AND    ftq_opt_typ   = :st_first_ordbk.c_opt_typ
         AND    ftq_strk_prc  = :st_first_ordbk.l_strike_prc;

	/*** Ver 2.4 Ends ***/

    if ( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31225",SQLMSG,c_err_msg);
      fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

		if(DEBUG_MSG_LVL_0) /*** Added in Ver 2.4 ***/
		{
			fn_userlog(c_ServiceName,"Lot Size Is :%ld:",l_lot_size);
		}

    l_no_of_calls = st_first_ordbk.l_ord_tot_qty/l_lot_size;

		for( i_counter = 0; i_counter < l_no_of_calls; i_counter++ )
		{
			strcpy ( st_first_ordbk.c_expry_dt, ( char * ) c_exp_dt.arr );
			strcpy ( st_next_ordbk.c_expry_dt, ( char * ) c_exp_dt.arr );

			st_first_ordbk.l_ord_tot_qty = l_lot_size;
			st_next_ordbk.l_ord_tot_qty = l_lot_size;

      /**** Commented in ver 2.9 starts here ************
			strcpy( st_s_sequence.c_pipe_id, st_usr_prfl.c_pipe_id );
      strcpy( st_s_sequence.c_trd_dt, (char *) c_trd_dt.arr );
      st_s_sequence.c_rqst_typ = GET_SPRDORD_SEQ;

      i_ip_len = sizeof ( struct vw_sequence );
      i_op_len = sizeof ( struct vw_sequence );
      fn_cpy_ddr ( st_s_sequence.c_rout_crt );
      ********* Comment 2.9, ends here ****************/

			/*********** Commented in Ver 2.7 **********
      i_returncode = fn_call_svc( c_ServiceName,
                                  c_err_msg,
                                  &st_s_sequence,
                                  &st_r_sequence,
                                  "vw_sequence",
                                  "vw_sequence",
                                  i_ip_len,
                                  i_op_len,
                                  0,
                                  "SFO_GET_SEQ" );
			********** Comment End in Ver 2.7  **********/
		  /*** Added in Ver 2.7 ***/
      /******** Ver 2.9, comment starts here *************
  		if(DEBUG_MSG_LVL_5)
  		{
    		fn_userlog(c_ServiceName,"Before Calling function fn_get_seq **********");
  		}
  		i_returncode = fn_get_seq(c_ServiceName,c_err_msg,st_s_sequence.c_pipe_id,&st_r_sequence.l_seq_num,st_s_sequence.c_rqst_typ);
    	*** Add ended in Ver 2.7 ***
      if ( i_returncode != 0 )
      {
        fn_errlog( c_ServiceName, "S31230", LIBMSG, c_err_msg  );
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      ***  Ver 1.7 ***
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

      l_sprdord_seq_num = st_r_sequence.l_seq_num;
      sprintf( c_seq_num, "%08d", l_sprdord_seq_num );
      strcpy( c_sprdordr_rfrnc, (char *)c_date.arr );
      strcat( c_sprdordr_rfrnc, st_usr_prfl.c_pipe_id );
      strcat( c_sprdordr_rfrnc, c_seq_num );
      *********** Ver 2.9 Comment edns Here ***************/

			for( i_cnt = 0; i_cnt < 2; i_cnt++ )
			{
			
				sql_fop_opnpstn_qty = 0;
				sql_ffp_opnpstn_qty = 0;

				ptr_fml_Sbuf = (FBFR32 *)tpalloc( "FML32", NULL, MIN_FML_BUF_LEN*3 );
    		if ( ptr_fml_Sbuf == NULL )
    		{
      		fn_errlog( c_ServiceName, "S31235", TPMSG, c_err_msg  );
      		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
      		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
      		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    		}

    		i_returncode = Fvstof32( ptr_fml_Sbuf, (char *) &st_usr_prfl,
                              	 FUPDATE, "vw_usr_prfl" );
    		if ( i_returncode == -1 )
    		{
      		fn_errlog( c_ServiceName, "S31240", FMLMSG, c_err_msg  );
      		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
      		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
      		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    		}

    		ptr_fml_Rbuf = (FBFR32 *)tpalloc( "FML32", NULL, MIN_FML_BUF_LEN*3 );

    		if ( ptr_fml_Rbuf == NULL )
    		{
      		fn_errlog( c_ServiceName, "S31245", TPMSG, c_err_msg  );
      		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
      		tpfree ( ( char * ) ptr_fml_Sbuf );
      		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
      		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    		}

    		ptr_fml_Obuf = (FBFR32 *)tpalloc( "FML32", NULL, MIN_FML_BUF_LEN*3 );

    		if ( ptr_fml_Obuf == NULL )
    		{
      		fn_errlog( c_ServiceName, "S31250", TPMSG, c_err_msg  );
      		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
      		tpfree ( ( char * ) ptr_fml_Sbuf );
      		tpfree ( ( char * ) ptr_fml_Rbuf );
      		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
      		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    		}
			
      	if(st_usr_prfl.c_user_id[0] == BPID)
      	{
        	if(Fget32(ptr_fml_Ibuf,FFO_ALIAS,i_cnt,(char *)c_alias,0) == -1)
        	{
          	fn_errlog( c_ServiceName, "S31255", FMLMSG, c_err_msg  );
          	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
          	tpfree ( ( char * ) ptr_fml_Sbuf );
          	tpfree ( ( char * ) ptr_fml_Rbuf );
          	tpfree ( ( char * ) ptr_fml_Obuf );
          	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
          	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        	}
      	}

				if( i_cnt%2 == 0 )
				{
					st_ordbook.l_ord_tot_qty = st_first_ordbk.l_ord_tot_qty;
        	strcpy(st_ordbook.c_xchng_cd ,st_first_ordbk.c_xchng_cd);
        	st_ordbook.c_prd_typ = st_first_ordbk.c_prd_typ;
        	strcpy(st_ordbook.c_undrlyng ,st_first_ordbk.c_undrlyng);
        	strcpy(st_ordbook.c_expry_dt ,st_first_ordbk.c_expry_dt);
        	st_ordbook.c_exrc_typ = st_first_ordbk.c_exrc_typ;
        	st_ordbook.c_opt_typ = st_first_ordbk.c_opt_typ;
        	st_ordbook.l_strike_prc = st_first_ordbk.l_strike_prc;
					st_ordbook.c_ctgry_indstk = st_first_ordbk.c_ctgry_indstk;
					st_ordbook.c_ordr_flw = st_first_ordbk.c_ordr_flw;
        	st_ordbook.c_slm_flg = st_first_ordbk.c_slm_flg;
					strcpy(st_ordbook.c_channel,st_first_ordbk.c_channel);
					st_ordbook.l_ord_lmt_rt = st_first_ordbk.l_ord_lmt_rt;
					if( c_settlor_flg == YES )
        	{
        		strcpy(st_ordbook.c_settlor,st_first_ordbk.c_settlor);
        	}
				}
				else
				{
					st_ordbook.l_ord_tot_qty = st_next_ordbk.l_ord_tot_qty;
        	strcpy(st_ordbook.c_xchng_cd ,st_next_ordbk.c_xchng_cd);
        	st_ordbook.c_prd_typ = st_next_ordbk.c_prd_typ;
        	strcpy(st_ordbook.c_undrlyng ,st_next_ordbk.c_undrlyng);
        	strcpy(st_ordbook.c_expry_dt ,st_next_ordbk.c_expry_dt);
        	st_ordbook.c_exrc_typ = st_next_ordbk.c_exrc_typ;
        	st_ordbook.c_opt_typ = st_next_ordbk.c_opt_typ;
        	st_ordbook.l_strike_prc = st_next_ordbk.l_strike_prc;
					st_ordbook.c_ctgry_indstk = st_next_ordbk.c_ctgry_indstk;
					st_ordbook.c_ordr_flw = st_next_ordbk.c_ordr_flw;
        	st_ordbook.c_slm_flg = st_next_ordbk.c_slm_flg;
					strcpy(st_ordbook.c_channel,st_next_ordbk.c_channel);
					st_ordbook.l_ord_lmt_rt = st_next_ordbk.l_ord_lmt_rt;
					if( c_settlor_flg == YES )
        	{
        		strcpy(st_ordbook.c_settlor,st_next_ordbk.c_settlor);
        	}
				}

				st_ordbook.l_dsclsd_qty = 0 ;
				st_ordbook.l_stp_lss_tgr = 0 ;
				st_ordbook.c_ord_typ = IMMEDIATE_OR_CANCEL ;

				/***  Ver 1.8 Starts  ***/

      	EXEC SQL
        	SELECT  NVL(CLM_SPAN_ALLWD,'N')
        	INTO    :c_spn_allwd_flg
        	FROM    CLM_CLNT_MSTR
        	WHERE   CLM_MTCH_ACCNT  = :st_usr_prfl.c_cln_mtch_accnt;

      	if ( SQLCODE  !=  0 )
      	{
        	fn_errlog( c_ServiceName, "S31260",SQLMSG,c_err_msg);
        	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
        	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );
        	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      	}

     	 fn_userlog(c_ServiceName,"SPAN ALLWD FLAG IS :%c:",c_spn_allwd_flg);

      	if ( c_spn_allwd_flg == 'Y' )
      	{
        	strcpy(c_srvc_nm,"SFO_SPN_PLC_ORD");
      	}
      	else if ( c_spn_allwd_flg == 'N' )
      	{
        	if( st_ordbook.c_prd_typ == 'F')
        	{
          	strcpy(c_srvc_nm,"SFO_FUT_PLC_ORD");
        	}
        	else if( st_ordbook.c_prd_typ == 'O')
        	{
          	strcpy(c_srvc_nm,"SFO_OPT_PLC_ORD");
        	}
      	}     /***  Ver 1.8 Ends  ***/
				else
				{
					strcpy( c_err_msg, "Invalid product type");

					if(DEBUG_MSG_LVL_5)
					{
						fn_userlog( c_ServiceName, "Invalid product type :%c:", st_ordbook.c_prd_typ);
					}

   				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
   				tpfree ( ( char * ) ptr_fml_Sbuf );
   				tpfree ( ( char * ) ptr_fml_Rbuf );
   				tpfree ( ( char * ) ptr_fml_Obuf );
   				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
   				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}

  			i_err[0] = Fchg32 ( ptr_fml_Sbuf, FFO_XCHNG_CD, 0,
                  												(char *)st_ordbook.c_xchng_cd, 0);
  			i_ferr [ 0 ] = Ferror32;

  			i_err[1] = Fchg32 ( ptr_fml_Sbuf, FFO_PRDCT_TYP, 0,
                  												(char *)&st_ordbook.c_prd_typ, 0);
  			i_ferr [ 1 ] = Ferror32;

  			i_err[2] = Fchg32 ( ptr_fml_Sbuf, FFO_UNDRLYNG, 0,
                  												(char *)st_ordbook.c_undrlyng, 0);
  			i_ferr [ 2 ] = Ferror32;

  			i_err[3] = Fchg32 ( ptr_fml_Sbuf, FFO_EXPRY_DT, 0,
                  												(char *)c_exp_dt.arr, 0);
  			i_ferr [ 3 ] = Ferror32;

  			i_err[4] = Fchg32 ( ptr_fml_Sbuf, FFO_EXER_TYP, 0,
                  												(char *)&st_ordbook.c_exrc_typ, 0);
  			i_ferr [ 4 ] = Ferror32;

  			i_err[5] = Fchg32 ( ptr_fml_Sbuf, FFO_OPT_TYP, 0,
                  												(char *)&st_ordbook.c_opt_typ, 0);
  			i_ferr [ 5 ] = Ferror32;

  			i_err[6] = Fchg32 ( ptr_fml_Sbuf, FFO_STRK_PRC, 0,
                  												(char *)&st_ordbook.l_strike_prc, 0);
  			i_ferr [ 6 ] = Ferror32;

  			i_err[7] = Fchg32 ( ptr_fml_Sbuf, FFO_CTGRY_INDSTK, 0,
                  												(char *)&st_ordbook.c_ctgry_indstk, 0);
  			i_ferr [ 7 ] = Ferror32;

  			i_err[8] = Fchg32 ( ptr_fml_Sbuf, FFO_ORDR_FLW, 0,
                  												(char *)&st_ordbook.c_ordr_flw, 0);
  			i_ferr [ 8 ] = Ferror32;

  			i_err[9] = Fchg32 ( ptr_fml_Sbuf, FFO_LMT_MKT_SL_FLG, 0,
                  												(char *)&st_ordbook.c_slm_flg, 0);
  			i_ferr [ 9 ] = Ferror32;

  			i_err[10] = Fchg32 ( ptr_fml_Sbuf, FFO_ORD_TYP, 0,
                  												 (char *)&st_ordbook.c_ord_typ, 0);
  			i_ferr [ 10 ] = Ferror32;

  			i_err[11] = Fchg32 ( ptr_fml_Sbuf, FFO_ORD_TOT_QTY, 0,
                  												 (char *)&l_lot_size, 0);
  			i_ferr [ 11 ] = Ferror32;

  			i_err[12] = Fchg32 ( ptr_fml_Sbuf, FFO_LMT_RT, 0,
                  										     (char *)&st_ordbook.l_ord_lmt_rt, 0);
  			i_ferr [ 12 ] = Ferror32;

  			i_err[13] = Fchg32 ( ptr_fml_Sbuf, FFO_DSCLSD_QTY, 0,
                  												 (char *)&st_ordbook.l_dsclsd_qty, 0);
  			i_ferr [ 13 ] = Ferror32;

  			i_err[14] = Fchg32 ( ptr_fml_Sbuf, FFO_STP_LSS_TGR, 0,
                  										     (char *)&st_ordbook.l_stp_lss_tgr, 0);
  			i_ferr [ 14 ] = Ferror32;

  			i_err[15] = Fchg32 ( ptr_fml_Sbuf, FFO_CHANNEL, 0,
                  												 (char *)st_ordbook.c_channel, 0); 
  			i_ferr [ 15 ] = Ferror32;

  			i_err[16] = Fchg32 ( ptr_fml_Sbuf, FFO_ALIAS, 0,
                  												 (char *)c_alias, 0); 
  			i_ferr [ 16 ] = Ferror32;

  			i_err[17] = Fchg32 ( ptr_fml_Sbuf, FFO_SPL_FLG, 0,
                  												 (char *)&c_spl_flg, 0);
  			i_ferr [ 17 ] = Ferror32;

  			i_err[18] = Fchg32 ( ptr_fml_Sbuf, FFO_SVC_NAME, 0,
                  												 (char *)c_srvc_nm, 0);
  			i_ferr [ 18 ] = Ferror32;

  			i_err[19] = Fchg32 ( ptr_fml_Sbuf, FFO_SPRD_ORD_IND, 0,
                  												 (char *)&c_sprd_ord_ind, 0);
  			i_ferr [ 19 ] = Ferror32;
        

  			for(i=0; i < 20; i++)
  			{
  				if ( (i_err[ i ] == -1 ) )
					{
						fn_errlog( c_ServiceName, "S31265", Fstrerror32(i_ferr[i]),c_err_msg);
   					fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
   					tpfree ( ( char * ) ptr_fml_Sbuf );
   					tpfree ( ( char * ) ptr_fml_Rbuf );
   					tpfree ( ( char * ) ptr_fml_Obuf );
   					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
   					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
					}
				

}
        i_err[0]= Fchg32 ( ptr_fml_Sbuf, FFO_OI_INDCTR, 0, (char *)c_ip_address, 0); /**ver 3.2 start:**/
          i_ferr[ 0 ] = Ferror32;

         if ( (i_err[0  ] == -1 ) )
             {
               fn_errlog( c_ServiceName, "S31270", Fstrerror32(i_ferr[i]),c_err_msg);
              fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
               tpfree ( ( char * ) ptr_fml_Sbuf );
               tpfree ( ( char * ) ptr_fml_Rbuf );
               tpfree ( ( char * ) ptr_fml_Obuf );
               Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
               Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }                                                                         /*ver 3.2  end*/

				if( c_settlor_flg == YES )
				{
					i_returncode = Fchg32 ( ptr_fml_Sbuf, FFO_SETTLOR, 0, (char *)st_ordbook.c_settlor, 0);
      		if ( i_returncode == -1 )
      		{
        		fn_errlog( c_ServiceName, "S31275",FMLMSG,c_err_msg);
        		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
        		tpfree ( ( char * ) ptr_fml_Sbuf );
        		tpfree ( ( char * ) ptr_fml_Rbuf );
        		tpfree ( ( char * ) ptr_fml_Obuf );
        		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
        		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      		}
				}

        /**** Ver 2.9 Starts here *****/
        MEMSET(c_mleg_pipe_id);
        if( i_cnt == 0 )
        {
          strcpy(c_mleg_pipe_id,"NA");
        }
        else
        {
          strcpy(c_mleg_pipe_id,c_pipe_id);
        }

        fn_userlog(c_ServiceName,"c_mleg_pipe_id :%s:",c_mleg_pipe_id);

        i_returncode = Fchg32 ( ptr_fml_Sbuf, FFO_INDX_CD, 0, (char *)c_mleg_pipe_id, 0);

        if ( i_returncode == -1 )
        {
          fn_errlog( c_ServiceName, "S31280",FMLMSG,c_err_msg);
          fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
          tpfree ( ( char * ) ptr_fml_Sbuf );
          tpfree ( ( char * ) ptr_fml_Rbuf );
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 ); 
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); 
        }
        /**** Ver 2.9 Ends Here *******/

				i_returncode = fn_chk_strtgy_ord( c_ServiceName,
                                 	  			&st_ordbook,
                                 	  			&st_err_msg );

				if ( i_returncode == -1 )
 				{
   				fn_errlog( c_ServiceName, "S31285", LIBMSG , c_err_msg );
					fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
					tpfree ( ( char * ) ptr_fml_Sbuf );
       		tpfree ( ( char * ) ptr_fml_Rbuf );
       		tpfree ( ( char * ) ptr_fml_Obuf );
   				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );
      		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
   				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
 				}

				if( st_ordbook.c_prd_typ == 'F' )
				{

					EXEC SQL
					 	 	 SELECT ffp_opnpstn_qty
					 	 	 INTO   :sql_ffp_opnpstn_qty
					 	 	 FROM   ffp_fo_futures_pstn
					 	 	 WHERE  ffp_clm_mtch_accnt = :st_usr_prfl.c_cln_mtch_accnt
					 	 	 AND    ffp_prdct_typ 		 = 'F'
					 	 	 AND    ffp_xchng_cd 		   = :st_ordbook.c_xchng_cd
					 	 	 AND    ffp_indstk 			   = :st_ordbook.c_ctgry_indstk
				   	 	 AND    ffp_undrlyng 			 = :st_ordbook.c_undrlyng
					 	 	 AND    ffp_expry_dt 			 = :c_exp_dt	
					 	 	 AND    ffp_exer_typ 			 = :st_ordbook.c_exrc_typ;

			  	if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
 					{
    			  fn_errlog( c_ServiceName, "S31290",SQLMSG,c_err_msg);
    			  fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    			  Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
    			  tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  		    }
			    if( SQLCODE == NO_DATA_FOUND )
				  {
					  sql_ffp_opnpstn_qty = 0;	
			 	  }
				
				  if( (sql_ffp_opnpstn_qty > 0 && st_ordbook.c_ordr_flw == 'S') || 
							(sql_ffp_opnpstn_qty < 0 && st_ordbook.c_ordr_flw == 'B') )
				  {
					  fn_errlog( c_ServiceName, "B66069",DEFMSG,c_err_msg);
    			  fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    			  Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
    			  tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				  }
			  	else if( ( (sql_ffp_opnpstn_qty < 0 && st_ordbook.c_ordr_flw == 'S') ||
							 	 	 	 (sql_ffp_opnpstn_qty > 0 && st_ordbook.c_ordr_flw == 'B') ) && c_warn_msg == 'N' )
			 		{
				  fn_errlog( c_ServiceName, "B66070",DEFMSG,c_err_msg);
    		  fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    		  Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			 		}
						 
				}					 
				else if( st_ordbook.c_prd_typ == 'O' )
				{
					EXEC SQL
           	 	 SELECT fop_opnpstn_qty
           	 	 INTO   :sql_fop_opnpstn_qty
           	 	 FROM   fop_fo_options_pstn
           	 	 WHERE  fop_clm_mtch_accnt = :st_usr_prfl.c_cln_mtch_accnt
           	 	 AND    fop_xchng_cd 			 = :st_ordbook.c_xchng_cd
           	 	 AND    fop_indstk 				 = :st_ordbook.c_ctgry_indstk
           	 	 AND    fop_undrlyng 			 = :st_ordbook.c_undrlyng
           	 	 AND    fop_expry_dt 			 = :c_exp_dt
							 AND    fop_strk_prc       = :st_ordbook.l_strike_prc
							 AND    fop_opt_typ        = :st_ordbook.c_opt_typ
           	 	 AND    fop_exer_typ 			 = :st_ordbook.c_exrc_typ;

      	  if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
      	 	{
         	 	fn_errlog( c_ServiceName, "S31295",SQLMSG,c_err_msg);
         	 	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
         	 	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
         	 	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     	   	}
				 	if( SQLCODE == NO_DATA_FOUND )
      	 	{
         	 	sql_fop_opnpstn_qty = 0;
       	 	}

				 	if( (sql_fop_opnpstn_qty > 0 && st_ordbook.c_ordr_flw == 'S') ||
           	  (sql_fop_opnpstn_qty < 0 && st_ordbook.c_ordr_flw == 'B') )
       	 	{
         	  fn_errlog( c_ServiceName, "B66069",DEFMSG,c_err_msg);
         	  fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
         	  Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
         	  tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
       	  }
       	  else if( ( (sql_fop_opnpstn_qty < 0 && st_ordbook.c_ordr_flw == 'S') ||
                	   (sql_fop_opnpstn_qty > 0 && st_ordbook.c_ordr_flw == 'B') ) && c_warn_msg == 'N' )
       	 	{
         	  fn_errlog( c_ServiceName, "B66070",DEFMSG,c_err_msg);
         	  fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
         	  Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      			Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
         	  tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
       	  }
			  }


  			i_returncode = tpcall("SFO_ORD_ROUT", (char *)ptr_fml_Sbuf, 0, (char **)&ptr_fml_Rbuf, &l_recvbuff, 0);

  			if (i_returncode == -1)
  			{
    			if (TPCODE != TPESVCFAIL)
    			{
						fn_errlog( c_ServiceName, "S31300",TPMSG,c_err_msg);
    			}
    			else
    			{
     				i_returncode = Fget32(ptr_fml_Rbuf, FFO_ERR_MSG, 0, c_err_msg, 0);
     				if (i_returncode == -1)
     				{
							fn_errlog( c_ServiceName, "S31305",FMLMSG,c_err_msg);
    					fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    					tpfree ( ( char * ) ptr_fml_Sbuf );
    					tpfree ( ( char * ) ptr_fml_Rbuf );
    					tpfree ( ( char * ) ptr_fml_Obuf );
    					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      				Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
    					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     				}
    			}
   				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );

					fn_userlog( c_ServiceName,"Error message is :%s:",c_err_msg );
   				tpfree ( ( char * ) ptr_fml_Sbuf );
   				tpfree ( ( char * ) ptr_fml_Rbuf );
   				tpfree ( ( char * ) ptr_fml_Obuf );

					/*-------------------------------------------------------------------------------------------------------*/
					/* Code below is added to show correct values of current limit in case a customer has insufficient limit */
					/* while placing 2L order. Here both orders are placed in a single transaction, if the customer has      */
					/* sufficient limit for the first then it gets blocked , and he doesn't have for the second order the    */
					/* limit we show should be the original limit and not the one after placement of first order.            */
					/* So only in case of insufficient limit for the second order we will call SFO_GET_LIMITS to show exact  */
					/* current limit.																																												 */ 

					if( strstr( c_err_msg,"Available Limits##" ) != NULL && i_cnt == 1 )
					{

						strcpy( c_regonize_error,c_err_msg );
          	fn_userlog( c_ServiceName,"ERROR IS :%s:",c_err_msg );
          	strtok( c_regonize_error,"#");
          	fn_userlog( c_ServiceName,"ERROR is :%s:",c_regonize_error );

						fn_userlog( c_ServiceName," i_cnt is :%d:",i_cnt );
						fn_userlog( c_ServiceName," We Need to call service get limits " );

						EXEC SQL
      					 SELECT to_char(sysdate, 'DD-Mon-YYYY')
      					 INTO   :c_trade_dt
      					 FROM   DUAL;

    				if( SQLCODE != 0 )
    				{
      				fn_errlog( c_ServiceName, "S31310", SQLMSG, c_err_msg);
							tpfree ( ( char * ) ptr_fml_Sbuf );
              tpfree ( ( char * ) ptr_fml_Rbuf );
              tpfree ( ( char * ) ptr_fml_Obuf );
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      				Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    				}

					  SETNULL(c_trade_dt);
   				  strcpy(st_gt_lmt_dtls.c_trd_dt,(char *) c_trade_dt.arr);
    			  strcpy( st_gt_lmt_dtls.c_cln_mtch_accnt,st_usr_prfl.c_cln_mtch_accnt);
    			  st_gt_lmt_dtls.c_rqst_typ = LIMIT_X_GID;
						st_gt_lmt_dtls.l_gid = 1;
					  strcpy(st_gt_lmt_dtls.c_xchng_cd,"NFO");

    				i_ip_len = sizeof ( struct vw_gt_lmt_dtls);

    				fn_cpy_ddr(st_gt_lmt_dtls.c_rout_crt);
            
            /********** Ver 2.2 Starts Here ********************
    				i_returncode = fn_call_svc( c_ServiceName,
                                				c_err_msg,
                                				&st_gt_lmt_dtls,
                                				&st_gt_lmt_dtls,
                                				"vw_gt_lmt_dtls",
                                				"vw_gt_lmt_dtls",
                                				i_ip_len,
                                				i_ip_len,
                                				0,
                                				"SFO_GET_LIMITS" );
            *********** Ver 2.2 Ends here *********************/
 
            /******** Ver 2.2 Starts Here ***************/
            i_returncode = fo_get_trd_limit(c_ServiceName,
                                            st_gt_lmt_dtls.c_cln_mtch_accnt,
                                            st_gt_lmt_dtls.c_trd_dt,
                                            st_gt_lmt_dtls.c_rqst_typ,
                                            st_gt_lmt_dtls.c_xchng_cd,
                                            st_gt_lmt_dtls.l_gid,
                                            &st_gt_lmt_dtls.d_amt,
                                            c_err_msg
                                            );
           /******** Ver 2.2 Ends Here *****************/
    				if ( i_returncode == -1 )
    				{
							tpfree ( ( char * ) ptr_fml_Sbuf );
              tpfree ( ( char * ) ptr_fml_Rbuf );
              tpfree ( ( char * ) ptr_fml_Obuf );
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      				Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    				}


						d_limit_amt = st_gt_lmt_dtls.d_amt; 

						fn_userlog( c_ServiceName,"Limit available is :%lf",d_limit_amt );

						strcat( c_regonize_error,"##");
            sprintf( c_err_msg,"%s:%0.2lf",c_regonize_error,d_limit_amt/100 );

					}

					/*----------------------Insuficient condition change for 2nd leg ends here-------------------------------*/

   				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
   				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  			}

  			i_returncode= Fget32(ptr_fml_Rbuf, FFO_ORDR_RFRNC,0, (char *)st_ordbook.c_ordr_rfrnc, 0);

  			if (i_returncode == -1)
  			{
					fn_errlog( c_ServiceName, "S31315",FMLMSG,c_err_msg);
   				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
 					tpfree ( ( char * ) ptr_fml_Sbuf );
   				tpfree ( ( char * ) ptr_fml_Rbuf );
   				tpfree ( ( char * ) ptr_fml_Obuf );
 					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
 					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  			}

  			i_returncode= Fget32(ptr_fml_Rbuf, FFO_PIPE_ID,0, (char *)c_pipe_id, 0);

  			if (i_returncode == -1)
  			{
					fn_errlog( c_ServiceName, "S31320",FMLMSG,c_err_msg);
   				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
 					tpfree ( ( char * ) ptr_fml_Sbuf );
   				tpfree ( ( char * ) ptr_fml_Rbuf );
   				tpfree ( ( char * ) ptr_fml_Obuf );
 					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
 					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
				}

				i_returncode = Fadd32 ( ptr_fml_Obuf, FFO_ORDR_RFRNC, ( char *)st_ordbook.c_ordr_rfrnc, 0 ); 
				if( i_returncode == -1)
  			{
   				fn_errlog( c_ServiceName, "S31325",FMLMSG,c_err_msg);
   				fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
   				tpfree ( ( char * ) ptr_fml_Sbuf );
   				tpfree ( ( char * ) ptr_fml_Rbuf );
   				tpfree ( ( char * ) ptr_fml_Obuf );
   				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
   				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  			}

				i_err[0] = 0 ;
				i_ferr[0] = 0 ;

				if ( Finit32 ( ptr_fml_Rbuf,
                  ( FLDLEN32 ) Fsizeof32 ( ptr_fml_Rbuf ) ) == -1 )
				{
     			fn_errlog( c_ServiceName, "S31330",FMLMSG,c_err_msg);
     			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
     			tpfree ( ( char * ) ptr_fml_Sbuf );
     			tpfree ( ( char * ) ptr_fml_Rbuf );
     			tpfree ( ( char * ) ptr_fml_Obuf );
     			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
     			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    		}

        /**** Ver 2.9 Starts Here ****/
        if( i_cnt == 0 )
        {
          strcpy( st_s_sequence.c_pipe_id, c_pipe_id);
          st_s_sequence.c_rqst_typ = GET_SPRDORD_SEQ;
          i_ip_len = sizeof ( struct vw_sequence );
          i_op_len = sizeof ( struct vw_sequence );
          fn_cpy_ddr ( st_s_sequence.c_rout_crt );

          i_returncode = fn_get_seq(c_ServiceName,c_err_msg,st_s_sequence.c_pipe_id,&st_r_sequence.l_seq_num,st_s_sequence.c_rqst_typ);
          if ( i_returncode != 0 )
          {
            fn_errlog( c_ServiceName, "S31335",FMLMSG,c_err_msg);
            fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
            tpfree ( ( char * ) ptr_fml_Sbuf );
            tpfree ( ( char * ) ptr_fml_Rbuf );
            tpfree ( ( char * ) ptr_fml_Obuf );
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
            Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 ); 
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 ); 
          }

          l_sprdord_seq_num = st_r_sequence.l_seq_num;
          sprintf( c_seq_num, "%08d", l_sprdord_seq_num );
          strcpy( c_sprdordr_rfrnc, (char *)c_date.arr );
          strcat( c_sprdordr_rfrnc, c_pipe_id );
          strcat( c_sprdordr_rfrnc, c_seq_num );
        }
        /**** Ver 2.9 Ends Here ****/

				strcpy( st_spd_ordbk.c_sprd_ord_rfrnc[i_cnt],c_sprdordr_rfrnc );
				strcpy( st_spd_ordbk.c_ordr_rfrnc[i_cnt],st_ordbook.c_ordr_rfrnc );
				st_spd_ordbk.c_sprd_ord_ind[i_cnt] = c_sprd_ord_ind;
				strcpy( st_spd_ordbk.c_pipe_id[i_cnt],c_pipe_id );
				st_spd_ordbk.l_mdfctn_cntr[i_cnt] = 1;
				st_spd_ordbk.l_ord_tot_qty[i_cnt] = st_ordbook.l_ord_tot_qty;
				st_spd_ordbk.c_rqst_typ[i_cnt] = INSERT_ON_ORDER_PLACEMENT;

				if(DEBUG_MSG_LVL_5)
				{
					fn_userlog(c_ServiceName,"Printing Values for Instance:%d:",i_cnt);
					fn_userlog(c_ServiceName,"st_spd_ordbk.c_sprd_ord_rfrnc:%s:",st_spd_ordbk.c_sprd_ord_rfrnc[i_cnt]);
					fn_userlog(c_ServiceName,"st_spd_ordbk.c_ordr_rfrnc[i_cnt]:%s:",st_spd_ordbk.c_ordr_rfrnc[i_cnt]);
					fn_userlog(c_ServiceName,"st_spd_ordbk.c_sprd_ord_ind[i_cnt]:%d:",st_spd_ordbk.c_sprd_ord_ind[i_cnt]);
					fn_userlog(c_ServiceName,"st_spd_ordbk.c_pipe_id[i_cnt]:%s:",st_spd_ordbk.c_pipe_id[i_cnt]);
					fn_userlog(c_ServiceName,"st_spd_ordbk.l_mdfctn_cntr[i_cnt]:%ld:",st_spd_ordbk.l_mdfctn_cntr[i_cnt]);
					fn_userlog(c_ServiceName,"st_spd_ordbk.l_ord_tot_qty[i_cnt]:%ld:",st_spd_ordbk.l_ord_tot_qty[i_cnt]);
				}

				EXEC SQL
         		 UPDATE fod_fo_ordr_dtls
         		 SET fod_is_flg = 'D'
         		 WHERE fod_ordr_rfrnc = :st_spd_ordbk.c_ordr_rfrnc[i_cnt];

				if ( SQLCODE != 0 )
    		{
      		fn_errlog( c_ServiceName, "S31340",SQLMSG,c_err_msg);
      		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
      		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      		Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
      		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    		}

			} /* End of loop for i_cnt; loop which actually places order  */

		
  		tpfree ( ( char * ) ptr_fml_Rbuf );
  		tpfree ( ( char * ) ptr_fml_Sbuf );

  		i_ip_len = sizeof ( struct vw_spdordbk );
  		i_op_len = sizeof ( struct vw_spdordbk );

  		fn_cpy_ddr ( st_spd_ordbk.c_rout_crt );

  		i_returncode = fn_call_svc( c_ServiceName,
                             			c_err_msg,
                             			&st_spd_ordbk,
                             			&st_spd_ordbk,
                             			"vw_spdordbk",
                             			"vw_spdordbk",
                             			i_ip_len,
                             			i_op_len,
                             			0,
                             			"SFO_UPD_SPDBK" );
  		if ( i_returncode != 0 )
  		{
    		fn_errlog( c_ServiceName, "S31345", LIBMSG, c_err_msg  );
    		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
    		tpfree ( ( char * ) ptr_fml_Obuf );
    		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
    		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  		}
			
			EXEC SQL
					 UPDATE fsd_fo_sprd_dtls
				   SET    fsd_ordtyp_ind = 'I'
					 WHERE  fsd_sprd_rfrnc = :c_sprdordr_rfrnc;

			if ( SQLCODE != 0 )
      {
        fn_errlog( c_ServiceName, "S31350",SQLMSG,c_err_msg);
        fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

		} /* End of loop for i_counter */

  	if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg ) == -1 )
  	{
    	tpfree ( ( char * ) ptr_fml_Obuf );
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
     	Fadd32( ptr_fml_Ibuf, FFO_ACTN_ID,(char *)&i_actn_id, 0 );      /***  Ver 1.7 ***/
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	}

	} /* End of condition c_is_flg == 'D' 1.4 */
	

  /********************************************************/
  /****Changes for Tux4 Triggers***************************/
  /********************************************************/


  /* To post the Trigger in Tux3 Domain Call the service SFO_FOS_TRG */

  strcpy ( c_fno_dmn_nm, "FNO" );
  strcpy ( c_fno_trg_nm, "TRG_LOOK_TAB" );
  strcpy ( c_fno_trg_dat, "TRG_LOOK_TAB" );

  i_returncode = fn_call_svc_fml ( c_ServiceName,
                                   c_err_msg,
                                   "SFO_FOS_TRG",
                                   0,
                                   4,
                                   0,
                                   FFO_DMN_NM, (char *)c_fno_dmn_nm,
                                   FFO_TRG_NM, (char *)c_fno_trg_nm,
                                   FFO_ABT_TRG_DATA, (char *)c_fno_trg_dat,
                                   FFO_ABT_FILTER, (char *)c_pipe_id);

  if ( i_returncode != SUCC_BFR )
  {
    fn_errlog( c_ServiceName, "S31355", LIBMSG, c_err_msg  );
  }

  /********************************************************/
  /****Changes for Tux4 Triggers ends**********************/
  /********************************************************/

  tpreturn( TPSUCCESS, 0, (char *)ptr_fml_Obuf, 0 , 0 );

}
