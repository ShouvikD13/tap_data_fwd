/******************************************************************************/
/* Program           : SFO_1CLK_DTLS                                          */
/*                                                                            */
/* Input             :                                                        */
/*                                                                            */
/*                                                                            */
/* Output            :                                                        */
/*                                                                            */
/*                                                                            */
/* Description       : This service returns data from different               */
/*                      tables based on input request type.                   */
/*                                                                            */
/* Log               : 1.0     ISEC | Ravindra panda                          */
/*					   1.1	   Shlok Ghan             27-Dec-2021 		 	  */
/*                     1.2     Mahesh Regulwar        28-Dec-2021             */
/*                     1.3     Ravindra Panda         20-Jan-2022             */
/*                     1.4     Pranav Anand           13-Dec-2022             */
/*                     1.5     Ravi M. 		      27-Mar-2023             */   
/******************************************************************************/
/* 1.0    -  New Release                                                      */
/* 1.1		-  Minor Changes 																										*/	
/* 1.2    -  Minor Changes (Ordering of Strategies)                           */
/* 1.3    -  Minor Changes                                                    */
/* 1.4    -  CR-ISEC10-177407_API_for_1clk_nonloggedin_section               */
/* 1.5    -  Survilance Changes									                              */
/******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <atmi.h>
#include <fml32.h>
#include <fo.h>
#include <fo_fml_def.h>
#include <fml_def.h>
#include <fo_view_def.h>
#include <sqlca.h>
#include <fn_log.h>
#include <fn_tuxlib.h>
#include <fn_session.h>
#include <fn_pos.h>
#include <fn_ddr.h>
#include <fml_rout.h>
#include <fn_read_debug_lvl.h>

void SFO_1CLK_DTLS(TPSVCINFO * rqst)
{
  /* variables used to accept values from database */
  char  c_match_accnt[11];
  char  c_prtflo_id[11];
  char  c_xchng_cd[4];
  char  c_prdct_typ = '\0';
  char  c_indstk = '\0';
  char  c_undrlyng[7];
	char  c_undrlyng2[7];/*** ver 1.3 ***/
  char  c_exer_typ ='\0';
  char  c_expry_dt[22];
  char  c_opt_typ = '\0';
  char  c_insert_dt[22];	/* not used */
  char  c_insert_by[11];	/* not used */
  char  c_lst_modified_dt[22];	/* not used */
  char  c_lst_modofied_by[11];	/* not used */
  char  c_bucket_type[51];
  char  c_view[21];
  char  c_action = '\0';
  char  c_risk_profile = '\0';
  char  c_segment ='\0';
  char  c_ind_stk_call ='\0';
  char  c_remark[301];
  char  c_call_action[22];
  char  c_strtgy_name[101];
  char  c_mrgn_rng[101];
  char  c_profit_rng[101];
  char  c_timeframe_rnf[101];
  char  c_rqst_type ='\0'; /* request type to decide operation */
  char  c_prefrence = '\0'; 
  char  c_prtfl_desc[501];
  char  c_time_frame[51];
  char  c_prtflo_name[51];
  char  c_mail_cat_id[6];
	char  c_bench_mark[101];
	char  c_prtfl_name[51];
  char  c_cust_rcmend_flg;
  char  c_ordr_typ;	
  char  c_call_date[22] = "\0";
  char  c_modified_date[22] = "\0";     /*** Ver 1.2 ***/
	char c_survmsg[500]="\0";			/* Ver 1.5 */
	char c_surv_flg='\0';			/* Ver 1.5 */

  int  i_action_call_no=0;  /*** Ver 1.2 **/

	double  d_sltp_prc = 0;
  double  d_rcmend_prc_frm=0;
  double  d_rcmend_prc_to=0;
  double  d_trgt_prc=0;
  double  d_book_profit=0;
  double  d_book_part_proft_perc=0;
  double  d_exit_price=0;
  double  d_potential=0;
  double  d_expctd_prftloss=0;
  double  d_total_margin=0;
  double  d_max_loss=0;
  double  d_max_profit=0;
  double  d_exptd_loss_perlot=0;
  double  d_exptd_prft_perlot=0;
	double  d_rt=0;
	double  d_leg_no=0; 

  long  l_strk_prc=0;
  long  l_time_frame=0;
  long  l_strtgy_id=0;
  long  l_mrgn_id=0;
  long  l_profit_id=0;
  long  l_timeframe_id=0;
  long  l_min_lot_qty=0;
	long  l_lst_trd_prc=0;
	long  l_bst1_bid_prc=0;
	long  l_bst1_offr_prc=0;
	long  l_ordr_qty=0;
	long  l_ordr_rt=0;
  long  l_strtgy_id_new_design=0;
  /* variables used for main function */
  char  c_err_msg[256];
  int  i_err[36];
  int  i_ferr[36];
  int  i_cnt;
  int  counter = 0;
  int  i_ch_val = 0;
  char  c_ServiceName[33];

  /* tuxedo variables */
  FBFR32 *ptr_fml_Ibuf; /* pointer to FML input */
  FBFR32 *ptr_fml_Obuf; /* pointer to FML output */

  ptr_fml_Ibuf = (FBFR32 *)rqst->data;
  strcpy( c_ServiceName, rqst->name );
  fn_userlog(c_ServiceName, "Working on this service");

  struct vw_usr_prfl st_usr_prfl;
  struct vw_err_msg st_err_msg;
  MEMSET(c_err_msg);

  /********************************************* User and session authentication starts here ****************************************/

  i_ch_val = Fvftos32( ptr_fml_Ibuf,
                           (char *)&st_usr_prfl,
                           "vw_usr_prfl" );
  i_ch_val = fn_unpack_fmltovar_dflt ( c_ServiceName,
                                      c_err_msg,
                                      ptr_fml_Ibuf,
                                      3,
                                      FFO_EBA_MTCH_ACT_NO, (char*)st_usr_prfl.c_cln_mtch_accnt, "*",
                                     FFO_USR_ID, (char*)st_usr_prfl.c_user_id, "NULL",
                                      FFO_SSSN_ID, (char*)&st_usr_prfl.l_session_id, "0");
  if ( i_ch_val != 0  )
  {
  	fn_errlog( c_ServiceName, "S31005", FMLMSG, c_err_msg  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
  
  if ( strcmp(st_usr_prfl.c_user_id,"system") != 0 && st_usr_prfl.l_session_id != 0)
  {
  	i_ch_val = fn_chk_sssn( c_ServiceName, &st_usr_prfl, &st_err_msg );

  	if ( i_ch_val == -1 )
  	{
	    fn_errlog( c_ServiceName,"S31010", LIBMSG, st_err_msg.c_err_msg  );
	    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, st_err_msg.c_err_msg, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	}
  }
  
 /*********************************************************** authentication ends here ********************************************/

  
  if (Fget32(ptr_fml_Ibuf, FFO_RQST_TYP, 0, (char * )&c_rqst_type, 0) == -1)
  {
	  fn_userlog(c_ServiceName, "error occured while fetching c_reqst_type ---- request type not available");
	  fn_errlog(c_ServiceName, "S31015", LIBMSG, c_err_msg);
	  Fadd32(ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0);
	  tpreturn(TPFAIL, ERR_BFR, (char * ) ptr_fml_Ibuf, 0, 0);

  }
	/** if( DEBUG_MSG_LVL_3)**/
    fn_userlog(c_ServiceName, "Retreived reqst_type sucessfully is :%c:",c_rqst_type);

  /* Allocating memory to output-buffer */
  ptr_fml_Obuf = (FBFR32 *)tpalloc( "FML32", NULL, MIN_FML_BUF_LEN * 10 );

  if ( ptr_fml_Obuf == NULL )
  {
    fn_errlog( c_ServiceName, "S31020", FMLMSG, c_err_msg  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  } 
	strcpy(c_match_accnt,st_usr_prfl.c_cln_mtch_accnt);
	rtrim(c_match_accnt);  
  if( c_rqst_type == 'L' )  /** rqst_type = 'L', to fetch leg deatails starts here **/
  {
		if( DEBUG_MSG_LVL_3)
	  	fn_userlog(c_ServiceName, "Performing Operation on Leg_detail Table");

		/** Retreiving Protfolio id **/
    int i_err_prtflio_id = Fget32(ptr_fml_Ibuf, FFO_BILL_NO, 0, (char *)c_prtflo_id, 0);
    int i_ferr_prtflio_id = Ferror32;
    if (i_err_prtflio_id == -1)
    {
      fn_errlog(c_ServiceName, "S31025", Fstrerror32(i_ferr_prtflio_id),c_err_msg);
      fn_userlog(c_ServiceName, "Unable to fget protfolio_if");
      Fadd32(ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0);
      tpfree((char*)ptr_fml_Obuf);
      tpreturn(TPFAIL, ERR_BFR, (char * ) ptr_fml_Ibuf, 0, 0);
    }
		
		if( DEBUG_MSG_LVL_3)
    	fn_userlog(c_ServiceName, "protfolio_id retreived sucessfully is :%s:",c_prtflo_id);

		rtrim(c_prtflo_id);

	  EXEC SQL
	  SELECT  nvl(FSB_TRGT_PRC,0.0),
						nvl(FSB_SLTP_PRC,0.0),                                       
 						nvl(FSB_BOOK_PROFIT,0.0),                                    
 				  	nvl(FSB_BOOK_PART_PROFT_PERC,0.0),                           
 						nvl(FSB_EXIT_PRICE,0.0),                                     
 						nvl(FSB_POTENTIAL,0.0),                                      
 						nvl(FSB_TIME_FRAME,0.0),                                     
 						nvl(FSB_RISK_PROFILE,'NA'),                         
 						nvl(FSB_SEGMENT,'NA'),                                        
 						nvl(FSB_EXPCTD_PRFTLOSS,0.0),                                
 						nvl(FSB_TOTAL_MARGIN,0.0),                                   
 						nvl(FSB_IND_STK_CALL,'*'),                                   
 						nvl(FSB_REMARKS,'NA'),                                        
 						nvl(FSB_CALL_ACTION,'NA'),
						nvl(FSB_EXPTD_PRFT_PERLOT,0.0),
						nvl(FSB_EXPTD_LOSS_PERLOT,0.0)
  	INTO    :d_trgt_prc,
						:d_sltp_prc,
						:d_book_profit,
						:d_book_part_proft_perc,
						:d_exit_price,
						:d_potential,
						:l_time_frame,
						:c_risk_profile,
						:c_segment,
						:d_expctd_prftloss,
						:d_total_margin,
						:c_ind_stk_call,
						:c_remark,
						:c_call_action,
						:d_exptd_prft_perlot,
						:d_exptd_loss_perlot
		FROM	 FSB_FO1CLICK_STRTGY_BUCKTDTLS 
		WHERE   FSB_PRTFL_ID = :c_prtflo_id;
		if ( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31030", SQLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      tpfree((char*)ptr_fml_Obuf);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

		if( DEBUG_MSG_LVL_3)
		{
    	fn_userlog(c_ServiceName,"----------------------------------------------");
    	fn_userlog(c_ServiceName,"Match account :%s:",c_match_accnt);
    	fn_userlog(c_ServiceName,"Segemet is :%c:",c_segment);
    	fn_userlog(c_ServiceName,"Risk profile is :%c:",c_risk_profile);
			fn_userlog(c_ServiceName,"Ind stock value is is :%c:",c_ind_stk_call);
    	fn_userlog(c_ServiceName,"----------------------------------------------");
 		} 

		/** Moving values to buffer **/
		i_err[0] = Fadd32(ptr_fml_Obuf, FFO_PLG_AMT, (char *)&d_trgt_prc, 0);
    i_err[1] = Fadd32(ptr_fml_Obuf, FFO_FUT_PRC, (char *)&d_sltp_prc, 0);
    i_err[2] = Fadd32(ptr_fml_Obuf, FFO_AMOUNT, (char *)&d_book_profit, 0);
    i_err[3] = Fadd32(ptr_fml_Obuf, FFO_INIT_MRGN_PRCNT, (char *)&d_book_part_proft_perc, 0);
		i_err[4] = Fadd32(ptr_fml_Obuf, FFO_EFF_CLS_PRC, (char *)&d_exit_price, 0);
    i_err[5] = Fadd32(ptr_fml_Obuf, FFO_MIN_MRGN_PRCNT, (char *)&d_potential, 0);
		i_err[6] = Fadd32(ptr_fml_Obuf, FFO_OPN_TM, (char * )&l_time_frame, 0);
    i_err[7] = Fadd32(ptr_fml_Obuf, FFO_ORD_TYP, (char *)&c_risk_profile, 0);
    i_err[8] = Fadd32(ptr_fml_Obuf, FFO_EX_ORDR_TYP, (char *)&c_segment, 0);
    i_err[9] = Fadd32(ptr_fml_Obuf, FFO_REMARKS, (char *)c_remark, 0);
    i_err[10] = Fadd32(ptr_fml_Obuf, FFO_ACTION1, (char *)c_call_action, 0);
		i_err[11] = Fadd32(ptr_fml_Obuf, FFO_OPERATION_TYP, (char *)&c_ind_stk_call, 0);
		i_err[12] = Fadd32(ptr_fml_Obuf, FFO_SPREAD_MRGN, (char *)&d_total_margin, 0);
    i_err[13] = Fadd32(ptr_fml_Obuf, FFO_UNRLZD_PL , (char *)&d_expctd_prftloss, 0);
		i_err[14] = Fadd32(ptr_fml_Obuf, FFO_EBA_MTCH_ACT_NO, (char *)c_match_accnt, 0);
    i_err[15] = Fadd32(ptr_fml_Obuf, FFO_OI_HIGH, (char *)&d_exptd_prft_perlot, 0);
		i_err[16] = Fadd32(ptr_fml_Obuf, FFO_OI_LOW, (char *)&d_exptd_loss_perlot, 0);
		

		for(i_cnt=0;i_cnt<17;i_cnt++)
    {
	    if(i_err[i_cnt] == -1)
      {
        fn_userlog(c_ServiceName,"Error in Fadd for i [%d]",i_cnt);
        fn_errlog( c_ServiceName, "S31035", FMLMSG, c_err_msg  );
        tpfree ( ( char * ) ptr_fml_Obuf );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
		}
		if(Fneeded32(1,MIN_FML_BUF_LEN) > Funused32(ptr_fml_Obuf))	/** Checking available buffer size **/
    {
      counter ++;
      ptr_fml_Obuf = (FBFR32 *)tprealloc( (char *)ptr_fml_Obuf, Fsizeof32(ptr_fml_Obuf) + counter * MIN_FML_BUF_LEN * 5 );
      if ( ptr_fml_Obuf == NULL )
      {
        fn_errlog( c_ServiceName, "S31040", TPMSG, c_err_msg  );
        tpfree ( ( char * ) ptr_fml_Obuf );
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
    }

    EXEC SQL
		DECLARE mail_ctg CURSOR FOR
		SELECT NVL(FCM_MAIL_CAT_ID,'*')
		FROM   FCM_FO1CLICK_CTGRT_MSTR
		WHERE  FCM_PRTFL_ID = :c_prtflo_id;

    EXEC SQL
		OPEN mail_ctg;    /** Opening mail_ctg cursor **/
		if ( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31045", SQLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			EXEC SQL CLOSE mail_ctg;
      tpfree((char*)ptr_fml_Obuf);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

    for( ; ; )      /** Infinite loop used for mail_ctg cursor starts here **/
		{ 
  		EXEC SQL
  		FETCH   mail_ctg
  		INTO    :c_mail_cat_id;

  		if ( SQLCODE != 0 )
  		{
    		if ( SQLCODE == NO_DATA_FOUND )
    		{
      		fn_userlog(c_ServiceName,"NO DATA FOUND ");
      		break;
    		}
    		else
    		{
      		fn_errlog( c_ServiceName, "S31050", SQLMSG, c_err_msg  );
      		EXEC SQL CLOSE mail_ctg;
      		tpfree ( ( char * ) ptr_fml_Obuf );
      		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    		}
  		}

      i_err[17] = Fadd32(ptr_fml_Obuf, FFO_SYMBOL, (char *)c_mail_cat_id, 0);
  
  		if(i_err[17] == -1)
  		{
    		fn_userlog(c_ServiceName,"Error in Fadd for i [%d]",17);
    		fn_errlog( c_ServiceName, "S31055", FMLMSG, c_err_msg  );
    		EXEC SQL CLOSE mail_ctg;
    		tpfree ( ( char * ) ptr_fml_Obuf );
    		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  		}

			if(Fneeded32(1,MIN_FML_BUF_LEN) > Funused32(ptr_fml_Obuf))
  		{
    		counter ++;
    		ptr_fml_Obuf = (FBFR32 *)tprealloc( (char *)ptr_fml_Obuf, Fsizeof32(ptr_fml_Obuf) + counter * MIN_FML_BUF_LEN * 5 );
    		if ( ptr_fml_Obuf == NULL )
    		{
      		fn_errlog( c_ServiceName, "S31060", TPMSG, c_err_msg  );
      		EXEC SQL CLOSE mail_ctg;
      		tpfree ( ( char * ) ptr_fml_Obuf );
      		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    		}
  		}
  	}     /** Infinite loop used with mail_ctg cursor ends here **/

    EXEC SQL
    CLOSE mail_ctg; /**  mail_ctg CURSOR closed **/
	
		EXEC SQL
		DECLARE leg_dtls CURSOR FOR                 	/** declaring leg_dtls CURSOR **/
		SELECT  nvl(FSL_XCHNG_CD,'NA'),
						nvl(FSL_PRDCT_TYP,'*'),
						nvl(FSL_INDSTK,'*'),
						nvl(FSL_UNDRLYNG,'NA'),
						FSL_EXPRY_DT,
						nvl(FSL_EXER_TYP,'*'),
						nvl(FSL_OPT_TYP,'*'),
						nvl(FSL_STRK_PRC,0.0),
						nvl(FSL_BUCKET_TYPE,'NA'),
						nvl(FSL_VIEW,'NA'),
						nvl(FSL_ACTION,'*'),
						nvl(FSL_RCMEND_PRC_FRM,0.0),
						nvl(FSL_RCMEND_PRC_TO,0.0),
					  NVL(FTQ_MIN_LOT_QTY,0),
	          NVL(FTQ_LST_TRD_PRC,0),
	          NVL(FTQ_BST1_BID_PRC,0),
	          NVL(FTQ_BST1_OFFR_PRC,0),
						NVL(LTQ_RT,0.0)*100,
						nvl(FSL_LEG_NO,0.0)	
		FROM    FSL_FO1CLICK_STRTGY_LEGDTLS,
						LTQ_TRD_QT,
						FTQ_FO_TRD_QT
		WHERE   FSL_PRTFLO_ID = :c_prtflo_id
		AND     FSL_STATUS = 'A'
		AND   	FTQ_XCHNG_CD = FSL_XCHNG_CD
    AND 	  FTQ_PRDCT_TYP = DECODE(FSL_PRDCT_TYP,'P','F',FSL_PRDCT_TYP)
    AND 	  FTQ_INDSTK = FSL_INDSTK
    AND 	  FTQ_UNDRLYNG = FSL_UNDRLYNG
    AND 	  FTQ_EXPRY_DT = FSL_EXPRY_DT
    AND 	  FTQ_EXER_TYP = FSL_EXER_TYP
    AND 	  FTQ_OPT_TYP = FSL_OPT_TYP
	AND       FSL_STRK_PRC = FTQ_STRK_PRC
    AND 	  LTQ_XCHNG_CD = DECODE(FSL_XCHNG_CD,'NFO','NSE', FSL_XCHNG_CD)
    AND	    LTQ_STCK_CD = FSL_UNDRLYNG;

		EXEC SQL
    OPEN leg_dtls;    /** Opening leg_dtls Cursor **/
		if ( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31065", SQLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			EXEC SQL CLOSE leg_dtls;
      tpfree((char*)ptr_fml_Obuf);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
	
  	/** Moving CURSOR content to buffer **/


		while(1)  /** Infinite for loop start **/
		{
	  	EXEC SQL
      FETCH   leg_dtls
      INTO    :c_xchng_cd,
     		 		  :c_prdct_typ,
      			  :c_indstk,
      			  :c_undrlyng,
      		 	  :c_expry_dt,
      		  	:c_exer_typ,
      		  	:c_opt_typ,
      		  	:l_strk_prc,
      		  	:c_bucket_type,
      		  	:c_view,
      		  	:c_action,
      		  	:d_rcmend_prc_frm,
      		  	:d_rcmend_prc_to,
							:l_min_lot_qty,
							:l_lst_trd_prc,
							:l_bst1_bid_prc,
							:l_bst1_offr_prc,
							:d_rt,
							:d_leg_no;
	 		 if ( SQLCODE != 0 )
       {
         if ( SQLCODE == NO_DATA_FOUND )
         {
           fn_userlog(c_ServiceName,"NO DATA FOUND ");
           break;
         }
         else
         {
           fn_errlog( c_ServiceName, "S31070", SQLMSG, c_err_msg  );
           EXEC SQL CLOSE leg_dtls;
           tpfree ( ( char * ) ptr_fml_Obuf );
           Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
           tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
         }
       }

			 i_err[15] = Fadd32(ptr_fml_Obuf, FFO_BILL_NO, (char *)c_prtflo_id, 0);	  
	  	 i_err[16] = Fadd32(ptr_fml_Obuf, FFO_XCHNG_CD, (char *)c_xchng_cd, 0);
	  	 i_err[17] = Fadd32(ptr_fml_Obuf, FFO_PRDCT_TYP, (char *)&c_prdct_typ, 0);
  	 	 i_err[18] = Fadd32(ptr_fml_Obuf, FFO_UNDRLYNG, (char *)c_undrlyng, 0);
	  	 i_err[19] = Fadd32(ptr_fml_Obuf, FFO_EXPRY_DT, (char *)c_expry_dt, 0);
	 		 i_err[20] = Fadd32(ptr_fml_Obuf, FFO_CTGRY_INDSTK, (char *)&c_indstk, 0);
	 		 i_err[21] = Fadd32(ptr_fml_Obuf, FFO_OPT_TYP, (char *)&c_opt_typ, 0);
       i_err[22] = Fadd32(ptr_fml_Obuf, FFO_STRK_PRC, (char *)&l_strk_prc, 0);
	  	 i_err[23] = Fadd32(ptr_fml_Obuf, FFO_EXER_TYP, (char *)&c_exer_typ, 0);
	  	 i_err[24] = Fadd32(ptr_fml_Obuf, FFO_IP_VIEW_NM, (char *)c_view, 0);
       i_err[25] = Fadd32(ptr_fml_Obuf, FFO_ORDR_FLW, (char *)&c_action, 0);
	  	 i_err[26] = Fadd32(ptr_fml_Obuf, FFO_TRNSCTN_TYP, (char *)c_bucket_type, 0);
       i_err[27] = Fadd32(ptr_fml_Obuf, FFO_IBUY_ORD_VL, (char *)&d_rcmend_prc_frm, 0);
       i_err[28] = Fadd32(ptr_fml_Obuf, FFO_ISELL_ORD_VL, (char *)&d_rcmend_prc_to, 0);
			 i_err[29] = Fadd32(ptr_fml_Obuf, FFO_MIN_LOT_QTY, (char *)&l_min_lot_qty, 0);
			 i_err[30] = Fadd32(ptr_fml_Obuf, FFO_LST_TRD_PRC, (char *)&l_lst_trd_prc, 0);
			 i_err[31] = Fadd32(ptr_fml_Obuf, FFO_BST_BID_PRC, (char *)&l_bst1_bid_prc, 0);
			 i_err[32] = Fadd32(ptr_fml_Obuf, FFO_BST_OFFR_PRC, (char *)&l_bst1_offr_prc, 0);
			 i_err[33] = Fadd32(ptr_fml_Obuf, FFO_RATE, (char *)&d_rt, 0);
			 i_err[34] = Fadd32(ptr_fml_Obuf, FFO_INDEX , (char *)&d_leg_no, 0);

	  	 for(i_cnt=15;i_cnt<35;i_cnt++)
       {
         if(i_err[i_cnt] == -1)
         {
	    	   fn_userlog(c_ServiceName,"Error in Fadd for i [%d]",i_cnt);
           fn_errlog( c_ServiceName, "S31075", FMLMSG, c_err_msg  );
           EXEC SQL CLOSE leg_dtls;		
           tpfree ( ( char * ) ptr_fml_Obuf );
           Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
           tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
         }
	  	 }


	  	 if(Fneeded32(1,MIN_FML_BUF_LEN) > Funused32(ptr_fml_Obuf))
    	 {
         counter ++;
         ptr_fml_Obuf = (FBFR32 *)tprealloc( (char *)ptr_fml_Obuf, Fsizeof32(ptr_fml_Obuf) + counter * MIN_FML_BUF_LEN * 5 ); 
         if ( ptr_fml_Obuf == NULL )
         {
           fn_errlog( c_ServiceName, "S31080", TPMSG, c_err_msg  );
           EXEC SQL CLOSE leg_dtls;
           tpfree ( ( char * ) ptr_fml_Obuf );
           Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
           tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
         }
	     }
	 	}	/** Infinite for loop for leg_dtls closed here **/

	
    EXEC SQL
    CLOSE leg_dtls;	/**  leg_dtls CURSOR closed **/
    
		if(DEBUG_MSG_LVL_3)
			fn_userlog( c_ServiceName,"leg_dtls_cursor contents moved sucessfully");

  }	/** if statement for reqst_typ = 'L' closed here **/

  else if( c_rqst_type == 'M' )	/** request_type = 'M', for fetching master table details starts here **/
  {
	  if(DEBUG_MSG_LVL_3)
			fn_userlog( c_ServiceName,"Performing operations on Master tables");

	  EXEC SQL
  	DECLARE strtgybuskts CURSOR FOR   /** Declaring strtgybuskts CURSOR **/
  	SELECT  nvl(FIS_STRTGY_NAME,'NA'),
        		nvl(FIS_STRTGY_ID,0)
  	FROM    FIS_FO1CLICK_STRTGYBUSKTS;

  	EXEC SQL
    OPEN strtgybuskts;    /** Opening strtgybuskts Cursor **/
		if ( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31085", SQLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			EXEC SQL CLOSE strtgybuskts;
      tpfree((char*)ptr_fml_Obuf);
			 tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }	


  	/** Moving CURSOR content to buffer **/
  	for ( ; ;)  /** Infinite for loop for strtgybuskt starts here **/
  	{
      EXEC SQL
      FETCH   strtgybuskts
      INTO    :c_strtgy_name,
        		  :l_strtgy_id;
	    if ( SQLCODE != 0 )
      {
        if ( SQLCODE == NO_DATA_FOUND )
        {
          fn_userlog(c_ServiceName,"NO DATA FOUND ");
          break;
        }
        else
        {
          fn_errlog( c_ServiceName, "S31090", SQLMSG, c_err_msg  );
          EXEC SQL CLOSE strtgybuskts;
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      }
	
	    i_err[0] = Fadd32(ptr_fml_Obuf, FFO_CSE_ID, (char *)&l_strtgy_id, 0);
      i_err[1] = Fadd32(ptr_fml_Obuf, FFO_TRG_NM, (char *)c_strtgy_name, 0);

	    for(i_cnt=0;i_cnt<2;i_cnt++)
      {
        if(i_err[i_cnt] == -1)
        {
          fn_userlog(c_ServiceName,"Error in Fadd for i [%d]",i_cnt);
          fn_errlog( c_ServiceName, "S31095", FMLMSG, c_err_msg  );
          EXEC SQL CLOSE strtgybuskts;
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      }
      if(Fneeded32(1,MIN_FML_BUF_LEN) > Funused32(ptr_fml_Obuf))
      {
        counter ++;
        ptr_fml_Obuf = (FBFR32 *)tprealloc( (char *)ptr_fml_Obuf, Fsizeof32(ptr_fml_Obuf) + counter * MIN_FML_BUF_LEN * 5 );
        if ( ptr_fml_Obuf == NULL )
        {
          fn_errlog( c_ServiceName, "S31100", TPMSG, c_err_msg  );
          EXEC SQL CLOSE strtgybuskts;
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      }
  	} /** Infinite for loop for strtgybuskt ends here **/
   	EXEC SQL
  	CLOSE strtgybuskts; /** closing strtgybuskts CURSOR **/

  	EXEC SQL
  	DECLARE margin CURSOR FOR   /** Declaring margin CURSOR **/
  	SELECT  nvl(FMR_MRGN_ID,0),
          	nvl(FMR_MRGN_RNG,'NA')
  	FROM  	FMR_FO1CLICK_MARGIN_RNGDTLS;

   	EXEC SQL
    OPEN margin;    /** Opening margin Cursor **/
		if ( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31105", SQLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			EXEC SQL CLOSE margin;
      tpfree((char*)ptr_fml_Obuf);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
		
		/** Moving CURSOR content to buffer **/
  	for ( ; ;)  /** Infinite for loop for margin starts here **/
  	{
      EXEC SQL
      FETCH   margin
      INTO    :l_mrgn_id,
						  :c_mrgn_rng;
	    if ( SQLCODE != 0 )
      {
        if ( SQLCODE == NO_DATA_FOUND )
        {
          fn_userlog(c_ServiceName,"NO DATA FOUND ");
          break;
        }
        else
        {
          fn_errlog( c_ServiceName, "S31110", SQLMSG, c_err_msg  );
          EXEC SQL CLOSE margin;
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      }
	
	 	  i_err[0] = Fadd32(ptr_fml_Obuf, FFO_SLIP_NO, (char *)&l_mrgn_id, 0);
   	  i_err[1] = Fadd32(ptr_fml_Obuf, FFO_SETTLOR, (char *)c_mrgn_rng, 0);

	 	  for(i_cnt=0;i_cnt<2;i_cnt++)
     	{
        if(i_err[i_cnt] == -1)
        {
          fn_userlog(c_ServiceName,"Error in Fadd for i [%d]",i_cnt);
          fn_errlog( c_ServiceName, "S31115", FMLMSG, c_err_msg  );
          EXEC SQL CLOSE margin;
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
 	    }
 	    if(Fneeded32(1,MIN_FML_BUF_LEN) > Funused32(ptr_fml_Obuf))
      {
        counter ++;
        ptr_fml_Obuf = (FBFR32 *)tprealloc( (char *)ptr_fml_Obuf, Fsizeof32(ptr_fml_Obuf) + counter * MIN_FML_BUF_LEN * 5 );
        if ( ptr_fml_Obuf == NULL )
        {
          fn_errlog( c_ServiceName, "S31120", TPMSG, c_err_msg  );
          EXEC SQL CLOSE margin;
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      }
	  } /** Infinite for loop for margin ends here **/

	  EXEC SQL
 	  CLOSE margin; /** closing margin CURSOR **/

    EXEC SQL
 	  DECLARE profit CURSOR FOR   /** Declaring profit CURSOR **/
 	  SELECT  nvl(FPR_PROFIT_ID,0),
            nvl(FPR_PROFIT_RNG,'NA')
 	  FROM    FPR_FO1CLICK_PROFIT_RNGDTLS;

	  EXEC SQL
    OPEN profit;    /** Opening profit Cursor **/  
		if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
    {
      fn_errlog( c_ServiceName, "S31125", SQLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			EXEC SQL CLOSE profit;
      tpfree((char*)ptr_fml_Obuf);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

	  /** Moving CURSOR content to buffer **/
	  for ( ; ;)	/** Infinite for loop for profit starts here **/
	  {	 
		  EXEC SQL
      FETCH   profit
      INTO    :l_profit_id,
		  				:c_profit_rng;
		  if ( SQLCODE != 0 )
   	  { 
   		  if ( SQLCODE == NO_DATA_FOUND )
   		  {
   		    fn_userlog(c_ServiceName,"NO DATA FOUND ");
   		    break;
   		  }
    	  else
     	  {
     	    fn_errlog( c_ServiceName, "S31130", SQLMSG, c_err_msg  );
     	    EXEC SQL CLOSE profit;
     	    tpfree ( ( char * ) ptr_fml_Obuf );
     	    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0); 
     	    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     	  }
   	  }
		  i_err[0] = Fadd32(ptr_fml_Obuf, FFO_ACTN_ID , (char *)&l_profit_id, 0);
   	  i_err[1] = Fadd32(ptr_fml_Obuf, FFO_MAX_PRF_AT_EXP, (char *)c_profit_rng, 0);
		  for(i_cnt=0;i_cnt<2;i_cnt++)  
   	  { 
     	  if(i_err[i_cnt] == -1)
   		  {
   		    fn_userlog(c_ServiceName,"Error in Fadd for i [%d]",i_cnt);
   		    fn_errlog( c_ServiceName, "S31135", FMLMSG, c_err_msg  );
			    EXEC SQL CLOSE profit;
    	    tpfree ( ( char * ) ptr_fml_Obuf );
     	    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );   
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     	  }
		  }	
		  if(Fneeded32(1,MIN_FML_BUF_LEN) > Funused32(ptr_fml_Obuf))
      {
        counter ++;
        ptr_fml_Obuf = (FBFR32 *)tprealloc( (char *)ptr_fml_Obuf, Fsizeof32(ptr_fml_Obuf) + counter * MIN_FML_BUF_LEN * 5 ); 
        if ( ptr_fml_Obuf == NULL )
        {
          fn_errlog( c_ServiceName, "S31140", TPMSG, c_err_msg  );
          EXEC SQL CLOSE profit;
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
   	  }
	  }	/** Infinite for loop for profit ends here **/

  	EXEC SQL
	  CLOSE profit;	/** closing profit CURSOR **/
		EXEC SQL CLOSE profit;

  	EXEC SQL
 	  DECLARE timeframe CURSOR FOR    /** Declaring timeframe CURSOR **/
 	  SELECT  nvl(FTD_TIMEFRAME_ID,0),
          	nvl(FTD_TIMEFRAME_RNF,'NA')
 	  FROM    FTD_FO1CLICK_TIMEFRAME_DTLS;

 	  EXEC SQL
    OPEN timeframe;    /** Opening timeframe Cursor **/
		if ( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31145", SQLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			EXEC SQL CLOSE timeframe;
      tpfree((char*)ptr_fml_Obuf);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
 
	  /** Moving CURSOR content to buffer **/
	  for ( ; ;)	/** Infinite for loop for timeframe starts here **/
	  { 	
		  EXEC SQL
      FETCH   timeframe
      INTO    :l_timeframe_id,
			  			:c_timeframe_rnf;
		  if ( SQLCODE != 0 )
      {
    	  if ( SQLCODE == NO_DATA_FOUND )
     	  {
     	    fn_userlog(c_ServiceName,"NO DATA FOUND ");
     	    break;
     	  }
     	  else
     	  {   
     	    fn_errlog( c_ServiceName, "S31150", SQLMSG, c_err_msg  );
     	    EXEC SQL CLOSE timeframe;
     	    tpfree ( ( char * ) ptr_fml_Obuf );
     	    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
     	    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     	  }
   	  }
		  i_err[0] = Fadd32(ptr_fml_Obuf, FFO_QT_TM, (char *)c_timeframe_rnf, 0);
   	  i_err[1] = Fadd32(ptr_fml_Obuf, FFO_TMPLT, (char *)&l_timeframe_id, 0);
		  for(i_cnt=0;i_cnt<2;i_cnt++)  
   	  {
     	  if(i_err[i_cnt] == -1)
   		  {
   		    fn_userlog(c_ServiceName,"Error in Fadd for i [%d]",i_cnt);
   		    fn_errlog( c_ServiceName, "S31155", FMLMSG, c_err_msg  );
			    EXEC SQL CLOSE timeframe;
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );   
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
     	  }
		  }
		  if(Fneeded32(1,MIN_FML_BUF_LEN) > Funused32(ptr_fml_Obuf))
      {
        counter ++;
        ptr_fml_Obuf = (FBFR32 *)tprealloc( (char *)ptr_fml_Obuf, Fsizeof32(ptr_fml_Obuf) + counter * MIN_FML_BUF_LEN * 5 ); 
        if ( ptr_fml_Obuf == NULL )
   	    {
          fn_errlog( c_ServiceName, "S31160", TPMSG, c_err_msg  );
          EXEC SQL CLOSE timeframe;
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      }
	  }	/** Infinite for loop for timeframe ends here **/

	  EXEC SQL
	  CLOSE timeframe;	/** closing timeframe CURSOR **/
		
		/** Portfolio cursor starts gaurav**/

    EXEC SQL
    DECLARE portfolio CURSOR FOR    /** Declaring portfolio CURSOR **/
    SELECT  nvl(FSB_PRTFL_ID,0),
						nvl(FSB_PRTFL_NAME ,'NA') || ' - '|| nvl(FSB_NICK_NAME,'NA')  
		FROM    FSB_FO1CLICK_STRTGY_BUCKTDTLS
      WHERE  FSB_CUST_RCMEND_FLG='R'
        AND  FSB_STATUS!='D';   /** ver 1.3 **/ 
    EXEC SQL
    OPEN portfolio;    /** Opening portfolio Cursor **/
		if ( SQLCODE != 0)
    {
      fn_errlog( c_ServiceName, "S31165", SQLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			EXEC SQL CLOSE portfolio;
      tpfree((char*)ptr_fml_Obuf);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }


    /** Moving CURSOR content to buffer **/
    for ( ; ;)  /** Infinite for loop for portfolio starts here **/
    {
      EXEC SQL
      FETCH   portfolio
      INTO    :c_prtflo_id,
              :c_prtflo_name;
      if ( SQLCODE != 0 )
      {
        if ( SQLCODE == NO_DATA_FOUND )
        {
          fn_userlog(c_ServiceName,"NO DATA FOUND ");
          break;
        }
        else
        {
          fn_errlog( c_ServiceName, "S31170", SQLMSG, c_err_msg  );
          EXEC SQL CLOSE portfolio;
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      }
    
      rtrim(c_prtflo_id);
			rtrim(c_prtflo_name);

      i_err[0] = Fadd32(ptr_fml_Obuf, FFO_BILL_NO , (char *)c_prtflo_id, 0);
      i_err[1] = Fadd32(ptr_fml_Obuf, FFO_QUEUE_NAME , (char *)c_prtflo_name, 0);
      for(i_cnt=0;i_cnt<2;i_cnt++)
      {
        if(i_err[i_cnt] == -1)
        {
          fn_userlog(c_ServiceName,"Error in Fadd for i [%d]",i_cnt);
          fn_errlog( c_ServiceName, "S31175", FMLMSG, c_err_msg  );
          EXEC SQL CLOSE portfolio;
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      }
      if(Fneeded32(1,MIN_FML_BUF_LEN) > Funused32(ptr_fml_Obuf))
      {
        counter ++;
        ptr_fml_Obuf = (FBFR32 *)tprealloc( (char *)ptr_fml_Obuf, Fsizeof32(ptr_fml_Obuf) + counter * MIN_FML_BUF_LEN * 5 );
        if ( ptr_fml_Obuf == NULL )
        {
          fn_errlog( c_ServiceName, "S31180", TPMSG, c_err_msg  );
          EXEC SQL CLOSE portfolio;
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      }
    } /** Infinite for loop for timeframe ends here **/

    EXEC SQL
    CLOSE portfolio;  /** closing portfolio CURSOR **/
		/** Portfolio cursor ends**/
 
		EXEC SQL 
    DECLARE strtgy_dtls CURSOR FOR   /** Declaring strtgy_dtls CURSOR **/
    SELECT  DISTINCT  nvl(FIS_STRTGY_NAME,'NA'),
                nvl(FIS_STRTGY_ID,0)
    FROM    FIS_FO1CLICK_STRTGYBUSKTS,
            FSB_FO1CLICK_STRTGY_BUCKTDTLS,
            FSL_FO1CLICK_STRTGY_LEGDTLS
    WHERE   FSB_STRTGY_LAUNCH='Y'
    AND     FSB_PRTFL_ID = FSL_PRTFLO_ID
    AND     FSB_STRGY_ID = FIS_STRTGY_ID
		AND  		FSB_STATUS!='D';

    EXEC SQL
    OPEN strtgy_dtls;    /** Opening strtgy_dtls Cursor **/
    if ( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31185", SQLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      EXEC SQL CLOSE strtgy_dtls;
      tpfree((char*)ptr_fml_Obuf);
		  tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

    for ( ; ;)  /** Infinite for loop for strtgybuskt starts here **/
    {
      EXEC SQL
      FETCH   strtgy_dtls
      INTO    :c_strtgy_name,
              :l_strtgy_id;
      if ( SQLCODE != 0 )
      {
        if ( SQLCODE == NO_DATA_FOUND )
        {
          fn_userlog(c_ServiceName,"NO DATA FOUND ");
          break;
        }
        else
        {
          fn_errlog( c_ServiceName, "S31190", SQLMSG, c_err_msg  );
          EXEC SQL CLOSE strtgy_dtls;
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      }

      i_err[0] = Fadd32(ptr_fml_Obuf, FFO_TOKEN_ID, (char *)&l_strtgy_id, 0);
      i_err[1] = Fadd32(ptr_fml_Obuf, FFO_USER_CODE, (char *)c_strtgy_name, 0);

      for(i_cnt=0;i_cnt<2;i_cnt++)
      {
        if(i_err[i_cnt] == -1)
        {
          fn_userlog(c_ServiceName,"Error in Fadd for i [%d]",i_cnt);
          fn_errlog( c_ServiceName, "S31195", FMLMSG, c_err_msg  );
          EXEC SQL CLOSE strtgy_dtls;
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      } 
      if(Fneeded32(1,MIN_FML_BUF_LEN) > Funused32(ptr_fml_Obuf))
      {
        counter ++;
        ptr_fml_Obuf = (FBFR32 *)tprealloc( (char *)ptr_fml_Obuf, Fsizeof32(ptr_fml_Obuf) + counter * MIN_FML_BUF_LEN * 5 );
        if ( ptr_fml_Obuf == NULL )
        {
          fn_errlog( c_ServiceName, "S31200", TPMSG, c_err_msg  );
          EXEC SQL CLOSE strtgy_dtls;
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      }
    }  /** Infinite for loop for strtgy_dtls ends here **/
    
    EXEC SQL
    CLOSE strtgy_dtls; /** closing strtgybuskts CURSOR **/
 
	}	/** elseif condition for reqst_type = 'M' ends here **/

  else if ( c_rqst_type == 'S' )	/** reqst_typ = 'S', for fetching strategy details **/
  {
		if (DEBUG_MSG_LVL_3)
	  	fn_userlog(c_ServiceName, "Operating to fetch strategy details based on prefrence");

		/** Retreiving Input values **/
    i_err[0] = Fget32(ptr_fml_Ibuf, FFO_UNDRLYNG, 0, (char * )c_undrlyng, 0);
    i_ferr[0] = Ferror32;
    i_err[1] = Fget32(ptr_fml_Ibuf, FFO_TRG_NM, 0, (char * )c_bench_mark, 0);
    i_ferr[1] = Ferror32;
    i_err[2] = Fget32(ptr_fml_Ibuf, FFO_CSE_ID, 0, (char * )&l_strtgy_id, 0);
    i_ferr[2] = Ferror32;
    i_err[3] = Fget32(ptr_fml_Ibuf, FFO_MKT_TYP , 0, (char *)&c_prefrence, 0);
    i_ferr[3] = Ferror32;

		for (i_cnt = 0; i_cnt < 4; i_cnt++)
		{ 
  		if (i_err[i_cnt] == -1)
  		{
    		fn_errlog(c_ServiceName, "S31205", Fstrerror32(i_ferr[i_cnt]),c_err_msg);
    		fn_userlog(c_ServiceName, "Unable to fget for i :[%d]",i_cnt);
    		Fadd32(ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0);
        tpfree((char*)ptr_fml_Obuf);
    		tpreturn(TPFAIL, ERR_BFR, (char * ) ptr_fml_Ibuf, 0, 0);
  		}
		}

		if (DEBUG_MSG_LVL_3)
		{
    	fn_userlog(c_ServiceName, "------------------------------------------------------------------------------------------------");
			fn_userlog(c_ServiceName, "prefrence :%c:",c_prefrence);
			fn_userlog(c_ServiceName, "Strategy ID :%ld:",l_strtgy_id);
			fn_userlog(c_ServiceName, "Underlying :%s:",c_undrlyng);
			fn_userlog(c_ServiceName, "Benchmark :%s:",c_bench_mark);
			fn_userlog(c_ServiceName, "------------------------------------------------------------------------------------------------");
		}

 	  EXEC SQL
    DECLARE ind_stk_cursor CURSOR FOR
 	  SELECT DISTINCT nvl(FSB_PRTFL_ID,'NA'),
					 nvl(FSB_PRTFL_DESC,' '),                    
					 NVL(FSB_TRGT_PRC,0),
					 nvl(FTD_TIMEFRAME_RNF,'NA'), 
					 NVL(FSB_EXPTD_PRFT_PERLOT,0),
					 NVL(FSB_EXPTD_LOSS_PERLOT,0),
					 NVL(FSB_TOTAL_MARGIN,0),
					 NVL(FIS_STRTGY_NAME,'NA'),
           NVL(FSB_PRTFL_NAME,'NA'),
					 NVL(FSB_CALL_ACTION,'NA'),
				/*	 NVL(FSB_CALL_DATE,'NA') */
					 to_char(NVL(FSB_CALL_DATE,FSB_LST_MODIFIED_DT),'dd-mm-yyyy hh24:mi:ss'),  /** Ver 1.1 added NVL handling with last modified date coloumn **/
           NVL(FSB_CALL_DATE,FSB_LST_MODIFIED_DT),   /** Added in Ver 1.2 ***/
           NVL(FAL_OPN_CLS_ORDRNG,99),   /*** Ver 1.2 ****/
					 NVL(FSB_SLTP_PRC,0)           /** Ver 1.3 **/
    FROM   FSB_FO1CLICK_STRTGY_BUCKTDTLS,
					 FSL_FO1CLICK_STRTGY_LEGDTLS,
           FIS_FO1CLICK_STRTGYBUSKTS,
					 FTD_FO1CLICK_TIMEFRAME_DTLS,
       /*    FCM_FO1CLICK_CTGRT_MSTR,   
           MAIL_DIRECT,           *commented in ver 1.4*/
           FAL_FO1CLICK_ACTIONS_LIST  /** Ver 1.2 **/
    WHERE  FSL_INDSTK LIKE :c_prefrence
    AND    trim(FSL_UNDRLYNG) LIKE :c_undrlyng
    AND    trim(FSB_STRGY_ID ) LIKE DECODE ( :l_strtgy_id,0,'%', :l_strtgy_id )
    AND    trim(NVL(FSB_BENCH_MARK,'%')) LIKE :c_bench_mark
    AND    FSB_PRTFL_ID = FSL_PRTFLO_ID
		AND		 FTD_TIMEFRAME_ID = FSB_TIME_FRAME 
    AND    FSB_STRGY_ID = FIS_STRTGY_ID
  /*    AND    MAIL_USER_ID=:st_usr_prfl.c_user_id       
    AND    FCM_MAIL_CAT_ID = MAIL_ML_CATEGORY8
    AND    FSB_PRTFL_ID = FCM_PRTFL_ID               commented in  Ver 1.4 */
    AND    FSB_CALL_ACTION = FAL_CALL_ACTION(+)   /** Ver 1.2 **/
		AND		 NVL(FSB_STRTGY_LAUNCH,'N') = 'Y'
		AND 	 FSB_STATUS != 'D' 
    ORDER BY NVL(FAL_OPN_CLS_ORDRNG,99) ASC, NVL(FSB_CALL_DATE,FSB_LST_MODIFIED_DT) DESC;   /** Added in Ver 1.2 ***/ /** Ver 1.2, FAL_ACTNLST_ID ASC added **/

 	  EXEC SQL
  	OPEN ind_stk_cursor;    /** Opening ind_stk_cursor Cursor **/
		if ( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31210", SQLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			EXEC SQL CLOSE ind_stk_cursor;
      tpfree((char*)ptr_fml_Obuf);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }


    /** Moving CURSOR content to buffer **/

  	for( ; ; )	/** Infinite loop for ind_stk_cursor starts here **/
	  { 
      EXEC SQL
      FETCH   ind_stk_cursor
      INTO    :c_prtflo_id,
	  		  	  :c_prtfl_desc,
	    	      :d_trgt_prc,
	    	  		:c_timeframe_rnf,
	    	  		:d_max_profit,
	    	  		:d_max_loss,
	    	  		:d_total_margin,
							:c_strtgy_name,
							:c_prtfl_name,
							:c_call_action,
							:c_call_date,
              :c_modified_date,  /** Ver 1.2 **/
              :i_action_call_no,  /** Ver 1.2 **/
							:d_sltp_prc;       /** Ver 1.3 **/

      if ( SQLCODE != 0 )
      {
        if ( SQLCODE == NO_DATA_FOUND )
        {
          fn_userlog(c_ServiceName,"NO DATA FOUND  for ind_stk_cursor");
          break;
        }
        else
        {
          fn_errlog( c_ServiceName, "S31215", SQLMSG, c_err_msg  );
          EXEC SQL CLOSE ind_stk_cursor;
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      }


		/*** ver 1.2 start***/
		MEMSET(c_undrlyng2);
		rtrim(c_prtflo_id);	

		EXEC SQL
		select FSL_UNDRLYNG
		INTO :c_undrlyng2
		from FSL_FO1CLICK_STRTGY_LEGDTLS
		where FSL_PRTFLO_ID=:c_prtflo_id
  	and FSL_LEG_NO=1
    and ROWNUM <2;
		if(SQLCODE != 0 && SQLCODE != NO_DATA_FOUND)
		{
			 fn_errlog( c_ServiceName, "S31220", SQLMSG, c_err_msg  );
       EXEC SQL CLOSE ind_stk_cursor;
       tpfree ( ( char * ) ptr_fml_Obuf );	
		   Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
       tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
		if(SQLCODE == NO_DATA_FOUND )
		{
		 strcpy(c_undrlyng2,"");	
		} 
	
		/**** ver 1.2 End ***/
		
		

		
		


		/*** Ver 1.5 Start ***/
			MEMSET(c_survmsg);

			EXEC SQL SELECT 'P',NVL(SIM_DESC,'')||'['||NVL(SIM_SHORT_CD, ''||']')
								INTO 		:c_surv_flg,:c_survmsg
                FROM    XSM_XCHNG_STK_MSTR,SIM_SURV_INDCTR_MSTR
                WHERE   XSM_XCHNG_CD  = 'NSE'
                AND 		SIM_SURV_IND=NVL(XSM_SURV_IND, 0 )
                AND     XSM_STCK_CD   = :c_undrlyng2;
		if ( SQLCODE != 0 && SQLCODE!=NO_DATA_FOUND )
		{
			fn_errlog( c_ServiceName, "S31225", SQLMSG, c_err_msg  );
			EXEC SQL CLOSE ind_stk_cursor;
			tpfree ( ( char * ) ptr_fml_Obuf );	
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}
		else if(SQLCODE == NO_DATA_FOUND)
		{
			c_surv_flg='N'; 
		}	

		rtrim(c_survmsg);
		/*** Ver 1.5 End ***/

		fn_userlog(c_ServiceName,"Inside request type S, fetched strategy name is :%s:", c_strtgy_name);	
 
      i_err[0] = Fadd32(ptr_fml_Obuf, FFO_BILL_NO, (char *)c_prtflo_id, 0);
      i_err[1] = Fadd32(ptr_fml_Obuf, FFO_PRDCT_DESC, (char * )c_prtfl_desc, 0);
      i_err[2] = Fadd32(ptr_fml_Obuf, FFO_PLG_AMT, (char *)&d_trgt_prc, 0);
		  /*** ver 1.1  i_err[3] = Fadd32(ptr_fml_Obuf, FFO_TM_STMP, (char * )&c_timeframe_rnf, 0);	***/
      i_err[3] = Fadd32(ptr_fml_Obuf, FFO_TM_STMP, (char * )c_timeframe_rnf, 0); /*** ver 1.1  ***/
      i_err[4] = Fadd32(ptr_fml_Obuf,FFO_OI_HIGH , (char * )&d_max_profit, 0);
      i_err[5] = Fadd32(ptr_fml_Obuf,FFO_OI_LOW , (char * )&d_max_loss, 0);
      i_err[6] = Fadd32(ptr_fml_Obuf, FFO_SPREAD_MRGN, (char *)&d_total_margin, 0);
	    i_err[7] = Fadd32(ptr_fml_Obuf, FFO_QUEUE_NAME, (char *)c_strtgy_name, 0);
      i_err[8] = Fadd32(ptr_fml_Obuf, FFO_QSPACE_NAME, (char *)c_prtfl_name, 0);
			i_err[9] = Fadd32(ptr_fml_Obuf, FFO_RCRD_DT, (char *)c_call_date, 0);
      i_err[10] = Fadd32(ptr_fml_Obuf, FFO_ACTION1, (char *)c_call_action, 0);
			i_err[11] = Fadd32(ptr_fml_Obuf,FFO_REJ_DESC,(char *)c_undrlyng2,0);	/*** ver 1.2 ***/
			i_err[12] = Fadd32(ptr_fml_Obuf,FFO_FUT_PRC,(char *)&d_sltp_prc,0);  /*** ver 1.3 ***/
			i_err[13] = Fadd32(ptr_fml_Obuf,FFO_STLMNT_TYP,(char *)&c_surv_flg,0);  /*** ver 1.5 ***/
			i_err[14] = Fadd32(ptr_fml_Obuf,FFO_SYS_MSG,(char *)c_survmsg,0);  /*** ver 1.5 ***/

	
      for(i_cnt=0;i_cnt<15;i_cnt++)		/*** ver 1.3 change from 11 to 13 ***/ /*** ver 1.5 change from 13 to 15 ***/ 
      {
 	      if(i_err[i_cnt] == -1)
        {
          fn_userlog(c_ServiceName,"Error in Fadd for i [%d]",i_cnt);
          fn_errlog( c_ServiceName, "S31230", FMLMSG, c_err_msg  );
          EXEC SQL CLOSE ind_stk_cursor;
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      }

      if(Fneeded32(1,MIN_FML_BUF_LEN) > Funused32(ptr_fml_Obuf))
      {
        counter ++;
        ptr_fml_Obuf = (FBFR32 *)tprealloc( (char *)ptr_fml_Obuf, Fsizeof32(ptr_fml_Obuf) + counter * MIN_FML_BUF_LEN * 5 ); 
        if ( ptr_fml_Obuf == NULL )
        { 
          fn_errlog( c_ServiceName, "S31235", TPMSG, c_err_msg  );
          EXEC SQL CLOSE ind_stk_cursor;
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      }	 
    }	/** Infine for loop for ind_stk_cursor ends here **/
    EXEC SQL
    CLOSE ind_stk_cursor;	/**  leg_dtls CURSOR closed **/
		
		if (DEBUG_MSG_LVL_3)
    	fn_userlog( c_ServiceName," contents of ind_stk_cursor moved sucessfully");
  }	/** Elseif condition for reqst_typ = 'S' ends here**/

  else if ( c_rqst_type == 'C' ) /** reqst_typ = 'C', for fetching details of customer defined strategies **/ 
	{
		i_err[0] = Fget32(ptr_fml_Ibuf, FFO_BILL_NO, 0, (char *)c_prtflo_id, 0);
		i_ferr[0] = Ferror32;
		/** i_err[1] = Fget32(ptr_fml_Ibuf, FFO_SPL_FLG, 0, (char * )&c_cust_rcmend_flg, 0);
		i_ferr[1] = Ferror32; **commented for testing purpose**/     

		for (i_cnt = 0; i_cnt < 1; i_cnt++)
    {
      if (i_err[i_cnt] == -1)
      {
        fn_errlog(c_ServiceName, "S31240", Fstrerror32(i_ferr[i_cnt]),c_err_msg);
        fn_userlog(c_ServiceName, "Unable to fget for i :[%d]",i_cnt);
        Fadd32(ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0);
        tpfree((char*)ptr_fml_Obuf);
        tpreturn(TPFAIL, ERR_BFR, (char * )ptr_fml_Ibuf, 0, 0);
      }
    }

		if (DEBUG_MSG_LVL_3)
		{
    	fn_userlog(c_ServiceName, "------------------------------------------------------------------------------------------------");
    	fn_userlog(c_ServiceName, "protfolio-id :%s:",c_prtflo_id);
    /* fn_userlog(c_ServiceName, "customer or recommended flag :%c:",c_cust_rcmend_flg); */
    	fn_userlog(c_ServiceName, "------------------------------------------------------------------------------------------------");
		}

		EXEC SQL
		DECLARE custom CURSOR FOR
		SELECT	NVL(FTQ_LST_TRD_PRC,0),
        		NVL(FTQ_BST1_BID_PRC,0),
        		NVL(FTQ_BST1_OFFR_PRC,0),
						NVL(FSL_PRDCT_TYP,'*'),
						NVL(FSL_UNDRLYNG,'NA'),
						FSL_EXPRY_DT,
						NVL(FSL_STRK_PRC,0.0),
						NVL(FSL_OPT_TYP,'*'),
						NVL(FSL_ORDR_QTY,0),
						NVL(FSL_ORDR_TYP,'*'),
						NVL(FSL_ORDR_RT,0),
						NVL(FSL_ACTION,'*'),
						nvl(FSL_INDSTK,'*'),
						NVL(FTQ_MIN_LOT_QTY,0),
						nvl(FSL_XCHNG_CD,'NA'),
						nvl(FSL_EXER_TYP,'*'),
						NVL(LTQ_RT,0) * 100 
		FROM    FSB_FO1CLICK_STRTGY_BUCKTDTLS,
						FSL_FO1CLICK_STRTGY_LEGDTLS,
						FTQ_FO_TRD_QT,
            LTQ_TRD_QT
		WHERE		FSL_PRTFLO_ID = :c_prtflo_id
		/* AND			FSB_CUST_RCMEND_FLG LIKE :c_cust_rcmend_flg */  
		AND     FSL_STATUS = 'A'
		AND     FTQ_XCHNG_CD = FSL_XCHNG_CD
		AND     FTQ_PRDCT_TYP = DECODE(FSL_PRDCT_TYP,'P','F',FSL_PRDCT_TYP)
		AND     FTQ_INDSTK = FSL_INDSTK
		AND     FTQ_UNDRLYNG = FSL_UNDRLYNG
		AND     FTQ_EXPRY_DT = FSL_EXPRY_DT
		AND     FTQ_EXER_TYP = FSL_EXER_TYP
		AND     FTQ_OPT_TYP = FSL_OPT_TYP
		AND     FSL_STRK_PRC = FTQ_STRK_PRC
		AND     FSB_PRTFL_ID = FSL_PRTFLO_ID
    AND     LTQ_XCHNG_CD = DECODE(FSL_XCHNG_CD,'NFO','NSE', FSL_XCHNG_CD)
    AND     LTQ_STCK_CD = FSL_UNDRLYNG;

    EXEC SQL
		OPEN custom;    /** Opening custom Cursor **/
		if ( SQLCODE != 0 )
		{
  		fn_errlog( c_ServiceName, "S31245", SQLMSG, c_err_msg  );
  		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
  		EXEC SQL CLOSE custom;
      tpfree((char*)ptr_fml_Obuf);
  		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}	

		for (; ; )
		{
  		EXEC SQL
  		FETCH   custom
  		INTO    :l_lst_trd_prc,
      		    :l_bst1_bid_prc,
          		:l_bst1_offr_prc,
	  					:c_prdct_typ,
          		:c_undrlyng,
          		:c_expry_dt,
	  					:l_strk_prc,
	  					:c_opt_typ,
	  					:l_ordr_qty,
	  					:c_ordr_typ,
	  					:l_ordr_rt,
	  					:c_action,
							:c_indstk,
							:l_min_lot_qty,
							:c_xchng_cd,
							:c_exer_typ,
              :d_rt;

			if ( SQLCODE != 0 )
			{
  			if ( SQLCODE == NO_DATA_FOUND )
  			{
     			fn_userlog(c_ServiceName,"NO DATA FOUND for custom cursor ");
     			break;
  			}
  			else
  			{
    			fn_errlog( c_ServiceName, "S31250", SQLMSG, c_err_msg  );
    			EXEC SQL CLOSE custom;
    			tpfree ( ( char * ) ptr_fml_Obuf );
    			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  			}
			}





			/*** Ver 1.5 Start ***/
      MEMSET(c_survmsg);

      EXEC SQL SELECT 'P',NVL(SIM_DESC,'')||'['||NVL(SIM_SHORT_CD, ''||']')
                INTO    :c_surv_flg,:c_survmsg
                FROM    XSM_XCHNG_STK_MSTR,SIM_SURV_INDCTR_MSTR
                WHERE   XSM_XCHNG_CD  = 'NSE'
                AND     SIM_SURV_IND=NVL(XSM_SURV_IND, 0 )
                AND     XSM_STCK_CD   = :c_undrlyng;

    if ( SQLCODE != 0 && SQLCODE!=NO_DATA_FOUND )
    {
    			fn_errlog( c_ServiceName, "S31255", SQLMSG, c_err_msg  );
    			EXEC SQL CLOSE custom;
    			tpfree ( ( char * ) ptr_fml_Obuf );
    			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
    else if(SQLCODE == NO_DATA_FOUND)
    {
      c_surv_flg='N';
    }

    rtrim(c_survmsg);
    /*** Ver 1.5 End ***/

			i_err[0] = Fadd32(ptr_fml_Obuf, FFO_LST_TRD_PRC, (char *)&l_lst_trd_prc, 0);
			i_err[1] = Fadd32(ptr_fml_Obuf, FFO_BST_BID_PRC, (char *)&l_bst1_bid_prc, 0);
			i_err[2] = Fadd32(ptr_fml_Obuf, FFO_BST_OFFR_PRC, (char *)&l_bst1_offr_prc, 0);
			i_err[3] = Fadd32(ptr_fml_Obuf, FFO_PRDCT_TYP, (char *)&c_prdct_typ, 0);
			i_err[4] = Fadd32(ptr_fml_Obuf, FFO_UNDRLYNG, (char *)c_undrlyng, 0);
			i_err[5] = Fadd32(ptr_fml_Obuf, FFO_EXPRY_DT, (char *)c_expry_dt, 0);
			i_err[6] = Fadd32(ptr_fml_Obuf, FFO_OPT_TYP, (char *)&c_opt_typ, 0);
			i_err[7] = Fadd32(ptr_fml_Obuf, FFO_STRK_PRC, (char *)&l_strk_prc, 0);
			i_err[8] = Fadd32(ptr_fml_Obuf, FFO_ORDR_FLW, (char *)&c_action, 0);
			i_err[9] = Fadd32(ptr_fml_Obuf, FFO_TOT_QTY_TRDD, (char *)&l_ordr_qty, 0);
			i_err[10] = Fadd32(ptr_fml_Obuf, FFO_EX_ORDR_TYP, (char *)&c_ordr_typ, 0);
			i_err[11] = Fadd32(ptr_fml_Obuf, FFO_TOT_VAL_TRDD, (char *)&l_ordr_rt, 0);
			i_err[12] = Fadd32(ptr_fml_Obuf, FFO_XCHNG_CD, (char *)c_xchng_cd, 0);
			i_err[13] = Fadd32(ptr_fml_Obuf, FFO_CTGRY_INDSTK, (char *)&c_indstk, 0);
			i_err[14] = Fadd32(ptr_fml_Obuf, FFO_MIN_LOT_QTY, (char *)&l_min_lot_qty, 0);
			i_err[15] = Fadd32(ptr_fml_Obuf, FFO_EXER_TYP, (char *)&c_exer_typ, 0);
			i_err[16] = Fadd32(ptr_fml_Obuf, FFO_RATE, (char *)&d_rt, 0);

			i_err[17] = Fadd32(ptr_fml_Obuf, FFO_STLMNT_TYP, (char *)&c_surv_flg, 0);   /*** Ver 1.5 ***/
			i_err[18] = Fadd32(ptr_fml_Obuf, FFO_SYS_MSG, (char *)c_survmsg, 0);   /*** Ver 1.5 ***/

			for(i_cnt=0;i_cnt<19;i_cnt++)                                     /***i_cnt changed from 17 to 19 in Ver 1.5 ***/
			{
  			if(i_err[i_cnt] == -1)
  			{
    			fn_userlog(c_ServiceName,"Error in Fadd for i [%d]",i_cnt);
    			fn_errlog( c_ServiceName, "S31260", FMLMSG, c_err_msg  );
    			EXEC SQL CLOSE custom;
    			tpfree ( ( char * ) ptr_fml_Obuf );
    			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  			}
			}

			if(Fneeded32(1,MIN_FML_BUF_LEN) > Funused32(ptr_fml_Obuf))
			{
  			counter ++;
        ptr_fml_Obuf = (FBFR32 *)tprealloc( (char *)ptr_fml_Obuf, Fsizeof32(ptr_fml_Obuf) + counter * MIN_FML_BUF_LEN * 5 );
        if ( ptr_fml_Obuf == NULL )
        {
          fn_errlog( c_ServiceName, "S31265", TPMSG, c_err_msg  );
          EXEC SQL CLOSE custom;
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      }
		}      /** Infinite for loop for custom closed here **/

		EXEC SQL
  	CLOSE custom; /**  custom CURSOR closed **/
		if (DEBUG_MSG_LVL_3)
  		fn_userlog( c_ServiceName,"custom cursor contents moved sucessfully");

	}   /** else-if condition for rqst_typ = C closed here **/

  else if ( c_rqst_type == 'D' ) /** reqst_typ = 'D', for fetching description of customer defined strtegy  **/
  {
		EXEC SQL
    DECLARE custom_dtls CURSOR FOR
    SELECT nvl(FSB_PRTFL_DESC,' '),
           NVL(FSB_PRTFL_NAME,'NA'),
					 nvl(FSB_PRTFL_ID,'NA')
    FROM   FSB_FO1CLICK_STRTGY_BUCKTDTLS
    WHERE  FSB_INS_BY_MATCH like :c_match_accnt 
    AND	   FSB_CUST_RCMEND_FLG = 'C'
    ORDER BY FSB_INSERT_DT DESC;                

    EXEC SQL
    OPEN custom_dtls;    /** Opening custom_dtls Cursor **/
    if ( SQLCODE != 0 )
    {
      fn_errlog( c_ServiceName, "S31270", SQLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      EXEC SQL CLOSE custom_dtls;
      tpfree((char*)ptr_fml_Obuf);
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

		for( ; ; )  /** Infinite loop for custom_dtls starts here **/
    {
      EXEC SQL
      FETCH   custom_dtls
      INTO    :c_prtfl_desc,
              :c_prtfl_name,
							:c_prtflo_id;

      if ( SQLCODE != 0 )
      {
        if ( SQLCODE == NO_DATA_FOUND )
        {
          fn_userlog(c_ServiceName,"NO DATA FOUND for custom_dtls ");
          break;
        }
        else
        {
          fn_errlog( c_ServiceName, "S31275", SQLMSG, c_err_msg  );
          EXEC SQL CLOSE custom_dtls;
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      }

  
      i_err[0] = Fadd32(ptr_fml_Obuf, FFO_PRDCT_DESC, (char * )c_prtfl_desc, 0);
      i_err[1] = Fadd32(ptr_fml_Obuf, FFO_QSPACE_NAME, (char *)c_prtfl_name, 0);
			i_err[2] = Fadd32(ptr_fml_Obuf, FFO_BILL_NO, (char *)c_prtflo_id, 0);
      for(i_cnt=0;i_cnt<3;i_cnt++)
      {
        if(i_err[i_cnt] == -1)
        {
          fn_userlog(c_ServiceName,"Error in Fadd for i [%d]",i_cnt);
          fn_errlog( c_ServiceName, "S31280", FMLMSG, c_err_msg  );
          EXEC SQL CLOSE custom_dtls;
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      }

 			if(Fneeded32(1,MIN_FML_BUF_LEN) > Funused32(ptr_fml_Obuf))
      {
        counter ++;
        ptr_fml_Obuf = (FBFR32 *)tprealloc( (char *)ptr_fml_Obuf, Fsizeof32(ptr_fml_Obuf) + counter * MIN_FML_BUF_LEN * 5 );
        if ( ptr_fml_Obuf == NULL )
        {
          fn_errlog( c_ServiceName, "S31285", TPMSG, c_err_msg  );
          EXEC SQL CLOSE custom_dtls;
          tpfree ( ( char * ) ptr_fml_Obuf );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }
      }
    } /** Infine for loop for custom_dtls ends here **/
    EXEC SQL
    CLOSE custom_dtls; /**  leg_dtls CURSOR closed **/
		if (DEBUG_MSG_LVL_3)
    	fn_userlog( c_ServiceName," contents of custom_dtls moved sucessfully");
  } /** Elseif condition for reqst_typ = 'D' ends here**/


	if (DEBUG_MSG_LVL_3)
  	fn_userlog("Service %s complete successfully...", c_ServiceName);
  tpreturn(TPSUCCESS, 0L, (char *)ptr_fml_Obuf, 0L, 0);

}	/** Function definition ends here **/ 
