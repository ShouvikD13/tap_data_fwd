/************************************************************************************************/
/* File            : SFO_ATS_TRDPRT.PC																							 						*/ 
/*																																									 						*/
/* Description     : This code picks up data from Trade table based on various strategies       */ 
/*                   defined by ATS team using a front end  & categorises the trades into       */ 
/*									 various strategies.                                                        */
/*                                                                                              */
/* Called From     : Trading Screen link                                                        */
/* 																																															*/
/* Input FMLs			 :																																						*/
/* Output FMLs     :                                                                            */
/* 																																															*/
/*                                                                                              */
/* Author          : Vidyayini Krish                                                            */
/*                                                                                              */
/* Created on      : 30-Oct-2009                                                                */
/*                                                                                              */
/* Modification History:                                                                        */
/*                                                                                              */
/* Date        Version No.    Modified by    Modification Description                           */
/************************************************************************************************/
/*17-Nov-2009  1.0                           Release                                            */ 
/*04-Aug-2015  1.1  :Contract Master and Trade Quote Table Merger Changes - Anand Dhopte        */
/************************************************************************************************/

/* Standards include files*/

#include<stdio.h>           /* C Header File */
#include<stdlib.h>          /* C Header File */
#include<sqlca.h>           /* Oracle header file */
#include <atmi.h>           /* TUXEDO Header File */
#include <userlog.h>        /* TUXEDO Header File */
#include <fml32.h>          /* TUXEDO Header File */
#include <fml_def.h>
#include <string.h>
#include <fml_rout.h>
#include <fn_read_debug_lvl.h>
#include <fo.h>
#include <fn_log.h>
#include <fn_tuxlib.h>
#include <fn_collateral.h>
#include <fn_battmpt.h>
#include <time.h>

#define LEN_CONTRACT 30
#define MAX_CNTRCT_SZ   15
#define UNIQUE_VIOLATION 1401
#define BAT_TRAN_LOCAL 4000

void trim(char *str);


void SFO_ATS_TRDRPT( TPSVCINFO *rqst )
{

	/* Declaring and Initializing Variables */

	FBFR32 *ptr_fml_Ibuf;
  FBFR32 *ptr_fml_Obuf;

  char   c_ServiceName[33];
  char   c_err_msg[256];
  char   c_msg[256];
	char   c_contracts[MAX_CNTRCT_SZ][LEN_CONTRACT];
	char   c_tmp_mtch[11];
	char   c_tmp_stgy[10];
	char   c_cntrct_desc_for_eq[MAX_CNTRCT_SZ][LEN_CONTRACT];
	char   c_eq_cnt_desc[MAX_CNTRCT_SZ][LEN_CONTRACT];
	char   c_turnover[10];
	char   c_underlying[7];
 
	int    i_returncode;
  int    i_trnsctn;
  int    i_err[60];
  int    i_ferr[60];
  int    i_cnt;
	int    i;
	int    j;
  int    i_ip_len;
  int    i_op_len; 
	int    i_counter=0;
	int    k_counter=0;
	int    temp_counter = 0;
	int    TEMP_COUNT = 0; /* TESTING */
	
	long   l_sad_lot_sz[MAX_CNTRCT_SZ];
	long   l_atm_count_for_eq[MAX_CNTRCT_SZ];
	long   l_times_fno[MAX_CNTRCT_SZ];
	long   l_sad_eq_qty[MAX_CNTRCT_SZ];
	long   l_count_substrt = 0;
	long   l_count_substrtgy = 0;
	long   l_atm_lot_sz = 0;
	long   l_no_of_rows = 0;
	long   no_of_records = 0;
	long   no_of_atm_rec_for_eq = 0;
	long   no_of_eqrecords = 0;
	long   number_of_records = 0;
	long   l_quotient = 0;
	long   l_multiplier = 0;
	long   count_records = 0;
	long   l_cnt_of_stgy = 0;
	long   l_no_of_cust = 0;
	long   l_eq_trd_qty = 0;
	long   l_cnt_of_stgy_atm = 0;
	long   l_cnt_of_stgy_sad = 0;


	double   d_sql_sad_low_prc[MAX_CNTRCT_SZ];
	double   d_sql_sad_high_prc[MAX_CNTRCT_SZ];
	double   d_sql_sad_low_prc_fno[MAX_CNTRCT_SZ];
	double   d_sql_sad_high_prc_fno[MAX_CNTRCT_SZ];
	long   l_atm_count_eq[MAX_CNTRCT_SZ];
	long   l_test_counter = 0;

	long   l_combination_flg = 0;
	long   l_eq_extra_qty = 0;
	long   l_eq_rowq = 0;
	long   l_count = 0;
	long   l_lesser_of_eq = 0;
	long   l_times_actually_used = 0;

	double d_eq_trd_val = 0.0;
	double d_new_eq_strk_prc = 0.0;
  double d_new_eq_trd_val  = 0.0;
	double d_eq_extra_prc = 0.0;
	double d_eq_extra_val = 0.0;
	double d_avg_eq_trd_rt = 0.0;
	double d_turnover = 0.0;

	struct vw_err_msg st_err_msg;

	EXEC SQL INCLUDE "table/sad_stgy_atsrpt_dtls.h";
	EXEC SQL INCLUDE "table/atm_ats_trade_mstr.h";

	EXEC SQL BEGIN DECLARE SECTION;
    varchar c_trd_dt [ LEN_DATE ];
  EXEC SQL END DECLARE SECTION;


	/* Getting data from input buffer */

  ptr_fml_Ibuf = (FBFR32 *)rqst->data;
  strcpy( c_ServiceName, rqst->name );

  /* Debug level is being read */

  INITDBGLVL(c_ServiceName);


  /* Reading data in FMLs obtained from ASP */

	MEMSET(c_trd_dt);

  if(Fget32(ptr_fml_Ibuf,FFO_EXPRY_DT,0,(char *)c_trd_dt.arr,0) == -1)
  {
      fn_errlog( c_ServiceName, "S31005", FMLMSG, c_err_msg  );
      Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

	SETLEN(c_trd_dt);

		
	/************Calling function to begin Transaction******************/

  /* i_trnsctn  = fn_begintran( c_ServiceName, c_err_msg );   */

	i_trnsctn = tpbegin(BAT_TRAN_LOCAL,0);

  if ( i_trnsctn == -1 )
  {
    fn_errlog( c_ServiceName, "S31010", LIBMSG, c_err_msg  );
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

	EXEC SQL
			 DELETE FROM atm_ats_trade_mstr;

	EXEC SQL
         UPDATE sad_stgy_atsrpt_dtls
         SET    sad_prcsd_flg = 'N';

  if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
  {
    fn_errlog(c_ServiceName, "S31015", SQLMSG, c_err_msg);
    tpabort(0);
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

	if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg ) == -1 )
  {
    tpfree ( ( char * ) ptr_fml_Obuf );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

	/*---------------------------------------------------------------------------------------------------------------------|
	|                                           PART 2                                                                     |
	| In this part we get the particulars of all enabled strategies. We will look at only those trades that meet these     |
	| particulars. Initailly we had not added high price and low price but then later came to know that the same contract  |
	| with the same buy/sell flag but with different price ranges will be part of different strategies. So the prices too  | 
	| were included in the query below.                                                                                    |
	|---------------------------------------------------------------------------------------------------------------------*/  


	/* i_trnsctn  = fn_begintran( c_ServiceName, c_err_msg ); */

	i_trnsctn = tpbegin(BAT_TRAN_LOCAL,0);

  if ( i_trnsctn == -1 )
  {
    fn_errlog( c_ServiceName, "S31020", LIBMSG, c_err_msg  );
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

  EXEC SQL
			 DECLARE cur_sad_mstr CURSOR FOR 

			 				 SELECT distinct(sad_cntrct_dscrp),
										  sad_bs_flg,
											sad_segment,
										  sad_low_prc,
											sad_high_prc 
							 FROM   sad_stgy_atsrpt_dtls
							 WHERE  sad_enbl_disbl_flg = 'E';

	fn_userlog( c_ServiceName,"Declared Cursor for getting records from sad_stgy_atsrpt_dtls ");
							   		
	EXEC SQL
			 OPEN cur_sad_mstr;

	if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND)
  {
    EXEC SQL CLOSE cur_sad_mstr;
    fn_errlog(c_ServiceName, "S31025", SQLMSG, c_err_msg);
    tpabort(0);
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }	
	if ( SQLCODE == NO_DATA_FOUND)
  {
    EXEC SQL CLOSE cur_sad_mstr;

    fn_errlog(c_ServiceName, "S31030", SQLMSG, c_err_msg);
    strcpy(c_msg,"No Data Found in sad_stgy_atsrpt_mstr ");
    fn_userlog(c_ServiceName,c_msg);
    tpabort(0);
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }	
	

	while(1)
	{
		if(DEBUG_MSG_LVL_3)
    {
      fn_userlog(c_ServiceName,"Fetching Records for cur_sad_mstr Cursor");
    }

		MEMSET(sql_sad_cntrct_dscrp);	
		MEMSET(sql_sad_segment);	
			
		EXEC SQL FETCH cur_sad_mstr
             INTO  :sql_sad_cntrct_dscrp,
                   :sql_sad_bs_flg,
									 :sql_sad_segment,
									 :sql_sad_low_prc,
									 :sql_sad_high_prc;	

		if(SQLCODE != 0)
    {
        if(SQLCODE == NO_DATA_FOUND)
        {
          fn_userlog(c_ServiceName,c_msg);
          EXEC SQL CLOSE cur_sad_mstr;
          break;
        }
        else
        {
          sprintf(c_msg,"Error occured while fetching cur_sad_mstr ,sqlcode-:%d:",sqlca.sqlcode);
          fn_userlog(c_ServiceName,c_msg);
          fn_errlog( c_ServiceName, "S31035", SQLMSG, c_err_msg  );
        }
        tpabort(0);
        EXEC SQL CLOSE cur_sad_mstr;
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

		SETLEN(sql_sad_cntrct_dscrp);
		SETLEN(sql_sad_segment);

    sprintf( c_msg,"Fetched  :%s: :%c: :%s:",sql_sad_cntrct_dscrp.arr,sql_sad_bs_flg,sql_sad_segment.arr );
    fn_userlog( c_ServiceName,c_msg );	


		/*-------------------------------------------------------------------------------------------------------------------|
		|                                            PART 3                                                                  |
		| Based on the segment ( FNO or EQUITY ) we get trades from their respective tables .                                |
		|-------------------------------------------------------------------------------------------------------------------*/

		if( strcmp( sql_sad_segment.arr,"FNO" ) == 0 )
		{

			fn_userlog( c_ServiceName," Strategy is :%s:",sql_sad_cntrct_dscrp.arr );
			fn_userlog( c_ServiceName," Buy/Sell is :%c:",sql_sad_bs_flg );
			fn_userlog( c_ServiceName," Expiry date is :%s:",c_trd_dt.arr );
			

			EXEC SQL
				   INSERT INTO atm_ats_trade_mstr
				   (
							atm_trd_ref,
						  atm_cntrct_dscrpt,
						  atm_mtch_accnt,
						  atm_trd_qty,
						  atm_trd_val,
						  atm_lotsz,
						  atm_prdct_typ,
						  atm_undrlyng,
						  atm_expry_dt,
						  atm_exerc_typ,
						  atm_opt_typ,
						  atm_strk_prc,
						  atm_fcm_lotsz,
							atm_trd_rt
				   )
				   (
						  SELECT distinct(ftd_eba_trd_ref),
										 sad_cntrct_dscrp||'-'||ftd_trd_flw, 
									   ftd_clm_mtch_accnt,
									   ftd_exctd_qty,
									   ftd_exctd_qty*ftd_exctd_rt,
									   /*** ftd_exctd_qty/fcm_lot_sz,  commented in Ver 1.1 ***/
                     ftd_exctd_qty/ftq_min_lot_qty,          /*** Ver 1.1 ***/
									   ftd_prdct_typ,
									   ftd_undrlyng,
									   ftd_expry_dt,
									   ftd_exer_typ,
									   ftd_opt_typ,
									   ftd_strk_prc,
									   /*** fcm_lot_sz, commented in Ver 1.1 ***/
                     ftq_min_lot_qty,         /*** Ver 1.1 ***/
										 ftd_exctd_rt
						  FROM   sad_stgy_atsrpt_dtls,ftd_fo_trd_dtls,/*** fcm_fo_cntrct_mstr *** Ver 1.1 Comment ***/
                     ftq_fo_trd_qt                        /*** Ver 1.1 ***/ 
						  WHERE  trim(sad_cntrct_dscrp) = :sql_sad_cntrct_dscrp
              /*** Commented in Ver 1.1 ***
						  AND    ftd_undrlyng     			= fcm_undrlyng
						  AND    ftd_prdct_typ    			= fcm_prdct_typ
						  AND    ftd_indstk       			= fcm_indstk
						  AND    ftd_expry_dt     			= fcm_expry_dt
						  AND    ftd_exer_typ     			= fcm_exer_typ
						  AND    ftd_opt_typ      			= fcm_opt_typ
						  AND    ftd_strk_prc     			= fcm_strk_prc
              *** Ver 1.1 Comment Ends ***/
              AND    ftd_undrlyng           = ftq_undrlyng       /*** Ver 1.1 ***/
              AND    ftd_prdct_typ          = ftq_prdct_typ      /*** Ver 1.1 ***/
              AND    ftd_indstk             = ftq_indstk         /*** Ver 1.1 ***/
              AND    ftd_expry_dt           = ftq_expry_dt       /*** Ver 1.1 ***/
              AND    ftd_exer_typ           = ftq_exer_typ       /*** Ver 1.1 ***/
              AND    ftd_opt_typ            = ftq_opt_typ        /*** Ver 1.1 ***/ 
              AND    ftd_strk_prc           = ftq_strk_prc       /*** Ver 1.1 ***/ 
						  AND    ftd_trd_flw      			= :sql_sad_bs_flg
							AND    ftd_exctd_rt     			>= :sql_sad_low_prc*100
							AND    ftd_exctd_rt     			<= :sql_sad_high_prc*100
							AND    trunc(ftd_trd_dt)			= :c_trd_dt
						  AND    decode(ftd_prdct_typ,'O','OPT','F','FUT')||'-'||trim(ftd_undrlyng)||'-'||to_char(ftd_expry_dt,'MON')||'-'||ftd_strk_prc||'-'||ftd_opt_typ||'-'||ftd_exer_typ 	= :sql_sad_cntrct_dscrp );

				   if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
    		   {
      			  EXEC SQL CLOSE cur_sad_mstr;
      			  fn_errlog(c_ServiceName, "S31040", SQLMSG, c_err_msg);
      			  tpabort(0);
							Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    					tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    		   }

		 }	
		 else   /* Segment is EQUITY */
		 {

				/* Note:- Check on exchange is not implemented ( segment, settlement not considered )  */

				fn_userlog( c_ServiceName,"Getting data from trd table for :%s: :%c: ",sql_sad_cntrct_dscrp.arr,sql_sad_bs_flg );

				EXEC SQL
           INSERT INTO atm_ats_trade_mstr
           (
              atm_cntrct_dscrpt,
              atm_mtch_accnt,
              atm_trd_qty,
              atm_trd_val,
              atm_lotsz,
              atm_prdct_typ, 
              atm_undrlyng,
              atm_expry_dt,
							atm_strk_prc,
              atm_trd_ref,
						  atm_trd_rt
           )
           (
              SELECT distinct(sad_cntrct_dscrp||'-'||sad_bs_flg),
                     trd_clm_mtch_accnt,
                     trd_exctd_qty,
                     trd_exctd_qty*trd_exctd_rt,
                     trd_exctd_qty/trd_exctd_qty,
                     substr(sad_cntrct_dscrp,1,1),                 /* For Equity product type will be 'E' */
                     trd_stck_cd,
                     trunc(trd_trd_dt),
										 trd_exctd_rt, 
                     trd_trd_ref,
										 trd_exctd_rt
              FROM   sad_stgy_atsrpt_dtls,trd_trd_dtls
              WHERE  sad_cntrct_dscrp  = :sql_sad_cntrct_dscrp
              AND    trunc(trd_trd_dt) = :c_trd_dt
              AND    trd_exctd_rt      >=  :sql_sad_low_prc 
							AND    trd_exctd_rt      <=  :sql_sad_high_prc
              AND    trd_trd_flw       = :sql_sad_bs_flg
							AND    trd_trd_flw       = sad_bs_flg
              AND    'EQ'||'-'||trim(trd_stck_cd)||'-'||to_char(trd_trd_dt,'MON')||'-'||'0'||'-'||'*'||'-'||'*'   = :sql_sad_cntrct_dscrp );

				if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND)
        {
           EXEC SQL CLOSE cur_sad_mstr;
           fn_errlog(c_ServiceName, "S31045", SQLMSG, c_err_msg);
           tpabort(0);
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        }

		 }


	} /* End of While 1 */

	if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg ) == -1 )
  {
    tpfree ( ( char * ) ptr_fml_Obuf );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }



	/*--------------------------------------------------------------------------------------------------------------------|
	|                                              PART 4                                                                 |
	| At the end of this we have in our atm_ats_trade_mstr all records of FNO trades falling under one of the categories  |
  | defined in sad_stgy_atsrpt_dtls.                                                                                    |
	|                                                                                                                     |
  | The lot size in atm_ats_trade_mstr will be the sade as the one in FTD for each trade reference.                     |
	|	We will now spilt the trades such that the lot size is always 1. That means there will be multiple entries for each |
	| trade reference. 																																																		|
  | While spliting the lot size we will also split the trade value and executed qty accordingly. 												|
	|--------------------------------------------------------------------------------------------------------------------*/   


	/* i_trnsctn  = fn_begintran( c_ServiceName, c_err_msg ); */

	i_trnsctn = tpbegin(BAT_TRAN_LOCAL,0);

  if ( i_trnsctn == -1 )
  {
    fn_errlog( c_ServiceName, "S31050", LIBMSG, c_err_msg  );
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

	EXEC SQL
			 DECLARE cur_ats_trdmstr CURSOR FOR
               SELECT atm_trd_ref,
											atm_trd_qty,
											atm_lotsz,
											atm_trd_val,
											atm_fcm_lotsz,
											atm_cntrct_dscrpt,
											atm_mtch_accnt,
											atm_prdct_typ,
											atm_undrlyng,
										  atm_expry_dt,
											atm_exerc_typ,
											atm_opt_typ,
											atm_strk_prc,
											atm_trd_rt
							 FROM   atm_ats_trade_mstr 
							 WHERE  atm_lotsz != 1;

  fn_userlog( c_ServiceName,"Declared Cursor for getting records from atm_ats_trade_mstr where lot size is more than 1");

  EXEC SQL
       OPEN cur_ats_trdmstr;

  if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND)
  {
    EXEC SQL CLOSE cur_ats_trdmstr;
    fn_errlog(c_ServiceName, "S31055", SQLMSG, c_err_msg);
    tpabort(0);
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }
  if ( SQLCODE == NO_DATA_FOUND)
  {
    EXEC SQL CLOSE cur_ats_trdmstr;

    fn_errlog(c_ServiceName, "S31060", SQLMSG, c_err_msg);
    strcpy(c_msg,"No Data Found in atm_ats_trade_mstr ");
    fn_userlog(c_ServiceName,c_msg);
    tpabort(0);
		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

	while(1)
  {
    if(DEBUG_MSG_LVL_3)
    {
      fn_userlog(c_ServiceName,"Fetching Records for cur_ats_trdmstr Cursor");
    }

    MEMSET( sql_atm_trd_ref );
    MEMSET( sql_atm_cntrct_dscrpt );
    MEMSET( sql_atm_mtch_accnt );
    MEMSET( sql_atm_undrlyng );
    MEMSET( sql_atm_expry_dt );
		sql_atm_trd_qty   = 0;
		sql_atm_lotsz     = 0;
		sql_atm_trd_val   = 0;
		sql_atm_fcm_lotsz = 0;
		sql_atm_strk_prc  = 0;

    EXEC SQL FETCH cur_ats_trdmstr
             INTO  :sql_atm_trd_ref,
                   :sql_atm_trd_qty,
									 :sql_atm_lotsz,
									 :sql_atm_trd_val,
									 :sql_atm_fcm_lotsz,
									 :sql_atm_cntrct_dscrpt,
									 :sql_atm_mtch_accnt,
									 :sql_atm_prdct_typ,
									 :sql_atm_undrlyng,
									 :sql_atm_expry_dt,
									 :sql_atm_exerc_typ,
									 :sql_atm_opt_typ,
									 :sql_atm_strk_prc,
									 :sql_atm_trd_rt;

    if(SQLCODE != 0)
    {
        if(SQLCODE == NO_DATA_FOUND)
        {
          EXEC SQL CLOSE cur_ats_trdmstr;
          break;
        }
        else
        {
          sprintf(c_msg,"Error occured while fetching cur_ats_trdmstr ,sqlcode-:%d:",sqlca.sqlcode);
          fn_userlog(c_ServiceName,c_msg);
          fn_errlog( c_ServiceName, "S31065", SQLMSG, c_err_msg  );
        }
        tpabort(0);
        EXEC SQL CLOSE cur_ats_trdmstr;
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

		SETLEN( sql_atm_trd_ref );
		SETLEN( sql_atm_cntrct_dscrpt );
		SETLEN( sql_atm_mtch_accnt );
		SETLEN( sql_atm_undrlyng );
		SETLEN( sql_atm_expry_dt );

		fn_userlog( c_ServiceName,"Lots :%ld:",sql_atm_lotsz );

	  for( i=0; i < sql_atm_lotsz; i++ )
		{

			EXEC SQL
					 INSERT INTO atm_ats_trade_mstr
					 (
						 atm_cntrct_dscrpt,
						 atm_mtch_accnt,
						 atm_trd_qty,
						 atm_lotsz,
						 atm_trd_val,
						 atm_prdct_typ,
						 atm_undrlyng,
						 atm_expry_dt,
						 atm_exerc_typ,
						 atm_opt_typ,
						 atm_strk_prc,
						 atm_fcm_lotsz,
						 atm_trd_ref,
						 atm_trd_rt
				   )
					 VALUES
					 (
							:sql_atm_cntrct_dscrpt,
							:sql_atm_mtch_accnt,
							:sql_atm_fcm_lotsz,
							1,
							:sql_atm_trd_val/:sql_atm_lotsz,
							:sql_atm_prdct_typ,
							:sql_atm_undrlyng,
							:sql_atm_expry_dt,
							:sql_atm_exerc_typ,
							:sql_atm_opt_typ,
							:sql_atm_strk_prc,
							:sql_atm_fcm_lotsz,
							:sql_atm_trd_ref,
							:sql_atm_trd_rt
					 );

			if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND)
  		{
    		EXEC SQL CLOSE cur_ats_trdmstr;
    		fn_errlog(c_ServiceName, "S31070", SQLMSG, c_err_msg);
    		tpabort(0);
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  		}
  		if ( SQLCODE == NO_DATA_FOUND)
  		{
    		EXEC SQL CLOSE cur_ats_trdmstr;

    		fn_errlog(c_ServiceName, "S31075", SQLMSG, c_err_msg);
    		strcpy(c_msg,"No Data Found in atm_ats_trade_mstr ");
    		fn_userlog(c_ServiceName,c_msg);
    		tpabort(0);
				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  		}
			
		}/* End of For loop */
		
	} /* End of while 2 */


	EXEC SQL
			 DELETE FROM atm_ats_trade_mstr WHERE  atm_lotsz != 1;

	if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND)
  {
     fn_errlog(c_ServiceName, "S31080", SQLMSG, c_err_msg);
     tpabort(0);
		 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
     tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

	if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg ) == -1 )
  {
    tpfree ( ( char * ) ptr_fml_Obuf );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

	/*--------------------------------------------------------------------------------------------------------------------|
	|                                                      PART 5                                                         |
	| Now we have to categorize the rows based on Strategies defined in sad_stgy_atsrpt_dtls. We will first choose a      |
  | strategy with highest priority and try to mark the rows of atm_ats_trade_mstr falling in that category.             |
  |	Then we move to strategy with next higher priority.                                                                 |
	|--------------------------------------------------------------------------------------------------------------------*/

	while(1)
	{

		/* i_trnsctn  = fn_begintran( c_ServiceName, c_err_msg ); */

		i_trnsctn = tpbegin(BAT_TRAN_LOCAL,0);

  	if ( i_trnsctn == -1 )
  	{
    	fn_errlog( c_ServiceName, "S31085", LIBMSG, c_err_msg  );
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	}

		MEMSET(sql_sad_strtgy_subnm);
		MEMSET(sql_sad_segment);

		EXEC SQL
			 	 SELECT sad_alias.sad_strtgy_subnm,
								sad_alias.sad_count,
								sad_alias.sad_segment

			   INTO   :sql_sad_strtgy_subnm,
								:l_count_substrtgy,
								:sql_sad_segment

			   FROM   ( SELECT sad_strtgy_subnm ,sad_count,sad_segment,ROWNUM rnum 

			            FROM ( SELECT sad_strtgy_subnm,sad_priority,sad_segment,count(*) sad_count 
											   FROM   sad_stgy_atsrpt_dtls
											   WHERE  sad_enbl_disbl_flg = 'E'
												 AND    sad_prcsd_flg    = 'N'
												 GROUP BY sad_strtgy_subnm,sad_priority,sad_segment
											   ORDER BY sad_priority  )  

								  WHERE ROWNUM = 1 ) sad_alias;

	  if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
    {
       fn_errlog(c_ServiceName, "S31090", SQLMSG, c_err_msg);
       tpabort(0);
			 Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    	 tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }
		if ( SQLCODE == NO_DATA_FOUND )
    {
			tpabort(0);
			break;
    }
		
		SETLEN( sql_sad_segment );
		SETLEN( sql_sad_strtgy_subnm );

		if(DEBUG_MSG_LVL_3)
    {

		fn_userlog( c_ServiceName,"SEGMENT OF SELECTED STRATEGY IS :%s:", sql_sad_segment.arr );
		fn_userlog( c_ServiceName,"NAME OF SELECTED STRATEGY IS :%s:", sql_sad_strtgy_subnm.arr );

		}
	

		if ( strcmp( sql_sad_segment.arr,"FNO" ) == 0 )
		{

			EXEC SQL
					 DELETE FROM tmp_atm_trd_mstr;

			if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
      {
          fn_errlog(c_ServiceName, "S31095", SQLMSG, c_err_msg);
          tpabort(0);
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

			 /* Suppose there is a strategy which involves both FNO and EQ trades as in Reverse Arbitrage Strategy the; in case
			    FNO contract comes first in the above query (FNO or EQ can come first; then we also process for EQ and mark the 					  processed flag as 'P' so that it doesn't get picked up again for EQ when the above query runs again for Equity */

			l_combination_flg = 0;

			EXEC SQL
					 SELECT 1 INTO :l_combination_flg
					 FROM   sad_stgy_atsrpt_dtls 
					 WHERE  sad_strtgy_subnm  = :sql_sad_strtgy_subnm
					 AND    sad_segment = 'EQ'
				   AND    sad_prcsd_flg in ('N','I');

			if(( SQLCODE != 0 ) && ( SQLCODE != NO_DATA_FOUND ))
      {
          fn_errlog( c_ServiceName, "S31100", SQLMSG, c_err_msg  );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpabort(0);
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

			memset( c_contracts,'\0',sizeof(c_contracts) );

      no_of_records = 0;

      EXEC SQL
           SELECT distinct(sad_cntrct_dscrp)||'-'||sad_bs_flg,
                  sad_lot_sz,
									sad_low_prc,
									sad_high_prc
           INTO   :c_contracts,
                  :l_sad_lot_sz,
									:d_sql_sad_low_prc_fno,
									:d_sql_sad_high_prc_fno
           FROM   sad_stgy_atsrpt_dtls
           WHERE  sad_strtgy_subnm  = :sql_sad_strtgy_subnm
           AND    sad_segment       = 'FNO'
           AND    sad_prcsd_flg     = 'N';

      no_of_records = sqlca.sqlerrd[2];

      fn_userlog( c_ServiceName,"Number of Records are :%ld:", no_of_records );

      if(( SQLCODE != 0 ) && ( SQLCODE != NO_DATA_FOUND ))
      {
          fn_errlog( c_ServiceName, "S31105", SQLMSG, c_err_msg  );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpabort(0);
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
      if( SQLCODE == NO_DATA_FOUND && sqlca.sqlerrd[2] == 0 )
      {
          strcpy( c_err_msg,"No records found for this strategy code under FNO" );
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpabort(0);
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

			for( temp_counter = 0; temp_counter < no_of_records; temp_counter++ )
			{

				trim(c_contracts[temp_counter]);

			if(DEBUG_MSG_LVL_3)
      {

			fn_userlog( c_ServiceName,"COntract description for inserting in TEMP table is :%s:", c_contracts[temp_counter] );
			fn_userlog( c_ServiceName,"Low price for inserting in TEMP table is :%lf:", d_sql_sad_low_prc_fno[temp_counter] );
			fn_userlog( c_ServiceName,"High price for inserting in TEMP table is :%lf:", d_sql_sad_high_prc_fno[temp_counter] );

			}

			EXEC SQL
					 INSERT INTO tmp_atm_trd_mstr
           (
              tmp_atm_mtch_accnt,
              tmp_atm_cntrct_dscrpt,
              tmp_atm_count
           )
					 (
							SELECT atm_mtch_accnt,
                     atm_cntrct_dscrpt,
                     COUNT(atm_lotsz)
              FROM   atm_ats_trade_mstr
              WHERE  atm_cntrct_dscrpt	 =  :c_contracts[temp_counter]
						  AND    atm_trd_rt          >= :d_sql_sad_low_prc_fno[temp_counter]*100 
					    AND    atm_trd_rt          <= :d_sql_sad_high_prc_fno[temp_counter]*100
						  AND    atm_strtgy_dscrpt IS NULL
						  GROUP BY atm_mtch_accnt,atm_cntrct_dscrpt
					 );

				if ( SQLCODE != 0 )
      	{
          fn_errlog(c_ServiceName, "S31110", SQLMSG, c_err_msg);
          tpabort(0);
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      	}

			}

/*  Commented as it doesn't consider price range for FNO 

	  	EXEC SQL
				 	INSERT INTO tmp_atm_trd_mstr
				 	(
					 		tmp_atm_mtch_accnt,
							tmp_atm_cntrct_dscrpt,
							tmp_atm_count
				 	)
				 	( SELECT atm_mtch_accnt,
									 atm_cntrct_dscrpt,
									 COUNT(atm_lotsz) 
					 	FROM   atm_ats_trade_mstr 
					 	WHERE  atm_cntrct_dscrpt IN ( SELECT atm_cntrct_dscrpt 
																				 	FROM   atm_ats_trade_mstr,sad_stgy_atsrpt_dtls
																				 	WHERE  atm_cntrct_dscrpt = sad_cntrct_dscrp||'-'||sad_bs_flg 
																				 	AND    sad_strtgy_subnm  = :sql_sad_strtgy_subnm
																					AND    sad_segment       = 'FNO' 
																				  AND    sad_prcsd_flg     = 'N' ) 
					 	AND    atm_strtgy_dscrpt IS NULL 
					 	GROUP BY atm_mtch_accnt,atm_cntrct_dscrpt 
				 	);

			if ( SQLCODE != 0 )
    	{
       		fn_errlog(c_ServiceName, "S31115", SQLMSG, c_err_msg);
       		tpabort(0);
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    	} 

*/

			/* The query below will delete all those customers who have not placed even one order in all the contracts defined 
			 	 for the strategy */

			EXEC SQL
				 	 DELETE FROM tmp_atm_trd_mstr A 
				   WHERE       EXISTS ( SELECT B.tmp_atm_mtch_accnt,COUNT(*) 
															  FROM tmp_atm_trd_mstr B 
															  WHERE A.tmp_atm_mtch_accnt = B.tmp_atm_mtch_accnt
															  HAVING count(*) < :l_count_substrtgy 
															  GROUP BY tmp_atm_mtch_accnt );

			if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
    	{
       		fn_errlog(c_ServiceName, "S31120", SQLMSG, c_err_msg);
      	 	tpabort(0);
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    	}

			EXEC SQL
				 	 DECLARE cur_tmp_mtch CURSOR FOR SELECT distinct(tmp_atm_mtch_accnt) FROM tmp_atm_trd_mstr;

			EXEC SQL
				 	 OPEN cur_tmp_mtch; 
		
			if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
    	{
      		fn_errlog(c_ServiceName, "S31125", SQLMSG, c_err_msg);
      		tpabort(0);
					Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    	}
			if ( SQLCODE == NO_DATA_FOUND)
  		{
    			EXEC SQL CLOSE cur_tmp_mtch;
					fn_errlog(c_ServiceName, "S31130", SQLMSG, c_err_msg);
					EXEC SQL CLOSE cur_tmp_mtch;
      		tpabort(0);	
				  Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
			}
	
			while(1)
			{	

					EXEC SQL
					 		 FETCH cur_tmp_mtch
					 		 INTO  :c_tmp_mtch;

		  		if(SQLCODE != 0)
    			{
        		if(SQLCODE == NO_DATA_FOUND)
        		{
          				EXEC SQL CLOSE cur_tmp_mtch;
          				break;
        		}
        		else
        		{
									fn_errlog(c_ServiceName, "S31135", SQLMSG, c_err_msg);
        		}
						EXEC SQL CLOSE cur_tmp_mtch;
        		tpabort(0);
						Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    			}	

					fn_userlog( c_ServiceName,"Match Account is :%s:", c_tmp_mtch );

					for( i_counter = 0; i_counter < no_of_records; i_counter++ )
					{

						trim(c_contracts[i_counter]);

						EXEC SQL
					 	     SELECT tmp_atm_count 
					   		 INTO   :l_atm_lot_sz
					   		 FROM   tmp_atm_trd_mstr 
					   		 WHERE  trim(tmp_atm_cntrct_dscrpt) = :c_contracts[i_counter]
					   		 AND    tmp_atm_mtch_accnt    = :c_tmp_mtch; 

		    		if ( SQLCODE != 0 )
    	  		{
       	  				fn_errlog(c_ServiceName, "S31140", SQLMSG, c_err_msg);
       	  				tpabort(0);
									Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
                  tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    	  		}	

						fn_userlog( c_ServiceName,"Contract description is :%s: ,lot size available is :%ld: & lot size required is                                            :%ld:",c_contracts[i_counter],l_atm_lot_sz,l_sad_lot_sz[i_counter] );

						l_quotient = l_atm_lot_sz/l_sad_lot_sz[i_counter];

			  		if( i_counter == 0 )
						{
							l_multiplier = l_quotient;
						}	
						else
						{
							if ( l_multiplier > l_quotient )
							{
								l_multiplier = l_quotient;	
							}
						}

		  		} /* End of first FOR loop */

				  for( i_counter = 0; i_counter < no_of_records; i_counter++ )
      		{

						trim(c_contracts[i_counter]);

						fn_userlog( c_ServiceName,"MULTIPLIER is :%ld:", l_multiplier );
	
						l_no_of_rows = ( l_multiplier*l_sad_lot_sz[i_counter] ) ;

						fn_userlog( c_ServiceName,"Number of rows getting updated for :%s: is :%ld:", sql_sad_strtgy_subnm.arr,l_no_of_rows );
						
						for( j=1; j <= l_no_of_rows; j++ )
						{
							fn_userlog( c_ServiceName,"NAME IS --------:%s:", sql_sad_strtgy_subnm.arr );
        			EXEC SQL
             		 	 UPDATE atm_ats_trade_mstr 
						 		   SET    atm_strtgy_dscrpt = :sql_sad_strtgy_subnm,
												  atm_prcsd_flg     = 'P'
             		   WHERE  atm_mtch_accnt    = :c_tmp_mtch
             		   AND    atm_cntrct_dscrpt = :c_contracts[i_counter]
									 AND    atm_trd_rt        >= :d_sql_sad_low_prc_fno[i_counter]*100
									 AND    atm_trd_rt        <= :d_sql_sad_high_prc_fno[i_counter]*100 
								   AND    atm_strtgy_dscrpt IS NULL
						 		   AND    ROWNUM = 1;

						  if ( SQLCODE != 0 )
    				  {
      				  fn_errlog(c_ServiceName, "S31145", SQLMSG, c_err_msg);
      				  tpabort(0);
      				  Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      				  tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    				  }
						}

					}/* End of second For loop */

					if( l_combination_flg == 1 )   /* CASES HAVING FNO TRADES AND EQUITY TRADES FALLING UNDER SAME STRATEGY */
					{

						/* I would have updated ATM_ATS_TRADE_MSTR with STRTGY_SUBNM at this point of code for the selected client if
							 client has used STRTGY_SUBNM. But I have checked and updated only contracts of FNO segment which as part of 
							 STRTGY_SUBNM. Now since this STRTGY_SUBNM also includes trades in Equity I try to see if he has also done 
							 trading in the required equity stocks as defined in SAD master. If he has done I update ATM_ATS_TRADE_MSTR 
							 with STRTGY_SUBNM against the equity trade in ATM_ATS_TRADE_MSTR. In case he has traded for double the qty 
							 specified in SAD master under EQ then I split his trade of equity and update only one row having the qty 
							 specified in SAD master. In case he has used the stregy twice in FNO too then I update both the rows of 
							 Equity trade in atm_ats_trade_mstr */

						/* In the following 2 queries I try to find how many times customer used the STRTGY_SUBNM in FNO */ 

						no_of_atm_rec_for_eq = 0;

						memset( c_cntrct_desc_for_eq,'\0',sizeof(c_cntrct_desc_for_eq) );
				    for( i= 0 ; i < MAX_CNTRCT_SZ; i++ )
						{
							l_atm_count_for_eq[i] = 0;
							l_times_fno[i] = 0;
						}	

						if(DEBUG_MSG_LVL_3)
    				{
						fn_userlog( c_ServiceName,"NAME IS --------:%s:", sql_sad_strtgy_subnm.arr );
						fn_userlog( c_ServiceName,"MATCH IS --------:%s:", c_tmp_mtch );
						}


						/* Count because for FNO we will have each of Lot size 1 in ATM */

						EXEC SQL
								 SELECT atm_cntrct_dscrpt,
												COUNT(atm_lotsz)
								 INTO   :c_cntrct_desc_for_eq,
												:l_atm_count_for_eq
								 FROM   atm_ats_trade_mstr
								 WHERE  atm_strtgy_dscrpt = :sql_sad_strtgy_subnm
								 AND    atm_prcsd_flg     = 'P'
								 AND    atm_mtch_accnt    = :c_tmp_mtch
								 GROUP BY atm_cntrct_dscrpt; 
 
						no_of_atm_rec_for_eq = sqlca.sqlerrd[2]; 

						fn_userlog( c_ServiceName," Rows selected testing :%ld:", l_atm_count_for_eq[0] );

						if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
            {
              fn_errlog(c_ServiceName, "S31150", SQLMSG, c_err_msg);
              tpabort(0);
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }
						if( SQLCODE == NO_DATA_FOUND && sqlca.sqlerrd[2] == 0 )
      			{
							fn_errlog(c_ServiceName, "S31155", SQLMSG, c_err_msg);
              tpabort(0);
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      			}

						for(  i = 0; i <  no_of_atm_rec_for_eq; i++ )
						{

							/* Note:- Here I am not checking for the executed rate to be between the 2 given rates in SAD master. I assume there will never be  strategy in which we will check to see if the customer has purchased between 2 given ranges of price for the same underlying in a single day. This assumption will mean that the query in STEP 2 below will always return only 1 row . */
							trim(c_cntrct_desc_for_eq[i]);
			
							if(DEBUG_MSG_LVL_3)
    					{
							fn_userlog( c_ServiceName,"COntract Description selected from array is :%s:", c_cntrct_desc_for_eq[i] );
							fn_userlog( c_ServiceName,"Strategy code is :%s:", sql_sad_strtgy_subnm.arr );
							}

							EXEC SQL
                 	 SELECT :l_atm_count_for_eq[i]/sad_lot_sz
                   INTO   :l_times_fno[i] 
                   FROM   sad_stgy_atsrpt_dtls
                   WHERE  sad_strtgy_subnm = :sql_sad_strtgy_subnm
                   AND    sad_cntrct_dscrp||'-'||sad_bs_flg = :c_cntrct_desc_for_eq[i];

						  if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
              {
                fn_errlog(c_ServiceName, "S31160", SQLMSG, c_err_msg);
                tpabort(0);
                Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
               tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
              }
							if( SQLCODE == NO_DATA_FOUND && sqlca.sqlerrd[2] == 0 )
            {
              fn_errlog(c_ServiceName, "S31165", SQLMSG, c_err_msg);
              tpabort(0);
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }

							/* Ideally i_times_fno[i] must be the same for all values of i since the times each contract was part of the strategy will be the same */

							if ( ( i > 0 ) && ( l_times_fno[i] != l_times_fno[i-1] ) )  
							{
								fn_errlog(c_ServiceName, "S31170", SQLMSG, c_err_msg);
								fn_userlog( c_ServiceName,"The times customer used FNO is incorrect. Pls check" );
                tpabort(0);
                Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
               	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );	
							}

						}

						/* At this point of time I know how many times customer used STRTGY_SUBNM considering only contracts of FNO */


						/* The query below will get all the Equity trades required to complete this STRTGY_SUBNM */

						no_of_eqrecords = 0;

            memset( c_eq_cnt_desc,'\0',sizeof(c_eq_cnt_desc) );
						memset( c_underlying,'\0',sizeof(c_underlying) );

            for( i= 0 ; i < MAX_CNTRCT_SZ; i++ )
            {
              l_atm_count_eq[i] = 0;
              l_sad_eq_qty[i] = 0;
            }

						/* Note:- Here I am not checking for the executed rate to be between the 2 given rates in SAD master. I assume there will never be  strategy in which we will check to see if the customer has purchased between 2 given ranges of price for the same underlying in a single day. This assumption will mean that the query in STEP 2 below will always return only 1 row. */

						EXEC SQL
                 SELECT sad_cntrct_dscrp||'-'||sad_bs_flg,
                        sad_eq_qty,
												sad_low_prc,
												sad_high_prc
                 INTO   :c_eq_cnt_desc,             
                        :l_sad_eq_qty,
												:d_sql_sad_low_prc,
												:d_sql_sad_high_prc
                 FROM   sad_stgy_atsrpt_dtls
                 WHERE  sad_strtgy_subnm = :sql_sad_strtgy_subnm
                 AND    sad_segment = 'EQ';


						if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
            {
              fn_errlog(c_ServiceName, "S31175", SQLMSG, c_err_msg);
              tpabort(0);
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }
						if( SQLCODE == NO_DATA_FOUND && sqlca.sqlerrd[2] == 0 )
            {
              fn_errlog(c_ServiceName, "S31180", SQLMSG, c_err_msg);
              tpabort(0);
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            }
						no_of_eqrecords = sqlca.sqlerrd[2];

						/* At this point of time the trades in ATM are similar to those in equity trade master. 
							 Since I need to check the qty for verifying STRTGY_SUBNM I insert a single record in ATM master 
							 with processed flag as 'N' for the selected client and stock and mark all the old trades in ATM with 
							 processed flag as 'P' and ATM strategy name as INVALID */

						/* Now I check and try to split the trades if the customer traded for qty greater than that specified in SAD */

					  for( k_counter = 0; k_counter < no_of_eqrecords; k_counter++ )
						{

								/*  STEP 1: Get Underlying name from Contract string */

								strcpy(c_underlying,(strstr(c_eq_cnt_desc[k_counter],"-") + 1));
							 	strtok(c_underlying,"-");	

								fn_userlog( c_ServiceName,"Underlying for Equity is :%s:", c_underlying );

								/*  STEP 2: Get the total traded qty in this underlying where executed rate is within given range */
	
								l_eq_trd_qty = 0;
								trim( c_eq_cnt_desc[k_counter] );

								if(DEBUG_MSG_LVL_3)
    						{
								fn_userlog( c_ServiceName,"Match is :%s:", c_tmp_mtch );
								fn_userlog( c_ServiceName,"ATM Contract is :%s:", c_eq_cnt_desc[k_counter] );
								fn_userlog( c_ServiceName,"Strategy Code is :%s:", sql_sad_strtgy_subnm.arr );
								fn_userlog( c_ServiceName,"Trade date is :%s:", c_trd_dt.arr );
								fn_userlog( c_ServiceName,"Low price is :%lf:", d_sql_sad_low_prc[k_counter] );
								fn_userlog( c_ServiceName,"High price is :%lf:", d_sql_sad_high_prc[k_counter] );
                fn_userlog( c_ServiceName,"K Counter :%d:", k_counter);
                fn_userlog( c_ServiceName,"l_eq_trd_qty :%ld:", l_eq_trd_qty);
                fn_userlog( c_ServiceName,"no_of_eqrecords :%ld:", no_of_eqrecords);
								}

								EXEC SQL
                     SELECT sum(atm_trd_qty)
										 INTO	  :l_eq_trd_qty
										 FROM   atm_ats_trade_mstr,sad_stgy_atsrpt_dtls
										 WHERE  trim(atm_mtch_accnt) = :c_tmp_mtch
										 AND    trim(atm_cntrct_dscrpt) = :c_eq_cnt_desc[k_counter]
                     AND    sad_cntrct_dscrp||'-'||sad_bs_flg = :c_eq_cnt_desc[k_counter]
                     AND    sad_strtgy_subnm = :sql_sad_strtgy_subnm
                     AND    to_date(atm_expry_dt,'dd-Mon-YYYY') = to_date(:c_trd_dt,'dd-Mon-YYYY')
										 AND    atm_strk_prc >= trunc(:d_sql_sad_low_prc[k_counter])
										 AND    atm_strk_prc <= trunc(:d_sql_sad_high_prc[k_counter])  
										 AND    atm_strtgy_dscrpt IS NULL
                     AND    sad_segment = 'EQ'
                     AND    sad_prcsd_flg != 'P' ;

								if ( SQLCODE != 0  && SQLCODE !=NO_DATA_FOUND && SQLCODE != -1405 )
            		{
              		fn_errlog(c_ServiceName, "S31185", SQLMSG, c_err_msg);
              		tpabort(0);
              		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            		}
								if( SQLCODE == -1405 )
								{
									if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg ) == -1 )
									{
  									tpfree ( ( char * ) ptr_fml_Obuf );
  									Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
										 tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
									}

										tpreturn( TPSUCCESS, 0, (char *)ptr_fml_Obuf, 0 , 0 );
								}

								fn_userlog( c_ServiceName," Equity traded qty is :%ld:", l_eq_trd_qty );


								/*  STEP 3: Get the total traded value in this underlying where executed rate is within given range */

								d_eq_trd_val = 0.0;

								EXEC SQL
										 SELECT sum(atm_trd_val)
										 INTO   :d_eq_trd_val
										 FROM   atm_ats_trade_mstr,sad_stgy_atsrpt_dtls
										 WHERE  trim(atm_mtch_accnt) = :c_tmp_mtch
										 AND    trim(atm_cntrct_dscrpt) = :c_eq_cnt_desc[k_counter]
										 AND    sad_cntrct_dscrp||'-'||sad_bs_flg = :c_eq_cnt_desc[k_counter]
										 AND    sad_strtgy_subnm = :sql_sad_strtgy_subnm
										 AND    trim(atm_expry_dt) = to_date(:c_trd_dt,'dd-Mon-YYYY')
										 AND    atm_strk_prc >= trunc(:d_sql_sad_low_prc[k_counter])
										 AND    atm_strk_prc <= trunc(:d_sql_sad_high_prc[k_counter])
										 AND    atm_strtgy_dscrpt IS NULL
										 AND    sad_segment = 'EQ'
										 AND    sad_prcsd_flg != 'P';

                if ( SQLCODE != 0 )
                {
                  fn_errlog(c_ServiceName, "S31190", SQLMSG, c_err_msg);
                  tpabort(0);
                  Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
                  tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
                }

								fn_userlog( c_ServiceName," Equity traded value is :%lf:", d_eq_trd_val );

								/* Update the old trades with processed flag as 'P' and strategy name as 'INVALID' and insert 
									 new records each of qty defined in sad master */


							  l_eq_extra_qty = l_eq_trd_qty%l_sad_eq_qty[k_counter];
								d_avg_eq_trd_rt = d_eq_trd_val/l_eq_trd_qty; 	

								if ( l_eq_extra_qty != 0 ) /* The traded qty is not an exact multiple of eq_qty in SAD master */
								{
									l_eq_rowq = l_eq_trd_qty/l_sad_eq_qty[k_counter]; /* Says how many rows of given qty to be inserted */

									d_eq_extra_val = d_avg_eq_trd_rt*l_eq_extra_qty;

								}
								else                        /* The traded qty is an exact multiple of given qty */
								{

									l_eq_rowq = l_eq_trd_qty/l_sad_eq_qty[k_counter]; /* Says how many rows of given qty to be inserted */
								}

								fn_userlog(c_ServiceName," Updating as INVALID...." );
								fn_userlog(c_ServiceName," l_eq_rowq INVALID....:%ld:",l_eq_rowq );

								EXEC SQL
										 UPDATE atm_ats_trade_mstr
										 SET    atm_strtgy_dscrpt = 'INVALID',
														atm_prcsd_flg     = 'P'
										 WHERE  atm_mtch_accnt    = :c_tmp_mtch
										 AND    atm_cntrct_dscrpt = :c_eq_cnt_desc[k_counter]
										 AND    atm_expry_dt      = :c_trd_dt
                     AND    atm_strk_prc      >= :d_sql_sad_low_prc[k_counter]
										 AND    atm_strk_prc      <= :d_sql_sad_high_prc[k_counter]
										 AND    atm_strtgy_dscrpt IS NULL
										 AND    trim(atm_undrlyng) = :c_underlying
										 AND    atm_prcsd_flg     = 'N';


								if ( SQLCODE != 0 )
                {
                  fn_errlog(c_ServiceName, "S31195", SQLMSG, c_err_msg);
                  tpabort(0);
                  Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
                  tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
                }

								for( l_count = 0;l_count < l_eq_rowq; l_count++ )
								{
	
									d_new_eq_strk_prc = 0.0;
									d_new_eq_trd_val  = 0.0;

									d_new_eq_strk_prc = d_avg_eq_trd_rt;
									d_new_eq_trd_val = d_avg_eq_trd_rt*l_sad_eq_qty[k_counter];

									EXEC SQL
										 	 INSERT INTO atm_ats_trade_mstr
										 	 (
              						 atm_trd_ref,
              						 atm_cntrct_dscrpt,
              						 atm_mtch_accnt,
              						 atm_trd_qty,
              						 atm_trd_val,
              						 atm_lotsz,
              						 atm_prdct_typ,
              						 atm_undrlyng,
              						 atm_expry_dt,
              						 atm_exerc_typ,
              						 atm_opt_typ,
              						 atm_strk_prc,
              						 atm_fcm_lotsz,
													 atm_trd_rt
           						 )
           						 (
										    	 SELECT 'XXXXXXXX',
														   	 	sad_cntrct_dscrp||'-'||sad_bs_flg,
															 		:c_tmp_mtch,
															 		:l_sad_eq_qty[k_counter],
															 		:d_new_eq_trd_val, 
															 		1,
															 		'E',
															 		:c_underlying,
															 		:c_trd_dt,
															 		'*',
															 		'*',
															 		:d_new_eq_strk_prc,
															 		1,
																	:d_new_eq_strk_prc
									      		FROM  sad_stgy_atsrpt_dtls
										   		  WHERE sad_cntrct_dscrp||'-'||sad_bs_flg = :c_eq_cnt_desc[k_counter]
										        AND   sad_strtgy_subnm = :sql_sad_strtgy_subnm
										        AND   sad_segment = 'EQ'
														AND   sad_enbl_disbl_flg = 'E'
												    AND   sad_prcsd_flg != 'P'
										    );

									if ( SQLCODE != 0 )
            			{
              			fn_errlog(c_ServiceName, "S31200", SQLMSG, c_err_msg);
              			tpabort(0);
              			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
            			}

								}

								if ( l_eq_extra_qty > 0 )
								{

										/* In order to use this extra qty for another strategy I have to update the executed rate with 
											 the correct executed price. Since I cannot get the exact rate at this ponit I give a 
											 calculated rate. */

										d_eq_extra_prc = 0.0;

                  	d_eq_extra_prc = d_eq_extra_val/l_eq_extra_qty;

										EXEC SQL
                       INSERT INTO atm_ats_trade_mstr
                       (
                           atm_trd_ref,
                           atm_cntrct_dscrpt,
                           atm_mtch_accnt,
                           atm_trd_qty,
                           atm_trd_val,
                           atm_lotsz,
                           atm_prdct_typ,
                           atm_undrlyng,
                           atm_expry_dt,
                           atm_exerc_typ,
                           atm_opt_typ,
                           atm_strk_prc,
                           atm_fcm_lotsz,
													 atm_trd_rt
                       )
                       (
                           SELECT 'XXXXXXXX',
                                  sad_cntrct_dscrp||'-'||sad_bs_flg,
                                  :c_tmp_mtch,
                                  :l_eq_extra_qty,
                                  :d_eq_extra_val,   /* calculated above */
                                  1,
                                  'E',
                                  :c_underlying,
                                  :c_trd_dt,
                                  '*',
                                  '*',
																	:d_eq_extra_prc,
                                  1,
																	:d_eq_extra_prc
                            FROM   sad_stgy_atsrpt_dtls
                            WHERE  sad_cntrct_dscrp||'-'||sad_bs_flg = :c_eq_cnt_desc[k_counter]
                            AND    sad_strtgy_subnm = :sql_sad_strtgy_subnm
                            AND    sad_segment = 'EQ'
														AND    sad_enbl_disbl_flg = 'E'
                            AND    sad_prcsd_flg != 'P'
                        );

                  if ( SQLCODE != 0 )
                  {
                    fn_errlog(c_ServiceName, "S31205", SQLMSG, c_err_msg);
                    tpabort(0);
                    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
                    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
                  }

								}
						
								if( k_counter == 0 )
								{	
									l_lesser_of_eq = l_eq_rowq;
								}
								else if( l_lesser_of_eq > l_eq_rowq )
								{
									l_lesser_of_eq = l_eq_rowq;
								}

						} /* End of for Loop of k_count */
	
						fn_userlog( c_ServiceName,"No of times customer tried using the strategy in FNO is :%ld:", l_times_fno[0] );
						fn_userlog( c_ServiceName,"No of times customer tried using this strategy in EQ is :%ld:", l_eq_rowq );

						if( l_times_fno[0] > l_lesser_of_eq )
						{
							l_times_actually_used = l_lesser_of_eq;
						}
						else
						{
							l_times_actually_used = l_times_fno[0];
						}

						if( l_times_actually_used != 0 )
						{
							fn_userlog( c_ServiceName,"No of equity contract for the strategy is :%ld:", no_of_eqrecords );

							for( k_counter = 0; k_counter < no_of_eqrecords; k_counter++ )
							{

								fn_userlog( c_ServiceName,"l_times_actually_used is :%ld:", l_times_actually_used );

								for( j= 0; j < l_times_actually_used; j++ )
								{

									fn_userlog( c_ServiceName,"Updating....." );

									if(DEBUG_MSG_LVL_3)
   							  {
									fn_userlog( c_ServiceName,"Equity contract description is :%s:", c_eq_cnt_desc[k_counter] );
									fn_userlog( c_ServiceName,"Match is :%s:", c_tmp_mtch );
									fn_userlog( c_ServiceName,"Trade date is :%s:", c_trd_dt.arr );
									fn_userlog( c_ServiceName,"Low price is :%lf:", d_sql_sad_low_prc[k_counter] );
									fn_userlog( c_ServiceName,"High price is :%lf:", d_sql_sad_high_prc[k_counter] );
									}

									EXEC SQL
											 UPDATE atm_ats_trade_mstr
											 SET    atm_strtgy_dscrpt = :sql_sad_strtgy_subnm,
															atm_prcsd_flg     = 'P'
											 WHERE  atm_mtch_accnt    = :c_tmp_mtch
											 AND    atm_cntrct_dscrpt = :c_eq_cnt_desc[k_counter]
											 AND    to_char(atm_expry_dt,'dd-MON-YYYY')      = :c_trd_dt
											 AND    atm_strk_prc      >= trunc(:d_sql_sad_low_prc[k_counter])
											 AND    atm_strk_prc      <= trunc(:d_sql_sad_high_prc[k_counter])
											 AND    atm_strtgy_dscrpt IS NULL
											 AND    ROWNUM < 2;

        			  	if ( SQLCODE != 0 )
        			  	{
          			  	fn_errlog(c_ServiceName, "S31210", SQLMSG, c_err_msg);
          			  	tpabort(0);
          			  	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          			  	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        			  	}

								}

					 		 }
							 if( l_times_actually_used != l_times_fno[0] )
							 {

							 	 /* We have to rollback a few transactions ( as in where ever we have updated the strategy name for this 
								 		client against FNO orders ,as we do not have sufficient orders in Equity to suffice the requirements 
									 	of the strategy or to */ 

								 fn_userlog( c_ServiceName,"Match is :%s:", c_tmp_mtch );
								 fn_userlog( c_ServiceName,"Strategy code is :%s:", sql_sad_strtgy_subnm.arr );

								 EXEC SQL
									    UPDATE atm_ats_trade_mstr
										  SET    atm_strtgy_dscrpt = NULL,
													   atm_prcsd_flg = 'N'
									    WHERE  atm_mtch_accnt    = :c_tmp_mtch
										  AND    atm_strtgy_dscrpt = :sql_sad_strtgy_subnm
										  AND    atm_prdct_typ != 'E';  /* Retaining the updates of equity */

								 if ( SQLCODE != 0 )
                 {
                   fn_errlog(c_ServiceName, "S31215", SQLMSG, c_err_msg);
                   tpabort(0);
                   Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
                   tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
                 }

								 for( i_counter = 0; i_counter < no_of_records; i_counter++ )
          			 {

            			 trim(c_contracts[i_counter]);

            			 l_no_of_rows = ( l_times_actually_used*l_sad_lot_sz[i_counter] ) ;

            			 fn_userlog( c_ServiceName,"Number of rows getting updated for :%s: is :%ld:", 
															 sql_sad_strtgy_subnm.arr,l_no_of_rows );

            				for( j=1; j <= l_no_of_rows; j++ )
            				{
              				EXEC SQL
                   				 UPDATE atm_ats_trade_mstr
                   				 SET    atm_strtgy_dscrpt = :sql_sad_strtgy_subnm,
                          				atm_prcsd_flg     = 'P'
                   				 WHERE  atm_mtch_accnt    = :c_tmp_mtch
                   				 AND    atm_cntrct_dscrpt = :c_contracts[i_counter]
													 AND    atm_trd_rt        >= :d_sql_sad_low_prc_fno[i_counter]*100
                   				 AND    atm_trd_rt        <= :d_sql_sad_high_prc_fno[i_counter]*100
                   				 AND    atm_strtgy_dscrpt IS NULL
                   				 AND    ROWNUM = 1;

              				if ( SQLCODE != 0 )
             					{ 
                				fn_errlog(c_ServiceName, "S31220", SQLMSG, c_err_msg);
                				tpabort(0);
                				Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
                				tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
              				}
            			  }

          				}/* End of second For loop */

								}

						}
						else     /* Where the strategy was not used */
						{
								EXEC SQL
                     UPDATE atm_ats_trade_mstr
                     SET    atm_strtgy_dscrpt = NULL,
                            atm_prcsd_flg = 'N'
                     WHERE  atm_mtch_accnt    = :c_tmp_mtch
                     AND    atm_strtgy_dscrpt = :sql_sad_strtgy_subnm;

                if ( SQLCODE != 0 )
                {
                  fn_errlog(c_ServiceName, "S31225", SQLMSG, c_err_msg);
                  tpabort(0);
                  Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
                  tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
                }
	
						}

					} /* End of combination */

			} /* End of inner while */

			EXEC SQL
           UPDATE sad_stgy_atsrpt_dtls
           SET    sad_prcsd_flg = 'P'
           WHERE  sad_strtgy_subnm = :sql_sad_strtgy_subnm;

      if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
      {
        fn_errlog(c_ServiceName, "S31230", SQLMSG, c_err_msg);
        tpabort(0);
        Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

		} /* end of FNO */
		else if( strcmp( sql_sad_segment.arr,"EQ" ) == 0 )
		{

			EXEC SQL
           SELECT 1 INTO :l_combination_flg
           FROM   sad_stgy_atsrpt_dtls
           WHERE  sad_strtgy_subnm  = :sql_sad_strtgy_subnm
           AND    sad_segment = 'FNO'
					 AND    sad_prcsd_flg = 'N';

			/*--------------------------------------------------------------------------------------------------------|
			| If FNO contract comes first in the above query (FNO or EQ can come first; then I ignore this case and   |
			| pick it up later when the same Strategy gets selected for FNO                                           |
			|--------------------------------------------------------------------------------------------------------*/

      if( l_combination_flg == 1) 
      {
				EXEC SQL
						 UPDATE sad_stgy_atsrpt_dtls
         		 SET    sad_prcsd_flg = 'I'
         		 WHERE  sad_strtgy_subnm = :sql_sad_strtgy_subnm
						 AND    sad_segment = 'EQ';

    		if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
    		{
      		fn_errlog(c_ServiceName, "S31235", SQLMSG, c_err_msg);
      		tpabort(0);
      		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
   		 	}

    		if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg ) == -1 )
    		{
      		tpfree ( ( char * ) ptr_fml_Obuf );
      		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    		}		
				
				continue;
      }
	
				EXEC SQL
						 DECLARE cur_eq_map CURSOR FOR
						 SELECT  distinct(sad_cntrct_dscrp||'-'||sad_bs_flg),
										 sad_low_prc,
										 sad_high_prc,
										 sad_eq_qty
						 FROM    sad_stgy_atsrpt_dtls 
						 WHERE   sad_strtgy_subnm = :sql_sad_strtgy_subnm; 

				EXEC SQL
						 OPEN  cur_eq_map;

			
				if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND)
  			{
    			EXEC SQL CLOSE cur_eq_map;
    			fn_errlog(c_ServiceName, "S31240", SQLMSG, c_err_msg);
    			tpabort(0);
    			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  			}
  			if ( SQLCODE == NO_DATA_FOUND)
  			{
    			EXEC SQL CLOSE cur_eq_map;

    			fn_errlog(c_ServiceName, "S31245", SQLMSG, c_err_msg);
    			strcpy(c_msg,"No Data Found in sad_stgy_atsrpt_mstr ");
    			fn_userlog(c_ServiceName,c_msg);
    			tpabort(0);
    			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    			tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  			}

				while(1)
				{
					EXEC SQL
							 FETCH cur_eq_map
							 INTO  :sql_sad_cntrct_dscrp,
                   	 :sql_sad_low_prc,
                   	 :sql_sad_high_prc,
										 :sql_sad_eq_qty;

					if(SQLCODE != 0)
    			{
        		if(SQLCODE == NO_DATA_FOUND)
        		{
          		fn_userlog(c_ServiceName,c_msg);
          		EXEC SQL CLOSE cur_eq_map;
          		break;
        		}
        		else
        		{
          		sprintf(c_msg,"Error occured while fetching cur_eq_map ,sqlcode-:%d:",sqlca.sqlcode);
          		fn_userlog(c_ServiceName,c_msg);
          		fn_errlog( c_ServiceName, "S31250", SQLMSG, c_err_msg  );
        		}
        		tpabort(0);
        		EXEC SQL CLOSE cur_eq_map;
        		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
        		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    	    }

    			SETLEN(sql_sad_cntrct_dscrp);

					EXEC SQL
							 UPDATE atm_ats_trade_mstr
             	 SET    atm_strtgy_dscrpt =  :sql_sad_strtgy_subnm,
                      atm_prcsd_flg     =  'P'
               WHERE  atm_cntrct_dscrpt =  :sql_sad_cntrct_dscrp
               AND    atm_strk_prc      >= :sql_sad_low_prc
							 AND    atm_strk_prc      <= :sql_sad_high_prc
							 AND    atm_trd_qty       >= :sql_sad_eq_qty
							 AND    atm_strtgy_dscrpt IS NULL
							 AND    atm_prcsd_flg     = 'N';
					
					if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND)
        	{
						EXEC SQL CLOSE cur_eq_map;
          	fn_errlog(c_ServiceName, "S31255", SQLMSG, c_err_msg);
          	tpabort(0);
          	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        	}
	
				}

		}
		else
		{
			fn_userlog( c_ServiceName,"Invalid Segment defined for :%s:" , sql_sad_strtgy_subnm.arr );
			strcpy( c_err_msg,"Invalid Segment defined for " );
      tpabort(0);
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
		}

		fn_userlog( c_ServiceName,"Updating SAD table finally" );

		EXEC SQL
				 UPDATE sad_stgy_atsrpt_dtls
				 SET    sad_prcsd_flg = 'P'
				 WHERE  sad_strtgy_subnm = :sql_sad_strtgy_subnm;

		if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
    {
      fn_errlog(c_ServiceName, "S31260", SQLMSG, c_err_msg);
      tpabort(0);
			Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
      tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
    }

		if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg ) == -1 )
  	{
    	tpfree ( ( char * ) ptr_fml_Obuf );
    	Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    	tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  	}

	} /* End of while 3 */

	/*------------------------------------------------------------------------------------------------------------|
	|                                              PART 6                                                         |
	| We now generate the report and polulate the FMLs in Output buffer to be displayed on trading screens.       |
	|------------------------------------------------------------------------------------------------------------*/

	/* i_trnsctn  = fn_begintran( c_ServiceName, c_err_msg ); */

	i_trnsctn = tpbegin(BAT_TRAN_LOCAL,0);

  if ( i_trnsctn == -1 )
  {
    fn_errlog( c_ServiceName, "S31265", LIBMSG, c_err_msg  );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }


	EXEC SQL
       DELETE FROM tmp_atm_trd_mstr;

  if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
  {
    fn_errlog(c_ServiceName, "S31270", SQLMSG, c_err_msg);
    tpabort(0);
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

	if ( fn_committran( c_ServiceName, i_trnsctn, c_err_msg ) == -1 )
  {
    tpfree ( ( char * ) ptr_fml_Obuf );
    Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  }

	EXEC SQL
			 DECLARE cur_atm_ats CURSOR FOR 
							 ( SELECT atm_strtgy_dscrpt,
												SUM(atm_trd_val) 
								 FROM   atm_ats_trade_mstr 
								 WHERE  atm_strtgy_dscrpt IS NOT NULL 
								 GROUP BY atm_strtgy_dscrpt );

	EXEC SQL
           OPEN cur_atm_ats;

      if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
      {
          fn_errlog(c_ServiceName, "S31275", SQLMSG, c_err_msg);
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }
      if ( SQLCODE == NO_DATA_FOUND)
      {
          EXEC SQL CLOSE cur_atm_ats;
          fn_errlog(c_ServiceName, "S31280", SQLMSG, c_err_msg);
          EXEC SQL CLOSE cur_atm_ats;
          Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      }

			/* Initializing output buffer */

  		ptr_fml_Obuf = (FBFR32 *)tpalloc( "FML32", NULL, MIN_FML_BUF_LEN*10 );

  		if ( ptr_fml_Obuf == NULL )
  		{
    		fn_errlog( c_ServiceName, "S31285", TPMSG, c_err_msg  );
    		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
    		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
  		}

      while(1)
      {

          EXEC SQL
               FETCH cur_atm_ats
               INTO  :c_tmp_stgy,
										 :d_turnover;

          if(SQLCODE != 0)
          {
            if(SQLCODE == NO_DATA_FOUND)
            {
                  EXEC SQL CLOSE cur_atm_ats;
                  break;
            }
            else
            {
                  fn_errlog(c_ServiceName, "S31290", SQLMSG, c_err_msg);
            }
            EXEC SQL CLOSE cur_atm_ats;
            Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
            tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          } 

					trim(c_tmp_stgy);

					EXEC SQL
							 SELECT COUNT(DISTINCT(atm_mtch_accnt)) 
							 INTO   :l_no_of_cust
							 FROM   atm_ats_trade_mstr 
							 WHERE  atm_strtgy_dscrpt = :c_tmp_stgy;

					if ( SQLCODE != 0 )
      		{
          		fn_errlog(c_ServiceName, "S31295", SQLMSG, c_err_msg);
							EXEC SQL CLOSE cur_atm_ats;
          		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      		}


					EXEC SQL                                                      /* CHECK THIS QUERY VIDYA */
							 SELECT COUNT(atm_strtgy_dscrpt)
							 INTO   :l_cnt_of_stgy_atm
							 FROM   atm_ats_trade_mstr
							 WHERE  atm_strtgy_dscrpt is NOT NULL
							 AND    atm_strtgy_dscrpt = :c_tmp_stgy;

					if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
          {
              fn_errlog(c_ServiceName, "S31300", SQLMSG, c_err_msg);
              EXEC SQL CLOSE cur_atm_ats;
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          }


					EXEC SQL
							 SELECT SUM(sad_lot_sz)
							 INTO   :l_cnt_of_stgy_sad
							 FROM   sad_stgy_atsrpt_dtls
							 WHERE  sad_strtgy_subnm = :c_tmp_stgy
							 HAVING COUNT(sad_strtgy_subnm) > 0;

					if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
          {
              fn_errlog(c_ServiceName, "S31305", SQLMSG, c_err_msg);
              EXEC SQL CLOSE cur_atm_ats;
              Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
              tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
          }

		
					EXEC SQL
							 SELECT :l_cnt_of_stgy_atm/:l_cnt_of_stgy_sad
							 INTO   :l_cnt_of_stgy
							 FROM   DUAL;

					if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
      		{
          		fn_errlog(c_ServiceName, "S31310", SQLMSG, c_err_msg);
							EXEC SQL CLOSE cur_atm_ats;
          		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
      		}

					memset( c_turnover,'\0',sizeof(c_turnover) );
					sprintf( c_turnover,"%lf",d_turnover );

					if( strcmp(c_tmp_stgy,"INVALID") != 0 )
					{
				  i_err[0]  = Fadd32 ( ptr_fml_Obuf, FFO_XCHNG_RMRKS,( char *)c_tmp_stgy, 0 );
          i_err[1]  = Fadd32 ( ptr_fml_Obuf, FFO_OI_INDCTR,( char *)c_turnover, 0 );
          i_err[2]  = Fadd32 ( ptr_fml_Obuf, FFO_OPN_PRC,(char *)&l_cnt_of_stgy, 0 );	
          i_err[3]  = Fadd32 ( ptr_fml_Obuf, FFO_INDX_VAL,(char *)&l_no_of_cust, 0 );	

					for( i_cnt = 0; i_cnt < 4; i_cnt++ )
      		{
        		if( i_err[i_cnt] == -1 )
        		{
          		fn_errlog( c_ServiceName, "S31315",FMLMSG,c_err_msg);
          		fn_userlog(c_ServiceName, "Error while generating snapshot");
							EXEC SQL CLOSE cur_atm_ats;
          		Fadd32( ptr_fml_Ibuf, FFO_ERR_MSG, c_err_msg, 0 );
          		tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuf, 0, 0 );
        		}
      		}
					}

			}

			/*** Fprint32( ptr_fml_Obuf ); Commented In Ver 1.1	***/
			
	tpreturn( TPSUCCESS, 0, (char *)ptr_fml_Obuf, 0 , 0 );	

} /* End of service */


void trim(char *str)
{
  int i=0;
  char *ptr;
  ptr = str;
  while ( *str != '\0' )
  {
    if (*str != ' ' && *str != '\t')
    {
      i=i+1;
      *ptr++=*str;
    }
    str++;
  }
  *ptr='\0';
  while( i != 0 )
  {
    ptr--;
    i=i-1;
  }
  str = ptr;
}

