/******************************************************************************/
/*  Program           : CLN_RCV_CLNT                                          */
/*                                                                            */
/*  Input             : C_PIPE_ID                                             */
/*                                                                            */
/*  Output            :                                                       */
/*                                                                            */
/*  Description       : Receive client runs in the process space of the       */
/*                      EBA system and it is a Tuxedo based client process.   */
/*                      It receives messages from receive server in ORS       */
/*                      system and directs the message to appropriate services*/
/*                      in EBA sytem.                                         */
/*  Log               : 1.0   02-Nov-2001   Sridhar.T.N                       */
/*                      1.1   14-Nov-2002   Sridhar.T.N                       */
/*                      1.2   25-Nov-2002   Sangeet/Smriti										*/
/*                      1.3   25-Nov-2002   Sangeet/Sridhar	 									*/
/*                      1.4   04-Feb-2004   Smriti         	 									*/
/*											1.5		11-Oct-2004		Nitin A                           */
/*											1.6		17-Apr-2007		Shailesh                          */
/*                      1.7   14-Feb-2007   Vikash Kumar / Sushil Sharma      */
/*                      1.8   04-Dec-2007   Vikash Kumar                      */
/*                      1.9   07-Feb-2008   Sandeep														*/
/*                      2.0   10-Mar-2008   Shailesh													*/
/*                      2.1   18-Dec-2012   Navina D.                         */
/*                      2.2   23-Sep-2013   Navina D.                         */
/*                      2.3   07-Mar-2023   Sachin Birje                      */
/******************************************************************************/
/*  version 1.1 - For updation of freezed order rejection                     */
/*  version 1.2 - DT																													*/
/*  version 1.3 - Changes for send client coming down with TPEINVAL and some	*/ 
/*								other conditions 																						*/
/*  version 1.4 - Changes for DL Ver 1.1																			*/
/*	version 1.5	-	Changes in the reverse messaging architecture for trade and */
/*								order confirmation for direct link 													*/
/*  version 1.6 - Changes for handling of broker status closeout in login resp*/
/*  version 1.7 - Changes for DLRevamp Broadcast Message Comented             */
/*                Passing user_id also for trade confirmation                 */
/*  version 1.8 - Changes for NNF808 increase in size of trade no and order no*/
/*  version 1.9 - Changes For IBM Migration                                   */
/*  version 2.0 - Changes for FuturePlus                                      */
/*  version 2.1 - SLTP FuturePLUS handling                                    */
/*  version 2.2 - OptionPLUS handling                                         */
/*  version 2.3 - Minor Changes Client Lock Changes                           */
/******************************************************************************/

/**** C header ****/
#include <stdio.h> 
#include <stdlib.h>		/*** Ver 1.9 ***/
#include <string.h>		/*** Ver 1.9 ***/
#include <unistd.h> 
#include <sys/types.h> 
#include <sys/stat.h> 
#include <fcntl.h> 
#include <errno.h> 

/**** Tuxedo header ****/
#include <atmi.h>
#include <fml32.h>  
#include <Usysflds.h> 

#include <sqlca.h> 

/**** Application header ****/
#include <fo_fml_def.h>  
#include <fo_view_def.h>  
#include <fo.h>
#include <fn_env.h>
#include <fn_battmpt.h>
#include <fn_tuxlib.h>
#include <eba_to_ors.h>
#include <fn_scklib.h>
#include <fn_shm.h>
#include <rcv_cln_srvr.h>
#include <fn_fil_log.h>
#include <fn_ddr.h>
#include <fn_log.h>
#include <userlog.h>		/*** Ver 1.9 ***/
#include <fn_session.h> /*** Ver 1.9 ***/
#include <fn_read_debug_lvl.h>	/*** Ver 1.9 ***/
/*****  Commented in ver 1.7 *****************
#include <eba_tgw.h>    * V 1.2 DT Broadcast *
#include <fn_msgq.h>    * V 1.2 DT Broadcast *
#include <fml_def.h>    * V 1.2 DT Broadcast *
********** ver 1.7 End of Comment ***********/

int i_sck_id;
/*********  Commented in ver 1.7 ******
int	i_qid = 0; 							*Ver 1.2*
int	i_tgw_stts = STP_TGW; 	*Ver 1.2*
int	i_key; 									*Ver 1.2*
char c_temp[MAXDATA];				*Ver 1.5*
long li_snd_tgw_hnd; 				*Ver 1.2*
long li_stp_tgw_hnd; 				*Ver 1.2*
******** End of Comment in ver 1.7 ***/

char c_err_msg [ 256 ];
char c_ServiceName[33];
char c_mtch_accnt[10 + 1];	/*Ver 1.2*/
/***	Function declaration	***/
int fn_logon_res_hndlr( msg_exch_logon *ptr_st_logon_res,
												char *c_ServiceName,
												char *c_err_msg);

int fn_ors_opn_ord_dtls ( msg_opn_ord_dtls *ptr_st_opn_ord,
													char *c_ServiceName, 
                          char *c_err_msg );

int fn_new_ord_exer_res ( msg_reqres_dtls *ptr_st_res_dtls,
													long int li_msg_typ,
													char *c_ServiceName, 
                          char *c_err_msg );

int fn_new_spd_ord_res ( msg_sprd_ord_res *ptr_st_spd_ord_res,
												 long int li_msg_typ,
										     char *c_ServiceName, 
                         char *c_err_msg );

int fn_acpt_rjct ( msg_reqres_dtls *ptr_st_res_dtls,
									 long int li_msg_typ,
                   char *c_pipe_id,
                   char *c_ServiceName, 
                   char *c_err_msg             );

int fn_spd_acpt_rjct ( msg_sprd_ord_res *ptr_st_spd_ord_res,
									 		 long int li_msg_typ,
                       char *c_pipe_id,
                       char *c_ServiceName, 
                       char *c_err_msg             );

int fn_ord_frz_exp ( msg_reqres_dtls *ptr_st_res_dtls,
                     char *c_pipe_id,
										 char c_ord_res_stts, 
                     char *c_ServiceName, 
							       char *c_err_msg      );

int fn_spd_ord_cncl ( msg_sprd_ord_res *ptr_st_spd_ord_res,
								 		  long int li_msg_typ,
                      char *c_pipe_id,
                      char *c_ServiceName, 
							        char *c_err_msg      );

int fn_ord_trg ( msg_reqres_dtls *ptr_st_res_dtls,
                 char *c_pipe_id,
								 char c_ord_res_stts, 
                 char *c_ServiceName, 
						     char *c_err_msg      );

int fn_trd_conf ( msg_trd_conf *ptr_st_tconf,
                  char *c_pipe_id,
								  char *c_ServiceName, 
                  char *c_err_msg      );

int fn_nse_to_eba_tkn ( long int li_tkn,
                        struct vw_contract *ptr_cntrct,
                        char *c_ServiceName,
                        char *c_err_msg );

int fn_ioc_can ( msg_ioc_can_dtls *ptr_st_res_dtls,
								 long int li_msg_typ,
                 char *c_pipe_id, 
                 char *c_ServiceName, 
								 char *c_err_msg);
/*********Commented in ver 1.5****
void fn_snd_dtq(char *, long, long, int); *ver 1.2* *Changed in Ver 1.4 int added*
**********End os comments*************/

/******* Commented in ver 1.7 ***********
void fn_snd_dtq(); ***Added in ver 1.5****
*******  End of Comment in ver 1.7 *****/

void fn_print_pckt(union un_res_msg , long );

EXEC SQL BEGIN DECLARE SECTION;
	char c_pipe_id [ 2+1 ];
	char c_xchng_cd [ 3+1 ];
	varchar c_trd_ref [ 10 ];
	varchar c_trd_dt [ LEN_DT ];
EXEC SQL END DECLARE SECTION;

void CLN_RCV_CLNT ( int argc, char *argv[] )
{
	union un_res_msg rcv_q_msg;

	msg_frs_hdr st_hdr_msg;

	INITBATDBGLVL(c_ServiceName);
	strcpy( c_ServiceName, argv[0] );
	strcpy(c_pipe_id, argv[3] );

	while (1)
	{
		/*Ver 1.2*/
		fn_userlog(c_ServiceName, "Checking for unsolicited messages in loop");
		if(fn_chk_stts ( c_ServiceName ) == -1)
		{
  		fn_userlog(c_ServiceName, "Failed in checking for triggers");
		}
	 
		memset ( &rcv_q_msg, '\0', sizeof(union un_res_msg));

		if ( fn_read_msg_sck ( i_sck_id, 
                           &rcv_q_msg, 
                           &st_hdr_msg, 
                           0, 
													 c_ServiceName, 
                           c_err_msg       ) == -1 )
		{
			return;
		}

		/****	Unpack the message in case of retransmission message	*****/
		fn_userlog ( c_ServiceName, "Data received - |%ld|",
                 st_hdr_msg.li_msg_typ );

		/*****	Based on message type received, call appropriate RMS routine	****/
		switch ( st_hdr_msg.li_msg_typ )
		{
			case ORS_LOGON_RES :
				if ( fn_logon_res_hndlr(  &(rcv_q_msg.exch_logon),
																	c_ServiceName,
																	c_err_msg     ) == -1 )
				{
					return;
				}
			 	break;

      case ORS_RETRNS_END :
				/***	Send a trigger for recovery over	***/
				fn_pst_trg ( c_ServiceName, "TRG_RECO_OVER", "TRG_RECO_OVER", 
                     c_pipe_id );	
        break;

      case ORS_OPN_ORD_DTLS :
				if ( fn_ors_opn_ord_dtls ( ( msg_opn_ord_dtls * )&rcv_q_msg, 
                                   c_ServiceName, 
                                   c_err_msg                          ) == -1 )
				{
					return;
				}
        break;

      case ORS_NEW_ORD_RES :
      case ORS_NEW_EXER_RES : 
				if ( fn_new_ord_exer_res ( ( msg_reqres_dtls * )&rcv_q_msg, 
																	 st_hdr_msg.li_msg_typ,
                                   c_ServiceName, 
                                   c_err_msg                        ) == -1 )
				{
					return;
				}
				break;

      case ORS_SPN_ORD_RES :	
      case ORS_2LN_ORD_RES :	
      case ORS_3LN_ORD_RES :	
/******************
				Messge no more sent by ORS V4.9.3
******************/
				break;

      case ORS_NEW_ORD_ACPT :
      case ORS_NEW_EXER_ACPT :
      case ORS_MOD_ORD_ACPT :
      case ORS_MOD_EXER_ACPT :
      case ORS_CAN_ORD_RJCT :
      case ORS_CAN_EXER_ACPT :
      case ORS_NEW_ORD_RJCT :
      case ORS_NEW_EXER_RJCT :
      case ORS_MOD_ORD_RJCT :
      case ORS_MOD_EXER_RJCT :
      case ORS_CAN_ORD_ACPT :
      case ORS_CAN_EXER_RJCT :
				if ( fn_acpt_rjct ( ( msg_reqres_dtls * )&rcv_q_msg, 
													  st_hdr_msg.li_msg_typ,
                            c_pipe_id,
                            c_ServiceName, 
                            c_err_msg                        ) == -1 )
				{
					return;
				}
        /**********  Comment in ver 1.7 ************
        if(DEBUG_MSG_LVL_3)
				{
          fn_userlog ( c_ServiceName, "after call to FN_ACPT_RJCT ");
          fn_userlog ( c_ServiceName, "i_tgw_stts is :%d:",i_tgw_stts);
          fn_userlog ( c_ServiceName, "i_qid is :%d:",i_qid);
        }
        ********** ver 1.7 comment ends ***********/
					
				/*Ver 1.2*/
				/*************Commented in ver 1.5**
				if(i_tgw_stts == SND_TGW && i_qid != 0)
				{
					fn_print_pckt(rcv_q_msg, st_hdr_msg.li_msg_typ);
					fn_snd_dtq((char *)&rcv_q_msg, st_hdr_msg.li_msg_typ, st_hdr_msg.li_msg_len,
														sizeof(msg_reqres_dtls));	*Sizeof added in Ver 1.4*******

        if(DEBUG_MSG_LVL_3)
        {
				 	fn_userlog ( c_ServiceName, "SENT AT TGW FOR FN_ACPT_RJCT");
				}
				}****End of comment ****************/
				break;

      case ORS_IOC_CAN_ACPT :
      case ORS_ORD_FRZ_CNCL :  /*** v1.1 ***/
				if ( fn_ioc_can ( ( msg_ioc_can_dtls * )&rcv_q_msg, 
														st_hdr_msg.li_msg_typ,
                            c_pipe_id,
                            c_ServiceName, 
                            c_err_msg                        ) == -1 )
				{
					return;
				}
        if(DEBUG_MSG_LVL_3)
        {
					fn_userlog ( c_ServiceName, "ORS_ORD_FRZ_CNCL IS CALLED");
				}
        /*Ver 1.2*/
		    /********Commented in ver 1.5 ********	
        if(i_tgw_stts == SND_TGW && i_qid != 0)
        {
          fn_snd_dtq((char *)&rcv_q_msg, st_hdr_msg.li_msg_typ, st_hdr_msg.li_msg_len,
													sizeof(msg_ioc_can_dtls));	*sizeof added in Ver 1.4*

					fn_userlog ( c_ServiceName, "SND_TGW for ORS_ORD_FRZ_CNCL IS CALLED");
        }********End of comment **************/
        break;

      case ORS_SPN_ORD_ACPT :
      case ORS_SPN_ORD_RJCT :
      case ORS_2LN_ORD_ACPT :
      case ORS_2LN_ORD_RJCT :
      case ORS_3LN_ORD_ACPT :
      case ORS_3LN_ORD_RJCT :
				if ( fn_spd_acpt_rjct ( ( msg_sprd_ord_res *)&rcv_q_msg.st_spd_ord_res, 
															  st_hdr_msg.li_msg_typ,
                                c_pipe_id,
                                c_ServiceName, 
                                c_err_msg                        ) == -1 )
				{
					return;
				}
        if(DEBUG_MSG_LVL_3)
        {
					fn_userlog ( c_ServiceName, "ORS_2LN_ORD_ACPT IS CALLED");
				}
        /*Ver 1.2*/
				/*********Commented in ver 1.5**********
        if(i_tgw_stts == SND_TGW && i_qid != 0)
        {
					fn_userlog(c_ServiceName,"1111111111111111111111111111111111111111111");
					fn_userlog(c_ServiceName,"The 2LN_SPN_ACCPT_RJCT for :%s:"
																		,rcv_q_msg.st_spd_ord_res.st_res_dtls[0].c_ordr_rfrnc);
					fn_userlog(c_ServiceName,"2222222222222222222222222222222222222222222");
          fn_snd_dtq((char *)&rcv_q_msg, st_hdr_msg.li_msg_typ, st_hdr_msg.li_msg_len,
												sizeof(msg_sprd_ord_res));	*sizeof added in Ver 1.4*
					fn_userlog(c_ServiceName,"3333333333333333333333333333333333333333333");
        }********Endof comment*****************/
				break;

      case ORS_ORD_FRZ :
				if ( fn_ord_frz_exp ( ( msg_reqres_dtls * )&rcv_q_msg, 
                               c_pipe_id, 
                               FREEZED, 
											         c_ServiceName, 
                               c_err_msg                        ) == -1 )
				{
					return;
				}
        /*Ver 1.2*/
				/*******Commenetd in ver 1.5*******
        if(i_tgw_stts == SND_TGW && i_qid != 0)
        {
          fn_snd_dtq((char *)&rcv_q_msg, st_hdr_msg.li_msg_typ, st_hdr_msg.li_msg_len,
													sizeof(msg_reqres_dtls)); *sizeof added in Ver 1.4*
        }*******End of comment ************/
        break;

      case ORS_ORD_TRG :
				if ( fn_ord_trg ( ( msg_reqres_dtls * )&rcv_q_msg, 
                          c_pipe_id, 
                          TRIGGERED, 
											    c_ServiceName, 
                          c_err_msg                        ) == -1 )
				{
					return;
				}
        if(DEBUG_MSG_LVL_3)
        {
					fn_userlog ( c_ServiceName, "ORS_ORD_TRG IS CALLED");
				}
        /*Ver 1.2*/
				/********Commented in ver 1.5**
        if(i_tgw_stts == SND_TGW && i_qid != 0)
        {
          fn_snd_dtq((char *)&rcv_q_msg, st_hdr_msg.li_msg_typ, st_hdr_msg.li_msg_len,
								sizeof(msg_reqres_dtls));	*sizeof added in Ver 1.4*
        }**********end of comment*****/
        break;

      case ORS_ORD_EXP :
/*************************************** 
			commemted on 14-Jun-2002 to overcome automatic expiration of orders
				if ( fn_ord_frz_exp ( ( msg_reqres_dtls * )&rcv_q_msg, 
                              c_pipe_id, 
                              EXPIRED, 
											        c_ServiceName, 
                              c_err_msg                        ) == -1 )
				{
					return;
				}
***************************************/
				break;

      case ORS_SPD_ORD_CNCL :
      case ORS_2L_ORD_CNCL :
      case ORS_3L_ORD_CNCL :
				if ( fn_spd_ord_cncl ( ( msg_sprd_ord_res * )&rcv_q_msg, 
														   st_hdr_msg.li_msg_typ,
                               c_pipe_id, 
											         c_ServiceName, 
                               c_err_msg                        ) == -1 )
				{
					return;
				}
        /*Ver 1.2*/
        if(DEBUG_MSG_LVL_3)
        {
					fn_userlog ( c_ServiceName, "ORS_3L_ORD_CNCL IS CALLED");
				}
				/****commeneted in ver 1.5***
        if(i_tgw_stts == SND_TGW && i_qid != 0)
        {
          fn_snd_dtq((char *)&rcv_q_msg, st_hdr_msg.li_msg_typ, st_hdr_msg.li_msg_len,
														sizeof(msg_sprd_ord_res));	*sizeof added in Ver 1.4*
        }****End of comments*********/
        break;

      case ORS_TRD_CONF :
				if ( fn_trd_conf ( ( msg_trd_conf * )&rcv_q_msg, 
                           c_pipe_id, 
                           c_ServiceName, 
                           c_err_msg                      ) == -1 )
				{
					return;
				}
        if(DEBUG_MSG_LVL_3)
        {
					fn_userlog ( c_ServiceName, "ORS_TRD_CONF IS CALLED");
				}
				/****commenetd in ver 1.5***
        if(i_tgw_stts == SND_TGW && i_qid != 0)
        {
          fn_snd_dtq((char *)&rcv_q_msg, st_hdr_msg.li_msg_typ, st_hdr_msg.li_msg_len,
															sizeof(msg_trd_conf));		*sizeof added in Ver 1.4*
        }****end of comments********/
        break;
				

      default:	
				fn_userlog( c_ServiceName, "Protocol error %d", st_hdr_msg.li_msg_typ );
        break;
		} /* switch end */
		fn_userlog ( c_ServiceName, "Data processed" );
	} /* while end */
}

/******************************************************************************/
/*	This is the main function for receive client.														  */
/*	INPUT PARAMETERS																													*/
/*			argc	-	number of command line arguments															*/
/*			argv	-	array of pointer to command line arguments										*/
/*	OUTPUT PARAMETERS																													*/
/*			void																																	*/
/******************************************************************************/
int fn_bat_init ( int argc, char *argv[] )
{
	char c_ServiceName [ 33 ]; 
	char c_err_msg[256];

  char *ptr_c_ipaddress;
	char c_ip_addrs [ 16 ];
  /**** Comment in ver 1.7 *****
	char c_filter[256]; *Ver 1.2*
  ***** ver 1.7 comment ends ***/
	long int li_port;

	msg_prcs_req st_prcs_req_msg;
	msg_prcs_res st_prcs_res_msg;
	msg_frs_hdr st_req_hdr;
	msg_frs_hdr st_res_hdr;

	int	i_ch_val ;
	char *ptr_c_tmp;

  /*******  Commented in ver 1.7 *************
	*Ver 1.2 Subscribe to DT related triggers*
	strcpy(c_filter, "FFO_FILTER=='T3'");
	li_snd_tgw_hnd = 0;
	li_stp_tgw_hnd = 0;
	i_qid = 0;
	i_tgw_stts = STP_TGW;
	i_key = 0;

	li_snd_tgw_hnd = tpsubscribe("TRG_SND_TGW", ( char * ) c_filter, ( TPEVCTL * ) NULL, 0);
	if(li_snd_tgw_hnd == -1)
	{
		fn_userlog(c_ServiceName, "Failed in subscribing to trigger TRG_SND_TGW");
		return -1;
	}
if(DEBUG_MSG_LVL_3)
{
	fn_userlog(c_ServiceName, "Subscribed to Trigger TRG_SND_TGW");
}

	li_stp_tgw_hnd = tpsubscribe("TRG_STP_TGW", ( char * ) c_filter, ( TPEVCTL * ) NULL, 0);
	if(li_stp_tgw_hnd == -1)
	{
if(DEBUG_MSG_LVL_3)
{
		fn_userlog(c_ServiceName, "Failed in subscribing to trigger TRG_STP_TGW");
}
		return -1;
	}
if(DEBUG_MSG_LVL_3)
{
	fn_userlog(c_ServiceName, "Subscribed to Trigger TRG_STP_TGW");
}

  ************* ver 1.7 Comment ends *********/

	/*	check command line parameters	*/
	if ( argc != 4 )
  {
    fn_userlog ( c_ServiceName,
    "Usage - cln_rcv_clnt <tag qualifier> <Exchange cd> <Pipe id>" );
    return ( -1 );
  }

	strcpy(c_pipe_id, argv[3] );
	strcpy( c_ServiceName, argv[0] );

  /*** Initialize the Routing string ***/
  fn_init_ddr_pop ( argv[3],
                    TRADING_SECTION,
                    COMMON);

  /*** Getting the existing shared memory's identifier  ***/
  if (fn_get_shm_id(CLIENT,
                    c_ServiceName,
                    c_err_msg) == -1)
  {
    fn_errlog(c_ServiceName, "S31005", LIBMSG, c_err_msg);
    return ( -1 );
  }

	/*Get IP address and port no	*/
	ptr_c_ipaddress = fn_get_prcs_spc(c_ServiceName, "ORS_SRVR_ADDR");
	if( ptr_c_ipaddress == NULL)
  {
		fn_errlog(c_ServiceName,"S31010", LIBMSG, c_err_msg);
    return ( -1 );
  }
	strcpy ( c_ip_addrs, ptr_c_ipaddress );

	ptr_c_tmp = fn_get_prcs_spc ( c_ServiceName, "ORS_SRVR_PORT" );
  if ( ptr_c_tmp == NULL )
  {
		fn_errlog(c_ServiceName,"S31015", LIBMSG, c_err_msg);
    return ( -1 );
  }
	li_port = atol(ptr_c_tmp);

  /******** Comment in ver 1.7 ***********
	*Ver 1.2 Get Message queue identifier*
	ptr_c_tmp = fn_get_prcs_spc ( c_ServiceName, "MSSG_QUE");
  if ( ptr_c_tmp == NULL )
  {
		fn_errlog(c_ServiceName,"S31020", LIBMSG, c_err_msg);
    return ( -1 );
  }
	i_key = atoi(ptr_c_tmp);

  *********** ver 1.7 end of comment *****/
	/*	Create client socket	*/
	if ( fn_crt_clnt_sck ( c_ip_addrs, 
                         li_port, 
                         &i_sck_id,
											   c_ServiceName, 
                         c_err_msg        ) == -1 )
	{
		fn_errlog(c_ServiceName,"S31025", LIBMSG, c_err_msg);
    return ( -1 );
	}

	/* Request for receive server	*/
	st_prcs_req_msg.li_prcs_no = RCV_SRVR;
	st_req_hdr.li_msg_typ = ORS_SRVR_REQ;
	st_req_hdr.li_msg_len = sizeof(msg_prcs_req);
	
	st_res_hdr.li_msg_typ = ORS_SRVR_RES;
	st_res_hdr.li_msg_len = sizeof(msg_prcs_res);

	if( fn_snd_rcv_msg_sck ( i_sck_id, 
                           &st_prcs_req_msg, 
                           st_req_hdr, 
			                     &st_prcs_res_msg, 
                           st_res_hdr, 
                           c_ServiceName, 
                           c_err_msg         ) == -1 )
	{
		fn_errlog(c_ServiceName,"S31030", LIBMSG, c_err_msg);
    return ( -1 );
	}

	/* check the response from receive server	*/
	if(st_prcs_res_msg.li_stts == -1)
	{
		fn_errlog(c_ServiceName,"S31035", st_prcs_res_msg.c_msg, c_err_msg);
    return ( -1 );
	}

	EXEC SQL
		SELECT to_char ( exg_nxt_trd_dt, 'yyyymmdd' ),
           to_char ( exg_nxt_trd_dt, 'DD-Mon-yyyy' ),
           opm_xchng_cd
		INTO :c_trd_ref,
         :c_trd_dt,
         :c_xchng_cd
		FROM exg_xchng_mstr, opm_ord_pipe_mstr
		WHERE opm_pipe_id =  :c_pipe_id
		AND exg_xchng_cd = opm_xchng_cd;
	if ( SQLCODE != 0 )
	{
		fn_errlog(c_ServiceName,"S31040", SQLMSG, c_err_msg);
    return ( -1 );
	}
	SETNULL ( c_trd_ref );
	SETNULL ( c_trd_dt );

  /****  Commented in ver 1.7 ******
	*Ver 1.2*
	*Check the status of the send TGW program. If not up, start it*
	if(fn_tgw_stts() == -1)
	{
		fn_errlog(c_ServiceName,"S31045", "Error in calling function to check TGW status", c_err_msg);
		* return -1;   *							*commented by sangeet on dated 26-Dec-2002 *
	}
  ********** end of Comment in ver 1.7 ******/

	/*Ver 1.2*/
	fn_userlog(c_ServiceName, "Checking for unsolicited messages");
	i_ch_val = fn_chk_stts ( c_ServiceName ) ;
	if ( i_ch_val == -1 )
	{
  	fn_userlog(c_ServiceName, "Failed in checking for triggers");
	}
 
	/**** Do business logic ****/
	fn_var = CLN_RCV_CLNT;

  return ( 0 );

}

void fn_bat_term ( int argc, char *argv[] )
{
	char c_err_msg [ 256 ];
	char c_filter [ 256 ];

	userlog("Inside fn_bat_term");
	fn_close_sck ( i_sck_id,
                 argv[0],
                 c_err_msg );

	sprintf ( c_filter, "cln_snd_clnt_%s", argv[3] ); 
	fn_pst_trg ( argv[0], "TRG_STP_BAT", "TRG_STP_BAT", c_filter );
 
	return; 
}

int fn_prcs_trg ( char *c_ServiceName,
                  int i_trg_typ )
{	

	fn_userlog(c_ServiceName, "Inside Trigger processing loop");

  /***********  Commented in ver 1.7 **********

  *Ver 1.2*
	if(strcmp ( c_trg_msg, "TRG_SND_TGW") == 0)
	{
    if(DEBUG_MSG_LVL_3)
    {
			fn_userlog(c_ServiceName, "Processing Trigger TRG_SND_TGW");
	  }
		i_tgw_stts = SND_TGW;
		** Create the Message Q identifier **
    if(fn_crt_msg_q(&i_qid, i_key, CLIENT, c_ServiceName, c_err_msg) == -1)
    {
      fn_errlog(c_ServiceName,"S31050", c_err_msg, c_err_msg);
    }
	}
	else if(strcmp ( c_trg_msg, "TRG_STP_TGW") == 0)
	{
   if(DEBUG_MSG_LVL_3)
   {
		fn_userlog(c_ServiceName, "Processing Trigger TRG_STP_TGW");
	 }
		i_tgw_stts = STP_TGW;
		i_qid = 0;
	}

  ************ ver 1.7 end of comment ******/
	return 0;
}
 
int fn_logon_res_hndlr( msg_exch_logon *ptr_st_logon_res,
												char *c_ServiceName,
												char *c_err_msg)
{
	int i_ch_val;
	int i_trnsctn;
	char c_brkr_stts;					/**Ver 1.6 ***/

	EXEC SQL BEGIN DECLARE SECTION;
		char sql_passwd_lst_updt_dt[LEN_DT];
	EXEC SQL END DECLARE SECTION;

	fn_pst_trg ( c_ServiceName, "TRG_ORS_CON", ptr_st_logon_res->c_msg, 
               c_pipe_id );	
	strcpy(sql_passwd_lst_updt_dt, ptr_st_logon_res->c_lst_pass_wd_ch_dt);
	c_brkr_stts= ptr_st_logon_res->c_brkr_stts;
	fn_userlog(c_ServiceName,"Broker status from login packet:%c:",ptr_st_logon_res->c_brkr_stts);

		/**Ver 1.6 starts***/
	  i_trnsctn = fn_begintran(c_ServiceName, c_err_msg );
		if ( i_trnsctn == -1)
		{
			fn_errlog(c_ServiceName,"S31055", LIBMSG, c_err_msg);
			return -1;
		}
		/**Ver 1.6 Ends***/

	if ( ptr_st_logon_res->li_stts == 0 )
	{
	  /**Commented for Ver 1.6 i_trnsctn = fn_begintran(c_ServiceName, c_err_msg );
		if ( i_trnsctn == -1)
		{
			fn_errlog(c_ServiceName,"S31060", LIBMSG, c_err_msg);
			return -1;
		}Comment Ends**/
	
		EXEC SQL
	 		UPDATE opm_ord_pipe_mstr
	  	SET    opm_lst_pswd_chg_dt = to_date(:sql_passwd_lst_updt_dt,
																			'dd-Mon-yyyy hh24:mi:ss')
	    WHERE  opm_pipe_id = :c_pipe_id;
		if(SQLCODE != 0)
	 	{
	 		fn_errlog(c_ServiceName, "S31065", SQLMSG, c_err_msg);
			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
	 		return -1;
	 	}	

		if( c_brkr_stts == ACTIVE )
		{
			EXEC SQL
				UPDATE exg_xchng_mstr
				set exg_brkr_stts=:c_brkr_stts
				where EXG_XCHNG_CD='NFO';
			if(SQLCODE != 0)
			{
				fn_errlog(c_ServiceName, "S31070", SQLMSG, c_err_msg);
				fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
				return -1;
			}	
		}
	fn_userlog(c_ServiceName,"Broker status recd ACTIVE:%c:",c_brkr_stts);
		/**Commented for Ver 1.6	
		i_ch_val = fn_committran (c_ServiceName, i_trnsctn, c_err_msg);
		if ( i_ch_val == -1 )
		{
			fn_errlog(c_ServiceName,"S31075", LIBMSG, c_err_msg);
			return -1;
		} Comment Ends***/
	}
	else
	{
		if( c_brkr_stts == CLOSE_OUT || c_brkr_stts == SUSPEND )
		{
			EXEC SQL
				UPDATE exg_xchng_mstr
				set exg_brkr_stts=:c_brkr_stts
				where EXG_XCHNG_CD='NFO';
			if(SQLCODE != 0)
			{
				fn_errlog(c_ServiceName, "S31080", SQLMSG, c_err_msg);
				fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
				return -1;
			}	
		}
	fn_userlog(c_ServiceName,"Broker status recd other than ACTIVE:%c:",c_brkr_stts);
	}

		/**Ver 1.6 starts***/
		i_ch_val = fn_committran (c_ServiceName, i_trnsctn, c_err_msg);
		if ( i_ch_val == -1 )
		{
			fn_errlog(c_ServiceName,"S31085", LIBMSG, c_err_msg);
			return -1;
		} 
		/**Ver 1.6 Ends***/
	return 0;
}

/******************************************************************************/
/*	To update open order details like GTD / GTDs orders in database.					*/
/*	INPUT PARAMETERS																													*/
/*			rcv_q_msg			- Pointer to a message structure got from receive 			*/
/*											message queue.																				*/
/*			c_ServiceName - Service Name currently running												*/
/*			c_err_msg			-	Error message to be returned													*/
/*	OUTPUT PARAMETERS																													*/
/*				0		-	Success																												*/
/*				-1	-	Failure																												*/
/******************************************************************************/
int fn_ors_opn_ord_dtls ( msg_opn_ord_dtls *ptr_st_opn_ord,
													char *c_ServiceName, 
                          char *c_err_msg               )
{
	int i_ch_val;

	struct vw_orderbook st_i_ordbk;

	strcpy ( st_i_ordbk.c_xchng_ack , ptr_st_opn_ord->c_ord_ack );
	st_i_ordbk.l_exctd_qty = ptr_st_opn_ord->li_tot_qty - 
					                 ptr_st_opn_ord->li_un_exctd_qty;
	st_i_ordbk.l_ord_tot_qty = ptr_st_opn_ord->li_tot_qty;
	strcpy(st_i_ordbk.c_pipe_id, c_pipe_id);
	fn_cpy_ddr(st_i_ordbk.c_rout_crt);
	i_ch_val = fn_acall_svc ( c_ServiceName,
														c_err_msg,
														&st_i_ordbk,
														"vw_orderbook",
														sizeof ( st_i_ordbk ),
														TPNOREPLY,
														"SFO_OPN_ORD" );
	if ( i_ch_val != 0 )
	{
		fn_errlog(c_ServiceName,"S31090", LIBMSG, c_err_msg);
		return -1;
	}

	return 0;
}

/******************************************************************************/
/*	To update the response for new order / Exercise in database.							*/
/*	INPUT PARAMETERS																													*/
/*			rcv_q_msg			- Pointer to a message structure got from receive 			*/
/*											message queue.																				*/
/*			c_ServiceName - Service Name currently running												*/
/*			c_err_msg			-	Error message to be returned													*/
/*	OUTPUT PARAMETERS																													*/
/*				0		-	Success																												*/
/*				-1	-	Failure																												*/
/******************************************************************************/
int fn_new_ord_exer_res ( msg_reqres_dtls *ptr_st_res_dtls,
													long int li_msg_typ,
													char *c_ServiceName, 
                          char *c_err_msg )
{
	int i_trnsctn;
	int i_ch_val;
	int i_tmp_cntr;

	struct vw_xchngbook st_i_xchngbk;
	struct vw_exrcbook st_i_exrcbk;
	struct vw_orderbook st_i_ordbk;

	char c_refack_tmp[LEN_ORD_REFACK];

	/*** Update the shared memory counters ***/
	i_tmp_cntr = NEW_EXER_ACK_CNTR;

  i_trnsctn = fn_begintran(c_ServiceName, c_err_msg );
	if ( i_trnsctn == -1)
	{
		fn_errlog(c_ServiceName,"S31095", LIBMSG, c_err_msg);
		return -1;
	}

	/*** Update exchange book with placed status as ***/
	/*** Request Reached Exchange										***/
	/*Added by sangeet*/
if(DEBUG_MSG_LVL_3)
{
	fn_userlog(c_ServiceName,"The Rfrnc for fn_new_ord_exer_res is :%s:",ptr_st_res_dtls->c_ordr_rfrnc );
}
	strcpy ( st_i_xchngbk.c_ordr_rfrnc , 
						ptr_st_res_dtls->c_ordr_rfrnc );
	st_i_xchngbk.c_plcd_stts = PLACED;
	if ( ptr_st_res_dtls->i_retrans_flag == NOT_DOWNLOAD )
	{
		st_i_xchngbk.l_mdfctn_cntr = ptr_st_res_dtls->l_mdfctn_cntr;
	}
	else
	{
		strcpy ( st_i_xchngbk.c_xchng_cd, c_xchng_cd );
		strcpy ( st_i_xchngbk.c_pipe_id, c_pipe_id );
		strcpy ( st_i_xchngbk.c_mod_trd_dt, c_trd_dt.arr );		/*** Ver 1.9 ***/
	}
	st_i_xchngbk.d_jiffy = (double)ptr_st_res_dtls->ll_log_tm_stmp;
	st_i_xchngbk.l_dwnld_flg = ptr_st_res_dtls->i_retrans_flag;
	fn_cpy_ddr(st_i_xchngbk.c_rout_crt);
	st_i_xchngbk.c_oprn_typ = UPDATE_PLACED_STTS;

	i_ch_val = fn_call_svc ( c_ServiceName,
														c_err_msg,
														&st_i_xchngbk,
														&st_i_xchngbk,
														"vw_xchngbook",
														"vw_xchngbook",
														sizeof ( st_i_xchngbk ),
														sizeof ( st_i_xchngbk ),
														0,
														"SFO_UPD_XCHNGBK" );
	if ( ( i_ch_val != SUCC_BFR ) &&
       ( i_ch_val != RECORD_ALREADY_PRCSD ) )
	{
		fn_errlog(c_ServiceName,"S31100", LIBMSG, c_err_msg);
		fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
		return -1;
	}
	else if ( i_ch_val == RECORD_ALREADY_PRCSD )
	{
  	/** Increment the counter by one. **/
  	if( ( fn_set_cntr ( i_tmp_cntr,
                      	c_ServiceName,
                      	c_err_msg)      )== -1)
  	{
    	/** on error, log the error and return -1; **/
    	fn_errlog(c_ServiceName, "S31105", LIBMSG, c_err_msg);
			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
    	return -1;
  	}

	  /*** Update the order reference number and modification counter in SHM ***/
	  sprintf(c_refack_tmp, "%s - %ld", ptr_st_res_dtls->c_xchng_ack, li_msg_typ);
	  if( ( fn_set_ref_ack_dtls ( c_refack_tmp,
	                              ORD_RES,
	                              c_ServiceName,
	                              c_err_msg)      )== -1)
	  {
	    /** on error, log the error and return -1; **/
	    fn_errlog(c_ServiceName, "S31110", LIBMSG, c_err_msg);
			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
	    return -1;
	  }

		fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
		fn_userlog ( c_ServiceName, "Record already processed" );
		return 0;
	}

	strcpy ( st_i_exrcbk.c_xchng_ack, ptr_st_res_dtls->c_xchng_ack );	
	strcpy ( st_i_exrcbk.c_exrc_ordr_rfrnc, ptr_st_res_dtls->c_ordr_rfrnc );
	fn_cpy_ddr(st_i_exrcbk.c_rout_crt);
	st_i_exrcbk.c_oprn_typ = UPDATE_XCHNG_RESPONSE;

	i_ch_val = fn_call_svc ( c_ServiceName,
  												 c_err_msg,
													 &st_i_exrcbk,
													 &st_i_exrcbk,
													 "vw_exrcbook",
													 "vw_exrcbook",
													 sizeof ( st_i_exrcbk ),
													 sizeof ( st_i_exrcbk ),
													 0,
													 "SFO_UPD_EXBK" );
	if ( i_ch_val != SUCC_BFR )
	{
		fn_errlog(c_ServiceName,"S31115", LIBMSG, c_err_msg);
		fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
		return -1;
	}

	i_ch_val = fn_committran (c_ServiceName, i_trnsctn, c_err_msg);
	if ( i_ch_val == -1 )
	{
		fn_errlog(c_ServiceName,"S31120", LIBMSG, c_err_msg);
		return -1;
	}

  /** Increment the counter by one. **/
  if( ( fn_set_cntr ( i_tmp_cntr,
                      c_ServiceName,
                      c_err_msg)      )== -1)
  {
    /** on error, log the error and return -1; **/
    fn_errlog(c_ServiceName, "S31125", LIBMSG, c_err_msg);
    return -1;
  }

  /*** Update the order reference number and modification counter in SHM ***/
  sprintf(c_refack_tmp, "%s - %ld", ptr_st_res_dtls->c_xchng_ack, li_msg_typ);
  if( ( fn_set_ref_ack_dtls ( c_refack_tmp,
                              ORD_RES,
                              c_ServiceName,
                              c_err_msg)      )== -1)
  {
    /** on error, log the error and return -1; **/
    fn_errlog(c_ServiceName, "S31130", LIBMSG, c_err_msg);
    return -1;
  }

	return 0;
}

int fn_new_spd_ord_res ( msg_sprd_ord_res *ptr_st_spd_ord_res,
												 long int li_msg_typ,
							 			     char *c_ServiceName, 
                         char *c_err_msg )
{
	int i_trnsctn;
	int i_ch_val;
	int i_cnt;
	int i_rec_cnt;
	int i_tmp_cntr;

	struct vw_xchngbook st_i_xchngbk;
	struct vw_exrcbook st_i_exrcbk;
	struct vw_orderbook st_i_ordbk;
	struct vw_spdordbk st_spd_ordbk;

	char c_refack_tmp[LEN_ORD_REFACK];

	EXEC SQL BEGIN DECLARE SECTION;
		char c_tmp_sprd_rfrnc[19];	
		char c_tmp_ord_rfrnc[19];	
	EXEC SQL END DECLARE SECTION;

	/*** Update the shared memory counters ***/
	switch ( li_msg_typ )
	{
		case ORS_SPN_ORD_RES:
			i_tmp_cntr = SP_ORDR_ACK_CNTR;
			i_rec_cnt = 2;
			break;

		case ORS_2LN_ORD_RES:
			i_tmp_cntr = TWOL_ORDR_ACK_CNTR;
			i_rec_cnt = 2;
			break;

		case ORS_3LN_ORD_RES:
			i_tmp_cntr = THRL_ORDR_ACK_CNTR;
			i_rec_cnt = 3;
			break;
	}

  i_trnsctn = fn_begintran(c_ServiceName, c_err_msg );
	if ( i_trnsctn == -1)
	{
		fn_errlog(c_ServiceName,"S31135", LIBMSG, c_err_msg);
		return -1;
	}
	/*Added by sangeet*/
if(DEBUG_MSG_LVL_3)
{
	fn_userlog(c_ServiceName,"The spread Rfrnc for fn_new_spd_ord_res is :%s:",ptr_st_spd_ord_res->c_spd_ordr_rfrnc );
}

	/*** In download, we are getting only spread order reference. So we ***/
	/*** have to get each order reference nos for the corresponding 		***/
	/*** spread order reference.	added on 12-Jun-2002									***/
	if ( ptr_st_spd_ord_res->st_res_dtls[i_cnt].i_retrans_flag == DOWNLOAD )
	{
		strcpy(c_tmp_sprd_rfrnc, ptr_st_spd_ord_res->c_spd_ordr_rfrnc);

		EXEC SQL
		DECLARE ordref_cur CURSOR FOR
			SELECT fsd_ordr_rfrnc
			FROM fsd_fo_sprd_dtls
			WHERE fsd_sprd_rfrnc = :c_tmp_sprd_rfrnc;

		EXEC SQL OPEN ordref_cur;
		if ( SQLCODE != 0 )
		{
			fn_errlog(c_ServiceName,"S31140", SQLMSG, c_err_msg);
			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
			return -1;
		}

		for ( i_cnt=0; i_cnt<i_rec_cnt; i_cnt++ )
		{
			EXEC SQL FETCH ordref_cur
				INTO	:c_tmp_ord_rfrnc;
			if ( SQLCODE != 0 )
			{
				fn_errlog(c_ServiceName,"S31145", SQLMSG, c_err_msg);
				EXEC SQL CLOSE ordref_cur;
				fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
				return -1;
			}
			strcpy(ptr_st_spd_ord_res->st_res_dtls[i_cnt].c_ordr_rfrnc, 
																											c_tmp_ord_rfrnc);
		}
		EXEC SQL CLOSE ordref_cur;
	}

	for ( i_cnt=0; i_cnt<i_rec_cnt; i_cnt++ )
	{
		/*** Update exchange book with placed status as ***/
		/*** Request Reached Exchange										***/
		strcpy ( st_i_xchngbk.c_ordr_rfrnc , 
						 ptr_st_spd_ord_res->st_res_dtls[i_cnt].c_ordr_rfrnc );
		st_i_xchngbk.c_plcd_stts = PLACED;
		if ( ptr_st_spd_ord_res->st_res_dtls[i_cnt].i_retrans_flag == NOT_DOWNLOAD )
		{
			st_i_xchngbk.l_mdfctn_cntr = 
          ptr_st_spd_ord_res->st_res_dtls[i_cnt].l_mdfctn_cntr;
		}
		else
		{
			strcpy ( st_i_xchngbk.c_xchng_cd, c_xchng_cd );
			strcpy ( st_i_xchngbk.c_pipe_id, c_pipe_id );
			strcpy ( st_i_xchngbk.c_mod_trd_dt, c_trd_dt.arr );		/*** Ver 1.9 ***/
		}
		st_i_xchngbk.d_jiffy = 
        (double)ptr_st_spd_ord_res->st_res_dtls[i_cnt].ll_log_tm_stmp;
		st_i_xchngbk.l_dwnld_flg = 
        ptr_st_spd_ord_res->st_res_dtls[i_cnt].i_retrans_flag;
		fn_cpy_ddr(st_i_xchngbk.c_rout_crt);
		st_i_xchngbk.c_oprn_typ = UPDATE_PLACED_STTS;
	
		i_ch_val = fn_call_svc ( c_ServiceName,
															c_err_msg,
															&st_i_xchngbk,
															&st_i_xchngbk,
															"vw_xchngbook",
															"vw_xchngbook",
															sizeof ( st_i_xchngbk ),
															sizeof ( st_i_xchngbk ),
															0,
															"SFO_UPD_XCHNGBK" );
		if ( ( i_ch_val != SUCC_BFR ) &&
	       ( i_ch_val != RECORD_ALREADY_PRCSD ) )
		{
			fn_errlog(c_ServiceName,"S31150", LIBMSG, c_err_msg);
			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
			return -1;
		}
		else if ( i_ch_val == RECORD_ALREADY_PRCSD )
		{
	  	/** Increment the counter by one. **/
	  	if( ( fn_set_cntr ( i_tmp_cntr,
	                      	c_ServiceName,
	                      	c_err_msg)      )== -1)
	  	{
	    	/** on error, log the error and return -1; **/
	    	fn_errlog(c_ServiceName, "S31155", LIBMSG, c_err_msg);
				fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
	    	return -1;
	  	}

		  /*** Update the order reference number and modification counter in SHM***/
		  sprintf(c_refack_tmp, "%s - %ld", 
														ptr_st_spd_ord_res->st_res_dtls[0].c_xchng_ack,
														li_msg_typ);
		  if( ( fn_set_ref_ack_dtls ( c_refack_tmp,
		                              ORD_RES,
		                              c_ServiceName,
		                              c_err_msg)      )== -1)
		  {
		    /** on error, log the error and return -1; **/
		    fn_errlog(c_ServiceName, "S31160", LIBMSG, c_err_msg);
				fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
		    return -1;
		  }

			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
			fn_userlog ( c_ServiceName, "Record already processed" );
			return 0;
		}

		/*** Update order book with acknowledgement number	***/
		strcpy( st_i_ordbk.c_xchng_ack , 
            ptr_st_spd_ord_res->st_res_dtls[i_cnt].c_xchng_ack );
		strcpy( st_i_ordbk.c_ordr_rfrnc , 
            ptr_st_spd_ord_res->st_res_dtls[i_cnt].c_ordr_rfrnc );
		fn_cpy_ddr(st_i_ordbk.c_rout_crt);
		st_i_ordbk.c_oprn_typ = UPDATE_XCHNG_RESPONSE;
		
    i_ch_val = fn_call_svc ( c_ServiceName,
                             c_err_msg,
                             &st_i_ordbk,
                             &st_i_ordbk,
                             "vw_orderbook",
                             "vw_orderbook",
                             sizeof ( st_i_ordbk ),
                             sizeof ( st_i_ordbk ),
                             0,
                             "SFO_UPD_ORDRBK" );
		if ( i_ch_val != SUCC_BFR )
		{
			fn_errlog(c_ServiceName,"S31165", LIBMSG, c_err_msg);
			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
			return -1;
		}
	}

	strcpy( st_spd_ordbk.c_xchng_ack[0], 
          ptr_st_spd_ord_res->st_res_dtls[0].c_xchng_ack );
	strcpy( st_spd_ordbk.c_sprd_ord_rfrnc[0], 
          ptr_st_spd_ord_res->c_spd_ordr_rfrnc );
	fn_cpy_ddr(st_spd_ordbk.c_rout_crt);
	st_spd_ordbk.c_rqst_typ[0] = UPDATE_XCHNG_RESPONSE;
	
  i_ch_val = fn_call_svc ( c_ServiceName,
                           c_err_msg,
                           &st_spd_ordbk,
                           &st_spd_ordbk,
                           "vw_spdordbk",
                           "vw_spdordbk",
                           sizeof ( st_spd_ordbk ),
                           sizeof ( st_spd_ordbk ),
                           0,
                           "SFO_UPD_SPDBK" );
	if ( i_ch_val != SUCC_BFR )
	{
		fn_errlog(c_ServiceName,"S31170", LIBMSG, c_err_msg);
		fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
		return -1;
	}

	i_ch_val = fn_committran (c_ServiceName, i_trnsctn, c_err_msg);
	if ( i_ch_val == -1 )
	{
		fn_errlog(c_ServiceName,"S31175", LIBMSG, c_err_msg);
		return -1;
	}

  /** Increment the counter by one. **/
  if( ( fn_set_cntr ( i_tmp_cntr,
                      c_ServiceName,
                      c_err_msg)      )== -1)
  {
    /** on error, log the error and return -1; **/
    fn_errlog(c_ServiceName, "S31180", LIBMSG, c_err_msg);
    return -1;
  }

  /*** Update the order reference number and modification counter in SHM ***/
  sprintf(c_refack_tmp, "%s - %ld", 
												ptr_st_spd_ord_res->st_res_dtls[0].c_xchng_ack,
												li_msg_typ);
  if( ( fn_set_ref_ack_dtls ( c_refack_tmp,
                              ORD_RES,
                              c_ServiceName,
                              c_err_msg)      )== -1)
  {
    /** on error, log the error and return -1; **/
    fn_errlog(c_ServiceName, "S31185", LIBMSG, c_err_msg);
    return -1;
  }

	return 0;
}

/******************************************************************************/
/*	To update the accept and reject responses from Exchange 									*/
/*	INPUT PARAMETERS																													*/
/*			rcv_q_msg			- Pointer to a message structure got from receive 			*/
/*											message queue.																				*/
/*			c_ServiceName - Service Name currently running												*/
/*			c_err_msg			-	Error message to be returned													*/
/*	OUTPUT PARAMETERS																													*/
/*				0		-	Success																												*/
/*				-1	-	Failure																												*/
/******************************************************************************/
int fn_acpt_rjct ( msg_reqres_dtls *ptr_st_res_dtls,
									 long int li_msg_typ,
                   char *c_pipe_id,
									 char *c_ServiceName, 
                   char *c_err_msg      )
{
	struct vw_xchngbook st_i_xchngbk;
	struct vw_orderbook st_i_ordrbk;
	struct vw_exrcbook st_i_exrcbk;

	char c_svc_name [15+1];
	char c_refack_tmp[LEN_ORD_REFACK];

	int i_ch_val;
	int i_trnsctn;
	int i_tmp_cntr;

	/*** Update the shared memory counters ***/
	switch ( li_msg_typ )
	{
		case ORS_NEW_ORD_ACPT:
			i_tmp_cntr = NEW_ORDR_CONFRM_CNTR;
			break;

		case ORS_NEW_ORD_RJCT:
			i_tmp_cntr = NEW_ORDR_RJCT_CNTR;
         if(DEBUG_MSG_LVL_3)
        {
					fn_userlog ( c_ServiceName, "ORS_NEW_ORD_RJCT IS CALLED inside fn_acpt_rjct");
				}
			break;

		case ORS_MOD_ORD_ACPT:
			i_tmp_cntr = MOD_ORDR_CNFRM_CNTR;
			break;

		case ORS_MOD_ORD_RJCT:
			i_tmp_cntr = MOD_ORDR_RJCT_CNTR;
			break;

		case ORS_CAN_ORD_ACPT:
			i_tmp_cntr = CXL_ORDR_CNFRM_CNTR;
			break;

		case ORS_CAN_ORD_RJCT:
			i_tmp_cntr = CXL_ORDR_RJCT_CNTR;
			break;

		case ORS_NEW_EXER_ACPT:
			i_tmp_cntr = NEW_EXER_CNFRM_CNTR;
			break;

		case ORS_NEW_EXER_RJCT:
			i_tmp_cntr = NEW_EXER_RJCT_CNTR;
			break;

		case ORS_MOD_EXER_ACPT:
			i_tmp_cntr = MOD_EXER_CNFRM_CNTR;
			break;

		case ORS_MOD_EXER_RJCT:
			i_tmp_cntr = MOD_EXER_RJCT_CNTR;
			break;

		case ORS_CAN_EXER_ACPT:
			i_tmp_cntr = CXL_EXER_CNFRM_CNTR;
			break;

		case ORS_CAN_EXER_RJCT:
			i_tmp_cntr = CXL_EXER_RJCT_CNTR;
			break;
	}
/*Added by Sangeet*/

if(DEBUG_MSG_LVL_3)
{
	fn_userlog(c_ServiceName,"The ACK for fn_acpt_rjct is :%s:",ptr_st_res_dtls->c_xchng_ack );
	fn_userlog(c_ServiceName,"Order Ref Receive :%s:",ptr_st_res_dtls->c_ordr_rfrnc);
}


	if ( ( ptr_st_res_dtls->c_ex_ordr_typ == EXERCISE )     ||
	     ( ptr_st_res_dtls->c_ex_ordr_typ == DONT_EXERCISE )   )
	{
		strcpy ( st_i_exrcbk.c_xchng_ack , ptr_st_res_dtls->c_xchng_ack );
		strcpy ( st_i_exrcbk.c_pipe_id , c_pipe_id );
		fn_cpy_ddr(st_i_exrcbk.c_rout_crt);
	
		i_ch_val = fn_call_svc ( c_ServiceName,
	  												 c_err_msg,
														 &st_i_exrcbk,
														 &st_i_exrcbk,
														 "vw_exrcbook",
														 "vw_exrcbook",
														 sizeof ( st_i_exrcbk ),
														 sizeof ( st_i_exrcbk ),
														 0,
														 "SFO_ACK_TO_EXRQ" );
		if ( i_ch_val != SUCC_BFR )
		{
			fn_errlog(c_ServiceName,"S31190", LIBMSG, c_err_msg);
			return -1;
		}

		strcpy ( st_i_xchngbk.c_ordr_rfrnc, st_i_exrcbk.c_exrc_ordr_rfrnc );
		st_i_xchngbk.l_mdfctn_cntr = st_i_exrcbk.l_mdfctn_cntr;
		strcpy ( st_i_xchngbk.c_xchng_cd, st_i_exrcbk.c_xchng_cd );
		strcpy ( st_i_xchngbk.c_pipe_id, st_i_exrcbk.c_pipe_id );
		st_i_xchngbk.c_ord_typ = st_i_exrcbk.c_exrc_rqst_typ;
		strcpy( c_svc_name , "SFO_EXREQ_ACK" );
		strcpy(c_mtch_accnt, st_i_exrcbk.c_cln_mtch_accnt);											/*Ver 1.2*/
		strcpy(ptr_st_res_dtls->c_ordr_rfrnc, st_i_exrcbk.c_exrc_ordr_rfrnc);		/*Ver 1.2*/
	}
	else
	{
		strcpy ( st_i_ordrbk.c_ordr_rfrnc , ptr_st_res_dtls->c_ordr_rfrnc );
		fn_cpy_ddr(st_i_ordrbk.c_rout_crt);
  	st_i_ordrbk.c_oprn_typ = FOR_VIEW;
		i_ch_val = fn_call_svc ( c_ServiceName,
	  												 c_err_msg,
														 &st_i_ordrbk,
														 &st_i_ordrbk,
														 "vw_orderbook",
														 "vw_orderbook",
														 sizeof ( st_i_ordrbk ),
														 sizeof ( st_i_ordrbk ),
														 0,
														 "SFO_REF_TO_ORD" );
		if ( i_ch_val != SUCC_BFR )
		{
			fn_errlog(c_ServiceName,"S31195", LIBMSG, c_err_msg);
			return -1;
		}

		strcpy ( st_i_xchngbk.c_ordr_rfrnc, st_i_ordrbk.c_ordr_rfrnc );
		st_i_xchngbk.l_mdfctn_cntr = st_i_ordrbk.l_mdfctn_cntr;
		strcpy ( st_i_xchngbk.c_xchng_cd, st_i_ordrbk.c_xchng_cd );
		strcpy ( st_i_xchngbk.c_pipe_id, st_i_ordrbk.c_pipe_id );
		strcpy(c_mtch_accnt, st_i_ordrbk.c_cln_mtch_accnt);			/*Ver 1.2*/

		/*** if ( st_i_ordrbk.c_prd_typ == FUTURES || st_i_ordrbk.c_prd_typ == FUTURE_PLUS )	*ver 2.0 * Commented in Ver 2.1 ***/
		if ( st_i_ordrbk.c_prd_typ == FUTURES || st_i_ordrbk.c_prd_typ == FUTURE_PLUS || st_i_ordrbk.c_prd_typ == SLTP_FUTUREPLUS )		/*** Ver 2.1 ***/
		{
			strcpy( c_svc_name , "SFO_FUT_ACK" );
		}
		else
		{
			strcpy( c_svc_name , "SFO_OPT_ACK" );
		}
	}

	switch( ptr_st_res_dtls->li_ors_msg_typ )
	{
    case ORS_NEW_ORD_ACPT :
    case ORS_NEW_EXER_ACPT :	
    case ORS_MOD_EXER_ACPT:
    case ORS_MOD_ORD_ACPT :
    case ORS_CAN_ORD_ACPT :
    case ORS_CAN_EXER_ACPT :
			st_i_xchngbk.c_plcd_stts = ACCEPT;	
			break;
			
    case ORS_NEW_ORD_RJCT :
    case ORS_NEW_EXER_RJCT :
    case ORS_MOD_ORD_RJCT :
    case ORS_MOD_EXER_RJCT :
    case ORS_CAN_ORD_RJCT :
    case ORS_CAN_EXER_RJCT :		
			st_i_xchngbk.c_plcd_stts = REJECT;	
			break;
	}	/*	End of switch	*/

	/*** Update exchange book with ack time, RMS processed flag ***/
	/*** and placed status																			***/

	st_i_xchngbk.c_rms_prcsd_flg = NOT_PROCESSED;  
	st_i_xchngbk.l_ors_msg_typ = ptr_st_res_dtls->li_ors_msg_typ;
	strcpy ( st_i_xchngbk.c_ack_tm , ptr_st_res_dtls->c_ack_tm );
	strcpy ( st_i_xchngbk.c_xchng_rmrks , ptr_st_res_dtls->c_xchng_rmrks );
	st_i_xchngbk.d_jiffy = (double) ptr_st_res_dtls->ll_log_tm_stmp;
	st_i_xchngbk.l_dwnld_flg = ptr_st_res_dtls->i_retrans_flag;
	if ( ( ptr_st_res_dtls->li_ors_msg_typ == ORS_NEW_ORD_ACPT ) ||
       ( ptr_st_res_dtls->li_ors_msg_typ == ORS_NEW_ORD_RJCT ) ||
       ( ptr_st_res_dtls->li_ors_msg_typ == ORS_NEW_EXER_ACPT ) ||
       ( ptr_st_res_dtls->li_ors_msg_typ == ORS_NEW_EXER_RJCT )    )
	{
		strcpy ( st_i_xchngbk.c_entry_dt_tm, ptr_st_res_dtls->c_entry_dt_tm );
	}

	fn_cpy_ddr(st_i_xchngbk.c_rout_crt);
	st_i_xchngbk.c_oprn_typ = UPDATION_ON_EXCHANGE_RESPONSE;

	/***	Begin transaction	***/
  i_trnsctn = fn_begintran(c_ServiceName, c_err_msg );
	if ( i_trnsctn == -1)
	{
		fn_errlog(c_ServiceName,"S31200", LIBMSG, c_err_msg);
		return -1;
	}

	i_ch_val = fn_call_svc ( c_ServiceName,
														c_err_msg,
														&st_i_xchngbk,
														&st_i_xchngbk,
														"vw_xchngbook",
														"vw_xchngbook",
														sizeof ( st_i_xchngbk ),
														sizeof ( st_i_xchngbk ),
														0,
														"SFO_UPD_XCHNGBK" );
	if ( ( i_ch_val != SUCC_BFR ) &&
       ( i_ch_val != RECORD_ALREADY_PRCSD ) )
	{
		fn_errlog(c_ServiceName,"S31205", LIBMSG, c_err_msg);
		fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
		return -1;
	}
	else if ( i_ch_val == RECORD_ALREADY_PRCSD )
	{
  	/** Increment the counter by one. **/
  	if( ( fn_set_cntr ( i_tmp_cntr,
                      	c_ServiceName,
                      	c_err_msg)      )== -1)
  	{
    	/** on error, log the error and return -1; **/
    	fn_errlog(c_ServiceName, "S31210", LIBMSG, c_err_msg);
			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
    	return -1;
  	}

	  /*** Update the order reference number and modification counter in SHM ***/
	  sprintf(c_refack_tmp, "%s - %ld", ptr_st_res_dtls->c_xchng_ack, li_msg_typ);
	  if( ( fn_set_ref_ack_dtls ( c_refack_tmp,
	                              ORD_RES,
	                              c_ServiceName,
	                              c_err_msg)      )== -1)
	  {
	    /** on error, log the error and return -1; **/
	    fn_errlog(c_ServiceName, "S31215", LIBMSG, c_err_msg);
			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
	    return -1;
	  }

		fn_userlog ( c_ServiceName, "Record already processed" );
		fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
		return 0;
	}

	if ( ptr_st_res_dtls->c_ex_ordr_typ == ORDINARY_ORDER )
	{
		strcpy ( st_i_ordrbk.c_xchng_ack, ptr_st_res_dtls->c_xchng_ack );	
		fn_cpy_ddr(st_i_ordrbk.c_rout_crt);
		st_i_ordrbk.c_oprn_typ = UPDATE_XCHNG_RESPONSE;
		
    i_ch_val = fn_call_svc ( c_ServiceName,
                             c_err_msg,
                             &st_i_ordrbk,
                             &st_i_ordrbk,
                             "vw_orderbook",
                             "vw_orderbook",
                             sizeof ( st_i_ordrbk ),
                             sizeof ( st_i_ordrbk ),
                             0,
                             "SFO_UPD_ORDRBK" );
		if ( i_ch_val != SUCC_BFR )
		{
			fn_errlog(c_ServiceName,"S31220", LIBMSG, c_err_msg);
			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
			return -1;
		}
	}

	i_ch_val = fn_committran (c_ServiceName, i_trnsctn, c_err_msg);
	if ( i_ch_val == -1 )
	{
		fn_errlog(c_ServiceName,"S31225", LIBMSG, c_err_msg);
		return -1;
	}
	fn_cpy_ddr(st_i_xchngbk.c_rout_crt);

	i_ch_val = fn_acall_svc ( c_ServiceName,
														 c_err_msg,
														 &st_i_xchngbk,
														 "vw_xchngbook",
														 sizeof ( st_i_xchngbk ),
														 TPNOREPLY,
														 c_svc_name );
	if ( i_ch_val != 0 )
	{
		fn_errlog(c_ServiceName,"S31230", LIBMSG, c_err_msg);
		return -1;
	}

  /** Increment the counter by one. **/
  if( ( fn_set_cntr ( i_tmp_cntr,
                      c_ServiceName,
                      c_err_msg)      )== -1)
  {
    /** on error, log the error and return -1; **/
    fn_errlog(c_ServiceName, "S31235", LIBMSG, c_err_msg);
    return -1;
  }

  /*** Update the order reference number and modification counter in SHM ***/
  sprintf(c_refack_tmp, "%s - %ld", ptr_st_res_dtls->c_xchng_ack, li_msg_typ);
  if( ( fn_set_ref_ack_dtls ( c_refack_tmp,
                              ORD_RES,
                              c_ServiceName,
                              c_err_msg)      )== -1)
  {
    /** on error, log the error and return -1; **/
    fn_errlog(c_ServiceName, "S31240", LIBMSG, c_err_msg);
    return -1;
  }

  /******* Commented in ver 1.7 ********

	*** Added in ver 1.5 ***

  memset(c_temp, 0, MAXDATA);
	sprintf(c_temp, "%d,%ld,%s,%s,%s,%s,%s,%ld,%ld,%ld,%d" , FNO_EXCH,
															 														 li_msg_typ,
														   														 ptr_st_res_dtls->c_ordr_rfrnc,
															 														 c_mtch_accnt,
															 														 ptr_st_res_dtls->c_xchng_ack,
															 														 st_i_xchngbk.c_ack_tm,
															 														 ptr_st_res_dtls->c_xchng_rmrks,
															 														 ptr_st_res_dtls->l_ord_tot_qty,
                                                           ptr_st_res_dtls->l_ord_lmt_rt,	
															 														 ptr_st_res_dtls->l_mdfctn_cntr,
																													 ptr_st_res_dtls->i_retrans_flag 
															 														 );
		fn_userlog(c_ServiceName, "Calling fn_snd_dtq");
		fn_snd_dtq();
	*** End of Add ver 1.5 ***

  ***** End of Comment in ver 1.7 *****/

	return 0;
}

int fn_spd_acpt_rjct ( msg_sprd_ord_res *ptr_st_spd_ord_res,
									 		 long int li_msg_typ,
                       char *c_pipe_id,
                       char *c_ServiceName, 
                       char *c_err_msg             )
{ 
	struct vw_xchngbook st_i_xchngbk;
	struct vw_orderbook st_i_ordrbk;
	struct vw_exrcbook st_i_exrcbk;
	struct vw_spdordbk st_spd_ordbk;
	struct vw_spdxchbk st_spd_xchbk;

	char c_svc_name [15+1];
	char c_refack_tmp[LEN_ORD_REFACK];

	int i_ch_val;
	int i_trnsctn;
	int i_cnt;
	int i_rec_cnt;
	int i_tmp_cntr;

	/*** Update the shared memory counters ***/
	switch ( li_msg_typ )
	{
		case ORS_SPN_ORD_ACPT:
			i_tmp_cntr = SP_ORDR_CNFRM_CNTR;
			break;

		case ORS_SPN_ORD_RJCT:
			i_tmp_cntr = SP_ORDR_RJCT_CNTR;
			break;

		case ORS_2LN_ORD_ACPT:
			i_tmp_cntr = TWOL_ORDR_CNFRM_CNTR;
			break;

		case ORS_2LN_ORD_RJCT:
			i_tmp_cntr = TWOL_ORDR_RJCT_CNTR;
			break;

		case ORS_3LN_ORD_ACPT:
			i_tmp_cntr = THRL_ORDR_CNFRM_CNTR;
			break;

		case ORS_3LN_ORD_RJCT:
			i_tmp_cntr = THRL_ORDR_RJCT_CNTR;
			break;
	}

	if (( ptr_st_spd_ord_res->st_res_dtls[0].li_ors_msg_typ == ORS_3LN_ORD_RJCT)||
			( ptr_st_spd_ord_res->st_res_dtls[0].li_ors_msg_typ == ORS_3LN_ORD_ACPT) )
	{
		i_rec_cnt = 3;
	}
	else
	{
		i_rec_cnt = 2;
	}
/*Added by Sangeet*/
if(DEBUG_MSG_LVL_3)
{
	fn_userlog(c_ServiceName,"The Spread rfrnc for fn_spd_acpt_rjct is :%s:",ptr_st_spd_ord_res->c_spd_ordr_rfrnc );
}

	if ( ptr_st_spd_ord_res->st_res_dtls[0].i_retrans_flag == DOWNLOAD )
	{
		strcpy ( st_spd_ordbk.c_sprd_ord_rfrnc[0], 
	           ptr_st_spd_ord_res->c_spd_ordr_rfrnc );
		fn_cpy_ddr(st_spd_ordbk.c_rout_crt);
	 	st_spd_ordbk.c_rqst_typ[0] = SPDREF_TO_ORDREF;
		i_ch_val = fn_call_svc ( c_ServiceName,
	  												 c_err_msg,
														 &st_spd_ordbk,
														 &st_spd_ordbk,
														 "vw_spdordbk",
														 "vw_spdordbk",
														 sizeof ( st_spd_ordbk ),
														 sizeof ( st_spd_ordbk ),
														 0,
														 "SFO_QRY_SPDBK" );
		if ( i_ch_val != SUCC_BFR )
		{
			fn_errlog(c_ServiceName,"S31245", LIBMSG, c_err_msg);
			return -1;
		}
	}

  i_trnsctn = fn_begintran(c_ServiceName, c_err_msg );
	if ( i_trnsctn == -1)
	{
		fn_errlog(c_ServiceName,"S31250", LIBMSG, c_err_msg);
		return -1;
	}

	for ( i_cnt=0; i_cnt<i_rec_cnt; i_cnt++ )
	{
		if ( ptr_st_spd_ord_res->st_res_dtls[0].i_retrans_flag == DOWNLOAD )
		{
			strcpy ( st_i_ordrbk.c_ordr_rfrnc, st_spd_ordbk.c_ordr_rfrnc[i_cnt] );
			fn_cpy_ddr(st_i_ordrbk.c_rout_crt);
	  	st_i_ordrbk.c_oprn_typ = FOR_VIEW;
			i_ch_val = fn_call_svc ( c_ServiceName,
		  												 c_err_msg,
															 &st_i_ordrbk,
															 &st_i_ordrbk,
															 "vw_orderbook",
															 "vw_orderbook",
															 sizeof ( st_i_ordrbk ),
															 sizeof ( st_i_ordrbk ),
															 0,
															 "SFO_REF_TO_ORD" );
			if ( i_ch_val != SUCC_BFR )
			{
				fn_errlog(c_ServiceName,"S31255", LIBMSG, c_err_msg);
				fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
				return -1;
			}
	
			strcpy ( st_i_xchngbk.c_ordr_rfrnc, st_i_ordrbk.c_ordr_rfrnc );
			
			st_i_xchngbk.l_mdfctn_cntr = st_i_ordrbk.l_mdfctn_cntr;
			strcpy ( st_i_xchngbk.c_xchng_cd, st_i_ordrbk.c_xchng_cd );
			strcpy ( c_mtch_accnt, st_i_ordrbk.c_cln_mtch_accnt );						/* ver 1.2 */
			strcpy ( st_i_xchngbk.c_pipe_id, st_i_ordrbk.c_pipe_id );
		}
		else
		{
			strcpy ( st_i_xchngbk.c_ordr_rfrnc, 
               ptr_st_spd_ord_res->st_res_dtls[i_cnt].c_ordr_rfrnc );
			st_i_xchngbk.l_mdfctn_cntr = 
               ptr_st_spd_ord_res->st_res_dtls[i_cnt].l_mdfctn_cntr;
			strcpy ( st_i_xchngbk.c_xchng_cd, c_xchng_cd );
			strcpy ( st_i_xchngbk.c_pipe_id, c_pipe_id );
		}

		switch( ptr_st_spd_ord_res->st_res_dtls[0].li_ors_msg_typ )
		{
    	case ORS_SPN_ORD_ACPT :
    	case ORS_2LN_ORD_ACPT :
    	case ORS_3LN_ORD_ACPT :
				st_i_xchngbk.c_plcd_stts = ACCEPT;	
				break;
			
    	case ORS_SPN_ORD_RJCT :
    	case ORS_2LN_ORD_RJCT :
    	case ORS_3LN_ORD_RJCT :
				st_i_xchngbk.c_plcd_stts = REJECT;	
				break;
		}

		/*** Update exchange book with ack time, RMS processed flag ***/
		/*** and placed status																			***/
		st_i_xchngbk.c_rms_prcsd_flg = NOT_PROCESSED;  
		st_i_xchngbk.l_ors_msg_typ = 
           ptr_st_spd_ord_res->st_res_dtls[i_cnt].li_ors_msg_typ;
		strcpy ( st_i_xchngbk.c_ack_tm , 
             ptr_st_spd_ord_res->st_res_dtls[i_cnt].c_ack_tm );
		strcpy ( st_i_xchngbk.c_xchng_rmrks , 
             ptr_st_spd_ord_res->st_res_dtls[i_cnt].c_xchng_rmrks );
		st_i_xchngbk.d_jiffy = 
            (double) ptr_st_spd_ord_res->st_res_dtls[i_cnt].ll_log_tm_stmp;
		st_i_xchngbk.l_dwnld_flg = 
             ptr_st_spd_ord_res->st_res_dtls[i_cnt].i_retrans_flag;
		strcpy ( st_i_xchngbk.c_entry_dt_tm, 
             ptr_st_spd_ord_res->st_res_dtls[i_cnt].c_entry_dt_tm );
		fn_cpy_ddr(st_i_xchngbk.c_rout_crt);
		st_i_xchngbk.c_oprn_typ = UPDATION_ON_EXCHANGE_RESPONSE;

		i_ch_val = fn_call_svc ( c_ServiceName,
															c_err_msg,
															&st_i_xchngbk,
															&st_i_xchngbk,
															"vw_xchngbook",
															"vw_xchngbook",
															sizeof ( st_i_xchngbk ),
															sizeof ( st_i_xchngbk ),
															0,
															"SFO_UPD_XCHNGBK" );
		if ( ( i_ch_val != SUCC_BFR ) &&
	       ( i_ch_val != RECORD_ALREADY_PRCSD ) )
		{
			fn_errlog(c_ServiceName,"S31260", LIBMSG, c_err_msg);
			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
			return -1;
		}
		else if ( i_ch_val == RECORD_ALREADY_PRCSD )
		{
	  	/** Increment the counter by one. **/
	  	if( ( fn_set_cntr ( i_tmp_cntr,
	                      	c_ServiceName,
	                      	c_err_msg)      )== -1)
	  	{
	    	/** on error, log the error and return -1; **/
	    	fn_errlog(c_ServiceName, "S31265", LIBMSG, c_err_msg);
				fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
	    	return -1;
	  	}

		  /***Update the order reference number and modification counter in SHM ***/
		  sprintf(c_refack_tmp, "%s - %ld", 
									ptr_st_spd_ord_res->st_res_dtls[0].c_xchng_ack, li_msg_typ);
		  if( ( fn_set_ref_ack_dtls ( c_refack_tmp,
		                              ORD_RES,
		                              c_ServiceName,
		                              c_err_msg)      )== -1)
		  {
		    /** on error, log the error and return -1; **/
		    fn_errlog(c_ServiceName, "S31270", LIBMSG, c_err_msg);
				fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
		    return -1;
		  }

			fn_userlog ( c_ServiceName, "Record already processed" );
			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
			return 0;
		}

		/*** Update order book with acknowledgement number	***/
		strcpy( st_i_ordrbk.c_xchng_ack , 
            ptr_st_spd_ord_res->st_res_dtls[i_cnt].c_xchng_ack );

		if ( ptr_st_spd_ord_res->st_res_dtls[0].i_retrans_flag == DOWNLOAD )
		{
			strcpy ( st_i_ordrbk.c_ordr_rfrnc, st_spd_ordbk.c_ordr_rfrnc[i_cnt] );
		}
		else
		{
			strcpy( st_i_ordrbk.c_ordr_rfrnc, 
            ptr_st_spd_ord_res->st_res_dtls[i_cnt].c_ordr_rfrnc );
		}
		fn_cpy_ddr(st_i_ordrbk.c_rout_crt);
		st_i_ordrbk.c_oprn_typ = UPDATE_XCHNG_RESPONSE;
		
    i_ch_val = fn_call_svc ( c_ServiceName,
                             c_err_msg,
                             &st_i_ordrbk,
                             &st_i_ordrbk,
                             "vw_orderbook",
                             "vw_orderbook",
                             sizeof ( st_i_ordrbk ),
                             sizeof ( st_i_ordrbk ),
                             0,
                             "SFO_UPD_ORDRBK" );
		if ( i_ch_val != SUCC_BFR )
		{
			fn_errlog(c_ServiceName,"S31275", LIBMSG, c_err_msg);
			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
			return -1;
		}

		/** st_spd_xchbk to be initialised here **/
    strcpy ( st_spd_xchbk.c_xchng_cd[i_cnt], st_i_xchngbk.c_xchng_cd );
    strcpy ( st_spd_xchbk.c_ordr_rfrnc[i_cnt], st_i_xchngbk.c_ordr_rfrnc );
    strcpy ( st_spd_xchbk.c_pipe_id[i_cnt], st_i_xchngbk.c_pipe_id );
    strcpy ( st_spd_xchbk.c_mod_trd_dt[i_cnt], st_i_xchngbk.c_mod_trd_dt );
    st_spd_xchbk.l_ord_seq[i_cnt] = st_i_xchngbk.l_ord_seq;
    st_spd_xchbk.c_slm_flg[i_cnt] = st_i_xchngbk.c_slm_flg;
    st_spd_xchbk.l_dsclsd_qty[i_cnt] = st_i_xchngbk.l_dsclsd_qty;
    st_spd_xchbk.l_ord_tot_qty[i_cnt] = st_i_xchngbk.l_ord_tot_qty;
    st_spd_xchbk.l_ord_lmt_rt[i_cnt] = st_i_xchngbk.l_ord_lmt_rt;
    st_spd_xchbk.l_stp_lss_tgr[i_cnt] = st_i_xchngbk.l_stp_lss_tgr;
    st_spd_xchbk.l_mdfctn_cntr[i_cnt] = st_i_xchngbk.l_mdfctn_cntr;
    strcpy ( st_spd_xchbk.c_valid_dt[i_cnt], st_i_xchngbk.c_valid_dt );
    st_spd_xchbk.c_ord_typ[i_cnt] = st_i_xchngbk.c_ord_typ;
    st_spd_xchbk.c_sprd_ord_ind[i_cnt] = st_i_xchngbk.c_sprd_ord_ind;
    st_spd_xchbk.c_req_typ[i_cnt] = st_i_xchngbk.c_req_typ;
    st_spd_xchbk.l_quote[i_cnt] = st_i_xchngbk.l_quote;
    strcpy ( st_spd_xchbk.c_qt_tm[i_cnt], st_i_xchngbk.c_qt_tm );
    strcpy ( st_spd_xchbk.c_rqst_tm[i_cnt], st_i_xchngbk.c_rqst_tm );
    strcpy ( st_spd_xchbk.c_frwrd_tm[i_cnt], st_i_xchngbk.c_frwrd_tm );
    st_spd_xchbk.c_plcd_stts[i_cnt] = st_i_xchngbk.c_plcd_stts;
    st_spd_xchbk.c_rms_prcsd_flg[i_cnt] = st_i_xchngbk.c_rms_prcsd_flg;
    strcpy ( st_spd_xchbk.c_ack_tm[i_cnt], st_i_xchngbk.c_ack_tm );
    strcpy ( st_spd_xchbk.c_xchng_rmrks[i_cnt], st_i_xchngbk.c_xchng_rmrks );
    st_spd_xchbk.c_ex_ordr_typ[i_cnt] = st_i_xchngbk.c_ex_ordr_typ;
    st_spd_xchbk.l_xchng_can_qty[i_cnt] = st_i_xchngbk.l_xchng_can_qty;
    st_spd_xchbk.l_bit_flg[i_cnt] = st_i_xchngbk.l_bit_flg;
    st_spd_xchbk.c_spl_flg[i_cnt] = st_i_xchngbk.c_spl_flg;
    st_spd_xchbk.c_ordr_flw[i_cnt] = st_i_xchngbk.c_ordr_flw;
    st_spd_xchbk.c_oprn_typ[i_cnt] = st_i_xchngbk.c_oprn_typ;
		st_spd_xchbk.l_ors_msg_typ[i_cnt] = st_i_xchngbk.l_ors_msg_typ; 
    st_spd_xchbk.d_jiffy[i_cnt] = st_i_xchngbk.d_jiffy;
    st_spd_xchbk.l_dwnld_flg[i_cnt] = st_i_xchngbk.l_dwnld_flg;
    strcpy ( st_spd_xchbk.c_entry_dt_tm[i_cnt], st_i_xchngbk.c_entry_dt_tm );
	}

	strcpy( st_spd_ordbk.c_xchng_ack[0], 
          ptr_st_spd_ord_res->st_res_dtls[0].c_xchng_ack );
	strcpy( st_spd_ordbk.c_sprd_ord_rfrnc[0], 
          ptr_st_spd_ord_res->c_spd_ordr_rfrnc );
	fn_cpy_ddr(st_spd_ordbk.c_rout_crt);
	st_spd_ordbk.c_rqst_typ[0] = UPDATE_XCHNG_RESPONSE;
	
  i_ch_val = fn_call_svc ( c_ServiceName,
                           c_err_msg,
                           &st_spd_ordbk,
                           &st_spd_ordbk,
                           "vw_spdordbk",
                           "vw_spdordbk",
                           sizeof ( st_spd_ordbk ),
                           sizeof ( st_spd_ordbk ),
                           0,
                           "SFO_UPD_SPDBK" );
	if ( i_ch_val != SUCC_BFR )
	{
		fn_errlog(c_ServiceName,"S31280", LIBMSG, c_err_msg);
		fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
		return -1;
	}

	fn_cpy_ddr(st_spd_xchbk.c_rout_crt);

	i_ch_val = fn_committran (c_ServiceName, i_trnsctn, c_err_msg);
	if ( i_ch_val == -1 )
	{
		fn_errlog(c_ServiceName,"S31285", LIBMSG, c_err_msg);
		return -1;
	}

	i_ch_val = fn_acall_svc ( c_ServiceName,
														c_err_msg,
														&st_spd_xchbk,
														"vw_spdxchbk",
														sizeof ( st_spd_xchbk ),
														TPNOREPLY,
														"SFO_SPD_ACK" );
	if ( i_ch_val != 0 )
	{
		fn_errlog(c_ServiceName,"S31290", LIBMSG, c_err_msg);
		return -1;
	}

  /** Increment the counter by one. **/
  if( ( fn_set_cntr ( i_tmp_cntr,
                      c_ServiceName,
                      c_err_msg)      )== -1)
  {
    /** on error, log the error and return -1; **/
    fn_errlog(c_ServiceName, "S31295", LIBMSG, c_err_msg);
    return -1;
  }

  /*** Update the order reference number and modification counter in SHM ***/
  sprintf(c_refack_tmp, "%s - %ld", 
							ptr_st_spd_ord_res->st_res_dtls[0].c_xchng_ack, li_msg_typ);
  if( ( fn_set_ref_ack_dtls ( c_refack_tmp,
                              ORD_RES,
                              c_ServiceName,
                              c_err_msg)      )== -1)
  {
    /** on error, log the error and return -1; **/
    fn_errlog(c_ServiceName, "S31300", LIBMSG, c_err_msg);
    return -1;
  }
 
  /***** Commented in ver 1.7 ******
  *** Added in ver 1.5 ***
  for(i_cnt=0; i_cnt<i_rec_cnt; i_cnt++)
	{
  	memset(c_temp, 0, MAXDATA);
  	sprintf(c_temp,"%d,%ld,%s,%s,%s,%s,%s,%ld,%ld,%ld,%d", 
																					FNO_EXCH,
                                       	  li_msg_typ,
                   	                   		ptr_st_spd_ord_res->st_res_dtls[i_cnt].c_ordr_rfrnc,
                                       		c_mtch_accnt,
                                       		ptr_st_spd_ord_res->st_res_dtls[i_cnt].c_xchng_ack,
                                       		st_spd_xchbk.c_ack_tm[i_cnt],
                                       		ptr_st_spd_ord_res->st_res_dtls[i_cnt].c_xchng_rmrks,
                                       		ptr_st_spd_ord_res->st_res_dtls[i_cnt].l_ord_tot_qty,
                                       		ptr_st_spd_ord_res->st_res_dtls[i_cnt].l_ord_lmt_rt,
                                       		ptr_st_spd_ord_res->st_res_dtls[i_cnt].l_mdfctn_cntr,
                                       		ptr_st_spd_ord_res->st_res_dtls[i_cnt].i_retrans_flag
                                       		);
    	fn_snd_dtq();
	}
  *** End of Add ver 1.5 ***
  *** End of Comment in ver 1.7 ***/

	return 0;
}

/******************************************************************************/
/*	To update details about order freeze / order tiggered / order expired  		*/
/*	based on c_ord_res_stts variable.																					*/
/*	INPUT PARAMETERS																													*/
/*			rcv_q_msg			- Pointer to a message structure got from receive 			*/
/*											message queue.																				*/
/*			c_pipe_id			- Pipe ID																								*/
/*			c_ord_res_stts-	status of response ( FREEZED/TRIGGERED/EXPIRED )			*/
/*			c_ServiceName - Service Name currently running												*/
/*			c_err_msg			-	Error message to be returned													*/
/*	OUTPUT PARAMETERS																													*/
/*				0		-	Success																												*/
/*				-1	-	Failure																												*/
/******************************************************************************/
int fn_ord_frz_exp ( msg_reqres_dtls *ptr_st_res_dtls,
                     char *c_pipe_id, 
										 char c_ord_res_stts, 
                     char *c_ServiceName, 
										 char *c_err_msg)
{
	int i_trnsctn;
	int i_ch_val;
	int i_tmp_cntr;
	long int li_msg_typ;

	struct vw_xchngbook st_i_xchngbk;
	struct vw_xchngbook st_tmp_xchngbk;
	struct vw_orderbook st_i_ordbk;

	char c_svc_name [ 16 ];
	char c_refack_tmp[LEN_ORD_REFACK];
	char c_refack_tmp2[LEN_ORD_REFACK];

	/*** Update the shared memory counters ***/
	switch ( c_ord_res_stts )
	{
		case FREEZED:
			i_tmp_cntr = ORD_FRZ_CNTR;
			li_msg_typ = ORS_ORD_FRZ;
			break;

		case EXPIRED:
			i_tmp_cntr = BTCH_ORDR_CXL_CNTR;
			li_msg_typ = ORS_ORD_EXP;
			break;
	}
/*Added by Sangeet*/
if(DEBUG_MSG_LVL_3)
{
	fn_userlog(c_ServiceName,"The ACK for fn_ord_frz_exp is :%s:",ptr_st_res_dtls->c_xchng_ack );
}

	if ( c_ord_res_stts == EXPIRED )
	{
		strcpy ( st_i_ordbk.c_xchng_ack , ptr_st_res_dtls->c_xchng_ack );
		strcpy ( st_i_ordbk.c_pipe_id , c_pipe_id );
		fn_cpy_ddr(st_i_ordbk.c_rout_crt);
		st_i_ordbk.c_oprn_typ = FOR_VIEW;
	
		i_ch_val = fn_call_svc ( c_ServiceName,
  													 c_err_msg,
  													 &st_i_ordbk,
  													 &st_i_ordbk,
  													 "vw_orderbook",
  													 "vw_orderbook",
  													 sizeof ( st_i_ordbk ),
  													 sizeof ( st_i_ordbk ),
  													 0,
  													 "SFO_ACK_TO_ORD" );
		if ( i_ch_val != SUCC_BFR )
		{
			fn_errlog(c_ServiceName,"S31305", LIBMSG, c_err_msg);
			return -1;
		}

		strcpy ( st_i_xchngbk.c_ordr_rfrnc , st_i_ordbk.c_ordr_rfrnc );
		strcpy ( st_i_xchngbk.c_xchng_cd , st_i_ordbk.c_xchng_cd );
		strcpy ( st_i_xchngbk.c_pipe_id , st_i_ordbk.c_pipe_id );
		strcpy ( st_i_xchngbk.c_mod_trd_dt , ( char * )c_trd_dt.arr );
		st_i_xchngbk.l_ord_tot_qty = st_i_ordbk.l_ord_tot_qty;
		st_i_xchngbk.l_ord_lmt_rt = st_i_ordbk.l_ord_lmt_rt;
		st_i_xchngbk.l_ord_seq = 0;
		st_i_xchngbk.l_mdfctn_cntr = EXPIRY_MDFCTN_CNTR;
		st_i_xchngbk.c_rms_prcsd_flg = NOT_PROCESSED;
	}
	else
	{
		strcpy ( st_i_xchngbk.c_ordr_rfrnc , ptr_st_res_dtls->c_ordr_rfrnc );
		strcpy ( st_i_xchngbk.c_xchng_cd , c_xchng_cd );
		strcpy ( st_i_xchngbk.c_pipe_id , c_pipe_id );
		strcpy ( st_i_xchngbk.c_mod_trd_dt , ( char * )c_trd_dt.arr );
		st_i_xchngbk.l_ord_tot_qty = ptr_st_res_dtls->l_ord_tot_qty;
		st_i_xchngbk.l_ord_lmt_rt = ptr_st_res_dtls->l_ord_lmt_rt;
		st_i_xchngbk.l_ord_seq = 0;
		st_i_xchngbk.l_mdfctn_cntr = 0;
		st_i_xchngbk.c_rms_prcsd_flg = PROCESSED;
	}

	strcpy ( st_i_xchngbk.c_ack_tm , ptr_st_res_dtls->c_ack_tm );
	st_i_xchngbk.c_plcd_stts = c_ord_res_stts;
	st_i_xchngbk.l_ors_msg_typ = ptr_st_res_dtls->li_ors_msg_typ;
	strcpy ( st_i_xchngbk.c_xchng_rmrks , ptr_st_res_dtls->c_xchng_rmrks );
	st_i_xchngbk.d_jiffy = (double) ptr_st_res_dtls->ll_log_tm_stmp;
	st_i_xchngbk.l_dwnld_flg = ptr_st_res_dtls->i_retrans_flag;
	fn_cpy_ddr(st_i_xchngbk.c_rout_crt);
	st_i_xchngbk.c_oprn_typ = INSERTION_ON_ORDER_FTE;
	
  i_trnsctn = fn_begintran(c_ServiceName, c_err_msg );
  if ( i_trnsctn ==  -1 )
  {
		fn_errlog(c_ServiceName,"S31310", LIBMSG, c_err_msg);
    return -1;
  }

	i_ch_val = fn_call_svc ( c_ServiceName,
													 c_err_msg,
													 &st_i_xchngbk,
													 &st_i_xchngbk,
													 "vw_xchngbook",
													 "vw_xchngbook",
													 sizeof ( st_i_xchngbk ),
													 sizeof ( st_i_xchngbk ),
													 0,
													 "SFO_UPD_XCHNGBK" );
	if ( ( i_ch_val != SUCC_BFR ) &&
       ( i_ch_val != RECORD_ALREADY_PRCSD ) )
	{
		fn_errlog(c_ServiceName,"S31315", LIBMSG, c_err_msg);
		fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
		return -1;
	}
	else if ( i_ch_val == RECORD_ALREADY_PRCSD )
	{
  	/** Increment the counter by one. **/
  	if( ( fn_set_cntr ( i_tmp_cntr,
                      	c_ServiceName,
                      	c_err_msg)      )== -1)
  	{
    	/** on error, log the error and return -1; **/
    	fn_errlog(c_ServiceName, "S31320", LIBMSG, c_err_msg);
			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg); /*ver 1.3 */
    	return -1;
  	}

	  /*** Update the order reference number and modification counter in SHM ***/
	  sprintf(c_refack_tmp, "%s - %ld", ptr_st_res_dtls->c_xchng_ack, li_msg_typ);
	  if( ( fn_set_ref_ack_dtls ( c_refack_tmp,
	                              ORD_RES,
	                              c_ServiceName,
	                              c_err_msg)      )== -1)
	  {
	    /** on error, log the error and return -1; **/
	    fn_errlog(c_ServiceName, "S31325", LIBMSG, c_err_msg);
			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg); /*ver 1.3 */
	    return -1;
	  }

		fn_userlog ( c_ServiceName, "Record already processed" );
		fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
		return 0;
	}

	/**** In case of order freeze, update order book by status ****/
	if ( c_ord_res_stts == FREEZED )
	{
		strcpy ( st_i_ordbk.c_ordr_rfrnc , ptr_st_res_dtls->c_ordr_rfrnc );
		strcpy ( st_i_ordbk.c_xchng_ack, ptr_st_res_dtls->c_xchng_ack );	
		fn_cpy_ddr(st_i_ordbk.c_rout_crt);
		st_i_ordbk.c_oprn_typ = UPDATE_XCHNG_RESPONSE;
		
    i_ch_val = fn_call_svc ( c_ServiceName,
                             c_err_msg,
                             &st_i_ordbk,
                             &st_i_ordbk,
                             "vw_orderbook",
                             "vw_orderbook",
                             sizeof ( st_i_ordbk ),
                             sizeof ( st_i_ordbk ),
                             0,
                             "SFO_UPD_ORDRBK" );
		if ( i_ch_val != SUCC_BFR )
		{
			fn_errlog(c_ServiceName,"S31330", LIBMSG, c_err_msg);
			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
			return -1;
		}

		strcpy ( st_i_ordbk.c_ordr_rfrnc , ptr_st_res_dtls->c_ordr_rfrnc );
		st_i_ordbk.c_ordr_stts = FREEZED ;
		fn_cpy_ddr(st_i_ordbk.c_rout_crt);
		st_i_ordbk.c_oprn_typ = UPDATE_ORDER_STATUS;
		
		i_ch_val = fn_call_svc ( c_ServiceName,
															c_err_msg,
															&st_i_ordbk,
															&st_i_ordbk,
															"vw_orderbook",
															"vw_orderbook",
															sizeof ( st_i_ordbk ),
															sizeof ( st_i_ordbk ),
															0,
															"SFO_UPD_ORDRBK" );
		if ( i_ch_val != SUCC_BFR )
		{
			fn_errlog(c_ServiceName,"S31335", LIBMSG, c_err_msg);
			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
			return -1;
		}
	}

	strcpy(c_refack_tmp2, ptr_st_res_dtls->c_ordr_rfrnc);
	/*****Added by sangeet to get the Freeze Broadcast in DT ***/
	EXEC SQL
	SELECT FOD_CLM_MTCH_ACCNT
	INTO :c_mtch_accnt
	FROM fod_fo_ordr_dtls
	WHERE FOD_ORDR_RFRNC = :c_refack_tmp2	;				/* 1.2 */
	if (SQLCODE != 0)
	{
		fn_errlog(c_ServiceName,"S31340", SQLMSG, c_err_msg);
	}
	
	i_ch_val = fn_committran (c_ServiceName, i_trnsctn, c_err_msg);
	if ( i_ch_val == -1 )
	{
		fn_errlog(c_ServiceName,"S31345", LIBMSG, c_err_msg);
		return -1;
	}

	/****** In case of order expiration do the following	*****/
	if (c_ord_res_stts == EXPIRED )
	{
		if ( st_i_ordbk.c_prd_typ == OPTIONS || st_i_ordbk.c_prd_typ == OPTIONPLUS )	/*** OPTIONPLUS added Ver 2.2 ***/
		{
			strcpy ( c_svc_name , "SFO_OPT_ACK" );
		}
		/*** else if ( st_i_ordbk.c_prd_typ == FUTURES || st_i_ordbk.c_prd_typ == FUTURE_PLUS )	*ver 2.0 * Commented in Ver 2.1 ***/
		else if ( st_i_ordbk.c_prd_typ == FUTURES || st_i_ordbk.c_prd_typ == FUTURE_PLUS || st_i_ordbk.c_prd_typ == SLTP_FUTUREPLUS )	/*** Ver 2.1 ***/
    {
			strcpy ( c_svc_name , "SFO_FUT_ACK" );
    }
		fn_cpy_ddr(st_i_xchngbk.c_rout_crt);

		i_ch_val = fn_acall_svc ( c_ServiceName,
															c_err_msg,
															&st_i_xchngbk,
															"vw_xchngbook",
															sizeof ( st_i_xchngbk ),
															TPNOREPLY,
															c_svc_name );
		if ( i_ch_val != SUCC_BFR )
		{
			fn_errlog(c_ServiceName,"S31350", LIBMSG, c_err_msg);
			return -1;
		}
	}

  /** Increment the counter by one. **/
  if( ( fn_set_cntr ( i_tmp_cntr,
                      c_ServiceName,
                      c_err_msg)      )== -1)
  {
    /** on error, log the error and return -1; **/
    fn_errlog(c_ServiceName, "S31355", LIBMSG, c_err_msg);
    return -1;
  }

  /*** Update the order reference number and modification counter in SHM ***/
  sprintf(c_refack_tmp, "%s - %ld", ptr_st_res_dtls->c_xchng_ack, li_msg_typ);
  if( ( fn_set_ref_ack_dtls ( c_refack_tmp,
                              ORD_RES,
                              c_ServiceName,
                              c_err_msg)      )== -1)
  {
    /** on error, log the error and return -1; **/
    fn_errlog(c_ServiceName, "S31360", LIBMSG, c_err_msg);
    return -1;
  }

  /***** Commented in ver 1.7 ******

  *** Added in ver 1.5 ***

  memset(c_temp, 0, MAXDATA);
  sprintf(c_temp, "%d,%ld,%s,%s,%s,%s,%s,%ld,%ld,%ld,%d" ,FNO_EXCH,
                                                          ORS_ORD_FRZ,
                                                          ptr_st_res_dtls->c_ordr_rfrnc,
                                                          c_mtch_accnt,
                                                          ptr_st_res_dtls->c_xchng_ack,
                                                          st_i_xchngbk.c_ack_tm,
                                                          ptr_st_res_dtls->c_xchng_rmrks,
                                                          ptr_st_res_dtls->l_ord_tot_qty,
                                                          ptr_st_res_dtls->l_ord_lmt_rt,
                                                          ptr_st_res_dtls->l_mdfctn_cntr,
                                                          ptr_st_res_dtls->i_retrans_flag
                                                          );
    fn_snd_dtq();
  *** End of Add ver 1.5 ***

  *** End of Comment in ver 1.7 ***/

	return 0;
}

int fn_ord_trg ( msg_reqres_dtls *ptr_st_res_dtls,
                 char *c_pipe_id, 
								 char c_ord_res_stts, 
                 char *c_ServiceName, 
								 char *c_err_msg)
{
	int i_trnsctn;
	int i_ch_val;
	int i_returncode;

	struct vw_xchngbook st_i_xchngbk;
	struct vw_orderbook st_i_ordbk;

	char c_svc_name [ 16 ];
	char c_refack_tmp[LEN_ORD_REFACK];

  i_trnsctn = fn_begintran(c_ServiceName, c_err_msg );
  if ( i_trnsctn ==  -1 )
  {
		fn_errlog(c_ServiceName,"S31365", LIBMSG, c_err_msg);
    return -1;
  }

	strcpy ( st_i_ordbk.c_xchng_ack , ptr_st_res_dtls->c_xchng_ack );
	strcpy ( st_i_ordbk.c_pipe_id , c_pipe_id );
	fn_cpy_ddr(st_i_ordbk.c_rout_crt);
  st_i_ordbk.c_oprn_typ = FOR_UPDATE;
	
	i_ch_val = fn_call_svc ( c_ServiceName,
													 c_err_msg,
													 &st_i_ordbk,
													 &st_i_ordbk,
													 "vw_orderbook",
													 "vw_orderbook",
													 sizeof ( st_i_ordbk ),
													 sizeof ( st_i_ordbk ),
													 0,
													 "SFO_ACK_TO_ORD" );
	if ( i_ch_val != SUCC_BFR )
	{
		fn_errlog(c_ServiceName,"S31370", LIBMSG, c_err_msg);
    fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /* ver 1.3 */
		return -1;
	}
	strcpy(ptr_st_res_dtls->c_ordr_rfrnc,st_i_ordbk.c_ordr_rfrnc);							/*1.2*/

  /** i_returncode = fn_lock_usr( c_ServiceName,  st_i_ordbk.c_cln_mtch_accnt ); ** ver 2.3 **/
  i_returncode = fn_lock_fno( c_ServiceName,  st_i_ordbk.c_cln_mtch_accnt ); /** ver 2.3 **/
  if ( i_returncode != 0 )
  {
    fn_errlog ( c_ServiceName, "S31375", LIBMSG, c_err_msg );
    fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
		return -1;
  }

	strcpy ( st_i_xchngbk.c_ordr_rfrnc , st_i_ordbk.c_ordr_rfrnc );
	strcpy ( st_i_xchngbk.c_xchng_cd , st_i_ordbk.c_xchng_cd );
	strcpy ( c_mtch_accnt , st_i_ordbk.c_cln_mtch_accnt );						/*ver 1.2 */
	strcpy ( st_i_xchngbk.c_pipe_id , st_i_ordbk.c_pipe_id );
	strcpy ( st_i_xchngbk.c_mod_trd_dt , ( char * )c_trd_dt.arr );
	st_i_xchngbk.l_ord_tot_qty = st_i_ordbk.l_ord_tot_qty;
	st_i_xchngbk.l_ord_lmt_rt = st_i_ordbk.l_ord_lmt_rt;
	st_i_xchngbk.l_ord_seq = 0;
	st_i_xchngbk.l_mdfctn_cntr = 0;
	strcpy ( st_i_xchngbk.c_ack_tm , ptr_st_res_dtls->c_ack_tm );
	st_i_xchngbk.c_plcd_stts = c_ord_res_stts;
	st_i_xchngbk.c_rms_prcsd_flg = PROCESSED;
	st_i_xchngbk.l_ors_msg_typ = ptr_st_res_dtls->li_ors_msg_typ;
	strcpy ( st_i_xchngbk.c_xchng_rmrks , ptr_st_res_dtls->c_xchng_rmrks );
	st_i_xchngbk.d_jiffy = (double) ptr_st_res_dtls->ll_log_tm_stmp;
	st_i_xchngbk.l_dwnld_flg = ptr_st_res_dtls->i_retrans_flag;
	fn_cpy_ddr(st_i_xchngbk.c_rout_crt);
	st_i_xchngbk.c_oprn_typ = INSERTION_ON_ORDER_FTE;
	
	i_ch_val = fn_call_svc ( c_ServiceName,
													 c_err_msg,
													 &st_i_xchngbk,
													 &st_i_xchngbk,
													 "vw_xchngbook",
													 "vw_xchngbook",
													 sizeof ( st_i_xchngbk ),
													 sizeof ( st_i_xchngbk ),
													 0,
													 "SFO_UPD_XCHNGBK" );
	if ( ( i_ch_val != SUCC_BFR ) &&
       ( i_ch_val != RECORD_ALREADY_PRCSD ) )
	{
		fn_errlog(c_ServiceName,"S31380", LIBMSG, c_err_msg);
		fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
		return -1;
	}
	else if ( i_ch_val == RECORD_ALREADY_PRCSD )
	{
	  /** Increment the counter in shared memory by one. **/
	  if( ( fn_set_cntr ( ORD_TRG_CNTR,
	                      c_ServiceName,
	                      c_err_msg)      )== -1)
	  {
	    /** on error, log the error and return -1; **/
	    fn_errlog(c_ServiceName, "S31385", LIBMSG, c_err_msg);
    	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /* ver 1.3 */
	    return -1;
	  }

	  /***Update the order reference number and modification counter in SHM ***/
	  sprintf(c_refack_tmp,"%s - %ld", ptr_st_res_dtls->c_xchng_ack, ORS_ORD_TRG);
	  if( ( fn_set_ref_ack_dtls ( c_refack_tmp,
	                              ORD_RES,
	                              c_ServiceName,
	                              c_err_msg)      )== -1)
	  {
	    /** on error, log the error and return -1; **/
	    fn_errlog(c_ServiceName, "S31390", LIBMSG, c_err_msg);
    	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /* ver 1.3 */
	    return -1;
	  }

		fn_userlog ( c_ServiceName, "Record already processed" );
		fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
		return 0;
	}

  strcpy( st_i_ordbk.c_ack_tm , ptr_st_res_dtls->c_ack_tm);
	fn_cpy_ddr(st_i_ordbk.c_rout_crt);
  st_i_ordbk.c_oprn_typ = UPDATE_XCHNG_RESP_DTLS_OT;

  i_returncode = fn_call_svc( c_ServiceName,
                              c_err_msg,
                              &st_i_ordbk,
                              &st_i_ordbk,
                              "vw_orderbook",
                              "vw_orderbook",
													 		sizeof ( st_i_ordbk ),
													    sizeof ( st_i_ordbk ),
                              0,
                              "SFO_UPD_ORDRBK" );
  if ( i_returncode != SUCC_BFR )
  {
    fn_errlog ( c_ServiceName, "S31395", LIBMSG, c_err_msg );
    fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg );
		return -1;
  }

	i_ch_val = fn_committran (c_ServiceName, i_trnsctn, c_err_msg);
	if ( i_ch_val == -1 )
	{
		fn_errlog(c_ServiceName,"S31400", LIBMSG, c_err_msg);
		return -1;
	}

  /** Increment the counter in shared memory by one. **/
  if( ( fn_set_cntr ( ORD_TRG_CNTR,
                      c_ServiceName,
                      c_err_msg)      )== -1)
  {
    /** on error, log the error and return -1; **/
    fn_errlog(c_ServiceName, "S31405", LIBMSG, c_err_msg);
    return -1;
  }

  /*** Update the order reference number and modification counter in SHM ***/
  sprintf(c_refack_tmp, "%s - %ld", ptr_st_res_dtls->c_xchng_ack, ORS_ORD_TRG);
  if( ( fn_set_ref_ack_dtls ( c_refack_tmp,
                              ORD_RES,
                              c_ServiceName,
                              c_err_msg)      )== -1)
  {
    /** on error, log the error and return -1; **/
    fn_errlog(c_ServiceName, "S31410", LIBMSG, c_err_msg);
    return -1;
  }

  /***** Commented in ver 1.7 ******

  *** Added in ver 1.5 ***

  memset(c_temp, 0, MAXDATA);
  sprintf(c_temp, "%d,%ld,%s,%s,%s,%s,%s,%ld,%ld,%ld,%d" , FNO_EXCH,
                                                           ORS_ORD_TRG,
                                                           ptr_st_res_dtls->c_ordr_rfrnc,
                                                           c_mtch_accnt,
                                                           ptr_st_res_dtls->c_xchng_ack,
                                                           st_i_xchngbk.c_ack_tm,
                                                           ptr_st_res_dtls->c_xchng_rmrks,
                                                           ptr_st_res_dtls->l_ord_tot_qty,
                                                           ptr_st_res_dtls->l_ord_lmt_rt,
                                                           ptr_st_res_dtls->l_mdfctn_cntr,
                                                           ptr_st_res_dtls->i_retrans_flag
                                                           );
    fn_snd_dtq();
  *** End of Add ver 1.5 ***
  
  *** End of Comment in ver 1.7 ***/

	return 0;
}

int fn_spd_ord_cncl ( msg_sprd_ord_res *ptr_st_spd_ord_res,
								 		  long int li_msg_typ,
                      char *c_pipe_id,
                      char *c_ServiceName, 
							        char *c_err_msg      )
{
	struct vw_xchngbook st_i_xchngbk;
	struct vw_orderbook st_i_ordrbk;
	struct vw_exrcbook st_i_exrcbk;
	struct vw_spdordbk st_spd_ordbk;
	struct vw_spdxchbk st_spd_xchbk;

	char c_svc_name [15+1];
	char c_refack_tmp[LEN_ORD_REFACK];

	int i_ch_val;
	int i_trnsctn;
	int i_cnt;
	int i_rec_cnt;
	int i_tmp_cntr;
	long int li_exctd_qty;

	/*** Update the shared memory counters ***/
	switch ( li_msg_typ )
	{
		case ORS_SPD_ORD_CNCL:
			i_tmp_cntr = SP_ORDR_CXL_CNFRM_CNTR;
			i_rec_cnt = 2;
			break;

		case ORS_2L_ORD_CNCL:
			i_tmp_cntr = TWOL_ORDR_CXL_CNFRM_CNTR;
			i_rec_cnt = 2;
			break;

		case ORS_3L_ORD_CNCL:
			i_tmp_cntr = THRL_ORDR_CXL_CNFRM_CNTR;
			i_rec_cnt = 3;
			break;
	}

	strcpy ( st_spd_ordbk.c_xchng_ack[0], 
           ptr_st_spd_ord_res->st_res_dtls[0].c_xchng_ack );
	strcpy ( st_spd_ordbk.c_pipe_id[0], c_pipe_id );
	fn_cpy_ddr(st_spd_ordbk.c_rout_crt);
 	st_spd_ordbk.c_rqst_typ[0] = ACK_TO_ORD;
	i_ch_val = fn_call_svc ( c_ServiceName,
  												 c_err_msg,
													 &st_spd_ordbk,
													 &st_spd_ordbk,
													 "vw_spdordbk",
													 "vw_spdordbk",
													 sizeof ( st_spd_ordbk ),
													 sizeof ( st_spd_ordbk ),
													 0,
													 "SFO_QRY_SPDBK" );
	if ( i_ch_val != SUCC_BFR )
	{
		fn_errlog(c_ServiceName,"S31415", LIBMSG, c_err_msg);
		return -1;
	}

  i_trnsctn = fn_begintran(c_ServiceName, c_err_msg );
	if ( i_trnsctn == -1)
	{
		fn_errlog(c_ServiceName,"S31420", LIBMSG, c_err_msg);
		return -1;
	}

	for ( i_cnt=0; i_cnt<i_rec_cnt; i_cnt++ )
	{
		strcpy ( st_i_ordrbk.c_ordr_rfrnc, st_spd_ordbk.c_ordr_rfrnc[i_cnt] );
		strcpy ( ptr_st_spd_ord_res->st_res_dtls[i_cnt].c_ordr_rfrnc, st_spd_ordbk.c_ordr_rfrnc[i_cnt] );   /*Ver1.2*/
		fn_cpy_ddr(st_i_ordrbk.c_rout_crt);
  	st_i_ordrbk.c_oprn_typ = FOR_VIEW;
		i_ch_val = fn_call_svc ( c_ServiceName,
	  												 c_err_msg,
														 &st_i_ordrbk,
														 &st_i_ordrbk,
														 "vw_orderbook",
														 "vw_orderbook",
														 sizeof ( st_i_ordrbk ),
														 sizeof ( st_i_ordrbk ),
														 0,
														 "SFO_REF_TO_ORD" );
		if ( i_ch_val != SUCC_BFR )
		{
			fn_errlog(c_ServiceName,"S31425", LIBMSG, c_err_msg);
    	fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /* ver 1.3 */
			return -1;
		}
		strcpy(c_mtch_accnt, st_i_ordrbk.c_cln_mtch_accnt);     /*Ver 1.2*/

		strcpy ( st_i_xchngbk.c_ordr_rfrnc , st_i_ordrbk.c_ordr_rfrnc );
		strcpy ( st_i_xchngbk.c_xchng_cd , st_i_ordrbk.c_xchng_cd );
		strcpy ( st_i_xchngbk.c_pipe_id , st_i_ordrbk.c_pipe_id );
		strcpy ( st_i_xchngbk.c_mod_trd_dt , ( char * )c_trd_dt.arr );
		st_i_xchngbk.l_ord_tot_qty = st_i_ordrbk.l_ord_tot_qty;
		st_i_xchngbk.l_ord_lmt_rt = st_i_ordrbk.l_ord_lmt_rt;
		st_i_xchngbk.l_ord_seq = 0;
		st_i_xchngbk.l_mdfctn_cntr = EXPIRY_MDFCTN_CNTR;
		strcpy ( st_i_xchngbk.c_ack_tm , 
	           ptr_st_spd_ord_res->st_res_dtls[i_cnt].c_ack_tm );
		st_i_xchngbk.c_plcd_stts = CANCELLED;
		st_i_xchngbk.c_rms_prcsd_flg = NOT_PROCESSED;
		st_i_xchngbk.l_ors_msg_typ = 
	      ptr_st_spd_ord_res->st_res_dtls[i_cnt].li_ors_msg_typ;
		strcpy ( st_i_xchngbk.c_xchng_rmrks , 
	           ptr_st_spd_ord_res->st_res_dtls[i_cnt].c_xchng_rmrks );
		st_i_xchngbk.d_jiffy = 
	        (double) ptr_st_spd_ord_res->st_res_dtls[i_cnt].ll_log_tm_stmp;
		st_i_xchngbk.l_dwnld_flg = 
	            ptr_st_spd_ord_res->st_res_dtls[i_cnt].i_retrans_flag;
		fn_cpy_ddr(st_i_xchngbk.c_rout_crt);
		st_i_xchngbk.c_oprn_typ = INSERTION_ON_ORDER_FTE;
		
		i_ch_val = fn_call_svc ( c_ServiceName,
														 c_err_msg,
														 &st_i_xchngbk,
														 &st_i_xchngbk,
														 "vw_xchngbook",
														 "vw_xchngbook",
														 sizeof ( st_i_xchngbk ),
														 sizeof ( st_i_xchngbk ),
														 0,
														 "SFO_UPD_XCHNGBK" );
		if ( ( i_ch_val != SUCC_BFR ) &&
	       ( i_ch_val != RECORD_ALREADY_PRCSD ) )
		{
			fn_errlog(c_ServiceName,"S31430", LIBMSG, c_err_msg);
			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
			return -1;
		}
		else if ( i_ch_val == RECORD_ALREADY_PRCSD )
		{
	  	/** Increment the counter by one. **/
	  	if( ( fn_set_cntr ( i_tmp_cntr,
	                      	c_ServiceName,
	                      	c_err_msg)      )== -1)
	  	{
	    	/** on error, log the error and return -1; **/
	    	fn_errlog(c_ServiceName, "S31435", LIBMSG, c_err_msg);
    		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /* ver 1.3 */
	    	return -1;
	  	}
	
		  /***Update the order reference number and modification counter in SHM ***/
		  sprintf(c_refack_tmp, "%s - %ld", 
							ptr_st_spd_ord_res->st_res_dtls[0].c_xchng_ack, li_msg_typ);
		  if( ( fn_set_ref_ack_dtls ( c_refack_tmp,
		                              ORD_RES,
		                              c_ServiceName,
		                              c_err_msg)      )== -1)
		  {
		    /** on error, log the error and return -1; **/
		    fn_errlog(c_ServiceName, "S31440", LIBMSG, c_err_msg);
    		fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /* ver 1.3 */
		    return -1;
		  }

			fn_userlog ( c_ServiceName, "Record already processed" );
			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
			return 0;
		}

	/** st_spd_xchbk to be initialised here **/
    strcpy ( st_spd_xchbk.c_xchng_cd[i_cnt], st_i_xchngbk.c_xchng_cd );
    strcpy ( st_spd_xchbk.c_ordr_rfrnc[i_cnt], st_i_xchngbk.c_ordr_rfrnc );
    strcpy ( st_spd_xchbk.c_pipe_id[i_cnt], st_i_xchngbk.c_pipe_id );
    strcpy ( st_spd_xchbk.c_mod_trd_dt[i_cnt], st_i_xchngbk.c_mod_trd_dt );
    st_spd_xchbk.l_ord_seq[i_cnt] = st_i_xchngbk.l_ord_seq;
    st_spd_xchbk.c_slm_flg[i_cnt] = st_i_xchngbk.c_slm_flg;
    st_spd_xchbk.l_dsclsd_qty[i_cnt] = st_i_xchngbk.l_dsclsd_qty;
    st_spd_xchbk.l_ord_tot_qty[i_cnt] = st_i_xchngbk.l_ord_tot_qty;
    st_spd_xchbk.l_ord_lmt_rt[i_cnt] = st_i_xchngbk.l_ord_lmt_rt;
    st_spd_xchbk.l_stp_lss_tgr[i_cnt] = st_i_xchngbk.l_stp_lss_tgr;
    st_spd_xchbk.l_mdfctn_cntr[i_cnt] = st_i_xchngbk.l_mdfctn_cntr;
    strcpy ( st_spd_xchbk.c_valid_dt[i_cnt], st_i_xchngbk.c_valid_dt );
    st_spd_xchbk.c_ord_typ[i_cnt] = st_i_xchngbk.c_ord_typ;
    st_spd_xchbk.c_sprd_ord_ind[i_cnt] = st_i_xchngbk.c_sprd_ord_ind;
    st_spd_xchbk.c_req_typ[i_cnt] = st_i_xchngbk.c_req_typ;
    st_spd_xchbk.l_quote[i_cnt] = st_i_xchngbk.l_quote;
    strcpy ( st_spd_xchbk.c_qt_tm[i_cnt], st_i_xchngbk.c_qt_tm );
    strcpy ( st_spd_xchbk.c_rqst_tm[i_cnt], st_i_xchngbk.c_rqst_tm );
    strcpy ( st_spd_xchbk.c_frwrd_tm[i_cnt], st_i_xchngbk.c_frwrd_tm );
    st_spd_xchbk.c_plcd_stts[i_cnt] = st_i_xchngbk.c_plcd_stts;
    st_spd_xchbk.c_rms_prcsd_flg[i_cnt] = st_i_xchngbk.c_rms_prcsd_flg;
    strcpy ( st_spd_xchbk.c_ack_tm[i_cnt], st_i_xchngbk.c_ack_tm );
    strcpy ( st_spd_xchbk.c_xchng_rmrks[i_cnt], st_i_xchngbk.c_xchng_rmrks );
    st_spd_xchbk.c_ex_ordr_typ[i_cnt] = st_i_xchngbk.c_ex_ordr_typ;
    st_spd_xchbk.l_xchng_can_qty[i_cnt] = 
            ptr_st_spd_ord_res->st_res_dtls[i_cnt].l_xchng_can_qty;
    st_spd_xchbk.l_bit_flg[i_cnt] = st_i_xchngbk.l_bit_flg;
    st_spd_xchbk.c_spl_flg[i_cnt] = st_i_xchngbk.c_spl_flg;
    st_spd_xchbk.c_ordr_flw[i_cnt] = st_i_xchngbk.c_ordr_flw;
    st_spd_xchbk.c_oprn_typ[i_cnt] = st_i_xchngbk.c_oprn_typ;
		st_spd_xchbk.l_ors_msg_typ[i_cnt] = st_i_xchngbk.l_ors_msg_typ; 
    st_spd_xchbk.d_jiffy[i_cnt] = st_i_xchngbk.d_jiffy;
    st_spd_xchbk.l_dwnld_flg[i_cnt] = st_i_xchngbk.l_dwnld_flg;
    strcpy ( st_spd_xchbk.c_entry_dt_tm[i_cnt], st_i_xchngbk.c_entry_dt_tm );

		/*** Inspite the name is l_xchng_can_qty, it contains executed qty ***/
		/*** This name is little bit misleading 													 ***/
		st_spd_ordbk.l_exctd_qty[i_cnt] = 
       ptr_st_spd_ord_res->st_res_dtls[i_cnt].l_xchng_can_qty;
		st_spd_ordbk.l_can_qty[i_cnt] = 
       st_spd_ordbk.l_ord_tot_qty[i_cnt] -
       ptr_st_spd_ord_res->st_res_dtls[i_cnt].l_xchng_can_qty;

	}

	fn_cpy_ddr(st_spd_ordbk.c_rout_crt);
	st_spd_ordbk.c_rqst_typ[0] = UPDATE_XCHNG_RESPONSE_RC;
	
  i_ch_val = fn_call_svc ( c_ServiceName,
                           c_err_msg,
                           &st_spd_ordbk,
                           &st_spd_ordbk,
                           "vw_spdordbk",
                           "vw_spdordbk",
                           sizeof ( st_spd_ordbk ),
                           sizeof ( st_spd_ordbk ),
                           0,
                           "SFO_UPD_SPDBK" );
	if ( i_ch_val != SUCC_BFR )
	{
		fn_errlog(c_ServiceName,"S31445", LIBMSG, c_err_msg);
		fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
		return -1;
	}

	i_ch_val = fn_committran (c_ServiceName, i_trnsctn, c_err_msg);
	if ( i_ch_val == -1 )
	{
		fn_errlog(c_ServiceName,"S31450", LIBMSG, c_err_msg);
		return -1;
	}
	fn_cpy_ddr(st_spd_xchbk.c_rout_crt);

	i_ch_val = fn_acall_svc ( c_ServiceName,
														c_err_msg,
														&st_spd_xchbk,
														"vw_spdxchbk",
														sizeof ( st_spd_xchbk ),
														TPNOREPLY,
														"SFO_SPD_ACK" );
	if ( i_ch_val != 0 )
	{
		fn_errlog(c_ServiceName,"S31455", LIBMSG, c_err_msg);
		return -1;
	}

  /** Increment the counter by one. **/
  if( ( fn_set_cntr ( i_tmp_cntr,
                      c_ServiceName,
                      c_err_msg)      )== -1)
  {
    /** on error, log the error and return -1; **/
    fn_errlog(c_ServiceName, "S31460", LIBMSG, c_err_msg);
    return -1;
  }

  /*** Update the order reference number and modification counter in SHM ***/
  sprintf(c_refack_tmp, "%s - %ld", 
					ptr_st_spd_ord_res->st_res_dtls[0].c_xchng_ack, li_msg_typ);
  if( ( fn_set_ref_ack_dtls ( c_refack_tmp,
                              ORD_RES,
                              c_ServiceName,
                              c_err_msg)      )== -1)
  {
    /** on error, log the error and return -1; **/
    fn_errlog(c_ServiceName, "S31465", LIBMSG, c_err_msg);
    return -1;
  }

  /***** Commented in ver 1.7 ******

  *** Added in ver 1.5 ***

  for(i_cnt=0; i_cnt < i_rec_cnt; i_cnt++)
  {
    memset(c_temp, 0, MAXDATA);
    sprintf(c_temp, "%d,%ld,%s,%s,%s, %ld,%s,%ld,%ld,%ld,%d",
																					 FNO_EXCH,
                                           li_msg_typ,
                                           ptr_st_spd_ord_res->st_res_dtls[i_cnt].c_ordr_rfrnc,
                                           c_mtch_accnt,
                                           ptr_st_spd_ord_res->st_res_dtls[i_cnt].c_xchng_ack,
                                           st_spd_xchbk.c_ack_tm[i_cnt],
                                           ptr_st_spd_ord_res->st_res_dtls[i_cnt].c_xchng_rmrks,
                                           ptr_st_spd_ord_res->st_res_dtls[i_cnt].l_ord_tot_qty,
                                           ptr_st_spd_ord_res->st_res_dtls[i_cnt].l_ord_lmt_rt,
                                           ptr_st_spd_ord_res->st_res_dtls[i_cnt].l_mdfctn_cntr,
                                           ptr_st_spd_ord_res->st_res_dtls[i_cnt].i_retrans_flag
                                           );
    	fn_snd_dtq();
  }
  *** End of Add ver 1.5 ***

  *** End of Comment in ver 1.7 ***/ 

	return 0;
}

/******************************************************************************/
/*	To update details about trade confirmation 																*/
/*	INPUT PARAMETERS																													*/
/*			rcv_q_msg			- Pointer to a message structure got from receive 			*/
/*											message queue.																				*/
/*			c_pipe_id			- Pipe ID																								*/
/*			c_ServiceName - Service Name currently running												*/
/*			c_err_msg			-	Error message to be returned													*/
/*	OUTPUT PARAMETERS																													*/
/*				0		-	Success																												*/
/*				-1	-	Failure																												*/
/******************************************************************************/
int fn_trd_conf ( msg_trd_conf *ptr_st_tconf, 
                  char *c_pipe_id,
								  char *c_ServiceName, 
                  char *c_err_msg)
{
	int i_trnsctn;
	int i_ch_val;

	struct vw_orderbook st_i_ordbk;
	struct vw_tradebook st_i_trdbk;
	struct vw_sequence st_seq;
  struct vw_contract st_cntrct;

	char c_svc_name [ 16 ];
	char c_refack_tmp[LEN_ORD_REFACK];


	 int i2,i3 =0 ;		/*1.2*/
   char rfrnc[19],c_date[5] ;		/*1.2*/
   char ack[LEN_XCHNG_ACK];    /** Changed from size 16 to size 17 in ver 1.8 **/
	
  i_trnsctn = fn_begintran(c_ServiceName, c_err_msg );
  if ( i_trnsctn == -1)
  {
		fn_errlog(c_ServiceName,"S31470", LIBMSG, c_err_msg);
    return -1;
  }
/*Added by Sangeet*/
if(DEBUG_MSG_LVL_3)
{
	fn_userlog(c_ServiceName,"The ACK for fn_trd_conf is :%s:",ptr_st_tconf->c_ord_ack );
}

	strcpy ( st_i_ordbk.c_xchng_ack , ptr_st_tconf->c_ord_ack );
	strcpy ( st_i_ordbk.c_pipe_id , c_pipe_id );
	fn_cpy_ddr(st_i_ordbk.c_rout_crt);
  st_i_ordbk.c_oprn_typ = FOR_VIEW;
	
	i_ch_val = fn_call_svc ( c_ServiceName,
														c_err_msg,
														&st_i_ordbk,
														&st_i_ordbk,
														"vw_orderbook",
														"vw_orderbook",
														sizeof ( st_i_ordbk ),
														sizeof ( st_i_ordbk ),
														0,
														"SFO_ACK_TO_ORD" );
	if ( i_ch_val != SUCC_BFR )
	{
		if ( i_ch_val == TOO_MANY_ROWS_FETCHED )
		{
			if ( strcmp ( c_xchng_cd, "NFO" ) == 0 )
			{
				i_ch_val = fn_nse_to_eba_tkn ( ptr_st_tconf->l_token_id,
                                       &st_cntrct,
                                       c_ServiceName,
                                       c_err_msg );
				if ( i_ch_val != 0 )
				{
    			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /* ver 1.3 */
					fn_errlog(c_ServiceName,"S31475", LIBMSG, c_err_msg);
					return -1;
				}
				strcpy ( st_i_ordbk.c_xchng_cd, st_cntrct.c_xchng_cd );
				st_i_ordbk.c_prd_typ = st_cntrct.c_prd_typ;
				strcpy ( st_i_ordbk.c_expry_dt, st_cntrct.c_expry_dt );
				st_i_ordbk.c_exrc_typ = st_cntrct.c_exrc_typ;
				st_i_ordbk.c_opt_typ = st_cntrct.c_opt_typ;
				st_i_ordbk.l_strike_prc = st_cntrct.l_strike_prc;
				st_i_ordbk.c_ctgry_indstk = st_cntrct.c_ctgry_indstk;
				strcpy ( st_i_ordbk.c_undrlyng, st_cntrct.c_undrlyng );
				st_i_ordbk.l_ca_lvl = st_cntrct.l_ca_lvl;
				strcpy ( st_i_ordbk.c_xchng_ack , ptr_st_tconf->c_ord_ack );
				strcpy ( st_i_ordbk.c_pipe_id , c_pipe_id );
				fn_cpy_ddr(st_i_ordbk.c_rout_crt);
  		  st_i_ordbk.c_oprn_typ = FOR_VIEW;
				i_ch_val = fn_call_svc ( c_ServiceName,
														     c_err_msg,
														     &st_i_ordbk,
														     &st_i_ordbk,
														     "vw_orderbook",
														     "vw_orderbook",
														     sizeof ( st_i_ordbk ),
														     sizeof ( st_i_ordbk ),
														     0,
														     "SFO_AC_TO_ORD" );
				if ( i_ch_val != SUCC_BFR )
				{
					fn_errlog(c_ServiceName,"S31480", LIBMSG, c_err_msg);
    			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /* ver 1.3 */
					return -1;
				}
			}
			else
			{
				fn_errlog(c_ServiceName,"S31485", "Logic error", c_err_msg);
   			fn_aborttran( c_ServiceName, i_trnsctn, c_err_msg ); /* ver 1.3 */
				return -1;
			}
		}
		else
		{
			fn_errlog(c_ServiceName,"S31490", LIBMSG, c_err_msg);
			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
			/*return -1; */ /*ver 1.3 */
			return 0 ; 
		}
	}

	strcpy ( st_seq.c_pipe_id, st_i_ordbk.c_pipe_id );
	strcpy ( st_seq.c_trd_dt, ( char * )c_trd_dt.arr );
	fn_cpy_ddr(st_seq.c_rout_crt);
	st_seq.c_rqst_typ = GET_TRD_SEQ;
	i_ch_val = fn_call_svc ( c_ServiceName,
                           c_err_msg,
                           &st_seq,
                           &st_seq,
                           "vw_sequence",
                           "vw_sequence",
                           sizeof ( st_seq ),
                           sizeof ( st_seq ),
                           0,
                           "SFO_GET_SEQ" );
	if ( i_ch_val != SUCC_BFR )
	{
		fn_errlog(c_ServiceName,"S31495", LIBMSG, c_err_msg);
		fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
		return -1;
	}

	sprintf ( st_i_trdbk.c_trd_rfrnc, "%s%s%08ld", 
            ( char * )c_trd_ref.arr, c_pipe_id, st_seq.l_seq_num ); 
	strcpy ( st_i_trdbk.c_cln_mtch_accnt , st_i_ordbk.c_cln_mtch_accnt );
	strcpy ( c_mtch_accnt , st_i_ordbk.c_cln_mtch_accnt );									/*ver 1.2*/
	strcpy ( st_i_trdbk.c_xchng_cd , st_i_ordbk.c_xchng_cd );
	st_i_trdbk.c_prd_typ = st_i_ordbk.c_prd_typ;
	strcpy ( st_i_trdbk.c_undrlyng , st_i_ordbk.c_undrlyng );
	strcpy ( st_i_trdbk.c_expry_dt , st_i_ordbk.c_expry_dt );
	st_i_trdbk.c_exrc_typ = st_i_ordbk.c_exrc_typ;
	st_i_trdbk.c_opt_typ = st_i_ordbk.c_opt_typ;
	st_i_trdbk.l_strike_prc = st_i_ordbk.l_strike_prc;
	st_i_trdbk.c_ctgry_indstk = st_i_ordbk.c_ctgry_indstk;
	strcpy ( st_i_trdbk.c_ordr_rfrnc , st_i_ordbk.c_ordr_rfrnc );
	strcpy ( st_i_trdbk.c_xchng_ack , st_i_ordbk.c_xchng_ack );
	st_i_trdbk.l_xchng_trd_no = ( long )ptr_st_tconf->d_trd_ack;				
	strcpy ( st_i_trdbk.c_trd_dt , ptr_st_tconf->c_exctd_tm );
	st_i_trdbk.c_trd_flw = st_i_ordbk.c_ordr_flw;
	st_i_trdbk.l_exctd_qty = ptr_st_tconf->li_exctd_qty;
	st_i_trdbk.l_exctd_rt = ptr_st_tconf->li_exctd_rt;
	st_i_trdbk.d_jiffy = (double) ptr_st_tconf->ll_log_tm_stmp;
	st_i_trdbk.l_dwnld_flg = ptr_st_tconf->i_retrans_flag;
	fn_cpy_ddr(st_i_trdbk.c_rout_crt);

	strcpy(rfrnc,st_i_ordbk.c_ordr_rfrnc);				/*1.2*/
	strcpy(ack,st_i_ordbk.c_xchng_ack);				    /*1.2*/
  strcpy(st_i_trdbk.c_user_id,st_i_ordbk.c_user_id);                      /***** VER 1.7  *******/
  fn_userlog(c_ServiceName,"USER ID IS  :%s:",st_i_trdbk.c_user_id);      /***** VER 1.7  *******/
  fn_userlog(c_ServiceName,"CALLING SFO_UPD_TRDBK");                      /***** VER 1.7  *******/
	st_i_trdbk.c_oprn_typ = INSERT_TRADE_CONF;
	
	i_ch_val = fn_call_svc ( c_ServiceName,
														c_err_msg,
														&st_i_trdbk,
														&st_i_trdbk,
														"vw_tradebook",
														"vw_tradebook",
														sizeof ( st_i_trdbk ),
														sizeof ( st_i_trdbk ),
														0,
														"SFO_UPD_TRDBK" );
	if ( ( i_ch_val != SUCC_BFR ) &&
       ( i_ch_val != RECORD_ALREADY_PRCSD ) )
	{
		fn_errlog(c_ServiceName,"S31500", LIBMSG, c_err_msg);
		fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
		return -1;
	}
	else if ( i_ch_val == RECORD_ALREADY_PRCSD )
	{
		fn_userlog ( c_ServiceName, "Record already processed" );
  	if( ( fn_set_cntr ( TRD_CNFRM_CNTR,
                      	c_ServiceName,
                      	c_err_msg)      )== -1)
  	{
    	/** on error, log the error and return -1; **/
    	fn_errlog(c_ServiceName, "S31505", LIBMSG, c_err_msg);
			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg); /* ver 1.3 */
    	return -1;
  	}
	  /*** Update the order reference number and modification counter in SHM ***/
	  sprintf(c_refack_tmp, "%s - %ld", ptr_st_tconf->c_ord_ack, ORS_TRD_CONF);
	  if( ( fn_set_ref_ack_dtls ( c_refack_tmp,
	                              ORD_RES,
	                              c_ServiceName,
	                              c_err_msg)      )== -1)
	  {
	    /** on error, log the error and return -1; **/
	    fn_errlog(c_ServiceName, "S31510", LIBMSG, c_err_msg);
			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg); /* ver 1.3 */
	    return -1;
	  }

		fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
		return 0;
	}
	
	i_ch_val = fn_committran (c_ServiceName, i_trnsctn, c_err_msg);
	if ( i_ch_val == -1 )
	{
		fn_errlog(c_ServiceName,"S31515", LIBMSG, c_err_msg);
		return -1;
	}

	if ( st_i_trdbk.c_prd_typ == OPTIONS ||  st_i_trdbk.c_prd_typ == OPTIONPLUS )	/*** OPTIONPLUS added in Ver 2.2 ***/
	{
		strcpy ( c_svc_name , "SFO_OPT_TCONF" );
	}
	/*** else if ( st_i_trdbk.c_prd_typ == FUTURES || st_i_trdbk.c_prd_typ == FUTURE_PLUS  ) *Ver 2.0* Commented in Ver 2.1 ***/
	else if ( st_i_trdbk.c_prd_typ == FUTURES || st_i_trdbk.c_prd_typ == FUTURE_PLUS || st_i_trdbk.c_prd_typ == SLTP_FUTUREPLUS  ) /*** Ver 2.1 ***/
  {
		strcpy ( c_svc_name , "SFO_FUT_TCONF" );
  }
	fn_cpy_ddr(st_i_trdbk.c_rout_crt);
	
	i_ch_val = fn_acall_svc ( c_ServiceName,
														c_err_msg,
														&st_i_trdbk,
														"vw_tradebook",
														sizeof ( st_i_trdbk ),
														TPNOREPLY,
														c_svc_name );
	if ( i_ch_val != 0 )
	{
		fn_errlog(c_ServiceName,"S31520", LIBMSG, c_err_msg);
		/*return -1; */
 } 

	fn_userlog(c_ServiceName, "After fut/opt tconf");
  if( ( fn_set_cntr ( TRD_CNFRM_CNTR,
                      c_ServiceName,
                      c_err_msg)      )== -1)
  {
    /** on error, log the error and return -1; **/
    fn_errlog(c_ServiceName, "S31525", LIBMSG, c_err_msg);
    return -1;
  }

  /*** Update the order reference number and modification counter in SHM ***/
  sprintf(c_refack_tmp, "%s - %ld", ptr_st_tconf->c_ord_ack, ORS_TRD_CONF);
  if( ( fn_set_ref_ack_dtls ( c_refack_tmp,
                              ORD_RES,
                              c_ServiceName,
                              c_err_msg)      )== -1)
  {
    /** on error, log the error and return -1; **/
    fn_errlog(c_ServiceName, "S31530", LIBMSG, c_err_msg);
    return -1;
  }

	strncpy(c_date,rfrnc,5);											/*1.2*/
	ptr_st_tconf->l_token_id  = atol(c_date);			/*1.2*/

	for(i2=4; i2<=17; i2++)												/*1.2*/
  {
      ptr_st_tconf->c_ord_ack[i3] = rfrnc[i2] ;
      i3++ ;
  }

	ptr_st_tconf->c_ord_ack[i3] = 0;	/*Added in Ver 1.4*/

	fn_userlog(c_ServiceName, "Before snd_dtq in tconf");

  /***** Commented in ver 1.7 ******

	*** Added in Ver 1.5 ***

	memset(c_temp, 0, MAXDATA);
  sprintf(c_temp, "%d,%ld,%s,%s,%ld,%s,%ld,%ld" ,FNO_EXCH,
																							   ORS_TRD_CONF,
																								 rfrnc,
																								 c_mtch_accnt,
																								 st_i_trdbk.l_xchng_trd_no,
																								 ptr_st_tconf->c_exctd_tm,
																								 ptr_st_tconf->li_exctd_qty,
																								 ptr_st_tconf->li_exctd_rt 
																								 );
	fn_userlog(c_ServiceName, "||||%s||||", c_temp);
    fn_snd_dtq();

  ******* End of Add ver 1.5 *******

  *** End of Comment in ver 1.7 ***/

		return 0;
}

int fn_nse_to_eba_tkn ( long int li_tkn,
                        struct vw_contract *ptr_cntrct,
                        char *c_ServiceName,
                        char *c_err_msg )
{
  struct vw_nse_cntrct st_nse_dtls;
  int i_ch_val;

  st_nse_dtls.l_token_id =  li_tkn;
	fn_cpy_ddr(st_nse_dtls.c_rout_crt);
  st_nse_dtls.c_rqst_typ = NSE_TOKEN_TO_CONTRACT;
  i_ch_val = fn_call_svc ( c_ServiceName,
                           c_err_msg,
                           &st_nse_dtls,
                           ptr_cntrct,
                           "vw_nse_cntrct",
                           "vw_contract",
                           sizeof (st_nse_dtls),
                           sizeof (struct vw_contract),
                           0,
                           "SFO_CNT_FOR_ENT" );
  if ( i_ch_val != SUCC_BFR )
  {
    fn_errlog ( c_ServiceName, "S31535", LIBMSG, c_err_msg );
    fn_userlog ( c_ServiceName, "Token id |%ld|", li_tkn );
    return i_ch_val;
  }

  return 0;
}

/******************************************************************************/
/*	To update details about canceled details of IOC orders  									*/
/*	INPUT PARAMETERS																													*/
/*			rcv_q_msg			- Pointer to a message structure got from receive 			*/
/*											message queue.																				*/
/*			c_pipe_id			- Pipe ID																								*/
/*			c_ServiceName - Service Name currently running												*/
/*			c_err_msg			-	Error message to be returned													*/
/*	OUTPUT PARAMETERS																													*/
/*				0		-	Success																												*/
/*				-1	-	Failure																												*/
/******************************************************************************/
int fn_ioc_can ( msg_ioc_can_dtls *ptr_ioc_res_dtls,
								 long int li_msg_typ,
                 char *c_pipe_id, 
                 char *c_ServiceName, 
								 char *c_err_msg)
{
	int i_trnsctn;
	int i_ch_val;

	struct vw_xchngbook st_i_xchngbk;
	struct vw_orderbook st_i_ordbk;
  struct vw_contract st_cntrct;

	char c_svc_name [ 16 ];
	char c_refack_tmp[LEN_ORD_REFACK];
/*Added by Sangeet*/
if(DEBUG_MSG_LVL_3)
{
	fn_userlog(c_ServiceName,"The ACK for fn_ioc_can is :%s:",ptr_ioc_res_dtls->st_res_dtls.c_xchng_ack );
}

	strcpy ( st_i_ordbk.c_xchng_ack , ptr_ioc_res_dtls->st_res_dtls.c_xchng_ack );
	strcpy ( st_i_ordbk.c_pipe_id , c_pipe_id );
	fn_cpy_ddr(st_i_ordbk.c_rout_crt);
  st_i_ordbk.c_oprn_typ = FOR_VIEW;
	
	i_ch_val = fn_call_svc ( c_ServiceName,
													 c_err_msg,
													 &st_i_ordbk,
													 &st_i_ordbk,
													 "vw_orderbook",
													 "vw_orderbook",
													 sizeof ( st_i_ordbk ),
													 sizeof ( st_i_ordbk ),
													 0,
													 "SFO_ACK_TO_ORD" );
	if ( i_ch_val != SUCC_BFR )
	{
		if ( i_ch_val == TOO_MANY_ROWS_FETCHED )
		{
			if ( strcmp ( c_xchng_cd, "NFO" ) == 0 )
			{
				i_ch_val = fn_nse_to_eba_tkn ( ptr_ioc_res_dtls->l_token_id,
                                       &st_cntrct,
                                       c_ServiceName,
                                       c_err_msg );
				if ( i_ch_val != 0 )
				{
					return -1;
				}
				strcpy ( st_i_ordbk.c_xchng_cd, st_cntrct.c_xchng_cd );
				st_i_ordbk.c_prd_typ = st_cntrct.c_prd_typ;
				strcpy ( st_i_ordbk.c_expry_dt, st_cntrct.c_expry_dt );
				st_i_ordbk.c_exrc_typ = st_cntrct.c_exrc_typ;
				st_i_ordbk.c_opt_typ = st_cntrct.c_opt_typ;
				st_i_ordbk.l_strike_prc = st_cntrct.l_strike_prc;
				st_i_ordbk.c_ctgry_indstk = st_cntrct.c_ctgry_indstk;
				strcpy ( st_i_ordbk.c_undrlyng, st_cntrct.c_undrlyng );
				st_i_ordbk.l_ca_lvl = st_cntrct.l_ca_lvl;
				strcpy ( st_i_ordbk.c_xchng_ack , 
                 ptr_ioc_res_dtls->st_res_dtls.c_xchng_ack );
				strcpy ( st_i_ordbk.c_pipe_id , c_pipe_id );
				fn_cpy_ddr(st_i_ordbk.c_rout_crt);
  		  st_i_ordbk.c_oprn_typ = FOR_VIEW;
				i_ch_val = fn_call_svc ( c_ServiceName,
														     c_err_msg,
														     &st_i_ordbk,
														     &st_i_ordbk,
														     "vw_orderbook",
														     "vw_orderbook",
														     sizeof ( st_i_ordbk ),
														     sizeof ( st_i_ordbk ),
														     0,
														     "SFO_AC_TO_ORD" );
				if ( i_ch_val != SUCC_BFR )
				{
					fn_errlog(c_ServiceName,"S31540", LIBMSG, c_err_msg);
					return -1;
				}
				strcpy ( ptr_ioc_res_dtls->st_res_dtls.c_ordr_rfrnc,st_i_ordbk.c_ordr_rfrnc );  /*1.2*/
			}
			else
			{
				fn_errlog(c_ServiceName,"S31545", "Logic error", c_err_msg);
				return -1;
			}
		}
		else
		{
			fn_errlog(c_ServiceName,"S31550", LIBMSG, c_err_msg);
			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
			return -1;
		}
	}

	strcpy ( st_i_xchngbk.c_ordr_rfrnc , st_i_ordbk.c_ordr_rfrnc );
	strcpy ( st_i_xchngbk.c_xchng_cd , st_i_ordbk.c_xchng_cd );
	strcpy ( st_i_xchngbk.c_pipe_id , st_i_ordbk.c_pipe_id );
	strcpy ( st_i_xchngbk.c_mod_trd_dt , ( char * )c_trd_dt.arr );
	strcpy ( c_mtch_accnt , st_i_ordbk.c_cln_mtch_accnt );							/*Ver1.2*/	
	strcpy ( ptr_ioc_res_dtls->st_res_dtls.c_ordr_rfrnc,st_i_ordbk.c_ordr_rfrnc );  /*1.2*/
	st_i_xchngbk.l_ord_tot_qty = st_i_ordbk.l_ord_tot_qty;
	st_i_xchngbk.l_ord_lmt_rt = st_i_ordbk.l_ord_lmt_rt;
	st_i_xchngbk.l_ord_seq = 0;
	st_i_xchngbk.l_mdfctn_cntr = EXPIRY_MDFCTN_CNTR;
	strcpy ( st_i_xchngbk.c_ack_tm , 
           ptr_ioc_res_dtls->st_res_dtls.c_ack_tm );
	st_i_xchngbk.c_plcd_stts = CANCELLED;
	st_i_xchngbk.c_rms_prcsd_flg = NOT_PROCESSED;
	st_i_xchngbk.l_ors_msg_typ = 
         ptr_ioc_res_dtls->st_res_dtls.li_ors_msg_typ;
	strcpy ( st_i_xchngbk.c_xchng_rmrks , 
         ptr_ioc_res_dtls->st_res_dtls.c_xchng_rmrks );
	st_i_xchngbk.d_jiffy = 
         (double) ptr_ioc_res_dtls->st_res_dtls.ll_log_tm_stmp;
	st_i_xchngbk.l_dwnld_flg = 
         ptr_ioc_res_dtls->st_res_dtls.i_retrans_flag;
  st_i_xchngbk.l_xchng_can_qty = 
         ptr_ioc_res_dtls->st_res_dtls.l_xchng_can_qty;
	fn_cpy_ddr(st_i_xchngbk.c_rout_crt);
	st_i_xchngbk.c_oprn_typ = INSERTION_ON_ORDER_FTE;
	
  i_trnsctn = fn_begintran(c_ServiceName, c_err_msg );
  if ( i_trnsctn ==  -1 )
  {
		fn_errlog(c_ServiceName,"S31555", LIBMSG, c_err_msg);
    return -1;
  }

	i_ch_val = fn_call_svc ( c_ServiceName,
													 c_err_msg,
													 &st_i_xchngbk,
													 &st_i_xchngbk,
													 "vw_xchngbook",
													 "vw_xchngbook",
													 sizeof ( st_i_xchngbk ),
													 sizeof ( st_i_xchngbk ),
													 0,
													 "SFO_UPD_XCHNGBK" );
	if ( ( i_ch_val != SUCC_BFR ) &&
       ( i_ch_val != RECORD_ALREADY_PRCSD ) )
	{
		fn_errlog(c_ServiceName,"S31560", LIBMSG, c_err_msg);
		fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
		return -1;
	}
	else if ( i_ch_val == RECORD_ALREADY_PRCSD )
	{
  	/** Increment the counter by one. **/
  	if( ( fn_set_cntr ( CXL_ORDR_CNFRM_CNTR,
                      	c_ServiceName,
                      	c_err_msg)      )== -1)
  	{
    	/** on error, log the error and return -1; **/
    	fn_errlog(c_ServiceName, "S31565", LIBMSG, c_err_msg);
			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg); /* ver 1.3 */
    	return -1;
  	}

	  /*** Update the order reference number and modification counter in SHM ***/
		/*** v1.1  ***/
	  sprintf(c_refack_tmp, "%s - %ld", ptr_ioc_res_dtls->st_res_dtls.c_xchng_ack,
																ptr_ioc_res_dtls->st_res_dtls.li_ors_msg_typ);
		/*** v1.1  ***/

	  if( ( fn_set_ref_ack_dtls ( c_refack_tmp,
	                              ORD_RES,
	                              c_ServiceName,
	                              c_err_msg)      )== -1)
	  {
	    /** on error, log the error and return -1; **/
	    fn_errlog(c_ServiceName, "S31570", LIBMSG, c_err_msg);
			fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg); /* ver 1.3 */
	    return -1;
	  }

		fn_userlog ( c_ServiceName, "Record already processed" );
		fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
		return 0;
	}

	i_ch_val = fn_committran (c_ServiceName, i_trnsctn, c_err_msg);
	if ( i_ch_val == -1 )
	{
		fn_errlog(c_ServiceName,"S31575", LIBMSG, c_err_msg);
		return -1;
	}

	if ( st_i_ordbk.c_prd_typ == OPTIONS || st_i_ordbk.c_prd_typ == OPTIONPLUS )	/*** OPTIONPLUS added in Ver 2.2 ***/
	{
		strcpy ( c_svc_name , "SFO_OPT_ACK" );
	}
	/*** else if ( st_i_ordbk.c_prd_typ == FUTURES || st_i_ordbk.c_prd_typ == FUTURE_PLUS )	*Ver 2.0* Commented in ver 2.1 ***/
	else if ( st_i_ordbk.c_prd_typ == FUTURES || st_i_ordbk.c_prd_typ == FUTURE_PLUS || st_i_ordbk.c_prd_typ == SLTP_FUTUREPLUS )	/*** Ver 2.1 ***/
  {
		strcpy ( c_svc_name , "SFO_FUT_ACK" );
  }
	fn_cpy_ddr(st_i_xchngbk.c_rout_crt);

	i_ch_val = fn_acall_svc ( c_ServiceName,
														c_err_msg,
														&st_i_xchngbk,
														"vw_xchngbook",
														sizeof ( st_i_xchngbk ),
														TPNOREPLY,
														c_svc_name );
	if ( i_ch_val != SUCC_BFR )
	{
		fn_errlog(c_ServiceName,"S31580", LIBMSG, c_err_msg);
		return -1;
	}

  /** Increment the counter by one. **/
  if( ( fn_set_cntr ( CXL_ORDR_CNFRM_CNTR,
                      c_ServiceName,
                      c_err_msg)      )== -1)
  {
    /** on error, log the error and return -1; **/
    fn_errlog(c_ServiceName, "S31585", LIBMSG, c_err_msg);
    return -1;
  }

  /*** Update the order reference number and modification counter in SHM ***/
  sprintf(c_refack_tmp, "%s - %ld", ptr_ioc_res_dtls->st_res_dtls.c_xchng_ack, 
																		ORS_IOC_CAN_ACPT);
  if( ( fn_set_ref_ack_dtls ( c_refack_tmp,
                              ORD_RES,
                              c_ServiceName,
                              c_err_msg)      )== -1)
  {
    /** on error, log the error and return -1; **/
    fn_errlog(c_ServiceName, "S31590", LIBMSG, c_err_msg);
    return -1;
  }

  /***** Commented in ver 1.7 ******

  *** Added in ver 1.5 ***

	memset(c_temp, 0, MAXDATA);
	sprintf(c_temp, "%d,%ld,%s,%s,%s,%s,%s,%ld,%ld,%ld,%d", 
																					 FNO_EXCH,
                                           li_msg_typ,
                                           ptr_ioc_res_dtls->st_res_dtls.c_ordr_rfrnc,
                                           c_mtch_accnt,
                                           ptr_ioc_res_dtls->st_res_dtls.c_xchng_ack,
                                           st_i_xchngbk.c_ack_tm,
                                           ptr_ioc_res_dtls->st_res_dtls.c_xchng_rmrks,
                                           ptr_ioc_res_dtls->st_res_dtls.l_ord_tot_qty,
                                           ptr_ioc_res_dtls->st_res_dtls.l_ord_lmt_rt,
                                           ptr_ioc_res_dtls->st_res_dtls.l_mdfctn_cntr,
                                           ptr_ioc_res_dtls->st_res_dtls.i_retrans_flag
                                           );

	fn_snd_dtq();

	*** End of Add ver 1.5 ***

  *** End of Comment in ver 1.7 ***/

	return 0;
}

/*Ver 1.2 Function to send data to DT Queue*/
/*********** Commented in ver 1.5**********
void fn_snd_dtq(char *c_msg, long l_msgtyp, long l_msglen, int i_size)
{
	EBAFOExchPckt st_exchpckt;
	*****Commented in Ver 1.4
	EBAQueStruct	st_quepckt;*******
	FNOXchngQueStruct		st_quepckt;		*Added in Ver 1.4*

	memset(&st_exchpckt, 0, sizeof(st_exchpckt));		Changed in Ver 1.4 - '&' added*

	st_exchpckt.li_exch_msgtyp = l_msgtyp;
	******Commented in Ver 1.4
	st_exchpckt.li_exch_msglen = l_msglen;*******
	strcpy(st_exchpckt.c_mtch_accnt, c_mtch_accnt);
	*******Commented in Ver 1.4
	memcpy(st_exchpckt.c_exch_msg, c_msg, MAXDATA_FNO);********
	memcpy(st_exchpckt.c_exch_msg, c_msg, i_size);			*Added in Ver 1.4*

	memset(&st_quepckt, 0, sizeof(st_quepckt));		*Changed in Ver 1.4*
	memcpy(st_quepckt.c_message, (char *)&st_exchpckt, (i_size + 15));	*Changed in Ver 1.4*
	st_quepckt.l_msgtyp = htonl(NFO);
	sprintf(st_quepckt.c_msglen, "%d", (i_size + 15));			 *Added in Ver 1.4*

	if(fn_write_msg_q(i_qid, (void *)&st_quepckt, sizeof(st_quepckt), c_ServiceName, c_err_msg) == -1)
	{
		fn_errlog(c_ServiceName, "S31595", LIBMSG, c_err_msg);
	}
}********************************/

/***** Commented in ver 1.7 ****** 

*** Added in ver 1.5 ***

void fn_snd_dtq()
{
	EBAQueStruct		st_quepckt;	

	fn_userlog(c_ServiceName, "TGW status :%d: qid :%d:", i_tgw_stts, i_qid);

	if(i_tgw_stts == SND_TGW && i_qid != 0)
	{
		memset(&st_quepckt, 0, sizeof(st_quepckt));

		sprintf(st_quepckt.c_message, "%c%d,%s", 0x19, strlen(c_temp), c_temp);
  	st_quepckt.l_msgtyp = htonl(NFO);

  	if(fn_write_msg_q(i_qid, (void *)&st_quepckt, sizeof(st_quepckt), 
															c_ServiceName, c_err_msg) == -1)
  	{
    	fn_errlog(c_ServiceName, "S31600", LIBMSG, c_err_msg);
  	}
	}	
}

*** End Of Add ***

*** End of Comment in ver 1.7 ***/ 

/*****  Commented in ver 1.7 ****** 

*Ver 1.2*

int fn_tgw_stts(void)
{

  char  c_cmd_typ;
  char  c_pgm_name[33];
  char  c_mid[3];
  char  c_cmd_str[100];
  int   i_retval;
  long  l_bufflen;
  int   i_stts;

  FBFR32 *ptr_fml_Ibuffer;
  FBFR32 *ptr_fml_Obuffer;
	fn_userlog ( c_ServiceName, "Inside function fn_tgw_stts");

  ptr_fml_Ibuffer = (FBFR32 *)tpalloc("FML32", NULL, MIN_FML_BUF_LEN);
  if(ptr_fml_Ibuffer == NULL)
  {
    fn_errlog(c_ServiceName, "S31605", TPMSG, c_err_msg);
    return -1;
  }

  ptr_fml_Obuffer = (FBFR32 *)tpalloc("FML32", NULL, MIN_FML_BUF_LEN);
  if(ptr_fml_Obuffer == NULL)
  {
    fn_errlog(c_ServiceName, "S31610", TPMSG, c_err_msg);
    tpfree((char *)ptr_fml_Ibuffer);
    return -1;
  }

  **Find the status of the send TGW program**
  strcpy(c_pgm_name, "cln_snd_tgw");
  c_cmd_typ = CHK_STTS;
  strcpy(c_mid, "T3");

  if(Fadd32(ptr_fml_Ibuffer, FML_GMS_NM, (char *)c_pgm_name, 0) == -1)
  {
    fn_errlog(c_ServiceName, "S31615", FMLMSG, c_err_msg);
    tpfree((char *)ptr_fml_Ibuffer);
    tpfree((char *)ptr_fml_Obuffer);
    return -1;
  }

  if(Fadd32(ptr_fml_Ibuffer, FML_LM_FLG, (char *)&c_cmd_typ, 0) == -1)
  {
    fn_errlog(c_ServiceName, "S31620", FMLMSG, c_err_msg);
    tpfree((char *)ptr_fml_Ibuffer);
    tpfree((char *)ptr_fml_Obuffer);
    return -1;
  }

  if(Fadd32(ptr_fml_Ibuffer, FML_STATLIN, (char *)c_mid, 0) == -1)
  {
    fn_errlog(c_ServiceName, "S31625", FMLMSG, c_err_msg);
    tpfree((char *)ptr_fml_Ibuffer);
    tpfree((char *)ptr_fml_Obuffer);
    return -1;
  }

        if(DEBUG_MSG_LVL_3)
        {
					fn_userlog ( c_ServiceName, "Before calling SVC_CMD_TGW");
				}
  if(tpcall("SVC_CMD_TGW", (char *)ptr_fml_Ibuffer, 0, (char **)&ptr_fml_Obuffer,
                                      &l_bufflen, 0) == -1)
  {
    if(tperrno == TPESVCFAIL)
    {
      if(Fget32(ptr_fml_Obuffer, FML_ERR_MSG, 0, c_err_msg, 0 ) == -1)
      {
        fn_errlog(c_ServiceName, "S31630", FMLMSG, c_err_msg);
        tpfree((char *)ptr_fml_Ibuffer);
        tpfree((char *)ptr_fml_Obuffer);
        return -1;
      }
    }
    else
    {
      fn_errlog(c_ServiceName, "S31635", TPMSG, c_err_msg);
    }
    tpfree((char *)ptr_fml_Ibuffer);
    tpfree((char *)ptr_fml_Obuffer);
    return -1;
  }

  if(Fget32(ptr_fml_Obuffer, FML_ACTN_ID, 0, (char *)&i_stts, 0) == -1)
  {
    fn_errlog(c_ServiceName, "S31640", FMLMSG, c_err_msg);
    tpfree((char *)ptr_fml_Ibuffer);
    tpfree((char *)ptr_fml_Obuffer);
    return -1;
  }

if(DEBUG_MSG_LVL_3)
{
	fn_userlog ( c_ServiceName, "Status of TGW is %d", i_stts);
}

  if(i_stts == PGM_RUN)
  {
   if(DEBUG_MSG_LVL_3)
   {
	 	fn_userlog ( c_ServiceName, "Getting Message Queue Identifier");
	 }
    i_tgw_stts = SND_TGW;
    *Create the Message Q identifier*
    if(fn_crt_msg_q(&i_qid, i_key, CLIENT, c_ServiceName, c_err_msg) == -1)
    {
      fn_errlog(c_ServiceName,"S31645", c_err_msg, c_err_msg);
      return(-1);
    }
   if(DEBUG_MSG_LVL_3)
   {
		fn_userlog ( c_ServiceName, "i_qid after fn_crt_msg_q is  %d", i_qid);
	 }

  }
  else
  {
		fn_userlog ( c_ServiceName, "Starting TGW client");
    *Program is not running. Start it*
    sprintf(c_cmd_str, "nohup %s %s &", c_pgm_name, c_mid);
		fn_userlog ( c_ServiceName, "%s", c_cmd_str);
    system(c_cmd_str);
    i_qid = 0;
    i_tgw_stts = STP_TGW;
  }

  tpfree((char *)ptr_fml_Ibuffer);
  tpfree((char *)ptr_fml_Obuffer);
}
*******  ver 1.7 end of comment ****/ 

void fn_print_pckt(union un_res_msg rcv_q_msg, long l_msgtyp)
{
	msg_reqres_dtls *ptr;
		ptr = (msg_reqres_dtls *)&rcv_q_msg;
   if(DEBUG_MSG_LVL_3)
   {
		userlog("Order Reference |%s|\n", ptr->c_ordr_rfrnc);
		userlog("Trade Date |%s|\n", ptr->c_trd_dt);
		userlog("Order Sequence |%ld|\n", ptr->l_ord_seq);
		userlog("Exer Order type |%c|\n", ptr->c_ex_ordr_typ);
		userlog("Request type |%c|\n", ptr->c_req_typ);
		userlog("SLM type |%c|\n", ptr->c_slm_flg);
		userlog("Disc qty |%ld|\n", ptr->l_dsclsd_qty);
		userlog("Order qty |%ld|\n", ptr->l_ord_tot_qty);
		userlog("Order rate |%ld|\n", ptr->l_ord_lmt_rt);
		userlog("Trigger price |%ld|\n", ptr->l_stp_lss_tgr);
		userlog("Mod cntr |%ld|\n", ptr->l_mdfctn_cntr);
		userlog("Order Type |%c|\n", ptr->c_ord_typ);
		userlog("Valid date |%s|\n", ptr->c_valid_dt);
		userlog("Message type |%ld|\n", ptr->li_ors_msg_typ);
		userlog("exch can qty |%ld|\n", ptr->l_xchng_can_qty);
		userlog("Ack time	|%s|\n", ptr->c_ack_tm);
		userlog("Exchange Remarks |%s|\n", ptr->c_xchng_rmrks);
		userlog("Exchange ack |%s|\n", ptr->c_xchng_ack);
		userlog("Entry time |%s|\n", ptr->c_entry_dt_tm);
		userlog("last ack time |%s|\n", ptr->c_lst_ack_tm);
		userlog("retrans  flag |%d|\n", ptr->i_retrans_flag);
		userlog("timestamp |%lld|\n", ptr->ll_log_tm_stmp);
	}
		
}
