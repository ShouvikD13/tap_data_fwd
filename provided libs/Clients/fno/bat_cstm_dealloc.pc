/*******************************************************************************
*  Program           : bat_cstm_dealloc.pc                                     *
*                                                                              *
*  Description       : This Program checks whether a customer has a obligation *
*                      in equity, fno, mf or ipo. If yes,then it will return an*
*                      error code , else it will free up all the allocation by *
*                      calling the bank service.                               *
*                      CDS_PRCS_FLG                                            *
*                       N - Not yet processed                                  *
*                       S - Success in Deallocation                            *
*                       O - Obligation Pending                                 *
*                       E - Error in Deallocation                              *
*                       Records once processed will not be picked up again     *
*                                                                              *
*  Change Log        : 1.0   23-Sep-2009  Venture M|Infotech                   *
********************************************************************************
*  1.0    -  New Release                                                       *
*  1.1    -  View to FML Changes ( Sachin Birje )                              *
*  1.2    -  IBR product code changes ( Vishal Borhade )                       *
*  1.3    -  Changes for CR-ISEC03-118638_Migration_to_Deposit_Mode(Renuka)    *
*******************************************************************************/
                                                                                
/* Header Files */                                                              
                                                                                
#include<sqlca.h>
#include<atmi.h>
#include<string.h>     
#include<stdlib.h>     
#include<fo.h>
#include<fml32.h>
#include<fn_log.h>
#include<fn_tuxlib.h>
#include<fn_battmpt.h>
#include<fml_def.h>
#include<fo_fml_def.h>
#include<fn_ddr.h>
/** #include<fo_view_def.h> ** ver 1.1 **/
#include <fn_read_debug_lvl.h>  
#include "fml_rout.h"

/*--------------------------------------------------------------------------------*/

#define EQ_DEALC_FAILURE -2000
#define FO_DEALC_FAILURE -2001
#define MI_DEALC_FAILURE -2002
#define CDX_DEALC_FAILURE -2003  /* Ver 1.3 */
#define WTHDRAW_FAILURE  -2004  /* Ver 1.3 */

#define EQ_DEALC_SUCCESS 4000
#define FO_DEALC_SUCCESS 4001
#define MI_DEALC_SUCCESS 4002
#define CDX_DEALC_SUCCESS 4003   /* Ver 1.3 */

/*--------------------------------------------------------------------------------*/

int fn_check_eq_stts(long );

int fn_check_easymargin_open(long);

int fn_check_fo_stts(long);

int fn_check_futures_open(long);

int fn_check_options_open(long);

int fn_check_mf_stts(long);

/*int fn_check_ip_stts(long);   Ver 1.3 */
int fn_check_cdx_stts(long);   /* Ver 1.3 */
int fn_check_cdx_futures_open(long); /* Ver 1.3 */
int fn_check_cdx_options_open(long); /* Ver 1.3 */

int fn_deallocate_eq(long);

int fn_deallocate_fo(long);

int fn_deallocate_mfip(long);  /* Common for MF & IPO as per Zubin */ 
int fn_deallocate_cdx(long);   /* Ver 1.3 */ 

/*int fn_load_unprcsd_recs(void);    Ver 1.3 */

int fn_update_status(char *, long, char ,char *);

/******* Ver 1.3 starts ******/
#define DEALLOCATE_FROM_SEGMENT 'U'
#define WITHDRAW_FROM_WALLET 'W'
#define REDUCE_ONLY_WALLET 'R'       
#define FO_DEALLOCATE_FROM_SEGMENT 'D'       
#define CDX_DEALLOCATE_FROM_SEGMENT 'D'       
#define EQ 	'E'       
#define FNO 'F'       
#define CDX 'C'       
#define NEQ 'N'       
#define BLOCK_MODEL 'B'
#define DEPOSIT_MODEL 'D'

int fn_begin_trn_lock(long,int,char);
int fn_ins_mbs_commit(long,char,char);
int fn_lock_usr ( char c_ServiceName [ 33 ],char c_clm_mtch_accnt [ 10 + 1 ] );

int fn_ins_mbs(char *c_ServiceName,char *c_clnt_mtch_accnt,char *c_xchng_cd,char *c_prdct_cd,
               char *c_pipo_src,char *c_sgmnt_cd,long l_sttlmnt_nmbr,char *c_tran_date,
               double d_trn_amt,char *c_run_nmbr,char *c_instrument_nmbr,
               char c_instrument_typ,char *c_mdc_crdt_nmbr,char c_accntng_for,
               char *c_accntng_typ,char *c_bnk_trace_nmbr,char *c_bnk_accnt_nmbr,
               char *c_bnk_narr,char c_dbcr_flg,
               char *c_mtch_series,char *c_class_svc,char *c_src_rowid,char *c_err_msg, char c_blk_dep_flg);

int fn_ins_seg_log(char *,long,char *,char *,double,char,char *,double,char,char *,char *,long, char *,char *);

int fn_call_inc_dec_wallet(char,long);

int fn_ins_bft(char,long);
int fn_reduce_wallet(long,int,char);

char 	c_src_rowid[25];
char	c_blk_dep_flg;
int 	i_err_cd ;
long 	l_run_no;
/***** End of Ver 1.3 *******/

FBFR32  *ptr_fml_Sbuffer;     /* Pointer to FML send buffer  */
FBFR32  *ptr_fml_Rbuffer;     /* Pointer to FML receive buffer */
FBFR32  *ptr_fml_Ibuffer;     /* Pointer to FML input buffer  */
FBFR32  *ptr_fml_Obuffer;     /* Pointer to FML output buffer */

char c_user_id[9]={0};
char c_usr_id[100]={0};  
int  i_ferr[100]={0};
long l_session_id=0,l_rowcount=0;   
char i_err[100]={0};
char c_xchng_cd[4]={0};
char sql_uac_clm_mtch_accnt[21]={0};
char c_ServiceName[33]={0};
char c_err_msg[256]={0};
char c_msg[256]={0};
char c_trd_dt[23]={0};
char c_xchng_input[4]={'\0'};    /** Ver 1.2 **/
char c_CallServiceName[33];      /** Ver 1.3 **/

/************ Commented in ver 1.3 ****
typedef struct __recs_list
{
  char mtch_id[11];
  long  seq_number;
  double eq_alloc_amt;
  char eq_pipo_flg;

  double fo_alloc_amt;
  char fo_pipo_flg;

  double mf_alloc_amt;
  char mf_pipo_flg;
  
  double ip_alloc_amt;
  char ip_pipo_flg; 

} st_recs_list;

st_recs_list * ptr_recs_list = NULL;
******************End of Ver 1.3 *******/

/***** Ver 1.3 starts *******/
	char mtch_id[11];
  long  seq_number;
  double eq_alloc_amt;
  char eq_pipo_flg;

  double fo_alloc_amt;
  char fo_pipo_flg;

  double mf_alloc_amt;
  char mf_pipo_flg;

  double cdx_alloc_amt;  
  char cdx_pipo_flg;  

	double d_wallet_amt;
	char c_wallet_wdr_flag;
	char  c_ibr_prdct_cd[11];   
/******* End of Ver 1.3 ******/

/*----------------------------------------------------------------------------*/

EXEC SQL INCLUDE "table/clb_bnk_accts.h";         /* Ver 1.3 */
EXEC SQL INCLUDE "table/mbs_misc_bill_sttlmnt.h"; /* Ver 1.3 */
EXEC SQL INCLUDE "table/bft_bnk_fld_trnsctn.h";   /* Ver 1.3 */

void BAT_CSTM_DEALLOC ( int argc, char *argv[])                                 
{
  EXEC SQL BEGIN DECLARE SECTION;                                               

  char c_svc_name[18]={0};                                   
  char c_trd_date[21]={0};
  char c_flr_rmrk[255]={0};                                                     
  long i=0,l_flag_cnt=0;                                                      
  char c_tag[32]={0};                                                               
	int i_ret_cd = 0; /* Ver 1.3 */
	char c_mtch_flg = 'N'; /* Ver 1.3 */
  
  sql_cursor cstm_dealloc_cur;  /* Ver 1.3 */
  EXEC SQL  END  DECLARE SECTION;                                               

	/**** Ver 1.3 ****/
	MEMSET(c_src_rowid); 
	MEMSET(sql_bft_systm_trc_nmbr);  
  MEMSET(sql_bft_fld_dt); 
  MEMSET(mtch_id); 
	MEMSET(c_ibr_prdct_cd);
	i_err_cd = 0; 
	l_run_no = 0;  
	seq_number = 0;  
	l_rowcount = 0;
	c_wallet_wdr_flag=NO;
	d_wallet_amt=0;	
	/***** End of Ver 1.3 *****/

  strcpy(c_ServiceName,argv[0]);                                                

  INITBATDBGLVL(argv[0]); 
	strcpy( c_tag, "bat_cstm_dealloc_na");                                                      

  fn_userlog (c_ServiceName,"======================Started Batch - %s===============",
              argv[0]);

  sprintf(c_msg,"Batch process %s is started",argv[0]);                         
  fn_bat_pst_msg(c_ServiceName,c_msg,c_tag);                                    

  if ( ( argc != 5 )  && ( argc != 6 ) )
  {                                                                             
    fn_userlog (c_ServiceName,"Invalid Arguments passed %d",argc);
    fn_userlog (c_ServiceName,"Usage:bat_cstm_dealloc NFO NFO NA <Trade Date> <Optional Mtch ID>");
    exit(0);
  }

  strcpy(c_trd_dt,argv[4]);
  fn_userlog(c_ServiceName,"Current Date %s ",c_trd_dt);

	/******* Ver 1.3 .Get run no *****/
	i_ret_cd = tpbegin(TRAN_TIMEOUT,0);
  if(i_ret_cd == -1)
  {
    errlog(c_ServiceName, "S31005", TPMSG,(char *)c_user_id,l_session_id, c_err_msg);
		fn_userlog (c_ServiceName,"Error while begginning transaction");
    return ; /* Control will go to fn_battmpt to unresgister and terminate the process*/
  }

	EXEC SQL
    SELECT
      PAR_BNK_RUN_NMBR
    INTO
      :l_run_no
    FROM PAR_SYSTM_PRMTR
    FOR UPDATE OF PAR_BNK_RUN_NMBR;

  if(SQLCODE != 0)
  {
    tpabort(0);
    errlog(c_ServiceName, "S31010", SQLMSG,(char *)DEF_USR,DEF_SSSN, c_err_msg);
		fn_userlog (c_ServiceName,"Error while selecting run no");
		return ;
  }
  l_run_no = l_run_no+1;

	EXEC SQL
    UPDATE PAR_SYSTM_PRMTR
    SET   PAR_BNK_RUN_NMBR = :l_run_no;

  if(SQLCODE != 0)
  {
    tpabort(0);
		errlog(c_ServiceName, "S31015", SQLMSG,(char *)DEF_USR,DEF_SSSN, c_err_msg);
    fn_userlog (c_ServiceName,"Error while selecting run no");
    return ;
  }

	if(tpcommit(0)== -1)
  {
    errlog(c_ServiceName,"S31020",TPMSG,c_usr_id,l_session_id,c_err_msg);
		tpabort(0);
		fn_userlog (c_ServiceName,"Error while commiting transaction");
    return ;
  }	
	fn_userlog (c_ServiceName,"Run no is:%ld:",l_run_no);
	/**** End of Run No ***********/

  if (argc == 5 )
  {
    fn_userlog (c_ServiceName,"Arguments passed %d. Running for all unprocessed records",argc);
/*    sprintf(c_msg,"Arguments passed %d. Running for all unprocessed records");*/                         
    /*fn_bat_pst_msg(c_ServiceName,c_msg,c_tag);*/     
    /*fn_load_unprcsd_recs(); Ver 1.3 */
  }
  else
  {
    fn_userlog (c_ServiceName,"Arguments passed %d. Running for %s ",argc,argv[5]);
    
    /*sprintf(c_msg,"Arguments passed %d. Running for %s ",argc,argv[5]);*/                         
    /*fn_bat_pst_msg(c_ServiceName,c_msg,c_tag);*/     

		/****** Commented in Ver 1.3 *
    ptr_recs_list = calloc(sizeof ( st_recs_list ),1 );
    l_rowcount=1;

    if ( ptr_recs_list ==  NULL )
    {
      fn_errlog ( c_ServiceName, "S31025", SQLMSG, c_err_msg );
      exit(0);
    }

    strcpy( ptr_recs_list[0].mtch_id, argv[5]);    
		******** End of comments in Ver 1.3 */

    strcpy( c_xchng_input, argv[2] );                 /** Ver 1.2 **/

		/***** Commented in Ver 1.3 ******** 
    EXEC SQL
    SELECT '000', NVL(( MAX(CDS_SEQ_NUMBER) + 1),0) 
          ,0.00,'N',0.00,'N',0.00,'N',0.00,'N'
          INTO :ptr_recs_list[0]
    FROM CDS_CSTM_DEALLOC_SMRY; 

    if ( SQLCODE != 0 )
    {
      fn_errlog ( c_ServiceName, "S31030", SQLMSG, c_err_msg  );
      sprintf(c_err_msg,"Fetching failed with  :%s  ",sqlca.sqlerrm.sqlerrmc);
      fn_userlog(c_ServiceName,c_err_msg);  
      return ;
    }
    
    strcpy( ptr_recs_list[0].mtch_id, argv[5]);

    EXEC SQL
    INSERT INTO CDS_CSTM_DEALLOC_SMRY
        (CDS_SEQ_NUMBER,CDS_MTCH_ACCNO) 
    VALUES ( :ptr_recs_list[0].seq_number ,:ptr_recs_list[0].mtch_id);

    if ( SQLCODE != 0 )
    {
      fn_errlog ( c_ServiceName, "S31035", SQLMSG, c_err_msg  );
      sprintf(c_err_msg,"Insert failed with  :%s  ",sqlca.sqlerrm.sqlerrmc);
      fn_userlog(c_ServiceName,c_err_msg);  
      fn_bat_pst_msg(c_ServiceName,c_err_msg,c_tag);
      return ;
    }
		******** End of comment in Ver 1.3 ****************/

		/****** Ver 1.3 starts *********/
		strcpy(mtch_id, argv[5]);
		c_mtch_flg = 'Y';
		l_rowcount = 1;

		EXEC SQL
      SELECT NVL(( MAX(CDS_SEQ_NUMBER) + 1),0)
      INTO   :seq_number
      FROM CDS_CSTM_DEALLOC_SMRY;

		if ( SQLCODE != 0 )
    {
      fn_errlog ( c_ServiceName, "S31040", SQLMSG, c_err_msg  );
      sprintf(c_err_msg,"Fetching failed with  :%s  ",sqlca.sqlerrm.sqlerrmc);
      fn_userlog(c_ServiceName,c_err_msg);
      return ;
    }

		i_ret_cd = tpbegin(TRAN_TIMEOUT,0);
  	if(i_ret_cd == -1)
  	{
    	errlog(c_ServiceName, "S31045", TPMSG,(char *)c_user_id,l_session_id, c_err_msg);
    	fn_userlog (c_ServiceName,"Error while begginning transaction");
    	return ;
  	}

		EXEC SQL
    INSERT INTO CDS_CSTM_DEALLOC_SMRY
        				(CDS_SEQ_NUMBER,
								 CDS_MTCH_ACCNO)
    		VALUES (:seq_number ,:mtch_id);

    if ( SQLCODE != 0 )
    {
      fn_errlog ( c_ServiceName, "S31050", SQLMSG, c_err_msg  );
      sprintf(c_err_msg,"Insert failed with  :%s  ",sqlca.sqlerrm.sqlerrmc);
      fn_userlog(c_ServiceName,c_err_msg);
      fn_bat_pst_msg(c_ServiceName,c_err_msg,c_tag);
			return ;
    }

		if(tpcommit(0)== -1)
  	{
    	errlog(c_ServiceName,"S31055",TPMSG,c_usr_id,l_session_id,c_err_msg);
    	tpabort(0);
    	fn_userlog (c_ServiceName,"Error while commiting transaction");
    	return ;
  	}

		fn_userlog(c_ServiceName,"MTCH:%s: SEQ:%ld: Rec:%d:",mtch_id,seq_number,sqlca.sqlerrd[2]);	
		/***** End of Ver 1.3 **********/

    if ( DEBUG_MSG_LVL_3 )
    {
      fn_userlog(c_ServiceName,"The number of records to be Processed:%ld",l_rowcount);  
    }
  }

	/**** Ver 1.3 starts *****/
	if(c_mtch_flg != 'Y')
	{
		l_rowcount = 0;
		EXEC SQL
			 SELECT	COUNT(distinct(CDS_MTCH_ACCNO))
			 INTO		:l_rowcount
			 FROM   CDS_CSTM_DEALLOC_SMRY
       WHERE  CDS_PRCS_FLG = 'N';

		if(SQLCODE != 0)
  	{
			fn_errlog ( c_ServiceName, "S31060", SQLMSG, c_err_msg  );
      sprintf(c_err_msg,"Error.Contact System support ");
      fn_userlog(c_ServiceName,c_err_msg);
      fn_bat_pst_msg(c_ServiceName,c_err_msg,c_tag);
			return ;
  	}
	}
	fn_userlog(c_ServiceName,"Record count:%ld:",l_rowcount);

	EXEC SQL ALLOCATE :cstm_dealloc_cur;

	if(c_mtch_flg == 'Y')
	{
		EXEC SQL EXECUTE
  	BEGIN
    	OPEN :cstm_dealloc_cur FOR
      SELECT  CDS_MTCH_ACCNO, 
		  				CDS_SEQ_NUMBER,
              ROWID
      FROM    CDS_CSTM_DEALLOC_SMRY
			WHERE   CDS_MTCH_ACCNO = :mtch_id;
    END;
		END-EXEC;
	}
	else
	{
		EXEC SQL EXECUTE
    BEGIN
      OPEN :cstm_dealloc_cur FOR
      SELECT  CDS_MTCH_ACCNO,
              nvl(CDS_SEQ_NUMBER,0),
              ROWID
      FROM    CDS_CSTM_DEALLOC_SMRY
      WHERE   CDS_PRCS_FLG = 'N';
    END;
  	END-EXEC;
	}

	if(SQLCODE != 0)
  {
  	EXEC SQL FREE :cstm_dealloc_cur;
		fn_errlog ( c_ServiceName, "S31065", SQLMSG, c_err_msg  );
    sprintf(c_err_msg,"Error.Contact System support ");
    fn_userlog(c_ServiceName,c_err_msg);
    fn_bat_pst_msg(c_ServiceName,c_err_msg,c_tag);
		return ;
  }

	/***** End of Ver 1.3 *******/

  for (i=0;i<l_rowcount;i++) 
  {
		/* Ver 1.3 */
		MEMSET(mtch_id); 
		seq_number = 0;  
		eq_alloc_amt = 0;
		fo_alloc_amt = 0;
		mf_alloc_amt = 0;
		cdx_alloc_amt = 0;
		eq_pipo_flg = 'N';
		mf_pipo_flg = 'N';
		fo_pipo_flg = 'N';
		cdx_pipo_flg = 'N' ;
		c_blk_dep_flg= 'X';
		c_wallet_wdr_flag=NO;
		MEMSET(c_src_rowid);


		EXEC SQL
    	FETCH :cstm_dealloc_cur
      INTO  :mtch_id,
            :seq_number,
						:c_src_rowid;

		if(SQLCODE != 0)
    {
			fn_userlog(c_ServiceName,"SQLCODE :%d:",SQLCODE);

			if(SQLCODE == NO_DATA_FOUND)
			{
				fn_userlog(c_ServiceName,"No more Records ");
				EXEC SQL CLOSE  :cstm_dealloc_cur;
				EXEC SQL FREE  :cstm_dealloc_cur;
				break;
			}
			else
			{
				fn_errlog ( c_ServiceName, "S31070", SQLMSG, c_err_msg  );
				EXEC SQL CLOSE  :cstm_dealloc_cur;
				EXEC SQL FREE  :cstm_dealloc_cur;
				return ;
			}
		}

		EXEC SQL
			SELECT USR_FUND_MODEL_FLG
			INTO	:c_blk_dep_flg
			FROM	USR_USER_MASTER,
						UAC_USR_ACCNTS
			WHERE	UAC_CLM_MTCH_ACCNT = :mtch_id
			AND		UAC_USR_ID=USR_USR_ID;

		if(SQLCODE != 0)
		{
			sprintf(c_flr_rmrk,"Skipping MTCH fund model flag:%s:------",mtch_id );
      fn_bat_pst_msg(c_ServiceName,c_flr_rmrk,c_tag);
      continue;
		}

		fn_userlog(c_ServiceName,"Dtls:%s:%ld:%s:%c:",mtch_id,seq_number,c_src_rowid,c_blk_dep_flg); /*Ver 1.3 */	
		/***** End of Ver 1.3 *****/

		/*fn_userlog (c_ServiceName,"-------------------------MTCH -%ld- %s -------------------------"
				,i,ptr_recs_list[i].mtch_id );*/

		fn_userlog (c_ServiceName,"Procesing MTCH :%s:------",mtch_id ); /*V1.3*/
		sprintf(c_err_msg,"Record %ld : Match ID : %s  ",i,mtch_id); /*ptr_recs_list[l_index].mtch_id to mtch_id V1.3 */
		fn_userlog(c_ServiceName,c_err_msg);
		fn_bat_pst_msg(c_ServiceName,c_err_msg,c_tag);  
 
		l_flag_cnt=fn_check_eq_stts(i);

		l_flag_cnt=fn_check_fo_stts(i);

		l_flag_cnt=fn_check_mf_stts(i);

		/*l_flag_cnt=fn_check_ip_stts(i); Ver 1.3 */

		l_flag_cnt=fn_check_cdx_stts(i);  /* Ver 1.3 */

		fn_userlog(c_ServiceName,"EQ:%c|FO:%c|NEQ:%c|CDX:%c|",eq_pipo_flg,fo_pipo_flg,mf_pipo_flg,cdx_pipo_flg); 

		/**
		,ptr_recs_list[i].eq_pipo_flg
		,ptr_recs_list[i].fo_pipo_flg
		,ptr_recs_list[i].mf_pipo_flg
		,ptr_recs_list[i].ip_pipo_flg); Ver 1.3 *
		,ptr_recs_list[i].cdx_pipo_flg);Ver 1.3 */

		int ret_eq=0,ret_fo=0,ret_mi=0,ret_cdx=0,ret_wdrw;  /*ret_cdx,ret_ret_wdrw in Ver 1.3 */

		fn_userlog(c_ServiceName,"EQ:%lf:NEQ:%lf:NDX:%lf:NFO:%lf",eq_alloc_amt,mf_alloc_amt,cdx_alloc_amt,fo_alloc_amt); /*Ver1.3*/

/***************************
		if(
( ptr_recs_list[i].eq_pipo_flg  == 'N' )
&&
( ptr_recs_list[i].fo_pipo_flg  == 'N' )
&&
( ptr_recs_list[i].mf_pipo_flg  == 'N' )
&&
( ptr_recs_list[i].ip_pipo_flg  == 'N' )  
******* End of Ver 1.3 */
	
		if(eq_pipo_flg  == 'N' && fo_pipo_flg  == 'N' && 
			 mf_pipo_flg  == 'N'&& cdx_pipo_flg  == 'N')  /* Ver 1.3 */
		{
			/*Deallocation has to be processed*/
			fn_userlog(c_ServiceName,"Deallocating for equity ");
			ret_eq=fn_deallocate_eq(i);
			ret_wdrw = ret_eq ; 	/* Ver 1.3 */
			fn_userlog(c_ServiceName,"Deallocating for futures ");
			ret_fo=fn_deallocate_fo(i);
			ret_wdrw = ret_fo ; /* Ver 1.3 */
			fn_userlog(c_ServiceName,"Deallocating for mf and ipo ");
			ret_mi=fn_deallocate_mfip(i);
			ret_wdrw = ret_mi ; /* Ver 1.3 */
			fn_userlog(c_ServiceName,"Deallocating for Currency ");   /* Ver 1.3 */
			ret_cdx = fn_deallocate_cdx(i);    											  /* Ver 1.3 */
			ret_wdrw = ret_cdx ; /* Ver 1.3 */
			
			fn_userlog(c_ServiceName,"Ret Vals:%d:%d:%d:%d:",ret_eq,ret_fo,ret_mi,ret_cdx); /*V1.3*/	

			if ((ret_eq  == EQ_DEALC_FAILURE || ret_eq  == WTHDRAW_FAILURE) ||
					(ret_fo  == FO_DEALC_FAILURE || ret_fo  == WTHDRAW_FAILURE) ||
					(ret_mi  == MI_DEALC_FAILURE || ret_mi  == WTHDRAW_FAILURE) ||
					(ret_cdx == CDX_DEALC_FAILURE|| ret_cdx == WTHDRAW_FAILURE))  /* Ver 1.3 WTHDRAW_FAILURE added in V1.3 */ 
			{
				if( ret_wdrw != WTHDRAW_FAILURE)  /* If added in Ver 1.3 */
				{
					sprintf(c_flr_rmrk,"Failure in deallocation for EQ[%d]/FO[%d]/NEQ[%d]CDX[%d]",ret_eq,ret_fo,ret_mi,ret_cdx );
				}
				else
				{
					sprintf(c_flr_rmrk,"Failure in Withdraw");
				}
				/**** End of Ver 1.3 */
				/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variables */
				fn_update_status(mtch_id,seq_number,'E',c_flr_rmrk);
				fn_bat_pst_msg(c_ServiceName,c_err_msg,c_tag);
			}
			else
			{
				/**********Added ver 1.3 start**********/	
				tpfree((char *)ptr_fml_Sbuffer);
        tpfree((char *)ptr_fml_Rbuffer);

				ptr_fml_Sbuffer = (FBFR32 *)tpalloc("FML32",NULL,MIN_FML_BUF_LEN);
  			if (ptr_fml_Sbuffer == NULL)
  			{
    			errlog(c_ServiceName, "S31075", TPMSG,(char *)c_user_id,l_session_id, c_err_msg);
    			tpclose();
    			tpterm();
    			exit(0);
  			}

  			ptr_fml_Rbuffer = (FBFR32 *)tpalloc("FML32",NULL,MIN_FML_BUF_LEN);
  			if (ptr_fml_Rbuffer == NULL)
  			{
    			errlog(c_ServiceName, "S31080", TPMSG,(char *)c_user_id,l_session_id, c_err_msg);
    			tpfree((char *)ptr_fml_Sbuffer);
    			tpclose();
    			tpterm();
    			exit(0);
  			}

				if(c_blk_dep_flg == DEPOSIT_MODEL)
				{
					EXEC SQL
						SELECT	NVL(CLM_WALLET_AMT,0)
						INTO		:d_wallet_amt
						FROM		CLM_CLNT_MSTR
						WHERE		CLM_MTCH_ACCNT = :mtch_id;

					if(SQLCODE != 0)
					{
						fn_errlog ( c_ServiceName, "S31085", SQLMSG, c_err_msg  );
            EXEC SQL CLOSE  :cstm_dealloc_cur;
            EXEC SQL FREE  :cstm_dealloc_cur;
						tpfree((char *)ptr_fml_Sbuffer);
        		tpfree((char *)ptr_fml_Rbuffer);
            return ;
					}

					fn_userlog(c_ServiceName,"Wallet amt:%lf:",d_wallet_amt);	

					if(d_wallet_amt > 0)
					{
						c_wallet_wdr_flag=YES;

						i_ret_cd = fn_call_inc_dec_wallet(EQ,i);
    				if(i_ret_cd != 0)
    				{
							sprintf(c_flr_rmrk,"Skipping MTCH wallet wdr:%s:------",mtch_id );
							fn_bat_pst_msg(c_ServiceName,c_flr_rmrk,c_tag);
							tpfree((char *)ptr_fml_Sbuffer);
        			tpfree((char *)ptr_fml_Rbuffer);
							continue;
    				}
					}
				}

				tpfree((char *)ptr_fml_Sbuffer);
        tpfree((char *)ptr_fml_Rbuffer);
				/**********Added ver 1.3 end**********/	

				sprintf(c_flr_rmrk,"Success in deallocation for EQ[%d]/FO[%d]/NEQ[%d]CDX[%d]",ret_eq,ret_fo,ret_mi,ret_cdx );

				/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variables */
				fn_update_status(mtch_id,seq_number,'S', "Deallocation Successful. ");
				fn_bat_pst_msg(c_ServiceName,c_flr_rmrk,c_tag);
			}
		}
		else
		{
			/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variable */
			if (eq_pipo_flg == 'E') /* It has easy margin open position */
				sprintf(c_flr_rmrk,"Easy Margin open position present. Record not processed further !!");
			else if ( fo_pipo_flg == 'P') /* It has a FNO open position */
				/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variables */
				sprintf(c_flr_rmrk,"FNO open position present. Record not processed further !!");
			else
				sprintf(c_flr_rmrk,"Obligation present. Record not processed further !!");
 
			/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variables */ 
			fn_update_status(mtch_id,seq_number,'O', c_flr_rmrk);
			fn_bat_pst_msg(c_ServiceName,c_flr_rmrk,c_tag);
		}
	}

	sprintf(c_msg,"Completed Batch --- %ld records processed ",l_rowcount);                         
  fn_bat_pst_msg(c_ServiceName,c_msg,c_tag);

  fn_userlog (c_ServiceName,"==================Completed Batch --- %ld records processed ==================="
              ,l_rowcount );  
              
  return ;    

}                                                                               

/******************************************************************************
--------------------------------------------------------------------------------
******************************************************************************/

/******** Commented in Ver 1.3 ***********
int fn_load_unprcsd_recs()
{
  EXEC SQL BEGIN DECLARE SECTION;

  long l_rec_cnt=0;
  long i=0; 

  EXEC SQL END   DECLARE SECTION;

  EXEC SQL
  select count(rowid)
  INTO :l_rowcount
  FROM CDS_CSTM_DEALLOC_SMRY
  WHERE CDS_PRCS_FLG = 'N';

  if ( SQLCODE != 0 )
  {
    fn_errlog ( c_ServiceName, "S31090", SQLMSG, c_err_msg  );
    return (-1);
  }

  if (l_rowcount == 0)
  {
      fn_userlog(c_ServiceName,"No records to process. Exiting !!! ");
      return 0;
  }

  if ( DEBUG_MSG_LVL_3 )       
  {
    fn_userlog(c_ServiceName,"Allocating : %ld",l_rowcount);  
  }

  ptr_recs_list = calloc(sizeof ( st_recs_list ),l_rowcount );

  if ( ptr_recs_list ==  NULL )
  {
    fn_errlog ( c_ServiceName, "S31095", SQLMSG, c_err_msg );
    return ( -1 );
  }

  if ( DEBUG_MSG_LVL_3 )
  {
    fn_userlog(c_ServiceName,"The number of records to be Processed:%ld",l_rowcount);  
  }

  EXEC SQL
  DECLARE RECS_LIST CURSOR FOR
      SELECT 
      CDS_MTCH_ACCNO, CDS_SEQ_NUMBER,0.00,'N',0.00,'N',0.00,'N',0.00,'N'
  FROM CDS_CSTM_DEALLOC_SMRY
  WHERE CDS_PRCS_FLG = 'N';

  EXEC SQL OPEN RECS_LIST;

  if ( SQLCODE != 0 )
  {
    fn_errlog ( c_ServiceName, "S31100", SQLMSG, c_err_msg  );
    sprintf(c_err_msg,"Fetching failed with  :%s  ",sqlca.sqlerrm.sqlerrmc);
    fn_userlog(c_ServiceName,c_err_msg);

    return (-1);
  }

  EXEC SQL
  FOR :l_rowcount
  FETCH RECS_LIST
  INTO :ptr_recs_list;
		

  if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
  {
    fn_errlog ( c_ServiceName, "S31105", SQLMSG, c_err_msg  );
    return (-1);
  }

  l_rec_cnt=sqlca.sqlerrd[2];

  if (l_rowcount != l_rec_cnt)
  {
    fn_userlog(c_ServiceName,"Invalid count l_rowcount:%ld | l_rec_cnt:%ld ",
               l_rowcount, l_rec_cnt);
    return (-1);

  }

  if ( DEBUG_MSG_LVL_4 )
  {
    for(i=0;i<l_rowcount;i++)
          fn_userlog(c_ServiceName,"\t\t --- \t MTCH : |%s| ",
                     ptr_recs_list[i].mtch_id);
  }

  return (0);

}                                                                 
****** End of comment in Ver 1.3 ****/

/******************************************************************************
--------------------------------------------------------------------------------
******************************************************************************/

int fn_check_eq_stts(long l_index)                                                             
{            

  EXEC SQL BEGIN DECLARE SECTION;

    int    i_loopctr=0, i_loop=0, i_counter=0 ;                                     
    double d_csb_nt_blncs =0.00               ;                                                                             
    char   c_csb_db_cr_flg                    ;
    char   c_dom_id[10],c_stck_cd[6],c_sgmnt_cd[4];
    long   l_retval, l_recvbuff;
    double d_allocation_amt=0.00F;

  EXEC SQL END   DECLARE SECTION;

  tpfree((char *)ptr_fml_Sbuffer);                                        
  tpfree((char *)ptr_fml_Rbuffer);                                        

/******************************************************************************/
	/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variables */
  fn_userlog (c_ServiceName,"EQ check %s ",mtch_id);

  ptr_fml_Sbuffer = (FBFR32 *)tpalloc("FML32",NULL,MIN_FML_BUF_LEN);                    
  if (ptr_fml_Sbuffer == NULL)
  {
    errlog(c_ServiceName, "S31110", TPMSG,(char *)c_user_id,l_session_id, c_err_msg);
    tpclose();tpterm();exit(0);                                                                    
  }

  ptr_fml_Rbuffer = (FBFR32 *)tpalloc("FML32",NULL,MIN_FML_BUF_LEN);                    
  if (ptr_fml_Rbuffer == NULL)                                                          
  {
    errlog(c_ServiceName, "S31115", TPMSG,(char *)c_user_id,l_session_id, c_err_msg);
    tpfree((char *)ptr_fml_Sbuffer);                                                    
    tpclose();tpterm();exit(0);                                                                    
  }

  strcpy(c_usr_id,"system");
  l_session_id=0;
  strcpy(c_xchng_cd,"NSE");
  strcpy(c_stck_cd,"");
  strcpy(c_sgmnt_cd,"N");
  strcpy(c_dom_id,"BOF");

  i_err[0]  = Fadd32(ptr_fml_Sbuffer, FML_USR_ID, (char *)c_usr_id, 0);       
  i_ferr[0] = Ferror32;                                                       
  i_err[1]  = Fadd32(ptr_fml_Sbuffer, FML_SSSN_ID, (char *)&l_session_id, 0);    
  i_ferr[1] = Ferror32;                                                       
  i_err[2]  = Fadd32(ptr_fml_Sbuffer, FML_ORD_XCHNG_CD, (char *)c_xchng_cd, 0);
  i_ferr[2] = Ferror32;                                                       
	/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variables */
  i_err[3]  = Fadd32(ptr_fml_Sbuffer, FML_ORD_CLM_MTCH_ACCNT, (char *)mtch_id, 0);
  i_ferr[3] = Ferror32;                                                       
  i_err[4]  = Fadd32(ptr_fml_Sbuffer, FML_ORD_STCK_CD, (char *)c_stck_cd, 0); 
  i_ferr[4] = Ferror32;                                                       
  i_err[5]  = Fadd32(ptr_fml_Sbuffer, FML_ORD_XCHNG_SGMNT_CD, (char *)c_sgmnt_cd, 0);
  i_ferr[5] = Ferror32;                                                       
  i_err[6]  = Fadd32(ptr_fml_Sbuffer, FML_USR_DPRTMNT_ID, (char *)c_dom_id, 0);
  i_ferr[6] = Ferror32;                                                       

  for(i_loop = 0; i_loop < 7 ; i_loop++)                                      
  {                                                                           
    if(i_err[i_loop] == -1)                                                   
    {
      errlog(c_ServiceName, "S31120", Fstrerror32(i_ferr[i_loop]), c_usr_id, l_session_id,
                              c_err_msg);                                     
      Fadd32(ptr_fml_Ibuffer, FML_ERR_MSG, c_err_msg, 0);                     
      Fadd32(ptr_fml_Ibuffer, FML_ACTN_ID, (char *)&l_retval, 0);             
      tpfree((char *)ptr_fml_Sbuffer);                                        
      tpfree((char *)ptr_fml_Rbuffer);                                        
      tpfree((char *)ptr_fml_Obuffer);                                        
      tpreturn(TPFAIL, 0L, (char *)ptr_fml_Ibuffer , 0L, 0);                  
    }
  }

  /*  Call the function svc_get_limits to get the current limits for equity   */

  if (tpcall("SVC_VIEW_LIMITS", (char *)ptr_fml_Sbuffer, 0, (char **)&ptr_fml_Rbuffer,
              &l_recvbuff, 0) == -1)                                            
  {
    if (tperrno == TPESVCFAIL)
    {
      if (Fget32(ptr_fml_Rbuffer, FML_ERR_MSG, 0, c_err_msg, 0 ) == -1)          
      {
        errlog(c_ServiceName, "S31125", FMLMSG, c_usr_id, l_session_id, c_err_msg);
        Fadd32(ptr_fml_Ibuffer, FML_ERR_MSG, c_err_msg, 0);                     
        Fadd32(ptr_fml_Ibuffer, FML_ACTN_ID, (char *)&l_retval, 0);             
        tpfree((char *)ptr_fml_Sbuffer);                                        
        tpfree((char *)ptr_fml_Rbuffer);                                        
        tpreturn(TPFAIL, 0L, (char *)ptr_fml_Ibuffer, 0L, 0);                   
      }
    }
    else                                                                        
    {
      errlog(c_ServiceName, "S31130", TPMSG, c_usr_id, l_session_id, c_err_msg);   
    }
  }                                                                             

  if (Fget32(ptr_fml_Rbuffer, FML_AMNT_ALLCTD,i_loopctr,(char *)&d_allocation_amt,0) ==-1 )
			return (-1);

  EXEC SQL
  SELECT  NVL( 
              sum( 
                    decode ( csb_db_cr_flg, 
                            'D', csb_nt_blncs,
                            'C', (-1*csb_nt_blncs)) 
                 )
              ,0.00
             )
  INTO    :d_csb_nt_blncs
  FROM    csb_sttlmnt_blncs
	/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variables */
  WHERE   csb_clm_mtch_accnt = :mtch_id
  AND     csb_nt_blncs <> 0
  GROUP BY csb_clm_mtch_accnt
  ORDER BY csb_clm_mtch_accnt;

  if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
  {
    fn_errlog ( c_ServiceName, "S31135", SQLMSG, c_err_msg  );
    return (-1);
  }

	/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variables */
	eq_pipo_flg = (d_csb_nt_blncs != 0.00F ) ? 'Y' : 'N';
  eq_alloc_amt=d_allocation_amt;
  
  if (eq_pipo_flg == 'N')
	eq_pipo_flg = ( fn_check_easymargin_open(l_index) == 0 ) ? 'N' : 'E' ;

/******************************************************************************/

	/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variables */
  fn_userlog (c_ServiceName,"EQ Allocation  %lf Obligation %lf FLAG %c "
              , d_allocation_amt, d_csb_nt_blncs ,eq_pipo_flg );
  return(0);                                                                    
}                                                                               

/******************************************************************************
--------------------------------------------------------------------------------
******************************************************************************/

int fn_check_fo_stts(long l_index)                                                             
{                                                                               

  EXEC SQL BEGIN DECLARE SECTION;

  char c_rout_crt[4]={0};
  long li_len_tobuf;
  double d_fo_limit=0.00, d_fcb_dc_amt=0.00, d_fbd_normal_amt=0.00,d_fbd_tds_amt=0.00;
  int   ret_val;

  EXEC SQL END   DECLARE SECTION;

	/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variables */
  fn_userlog (c_ServiceName,"FO check %s ",mtch_id);

  tpfree((char *)ptr_fml_Sbuffer);                                        
  tpfree((char *)ptr_fml_Rbuffer);                                        

  ptr_fml_Sbuffer = (FBFR32 *)tpalloc("FML32",NULL,MIN_FML_BUF_LEN);                    
  if (ptr_fml_Sbuffer == NULL)
  {
    errlog(c_ServiceName, "S31140", TPMSG,(char *)c_user_id,l_session_id, c_err_msg);
    tpclose();                                                                
    tpterm();                                                                   
    exit(0);                                                                    
  }

  ptr_fml_Rbuffer = (FBFR32 *)tpalloc("FML32",NULL,MIN_FML_BUF_LEN);                    
  if (ptr_fml_Rbuffer == NULL)                                                          
  {
    errlog(c_ServiceName, "S31145", TPMSG,(char *)c_user_id,l_session_id, c_err_msg);
    tpfree((char *)ptr_fml_Sbuffer);                                                    
    tpclose();                                                                
    tpterm();                                                                   
    exit(0);                                                                    
  }

/******************************************************************************/

  strcpy(c_usr_id,"system");
  l_session_id=0;
  strcpy(c_xchng_cd,"NSE");
  strcpy(c_rout_crt,"333");

  i_err[0] = Fadd32(ptr_fml_Sbuffer,FFO_USR_ID, (char *)c_usr_id , 0);
  i_err[1] = Fadd32(ptr_fml_Sbuffer,FFO_SSSN_ID, (char *)&l_session_id , 0);
	/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variables */
  i_err[2] = Fadd32(ptr_fml_Sbuffer,FFO_EBA_MTCH_ACT_NO, (char *)mtch_id , 0);
  i_err[5] = Fadd32(ptr_fml_Sbuffer,FML_ORD_CLM_MTCH_ACCNT, (char *)mtch_id , 0);  
  i_err[3] = Fadd32(ptr_fml_Sbuffer,FFO_TRD_DT, (char *)c_trd_dt , 0);
  i_err[4] = Fadd32(ptr_fml_Sbuffer,FFO_ROUT_CRT, (char *)c_rout_crt , 0);

  d_fo_limit = 0.0;
  ret_val = tpcall("SFO_VIEW_LIMITS",(char*)ptr_fml_Sbuffer,0,(char **)&ptr_fml_Rbuffer,&li_len_tobuf,0);
  if(ret_val == -1)
  {
    fn_errlog( c_ServiceName, "S31150", FMLMSG , c_err_msg );
    tpfree((char *)ptr_fml_Obuffer);
    Fadd32( ptr_fml_Ibuffer, FFO_ERR_MSG, c_err_msg, 0 );
    tpreturn(TPFAIL, ERR_BFR, (char *)ptr_fml_Ibuffer, 0, 0 );
  }

  if ( Fget32(ptr_fml_Rbuffer,FFO_LIMIT,0,(char *)&d_fo_limit,0) == -1 ) 
			return (-1);
/*
  EXEC SQL
      SELECT
        NVL( 
          sum( 
              decode 
               ( 
                 fcb_dc_flg, 
                'D', fcb_dc_amt,
                'C', (-1*fcb_dc_amt)
               )
             )
          ,0
           )
      INTO    :d_fcb_dc_amt
      FROM    fcb_fo_clnt_blncs
      WHERE   fcb_clm_mtch_accnt = :ptr_recs_list[l_index].mtch_id 
      AND     fcb_dc_amt != 0;
*/

		EXEC SQL
		 SELECT  NVL(SUM(FBD_DC_AMT - FBD_PI_PO_AMT - FBD_INT_ADJ_AMT),0)
		 		INTO  :d_fbd_tds_amt
        FROM  FBD_FO_BNK_DRCR
        WHERE FBD_XCHNG_CD = 'NFO'
        AND   FBD_DC_FLG = 'D'
        AND   FBD_CLM_MTCH_ACCNT  = :mtch_id /*1.3 .ptr_recs_list replaced with variable */
        AND   FBD_PAYIN_DT <= to_date(:c_trd_dt, 'dd-Mon-yyyy' )
        AND   FBD_DC_AMT != FBD_PI_PO_AMT + FBD_INT_ADJ_AMT
        AND   FBD_GRP_ID = 9;
        
		if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
		{
		  fn_errlog ( c_ServiceName, "S31155", SQLMSG, c_err_msg  );
		  return (-1);
		}
		
		EXEC SQL        
		 SELECT  NVL(SUM(FBD_DC_AMT - FBD_PI_PO_AMT - FBD_INT_ADJ_AMT),0)
		 		INTO :d_fbd_normal_amt
        FROM  FBD_FO_BNK_DRCR
        WHERE FBD_XCHNG_CD = 'NFO'
        /*AND   FBD_DC_FLG = 'D'*/
        AND   FBD_CLM_MTCH_ACCNT  = :mtch_id  /* Ver 1.3 .ptr_recs_list replaced with variables */
        AND   FBD_PAYIN_DT <= to_date(:c_trd_dt, 'dd-Mon-yyyy' )
        AND   FBD_DC_AMT != FBD_PI_PO_AMT + FBD_INT_ADJ_AMT
        AND   FBD_GRP_ID = 1;
	        
	  if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
	  {
	    fn_errlog ( c_ServiceName, "S31160", SQLMSG, c_err_msg  );
	    return (-1);
	  }
	  
	d_fcb_dc_amt=d_fbd_tds_amt+d_fbd_normal_amt;

	/* Ver 1.3 .In below all statement ptr_recs_list replaced with individual variables */	
  fo_pipo_flg = (d_fcb_dc_amt != 0.00F ) ? 'Y' : 'N';
  fo_alloc_amt=d_fo_limit;
  
  if (fo_pipo_flg == 'N' )
	  fo_pipo_flg =
			( (fn_check_futures_open(l_index) == 0 ) 
												&&	  
	  	  (fn_check_options_open(l_index) == 0 ) 
			)
			? 'N' : 'P';

  fn_userlog (c_ServiceName,"FO Allocation  %lf Obligation %lf FLAG %c "
              , d_fo_limit, d_fcb_dc_amt , fo_pipo_flg );

  return(0);                                                                    
}                                                                               

/******************************************************************************
--------------------------------------------------------------------------------
******************************************************************************/


int fn_check_mf_stts(long l_index)                                                             
{ 

  EXEC SQL BEGIN DECLARE SECTION;

  char c_rout_crt[4]={0};
  long li_len_tobuf;
  double d_clm_mf_allctd_amt=0.00, d_mf_nt_blncs=0.00;
  int   ret_val;

  EXEC SQL END   DECLARE SECTION;

  EXEC SQL
  SELECT NVL(MF_NT_BLNCS,0.00) 
  INTO :d_mf_nt_blncs
  FROM MF_TOT_BLNCS
  WHERE MF_CLM_MTCH_ACCNT=:mtch_id;  /* Ver 1.3 .ptr_recs_list replaced with variables */

  if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
  {
    fn_errlog ( c_ServiceName, "S31165", SQLMSG, c_err_msg  );
    return (-1);
  }

  EXEC SQL
  SELECT NVL(CLM_MF_ALLCTD_AMT,0) 
  INTO :d_clm_mf_allctd_amt
  FROM CLM_CLNT_MSTR
  WHERE CLM_MTCH_ACCNT=:mtch_id; /* Ver 1.3 .ptr_recs_list replaced with variables */ 

  if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
  {
    fn_errlog ( c_ServiceName, "S31170", SQLMSG, c_err_msg  );
    return (-1);
  }

	/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variables */
  mf_pipo_flg = (d_mf_nt_blncs != 0.00F ) ? 'Y' : 'N';
  mf_alloc_amt=d_clm_mf_allctd_amt;
  
  fn_userlog (c_ServiceName,"MF Allocation %lf Obligation %lf FLAG %c"
              , d_clm_mf_allctd_amt, d_mf_nt_blncs, mf_pipo_flg );

  return(0);                                                                    
}                                                                               

/******************************************************************************
--------------------------------------------------------------------------------
******************************************************************************/
/******* Commented in Ver 1.3 **********************
int fn_check_ip_stts(long l_index)                                                             
{  

  EXEC SQL BEGIN DECLARE SECTION;

  char c_rout_crt[4]={0};
  long li_len_tobuf;
  double d_clm_mf_allctd_amt=0.00, d_ipo_nt_blncs=0.00;
  int   ret_val;

  EXEC SQL END   DECLARE SECTION;

  EXEC SQL
  SELECT NVL(IPO_NT_BLNCS,0.00) 
  INTO :d_ipo_nt_blncs
  FROM IPO_TOT_BLNCS
  WHERE IPO_CLM_MTCH_ACCNT=:ptr_recs_list[l_index].mtch_id;

  if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
  {
    fn_errlog ( c_ServiceName, "S31175", SQLMSG, c_err_msg  );
    return (-1);
  }

  EXEC SQL
  SELECT NVL(CLM_MF_ALLCTD_AMT,0) 
  INTO :d_clm_mf_allctd_amt
  FROM CLM_CLNT_MSTR
  WHERE CLM_MTCH_ACCNT=:ptr_recs_list[l_index].mtch_id

  if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
  {
    fn_errlog ( c_ServiceName, "S31180", SQLMSG, c_err_msg  );
    return (-1);
  }

	* Ver 1.3 .In below 3 statement ptr_recs_list replaced with individual variables *
  ip_pipo_flg = (d_ipo_nt_blncs != 0.00F ) ? 'Y' : 'N';
  ip_alloc_amt=d_clm_mf_allctd_amt;

  fn_userlog (c_ServiceName,"IP Allocation  %lf Obligation %lf FLAG %c"
              , d_clm_mf_allctd_amt, d_ipo_nt_blncs ,ip_pipo_flg  );

  return(0);   
}             
********* End of comment in Ver 1.3 ************/

int fn_deallocate_eq(long l_index)
{
	/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variables */
  fn_userlog (c_ServiceName,"Proceeding to deallocate  EQ %lf"  , eq_alloc_amt  );

	int   i_trnsctn = 0;    /* Ver 1.3 */
  char  c_narr[21];       /* Ver 1.3 */
  char  c_segment[3];     /* Ver 1.3 */
  char  c_bnk_accnt[21];  /* Ver 1.3 */
  char  c_channel[4];     /* Ver 1.3 */
  char  c_ip_id[3];       /* Ver 1.3 */
  char  l_bft_flg=0;      /* Ver 1.3 */
  char  i_loop_counter=2; /* Ver 1.3 */
  char  j=0;    					/* Ver 1.3 */
  char  i_ret_cd = 0;   	/* Ver 1.3 */

  EXEC SQL BEGIN DECLARE SECTION;
  char c_operation;
  char c_prdct;
  char c_event[256];
  long l_recv_buff_len,i; 
  double sql_clm_allctd_amt=0.00;
  char  c_mtch_acnt_id[13]={0};
  EXEC SQL END   DECLARE SECTION;

	MEMSET(c_narr);           /* Ver 1.3 */
  MEMSET(c_segment);        /* Ver 1.3 */
  MEMSET(c_bnk_accnt);      /* Ver 1.3 */
  MEMSET(c_channel);        /* Ver 1.3 */
  MEMSET(c_channel);        /* Ver 1.3 */
  strcpy(c_segment,"EQ");   /* Ver 1.3 */
  strcpy(c_segment,"SYS");  /* Ver 1.3 */
  strcpy(c_channel,"NA");   /* Ver 1.3 */

  tpfree((char *)ptr_fml_Sbuffer);                                        
  tpfree((char *)ptr_fml_Rbuffer);    

	/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variables */
  if ( (long)(eq_alloc_amt * 100 ) == 0 )
      return (EQ_DEALC_SUCCESS);                                    

  ptr_fml_Sbuffer = (FBFR32 *)tpalloc("FML32",NULL,MIN_FML_BUF_LEN);                    
  if (ptr_fml_Sbuffer == NULL)
  {
    errlog(c_ServiceName, "S31185", TPMSG,(char *)c_user_id,l_session_id, c_err_msg);
    tpclose();                                                                
    tpterm();                                                                   
    exit(0);                                                                    
  }

  ptr_fml_Rbuffer = (FBFR32 *)tpalloc("FML32",NULL,MIN_FML_BUF_LEN);                    
  if (ptr_fml_Rbuffer == NULL)                                                          
  {
    errlog(c_ServiceName, "S31190", TPMSG,(char *)c_user_id,l_session_id, c_err_msg);
    tpfree((char *)ptr_fml_Sbuffer);                                                    
    tpclose();                                                                
    tpterm();                                                                   
    exit(0);                                                                    
  }

	if(c_blk_dep_flg == BLOCK_MODEL)    /*Ver 1.3*/
  {
  	c_operation='D';
  	c_prdct='E';
  	/*strcpy(c_mtch_acnt_id,ptr_recs_list[l_index].mtch_id); **Ver 1.3**/
  	strcpy(c_user_id,"system");
  	l_session_id=0;
  	/*sql_clm_allctd_amt=ptr_recs_list[l_index].eq_alloc_amt; **Ver 1.3**/
    
  	i_err[0] = Fadd32(ptr_fml_Sbuffer,FML_USR_ID, (char *)c_user_id,0);
  	i_err[1] = Fadd32(ptr_fml_Sbuffer,FML_SSSN_ID, (char *)&l_session_id,0);
  	/*i_err[2] = Fadd32(ptr_fml_Sbuffer,FML_EBA_MTCH_ACT_NO, (char *)c_mtch_acnt_id, 0); **Ver 1.3**/
  	i_err[2] = Fadd32(ptr_fml_Sbuffer,FML_EBA_MTCH_ACT_NO, (char *)mtch_id, 0);		/*Ver 1.3*/
  	i_err[3] = Fadd32(ptr_fml_Sbuffer,FML_ORD_CLM_MTCH_ACCNT, (char *)c_mtch_acnt_id, 0);
  	/*i_err[4] = Fadd32(ptr_fml_Sbuffer,FML_TRNSCTN_AMT, (char *)&sql_clm_allctd_amt,0); **Ver 1.3**/
  	i_err[4] = Fadd32(ptr_fml_Sbuffer,FML_TRNSCTN_AMT, (char *)&eq_alloc_amt,0);  /**Ver 1.3**/
  	i_err[5] = Fadd32(ptr_fml_Sbuffer,FML_MSG_TYP, (char *)&c_operation,0);
  	i_err[6] = Fadd32(ptr_fml_Sbuffer,FML_PRDCT_TYP, (char *)&c_prdct,0);
  	i_err[7] = Fadd32(ptr_fml_Sbuffer,FML_TRNSCTN_FLW, (char *)&c_blk_dep_flg,0); /*Ver 1.3*/

  	for (i=0; i <8 ;i++ )
		{
  		if( i_err[i] == -1 )
  		{
    		fn_userlog(c_ServiceName,"Failed at FML %d ",i );
    		tpfree((char *)ptr_fml_Sbuffer);
    		tpfree((char *)ptr_fml_Rbuffer);
    		errlog(c_ServiceName,"S31195",FMLMSG,DEF_USR, DEF_SSSN,c_event);
    		exit(0);
  		}
		}

  	if(tpcall("SVC_BLK_ALLOC",(char *)ptr_fml_Sbuffer,0,
            (char **)&ptr_fml_Rbuffer,&l_recv_buff_len,TPNOTRAN|TPNOTIME) == -1)
  	{
    	fn_userlog(c_ServiceName,"Error in SVC_BLK_ALLOC call");
    	errlog(c_ServiceName,"S31200",TPMSG,DEF_USR, DEF_SSSN,c_event);
	  	/*sprintf(c_msg,"EQ deallocation failure %lf"  , ptr_recs_list[l_index].eq_alloc_amt );**Ver 1.3**/
	  	sprintf(c_msg,"EQ deallocation failure %lf"  , eq_alloc_amt);	/**Ver 1.3**/
  		fn_bat_pst_msg(c_ServiceName,c_msg,c_tag);
    	return EQ_DEALC_FAILURE;
  	}
  	else
  	{
    	fn_userlog(c_ServiceName,"Deallocation call to SVC_BLK_ALLOC successfull");
  	}
	}
	/**** Ver 1.3 starts *************/
	else
	{
		i_ret_cd = fn_call_inc_dec_wallet(EQ,l_index);
		if(i_ret_cd != 0)
		{
			fn_userlog(c_ServiceName,"Error in SVC_BLK_ALLOC call:%d:",i_ret_cd);
   		errlog(c_ServiceName,"S31205",TPMSG,DEF_USR, DEF_SSSN,c_event);
   		sprintf(c_msg,"EQ deallocation failure %lf",eq_alloc_amt );
			fn_bat_pst_msg(c_ServiceName,c_msg,c_tag);

			if(i_ret_cd == -2)
			{
				return WTHDRAW_FAILURE;
			}
			else
			{
   			return EQ_DEALC_FAILURE;
			}
		}
	}
	/******* End of Ver 1.3 **********/

	/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variables */
  fn_userlog (c_ServiceName,"EQ deallocation complete %lf"  , eq_alloc_amt  );
  sprintf(c_msg,"EQ deallocation complete %lf"  , eq_alloc_amt );                         
  fn_bat_pst_msg(c_ServiceName,c_msg,c_tag);     
  
  return EQ_DEALC_SUCCESS;
}

int fn_deallocate_fo(long l_index)
{
	/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variables */
  fn_userlog (c_ServiceName,"Proceeding to deallocate  FO %lf"  , fo_alloc_amt  );

  EXEC SQL BEGIN DECLARE SECTION;
  	char    c_operation;
  	char    c_prdct;
  	char    c_event[256];
  	long    l_recv_buff_len,i;  
  	double  sql_fab_alctd_amt=0.00;
  	char    c_mtch_acnt_id[13]={0};
  	char    c_mkt_typ='D';
  	char    c_req_typ='A';
  	char    c_rout_crt[4]={0};
  EXEC SQL END   DECLARE SECTION;
	
	int i_ret_cd = 0; /* Ver 1.3 */
	int	i_count;

	/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variables */
  if ( (long)(fo_alloc_amt * 100 ) == 0 )
      return (FO_DEALC_SUCCESS);  

  tpfree((char *)ptr_fml_Sbuffer);                                        
  tpfree((char *)ptr_fml_Rbuffer);                                        

  ptr_fml_Sbuffer = (FBFR32 *)tpalloc("FML32",NULL,MIN_FML_BUF_LEN);                    
  if (ptr_fml_Sbuffer == NULL)
  {
    errlog(c_ServiceName, "S31210", TPMSG,(char *)c_user_id,l_session_id, c_err_msg);
    tpclose();                                                                
    tpterm();                                                                   
    exit(0);                                                                    
  }

  ptr_fml_Rbuffer = (FBFR32 *)tpalloc("FML32",NULL,MIN_FML_BUF_LEN);                    
  if (ptr_fml_Rbuffer == NULL)                                                          
  {
    errlog(c_ServiceName, "S31215", TPMSG,(char *)c_user_id,l_session_id, c_err_msg);
    tpfree((char *)ptr_fml_Sbuffer);                                                    
    tpclose();                                                                
    tpterm();                                                                   
    exit(0);                                                                    
  }

	if(c_blk_dep_flg == BLOCK_MODEL)    /*Ver 1.3*/
	{
  	c_operation='D';
  	c_prdct='F';
  	/*strcpy(c_mtch_acnt_id,ptr_recs_list[l_index].mtch_id); **Ver 1.3**/
  	strcpy(c_user_id,"system");
  	l_session_id=0;
  	/*sql_fab_alctd_amt=ptr_recs_list[l_index].fo_alloc_amt; **Ver 1.3**/
  	strcpy(c_rout_crt,"333");
	
  	i_err[0] = Fadd32(ptr_fml_Sbuffer,FFO_USR_ID, (char *)c_user_id,0);
  	i_err[1] = Fadd32(ptr_fml_Sbuffer,FFO_SSSN_ID, (char *)&l_session_id,0);
  	/*i_err[2] = Fchg32(ptr_fml_Sbuffer,FFO_AMOUNT,(FLDOCC32) 0,(char *)&sql_fab_alctd_amt,0); **Ver 1.3*/
  	i_err[2] = Fchg32(ptr_fml_Sbuffer,FFO_AMOUNT,(FLDOCC32) 0,(char *)&fo_alloc_amt,0);	/**Ver 1.3**/
  	i_err[3] = Fchg32(ptr_fml_Sbuffer,FFO_DR_CR_FLG, (FLDOCC32) 0,(char *)&c_operation,0);
  	i_err[4] = Fchg32(ptr_fml_Sbuffer,FFO_MKT_TYP,(FLDOCC32) 0,(char *)&c_mkt_typ,0);
  	i_err[5] = Fchg32(ptr_fml_Sbuffer,FFO_RQST_TYP,(FLDOCC32) 0,(char *)&c_req_typ,0);

		/******** Commented in Ver 1.2 *****
  	i_err[4] = Fchg32(ptr_fml_Sbuffer,FFO_EBA_MTCH_ACT_NO,(FLDOCC32) 0,(char *)&c_mtch_acnt_id,0);
  	i_err[5] = Fchg32(ptr_fml_Sbuffer,FFO_ROUT_CRT,(FLDOCC32) 0,(char *)&c_rout_crt,0);  
		*****/


		/*i_err[6] = Fchg32(ptr_fml_Sbuffer,FFO_EBA_MTCH_ACT_NO,(FLDOCC32) 0,(char *)&c_mtch_acnt_id,0); ** Change Error no in 1.2 **Ver 1.3**/
		i_err[6] = Fchg32(ptr_fml_Sbuffer,FFO_EBA_MTCH_ACT_NO,(FLDOCC32) 0,(char *)mtch_id,0); /**Ver 1.3**/
		i_err[7] = Fchg32(ptr_fml_Sbuffer,FFO_ROUT_CRT,(FLDOCC32) 0,(char *)&c_rout_crt,0); /** Change Error no in 1.2 **/
  	i_err[8] = Fchg32(ptr_fml_Sbuffer,FFO_XCHNG_CD,(FLDOCC32) 0,(char *)c_xchng_input,0);  /** Ver 1.2 **/

		/*if( i_err[0] == -1 || i_err[1] == -1 || i_err[2] == -1|| i_err[2] == -1||i_err[2] == -1 || i_err[8] == -1) *** Added 8 in Ver 1.2 ***Commented in Ver 1.3***/
		for(i_count=0;i_count<9;i_count++)	/*Ver 1.3*/
		{		
			if(i_err[i_count] == -1)		/*Ver 1.3*/
			{
				fn_userlog(c_ServiceName,"Error in :%d:",i_count);
    		tpfree((char *)ptr_fml_Sbuffer);
    		tpfree((char *)ptr_fml_Rbuffer);
    		errlog(c_ServiceName,"S31220",FMLMSG,DEF_USR, DEF_SSSN,c_event);
    		tpclose();
    		tpterm();
    		exit(0);
			}
		}

  	if(tpcall("SFO_BLK_ALLOC",(char *)ptr_fml_Sbuffer,0,
            	(char **)&ptr_fml_Rbuffer,&l_recv_buff_len,TPNOTRAN|TPNOTIME) == -1)
  	{
    	fn_userlog(c_ServiceName,"Error in SFO_BLK_ALLOC call");
    	errlog(c_ServiceName,"S31225",TPMSG,DEF_USR, DEF_SSSN,c_event);
	  	/*sprintf(c_msg,"FO deallocation complete %lf"  , ptr_recs_list[l_index].fo_alloc_amt ); **Ver 1.3**/
	  	sprintf(c_msg,"FO deallocation complete %lf"  , fo_alloc_amt);	/*Ver 1.3*/
	  	fn_bat_pst_msg(c_ServiceName,c_msg,c_tag);
    	return FO_DEALC_FAILURE;
  	}
  	else
  	{
    	fn_userlog(c_ServiceName,"Call to SFO_BLK_ALLOC for unblock from alocations is successfull");
  	}
	}
	/**** Ver 1.3 starts *************/
	else
	{
  	i_ret_cd = fn_call_inc_dec_wallet(FNO,l_index);

  	if(i_ret_cd != 0)
  	{
			fn_userlog(c_ServiceName,"Error in SFO_BLK_ALLOC call:%d:",i_ret_cd);
    	errlog(c_ServiceName,"S31230",TPMSG,DEF_USR, DEF_SSSN,c_event);
    	sprintf(c_msg,"FO deallocation complete %lf"  , fo_alloc_amt );
    	fn_bat_pst_msg(c_ServiceName,c_msg,c_tag);
			if(i_ret_cd == -2)
    	{
      	return WTHDRAW_FAILURE;
    	}
    	else
    	{
    		return FO_DEALC_FAILURE;
			}
  	}
	}
  /******* End of Ver 1.3 **********/	
	
	/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variables */
  fn_userlog (c_ServiceName,"FO deallocation complete %lf"  , fo_alloc_amt  );
  sprintf(c_msg,"FO deallocation complete %lf"  , fo_alloc_amt );                         
  fn_bat_pst_msg(c_ServiceName,c_msg,c_tag);
  return FO_DEALC_SUCCESS;
}

int fn_deallocate_mfip(long l_index)  /* Common for MF & IPO as per Zubin */
{
  /* Here  I am assuming that the amount for MF and IP is the same allocation*/ 
  /*fn_userlog (c_ServiceName,"Proceeding to deallocate  MFIP %lf"  ,ptr_recs_list[l_index].ip_alloc_amt  );  * Ver 1.3 */

	/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variables */
  if ( (long)(mf_alloc_amt * 100 ) == 0 )
      return (MI_DEALC_SUCCESS);  

	int  i_ret_cd = 0;  /* Ver 1.3 */

  EXEC SQL BEGIN DECLARE SECTION;
  char c_operation;
  char c_prdct;
  char c_event[256];
  long l_recv_buff_len,i; 
  double sql_clm_mf_allctd_amt=0.00;
  char  c_mtch_acnt_id[13]={0};

  EXEC SQL END   DECLARE SECTION;

  tpfree((char *)ptr_fml_Sbuffer);                                        
  tpfree((char *)ptr_fml_Rbuffer);                                        

  ptr_fml_Sbuffer = (FBFR32 *)tpalloc("FML32",NULL,MIN_FML_BUF_LEN);                    
  if (ptr_fml_Sbuffer == NULL)
  {
    errlog(c_ServiceName, "S31235", TPMSG,(char *)c_user_id,l_session_id, c_err_msg);
    tpclose();                                                                
    tpterm();                                                                   
    exit(0);                                                                    
  }

  ptr_fml_Rbuffer = (FBFR32 *)tpalloc("FML32",NULL,MIN_FML_BUF_LEN);                    
  if (ptr_fml_Rbuffer == NULL)                                                          
  {
    errlog(c_ServiceName, "S31240", TPMSG,(char *)c_user_id,l_session_id, c_err_msg);
    tpfree((char *)ptr_fml_Sbuffer);                                                    
    tpclose();                                                                
    tpterm();                                                                   
    exit(0);                                                                    
  }

	if(c_blk_dep_flg == BLOCK_MODEL)    /*Ver 1.3*/
	{
  	c_operation='D';
  	c_prdct='M';
  	strcpy(c_mtch_acnt_id,mtch_id);
  	strcpy(c_user_id,"system");
  	l_session_id=0;
  	sql_clm_mf_allctd_amt=mf_alloc_amt;

  	i_err[0] = Fadd32(ptr_fml_Sbuffer,FML_USR_ID, (char *)c_user_id,0);
  	i_err[1] = Fadd32(ptr_fml_Sbuffer,FML_SSSN_ID, (char *)&l_session_id,0);
  	i_err[2] = Fadd32(ptr_fml_Sbuffer,FML_EBA_MTCH_ACT_NO, (char *)c_mtch_acnt_id, 0);
  	i_err[3] = Fadd32(ptr_fml_Sbuffer,FML_ORD_CLM_MTCH_ACCNT, (char *)c_mtch_acnt_id, 0);
  	i_err[4] = Fadd32(ptr_fml_Sbuffer,FML_TRNSCTN_AMT, (char *)&sql_clm_mf_allctd_amt,0);
  	i_err[5] = Fadd32(ptr_fml_Sbuffer,FML_MSG_TYP, (char *)&c_operation,0);
  	i_err[6] = Fadd32(ptr_fml_Sbuffer,FML_PRDCT_TYP, (char *)&c_prdct,0);
		i_err[7] = Fadd32(ptr_fml_Sbuffer,FML_TRNSCTN_FLW, (char *)&c_blk_dep_flg,0);

  	for (i=0; i <8 ;i++ )
		{
  		if( i_err[i] == -1 )
  		{
    		fn_userlog(c_ServiceName,"Failed at FML %d ",i );
    		errlog(c_ServiceName,"S31245",FMLMSG,DEF_USR, DEF_SSSN,c_event);
    		tpfree((char *)ptr_fml_Sbuffer);
    		tpfree((char *)ptr_fml_Rbuffer);
    		exit(0);
  		}
		}

  	if(tpcall("SVC_BLK_ALLOC",(char *)ptr_fml_Sbuffer,0,
            	(char **)&ptr_fml_Rbuffer,&l_recv_buff_len,TPNOTRAN|TPNOTIME) == -1)
  	{
    	fn_userlog(c_ServiceName,"Error in SVC_BLK_ALLOC call");
    	errlog(c_ServiceName,"S31250",TPMSG,DEF_USR, DEF_SSSN,c_event);
	  	/*sprintf(c_msg,"MFIP deallocation failure %lf"  , ptr_recs_list[l_index].ip_alloc_amt );**Ver 1.3**/
	  	sprintf(c_msg,"MFIP deallocation failure %lf"  , sql_clm_mf_allctd_amt); /**Ver 1.3**/
	  	fn_bat_pst_msg(c_ServiceName,c_msg,c_tag);
    	return MI_DEALC_FAILURE;
  	}
  	else
  	{
    	fn_userlog(c_ServiceName,"Call to SVC_BLK_ALLOC is successful");
  	}
	}
	/**** Ver 1.3 starts *************/
	else
	{
  	i_ret_cd = fn_call_inc_dec_wallet(NEQ,l_index);
  	if(i_ret_cd != 0)
  	{
    	fn_userlog(c_ServiceName,"Error in SVC_BLK_ALLOC call:%d:",i_ret_cd);
    	errlog(c_ServiceName,"S31255",TPMSG,DEF_USR, DEF_SSSN,c_event);
    	sprintf(c_msg,"NEQ deallocation failure %lf"  , mf_alloc_amt );
    	fn_bat_pst_msg(c_ServiceName,c_msg,c_tag);
			if(i_ret_cd == -2)
    	{
      	return WTHDRAW_FAILURE;
    	}
    	else
    	{
    		return MI_DEALC_FAILURE;
			}
  	}
	}
  /******* End of Ver 1.3 **********/	
	
	/**** Modified userlogs in Ver 1.3 */
  fn_userlog(c_ServiceName,"NEQ deallocation complete %lf",mf_alloc_amt  ); 
	sprintf(c_msg,"NEQ deallocation complete %lf",mf_alloc_amt );  
	fn_bat_pst_msg(c_ServiceName,c_msg,c_tag);  

  return MI_DEALC_SUCCESS;
} 

int fn_update_status(c_l_mtch_id, l_l_seq_number, c_flag , c_remarks)
EXEC SQL BEGIN DECLARE SECTION;
char * c_l_mtch_id;
long l_l_seq_number;
char c_flag;
char * c_remarks;
EXEC SQL END   DECLARE SECTION;
{
	
	/****** Ver 1.3 ***********/
	int i_ret_cd = 0;

	fn_userlog(c_ServiceName,"fn_update_status :%s:%ld:%c:%s:",c_l_mtch_id,l_l_seq_number,c_flag,c_remarks  ); 

	i_ret_cd = tpbegin(TRAN_TIMEOUT,0);
  if(i_ret_cd == -1)
  {
    errlog(c_ServiceName, "S31260", TPMSG,(char *)c_user_id,l_session_id, c_err_msg);
    fn_userlog (c_ServiceName,"Error while begginning transaction");
		return -1;
  }
	/**** End of Ver 1.3 */

  EXEC SQL
    UPDATE CDS_CSTM_DEALLOC_SMRY
    SET 
      CDS_PRCS_FLG=:c_flag,
      CDS_RMRKS=:c_remarks
    WHERE
      CDS_MTCH_ACCNO=:c_l_mtch_id
      AND CDS_SEQ_NUMBER=:l_l_seq_number;

  if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
  {
    fn_errlog ( c_ServiceName, "S31265", SQLMSG, c_err_msg  );
    return (-1);
  }

	fn_userlog(c_ServiceName,"Records Updated:%d:%d:",sqlca.sqlerrd[2],SQLCODE); /*Ver 1.3 */

	/***** Ver 1.3 ****/
	if(tpcommit(0)== -1)
  {
    errlog(c_ServiceName,"S31270",TPMSG,c_usr_id,l_session_id,c_err_msg);
    tpabort(0);
    fn_userlog (c_ServiceName,"Error while commiting transaction");
		return -1;
  }
	/***** End of Ver 1.3 ****/
  
  return(0);

}

int fn_check_futures_open(long l_index)
{
	/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variables */
  fn_userlog (c_ServiceName,"Checking Open position- Futures %s"  , mtch_id);

  EXEC SQL BEGIN DECLARE SECTION;
	long l_ffp_opnpstn_qty=0;
  EXEC SQL END   DECLARE SECTION;

  EXEC SQL
  SELECT
		NVL(SUM(ABS(FFP_OPNPSTN_QTY)),0)
	INTO
		:l_ffp_opnpstn_qty
	FROM
		FFP_FO_FUTURES_PSTN
	WHERE
			FFP_CLM_MTCH_ACCNT=:mtch_id /* Ver 1.3 .ptr_recs_list replaced with variables */
	AND FFP_XCHNG_CD='NFO'
	AND FFP_PRDCT_TYP	in ( 'F' , 'P' )
	AND
		(     ffp_opnpstn_qty != 0
		OR    ffp_ibuy_qty    != 0
		OR    ffp_isell_qty   != 0
		);
		
  if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
  {
    fn_errlog ( c_ServiceName, "S31275", SQLMSG, c_err_msg  );
    return (-1);
  }

	/* Ver 1.3 .ptr_recs_list replaced with variables */
  if ( DEBUG_MSG_LVL_3 )
  	fn_userlog (c_ServiceName,"Open position- Futures %s %ld "  
								, mtch_id
								, l_ffp_opnpstn_qty);
  	
	if (l_ffp_opnpstn_qty > 0 ) return(1);
	
	return (0);
}

int fn_check_options_open(long l_index)
{
	/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variables */
  fn_userlog (c_ServiceName,"Checking Open position- Options %s"  , mtch_id);

  EXEC SQL BEGIN DECLARE SECTION;
	long l_fop_opnpstn_qty=0;
  EXEC SQL END   DECLARE SECTION;

	EXEC SQL
  SELECT 
		NVL(SUM(ABS(FOP_OPNPSTN_QTY)),0)
	INTO
		:l_fop_opnpstn_qty		
	FROM
		FOP_FO_OPTIONS_PSTN
	WHERE
			FOP_CLM_MTCH_ACCNT=:mtch_id /* Ver 1.3 .ptr_recs_list replaced with variables */
	AND FOP_XCHNG_CD        = 'NFO'
	AND FOP_PRDCT_TYP				= 'O'
	AND  
		(     fop_opnpstn_qty != 0
		OR    fop_ibuy_qty    != 0
		OR    fop_isell_qty   != 0
		);

  if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
  {
    fn_errlog ( c_ServiceName, "S31280", SQLMSG, c_err_msg  );
    return (-1);
  }

	/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variables */
  if ( DEBUG_MSG_LVL_3 )
  	fn_userlog (c_ServiceName,"Open position- Options %s %ld "  
								, mtch_id
								, l_fop_opnpstn_qty);
  
  if (l_fop_opnpstn_qty > 0 ) return(1);

	return (0);
}

int fn_check_easymargin_open(long l_index)
{
	/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variables */
  fn_userlog (c_ServiceName,"Checking EasyMargin position- %s"  ,mtch_id);

  EXEC SQL BEGIN DECLARE SECTION;
	long l_esymrgn_opnpstn_qty=0;
  EXEC SQL END   DECLARE SECTION;

	EXEC SQL
	SELECT NVL(SUM(NVL(EPB_NET_PSTN_QTY,0)),0)
	INTO   :l_esymrgn_opnpstn_qty
	FROM   EPB_EM_PSTN_BOOK
	WHERE  EPB_CLM_MTCH_ACCNT = :mtch_id; /* Ver 1.3 .ptr_recs_list replaced with variables */
	
  if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
  {
    fn_errlog ( c_ServiceName, "S31285", SQLMSG, c_err_msg  );
    return (-1);
  }

	/* Ver 1.3 .In below statement ptr_recs_list replaced with individual variables */
  if ( DEBUG_MSG_LVL_3 )
  	fn_userlog (c_ServiceName,"EasyMargin Open position %s %ld "  
								, mtch_id
								, l_esymrgn_opnpstn_qty);
  
  if (l_esymrgn_opnpstn_qty > 0 ) return(1);

	return (0);

}
/******************************************************************************/
/*******************************************************************************
--------------------------------------------------------------------------------
*******************************************************************************/
/******************************************************************************/
                                                                                
int fn_bat_init ( int argc, char *argv[] )                                      
{                                                                               
  fn_var = BAT_CSTM_DEALLOC;                                                    
  return 0;                                                                     
}                                                                               
                                                                                
void fn_bat_term ( int argc, char *argv[] )                                     
{                                                                               
  /*fn_rgstr_bat('U',c_ServiceName,"NA","BO");*/                                    
  return;                                                                       
}

int fn_prcs_trg ( char *c_pgm_nm, int i_trg_typ )
{
  return 0;
}
                                                                                
/******************************************************************************/
/*  END OF CODE                                                               */
/******************************************************************************/

/****** Ver 1.3 starts ******/
int fn_call_inc_dec_wallet(char c_segmnt,long l_index)
{
	int   i_trnsctn = 0;    
	int   i_ret_cd = 0;    
	int   i_return_cd = 0;    
	int   i = 0;    
	int   j = 0;    
	int   i_loop_cnt = 2;
  long  l_bft_flg = 0;    
	long 	l_recv_buff_len = 0;
  double d_trn_amt = 0;    
  char  c_narr[21];     
  char  c_segment[3];  
  char  c_bnk_accnt[21]; 
  char  c_channel[4];    
  char  c_ip_id[3];     
	char 	c_operation='N';
  char 	c_prdct='E';
	char  c_mkt_typ='D';
	char  c_req_typ='C';  /* Its an indicator to sfo_blk_alloc not to take a lock */
	char  c_rout_crt[4];
	char  c_xchng_input[4];

	MEMSET(c_narr);
	MEMSET(c_segment);
	MEMSET(sql_clb_bnk_acct_nmbr);
	MEMSET(c_channel);
	MEMSET(sql_clb_clm_mtch_accnt);
	MEMSET(sql_bft_systm_trc_nmbr);
	MEMSET(sql_bft_fld_dt);
	MEMSET(c_CallServiceName);
	MEMSET(c_rout_crt);
	MEMSET(c_xchng_input);
	MEMSET(sql_bft_rsn_cd);
	strcpy(c_channel,"SYS");
	strcpy(c_ip_id,"NA");
	strcpy(c_rout_crt,"333");
	i_err_cd = 0;


	fn_userlog(c_ServiceName,"In fn_cal_inc_dec_wallet:%c:%ld:%c:",c_segmnt,i_loop_cnt,c_wallet_wdr_flag);

	c_prdct = c_segmnt;	

	i_err_cd = 0;

	i_trnsctn = fn_begin_trn_lock (l_index,j,c_segmnt);
  if(i_trnsctn == -1)
  {
   	errlog(c_ServiceName, "S31290", TPMSG,(char *)c_user_id,l_session_id, c_err_msg);
		return -1;
  }

	if(c_wallet_wdr_flag == NO)
	{
		if(c_segmnt == EQ || c_segmnt == NEQ)
		{
			c_operation = DEALLOCATE_FROM_SEGMENT ;	
			strcpy(c_CallServiceName,"SVC_INC_WALLET");
			if(c_segmnt == EQ)
			{
				d_trn_amt = eq_alloc_amt;
				strcpy(c_segment,"EQ");
				strcpy(c_narr,"Dealloc From NSE Seg");
			}
			else
			{
				d_trn_amt = mf_alloc_amt;
				strcpy(c_segment,"NEQ");
				strcpy(c_narr,"Dealloc From NEQ Seg");
			}
		}
		else if(c_segmnt == FNO)
		{
			c_req_typ='C';  /* Its an indicator to sfo_blk_alloc not to take a lock */
			c_operation = FO_DEALLOCATE_FROM_SEGMENT ;
			d_trn_amt = fo_alloc_amt;
			strcpy(c_xchng_input,"NFO");
      strcpy(c_CallServiceName,"SFO_BLK_ALLOC");
			strcpy(sql_bft_rsn_cd,"NFO");
			strcpy(c_segment,"FNO");
		}
		else if(c_segmnt == CDX)
    {
			c_req_typ = 'Y';  /* Its an indicator to scd_blk_alloc not to take a lock */
      c_operation = CDX_DEALLOCATE_FROM_SEGMENT ;
      d_trn_amt = cdx_alloc_amt;
			strcpy( c_xchng_input,"NDX");
      strcpy(c_CallServiceName,"SCD_BLK_ALLOC");
			strcpy(sql_bft_rsn_cd,"NDX");
			strcpy(c_segment,"CDX");
    }
	}
	else
	{
		c_operation = WITHDRAW_FROM_WALLET ;
		strcpy(c_CallServiceName,"SVC_DEC_WALLET");
		strcpy(c_narr,"Withdraw From Wallet");
		c_prdct='N';
		strcpy(c_segment,"NA");
		d_trn_amt = d_wallet_amt;
	}

	l_session_id=0;
 	strcpy(c_user_id,"system");
 	strcpy(sql_clb_clm_mtch_accnt,mtch_id);

	EXEC SQL
		SELECT	CLB_BNK_ACCT_NMBR
		INTO   :sql_clb_bnk_acct_nmbr
		FROM   CLB_BNK_ACCTS
		WHERE  CLB_CLM_MTCH_ACCNT = :sql_clb_clm_mtch_accnt;

	if (SQLCODE != 0 )
 	{
   	tpabort(0);
   	errlog(c_ServiceName, "S31295", SQLMSG,(char *)c_user_id,l_session_id, c_err_msg);
		return -1;
 	}

 	SETNULL(sql_clb_bnk_acct_nmbr);

	Finit32(ptr_fml_Sbuffer, (FLDLEN32) Fsizeof32(ptr_fml_Sbuffer));
	Finit32(ptr_fml_Rbuffer, (FLDLEN32) Fsizeof32(ptr_fml_Rbuffer));

	if((c_segmnt == EQ || c_segmnt == NEQ) || c_operation == WITHDRAW_FROM_WALLET)
	{
		i_err[0] = Fchg32(ptr_fml_Sbuffer,FML_USR_ID,(FLDOCC32)0, (char *)c_user_id,0);
 		i_err[1] = Fchg32(ptr_fml_Sbuffer,FML_SSSN_ID,(FLDOCC32)0, (char *)&l_session_id,0);
 		i_err[2] = Fchg32(ptr_fml_Sbuffer,FML_EBA_MTCH_ACT_NO,(FLDOCC32)0, (char *)sql_clb_clm_mtch_accnt, 0);
 		i_err[3] = Fchg32(ptr_fml_Sbuffer,FML_ORD_CLM_MTCH_ACCNT,(FLDOCC32)0, (char *)sql_clb_clm_mtch_accnt, 0);
 		i_err[4] = Fchg32(ptr_fml_Sbuffer,FML_TRNSCTN_AMT,(FLDOCC32)0, (char *)&d_trn_amt,0);
 		i_err[5] = Fchg32(ptr_fml_Sbuffer,FML_MSG_TYP,(FLDOCC32)0, (char *)&c_operation,0);
 		i_err[6] = Fchg32(ptr_fml_Sbuffer,FML_PRDCT_TYP,(FLDOCC32)0, (char *)&c_prdct,0);
 		i_err[7] = Fchg32(ptr_fml_Sbuffer,FML_MDC_NARRATION,(FLDOCC32)0, (char *)c_narr,0);
 		i_err[8] = Fchg32(ptr_fml_Sbuffer,FML_VLME,(FLDOCC32)0, (char *)&l_run_no,0);
 		i_err[9] = Fchg32(ptr_fml_Sbuffer,FML_XCHNG_SG,(FLDOCC32)0, (char *)c_segment,0);
 		i_err[10] =Fchg32(ptr_fml_Sbuffer,FML_ARD_BNK_ACCNT_NMBR,(FLDOCC32)0,(char *)sql_clb_bnk_acct_nmbr.arr,0);
 		i_err[11] =Fchg32(ptr_fml_Sbuffer,FML_TRANS_TYP,(FLDOCC32)0,(char *)c_ibr_prdct_cd,0);
	}
	else if(c_segmnt == FNO || c_segmnt == CDX)
	{
		i_err[0] = Fchg32(ptr_fml_Sbuffer,FFO_USR_ID,(FLDOCC32)0, (char *)c_user_id,0);
 		i_err[1] = Fchg32(ptr_fml_Sbuffer,FFO_SSSN_ID,(FLDOCC32)0, (char *)&l_session_id,0);
 		i_err[2] = Fchg32(ptr_fml_Sbuffer,FFO_AMOUNT,(FLDOCC32) 0,(char *)&d_trn_amt,0);
 		i_err[3] = Fchg32(ptr_fml_Sbuffer,FFO_DR_CR_FLG, (FLDOCC32) 0,(char *)&c_operation,0);
 		i_err[4] = Fchg32(ptr_fml_Sbuffer,FFO_MKT_TYP,(FLDOCC32) 0,(char *)&c_mkt_typ,0);
 		i_err[5] = Fchg32(ptr_fml_Sbuffer,FFO_RQST_TYP,(FLDOCC32) 0,(char *)&c_req_typ,0);	
		i_err[6] = Fchg32(ptr_fml_Sbuffer,FFO_EBA_MTCH_ACT_NO,(FLDOCC32) 0,(char *)sql_clb_clm_mtch_accnt,0);
		i_err[7] = Fchg32(ptr_fml_Sbuffer,FFO_ROUT_CRT,(FLDOCC32) 0,(char *)&c_rout_crt,0);
		i_err[8] = Fchg32(ptr_fml_Sbuffer,FFO_XCHNG_CD,(FLDOCC32) 0,(char *)c_xchng_input,0);
		i_err[9]=0;
		i_err[10]=0;
		i_err[11]=0;
	}

	for (i=0; i <12 ;i++ )  
	{
 		if( i_err[i] == -1 )
 		{
   		tpabort(0); 
   		fn_userlog(c_ServiceName,"Failed at FML %d ",i );
   		errlog(c_ServiceName,"S31300",FMLMSG,DEF_USR, DEF_SSSN,c_err_msg);
			return -1;
 		}	
	}

	fn_userlog(c_ServiceName,"Calling :%s:%c",c_CallServiceName,c_operation);
	
	if(tpcall(c_CallServiceName,(char *)ptr_fml_Sbuffer,0,(char **)&ptr_fml_Rbuffer,&l_recv_buff_len,0) == -1)
  {
  	i_err_cd = tpurcode;
		errlog(c_ServiceName,"S31305",TPMSG,DEF_USR, DEF_SSSN,c_err_msg);
   	tpabort(0);

		/********** Get trace and timestamp ********************/
		if(c_operation == WITHDRAW_FROM_WALLET)
		{
			if(Fget32(ptr_fml_Rbuffer,FML_SYSTEM_TRACE, 0, (char*)sql_bft_systm_trc_nmbr, 0 ) == -1)
			{
				errlog(c_ServiceName, "S31310", FMLMSG,(char *)DEF_USR,DEF_SSSN, c_err_msg);
				return -2;
			}

			if(Fget32(ptr_fml_Rbuffer,FML_TM, 0, (char*)sql_bft_fld_dt.arr, 0 ) == -1)
			{
				errlog(c_ServiceName, "S31315", FMLMSG,(char *)DEF_USR,DEF_SSSN, c_err_msg);
				return -2;
			}

			SETLEN(sql_bft_fld_dt);

			fn_ins_bft(c_operation,l_index);

			if(i_err_cd == 115 || i_err_cd == 911 || i_err_cd == 907 || i_err_cd == -99 ||
			i_err_cd == -98 || i_err_cd == -1)
			{
				i_ret_cd = fn_reduce_wallet(l_index,i_err_cd,c_operation);
				fn_userlog(c_ServiceName,"i_ret_cd:%d:",i_ret_cd);

				if(i_ret_cd != 0)
				{
					fn_userlog(c_ServiceName,"Error in reduce wallet.Do BFT");
					fn_ins_bft(c_operation,l_index);
				}
			}

			fn_userlog(c_ServiceName,"Returning failure after WITHDRAW_FROM_WALLET");
			return -2;
		}
		else
		{
			fn_userlog(c_ServiceName,"Do BFT:%s:",sql_clb_clm_mtch_accnt);
			fn_ins_bft(c_operation,l_index);
		}

		fn_userlog(c_ServiceName,"Returning failure after :%s:",c_CallServiceName);
		return -1;
	}
	else
	{
		fn_userlog(c_ServiceName,"Deallocation call to :%s: successfull",c_CallServiceName);

		/****** Get trace and tiemstamp in case of withdraw successful */
		if(c_operation == WITHDRAW_FROM_WALLET)
		{
			if(Fget32(ptr_fml_Rbuffer,FML_SYSTEM_TRACE, 0, (char*)sql_bft_systm_trc_nmbr, 0 ) == -1)
			{
				errlog(c_ServiceName, "S31320", FMLMSG,(char *)DEF_USR,DEF_SSSN, c_err_msg);
				return -1;
			}

			if(Fget32(ptr_fml_Rbuffer,FML_TM, 0, (char*)sql_bft_fld_dt.arr, 0 ) == -1)
			{
				errlog(c_ServiceName, "S31325", FMLMSG,(char *)DEF_USR,DEF_SSSN, c_err_msg);
				return -1;
			}

			SETLEN(sql_bft_fld_dt);
		}
		/*** End of Getiing trace and timestamp ****/
	}

	fn_userlog(c_ServiceName,"FNO Amt:%lf:",fo_alloc_amt);

	i_return_cd = fn_ins_mbs_commit(l_index,c_operation,c_segmnt);
	if(i_return_cd == -1)
	{
		tpabort(0); 
		errlog(c_ServiceName, "S31330", TPMSG,(char *)c_user_id,l_session_id, c_err_msg);
		fn_ins_bft(c_operation,l_index);
		i_ret_cd = 0;

		i_ret_cd = fn_reduce_wallet(l_index,i_err_cd,c_operation);

		if(i_ret_cd != 0)
		{
			fn_userlog(c_ServiceName,"Error in reduce wallet.Do BFT");
		}

		return -2;
	}

	return 0;
}

/******* fn_begin_trn_lock : Begin Transaction and take lock ******/
int fn_begin_trn_lock(long l_index,int i_clm_seg_log,char c_segment_cd)
{
  int 	i_trnsctn = 0;
  int 	i_ret_cd = 0;
  double d_trn_amt = 0;
  double d_net_blncs = 0;
	char 	c_sgmnt_cd[3];
	char 	c_narr[30];
	char 	c_channel[3];
	char 	c_txn_src='N';
	char  c_pipo_src[6];       


	MEMSET(c_sgmnt_cd);
	MEMSET(c_narr);
	MEMSET(c_channel);
	MEMSET(c_ibr_prdct_cd);
	MEMSET(c_pipo_src);
	strcpy(c_channel,"NA");
	strcpy(c_pipo_src,"NA");

	if(c_segment_cd == EQ)
	{
  	d_trn_amt = eq_alloc_amt;
	}
	else
	{
		d_trn_amt = mf_alloc_amt;
	}

	fn_userlog(c_ServiceName,"Taking Lock");

	if(tpgetlev() == 1)
	{
		fn_userlog(c_ServiceName,"Already in Transaction");	
	}
	else
	{
		fn_userlog(c_ServiceName,"Not in Transaction");
	}

  i_trnsctn = tpbegin(TRAN_TIMEOUT,0);
  if(i_trnsctn == -1)
  {
    errlog(c_ServiceName, "S31335", TPMSG,(char *)c_user_id,l_session_id, c_err_msg);
    return -1;
  }

  i_ret_cd = fn_lock_usr(c_ServiceName,mtch_id);
  if(i_ret_cd == -1)
  {
    tpabort(0);
    return -1;
  }

	if(c_wallet_wdr_flag == YES)
	{
		fn_userlog(c_ServiceName,"Lock taken ");
		strcpy(c_ibr_prdct_cd,"WITHDRAW");
		return 0;
	}
	else
	{
		strcpy(c_ibr_prdct_cd,"DEALLOC");
	}

  if(i_clm_seg_log == 0 && (c_segment_cd == EQ || c_segment_cd == NEQ))
  {
		if(c_segment_cd == EQ)
		{
			fn_userlog(c_ServiceName,"Reducing CLM_ALLCTD_AMT");
			strcpy(c_narr,"Deallocation from EQ Segment");

			strcpy(c_sgmnt_cd,"EQ");

    	EXEC SQL
        UPDATE  CLM_CLNT_MSTR
        SET     CLM_ALLCTD_AMT =  nvl(CLM_ALLCTD_AMT,0) - :d_trn_amt
        WHERE   CLM_MTCH_ACCNT = :mtch_id
        AND     CLM_ALLCTD_AMT >= :d_trn_amt
        RETURNING CLM_ALLCTD_AMT
        INTO :d_net_blncs;
		}
		else
		{
			fn_userlog(c_ServiceName,"Reducing CLM_MF_ALLCTD_AMT");
			strcpy(c_narr,"Deallocation from NEQ Segment");
			strcpy(c_sgmnt_cd,"NEQ");

			EXEC SQL
        UPDATE  CLM_CLNT_MSTR
        SET     CLM_MF_ALLCTD_AMT =  nvl(CLM_MF_ALLCTD_AMT,0) - :d_trn_amt
        WHERE   CLM_MTCH_ACCNT 		= :mtch_id
        AND     CLM_MF_ALLCTD_AMT	>= :d_trn_amt
        RETURNING CLM_MF_ALLCTD_AMT
        INTO :d_net_blncs;
		}

    if(SQLCODE != 0 )
		{
      errlog(c_ServiceName,"S31340",SQLMSG,c_usr_id,l_session_id,c_err_msg);
      return -1;
    }

		fn_userlog(c_ServiceName,"d_net_blncs:%lf:%lf:",d_trn_amt,d_net_blncs);


    /******** Inert into Segment log **********/
    if(fn_ins_seg_log(c_usr_id,
											l_session_id,
											c_ServiceName,
                    	mtch_id,
                    	d_trn_amt,
                    	DEALLOCATE_FROM_SEGMENT,
                    	c_sgmnt_cd,
                    	d_net_blncs,
                    	c_txn_src,
											c_channel,
											c_narr,
											l_run_no,
											c_ibr_prdct_cd,
											c_pipo_src) == -1)
    {
      errlog(c_ServiceName,"S31345",TPMSG,c_usr_id,l_session_id,c_err_msg);
      return -1;
    }

  }
	else
	{
		fn_userlog(c_ServiceName,"No segment logging");
	}

	fn_userlog(c_ServiceName,"Lock taken ");

  return 0;
}

/******* fn_ins_mbs_commit : Insert into LOG tables and commit ******/
int fn_ins_mbs_commit(long l_index,char c_op_type,char c_segment)
{

  char c_pipo_src[10];
  double d_net_blncs =0;

  MEMSET(sql_mbs_clm_mtch_accnt);
  MEMSET(sql_mbs_xchng_cd);
  MEMSET(sql_mbs_narration);
  MEMSET(sql_mbs_tran_date);
  MEMSET(sql_mbs_segment);
  MEMSET(sql_mbs_run_nmbr);
  MEMSET(sql_mbs_class_svc);
  MEMSET(sql_mbs_mtch_series);
  MEMSET(sql_mbs_instrmnt_nmbr);
  MEMSET(sql_mbs_source_rowid);
  MEMSET(sql_mbs_accntg_entry_typ);
  MEMSET(sql_mbs_crdt_nmbr);
  MEMSET(sql_mbs_bnk_ref_nmbr);
  MEMSET(sql_mbs_bnk_acct_nmbr);
  MEMSET(sql_mbs_prdct_cd);
  MEMSET(c_pipo_src);
	
	sql_mbs_amount = 0;
  sql_mbs_sttlmnt_nmbr = 0;
  sql_mbs_dbcr_flg = ' ';
  sql_mbs_instrmnt_typ = ' ';
  sql_mbs_accent_for = 'X';

  strcpy(sql_mbs_clm_mtch_accnt,mtch_id);

  fn_userlog (c_ServiceName,"In fn_ins_mbs_commit:%d:%c: ",l_index,c_op_type);

  EXEC SQL
		SELECT TO_CHAR(SYSDATE,'dd-Mon-yyyy')
		INTO   :sql_mbs_tran_date
		FROM   DUAL;

  SETNULL(sql_mbs_tran_date);

	if(c_segment == EQ)
	{
		strcpy(sql_mbs_xchng_cd,"NSE");
		sql_mbs_amount = eq_alloc_amt;
	}
	else if(c_segment == NEQ)
	{
		strcpy(sql_mbs_xchng_cd,"NEQ");
		sql_mbs_amount = mf_alloc_amt;
	}
	else if(c_segment == CDX)
	{
		strcpy(sql_mbs_xchng_cd,"NDX");
		sql_mbs_amount = cdx_alloc_amt;	
	}
	else if(c_segment == FNO)
  {
		strcpy(sql_mbs_xchng_cd,"NFO");
		sql_mbs_amount = fo_alloc_amt/100;   /* FNO amount is in Paise */
  }
	else
	{
		strcpy(sql_mbs_xchng_cd,"");
	}

  strcpy(sql_mbs_prdct_cd.arr,"DEALLOC");
  strcpy(c_pipo_src,"NA");
  strcpy(sql_mbs_accntg_entry_typ.arr,"GENERAL");
  strcpy(sql_mbs_class_svc.arr,"SVC_ACC_ENT_MDC");
  strcpy(sql_mbs_source_rowid.arr,c_src_rowid);
  strcpy(sql_mbs_bnk_acct_nmbr.arr,sql_clb_bnk_acct_nmbr.arr);
  strcpy(sql_mbs_bnk_ref_nmbr.arr,sql_bft_systm_trc_nmbr);

	fn_userlog (c_ServiceName,"EXG:%s: PRDCT:%s:SRC:%s:%s:%s:%s:%c:",sql_mbs_xchng_cd,sql_mbs_prdct_cd.arr,c_pipo_src,sql_mbs_accntg_entry_typ.arr,sql_mbs_tran_date.arr,sql_mbs_source_rowid.arr,c_blk_dep_flg);

	if(c_op_type == DEALLOCATE_FROM_SEGMENT)
  {
  	if(fn_ins_mbs(c_ServiceName,
                sql_mbs_clm_mtch_accnt,sql_mbs_xchng_cd,sql_mbs_prdct_cd.arr,
                c_pipo_src,sql_mbs_segment.arr,sql_mbs_sttlmnt_nmbr,sql_mbs_tran_date.arr,
                sql_mbs_amount,sql_mbs_run_nmbr.arr,sql_mbs_instrmnt_nmbr.arr,
                sql_mbs_instrmnt_typ,sql_mbs_crdt_nmbr,sql_mbs_accent_for,
                sql_mbs_accntg_entry_typ.arr,
                sql_mbs_bnk_ref_nmbr.arr,sql_mbs_bnk_acct_nmbr.arr,sql_mbs_narration.arr,
                sql_mbs_dbcr_flg,
                sql_mbs_mtch_series.arr,sql_mbs_class_svc.arr,sql_mbs_source_rowid.arr,
                c_err_msg,c_blk_dep_flg) == -1)
  	{
    	errlog(c_ServiceName,"S31350",TPMSG,c_usr_id,l_session_id,c_err_msg);
    	return -1;
  	}
  }
  else if(c_op_type == WITHDRAW_FROM_WALLET )
  {
  	MEMSET(sql_mbs_prdct_cd);
  	MEMSET(sql_mbs_xchng_cd);

  	strcpy(sql_mbs_prdct_cd.arr,"WITHDRAW");
  	strcpy(sql_mbs_xchng_cd,"NA");
		sql_mbs_amount=d_wallet_amt;

  	if(fn_ins_mbs(c_ServiceName,
                sql_mbs_clm_mtch_accnt,sql_mbs_xchng_cd,sql_mbs_prdct_cd.arr,
                c_pipo_src,sql_mbs_segment.arr,sql_mbs_sttlmnt_nmbr,sql_mbs_tran_date.arr,
                sql_mbs_amount,sql_mbs_run_nmbr.arr,sql_mbs_instrmnt_nmbr.arr,
                sql_mbs_instrmnt_typ,sql_mbs_crdt_nmbr,sql_mbs_accent_for,
                sql_mbs_accntg_entry_typ.arr,
                sql_mbs_bnk_ref_nmbr.arr,sql_mbs_bnk_acct_nmbr.arr,sql_mbs_narration.arr,
								sql_mbs_dbcr_flg,
                sql_mbs_mtch_series.arr,sql_mbs_class_svc.arr,sql_mbs_source_rowid.arr,
                c_err_msg,c_blk_dep_flg) == -1)
  	{
    	errlog(c_ServiceName,"S31355",TPMSG,c_usr_id,l_session_id,c_err_msg);
    	return -1;
  	}
  }
  else
  {
    fn_userlog (c_ServiceName,"Invalid operation type passed %c",c_op_type);
  }

  if(tpcommit(0)== -1)
  {
    errlog(c_ServiceName,"S31360",TPMSG,c_usr_id,l_session_id,c_err_msg);
    return -1;
  }

  fn_userlog (c_ServiceName,"fn_ins_mbs_commit complete:%d:%c: ",l_index,c_op_type);

  return 0;
}

int fn_reduce_wallet(long l_index,int i_error_cd,char c_op_type)
{
  int   i_trnsctn = 0;
  int   i_retcode = 0;
  long  l_bft_flg = 0;
	long  l_recv_buff_len = 0;
  double d_net_wallet_amt= 0;
	char  c_opr_typ = REDUCE_ONLY_WALLET; 

  MEMSET(sql_bft_systm_trc_nmbr);
  MEMSET(sql_bft_fld_dt);

  strcpy(sql_bft_clm_mtch_accnt,mtch_id);
  sql_bft_fld_amnt = eq_alloc_amt;

  fn_userlog (c_ServiceName,"In fn_reduce_wallet .......");
  fn_userlog (c_ServiceName,"Error Code :%d:%d:%ld:",i_error_cd,i_err_cd,tpurcode);


  fn_userlog(c_ServiceName,"TRC:%s:TMSTMP:%s:ErrCd:%d:",sql_bft_systm_trc_nmbr,sql_bft_fld_dt.arr,i_err_cd);
	
 	i_trnsctn = fn_begin_trn_lock(l_index, 1,'N');
 	if(i_trnsctn == -1)
	{
		errlog(c_ServiceName, "S31365", TPMSG, (char *)DEF_USR, DEF_SSSN, c_err_msg);
    	return -1;
 	}

	/*** Only operation type needs to be changed,rest all parameters will be same in Sbuffer*/
	i_err[0] = Fchg32(ptr_fml_Sbuffer,FML_MSG_TYP,(FLDOCC32) 0,(char *)&c_opr_typ, 0);
	if(i_err[0] == -1)
	{
		errlog(c_ServiceName, "S31370", SQLMSG, (char *)DEF_USR, DEF_SSSN, c_err_msg);
   	tpabort(0);
   	return -1;
	}

	fn_userlog(c_ServiceName,"Calling SVC_DEC_WALLET for REDUCE_WALLET");

	if(tpcall("SVC_DEC_WALLET",(char *)ptr_fml_Sbuffer,0,
          (char **)&ptr_fml_Rbuffer,&l_recv_buff_len,0) == -1)
 	{
   	i_err_cd = tpurcode;
   	tpabort(0);
 		fn_userlog(c_ServiceName,"Error in :%s: call",c_CallServiceName);
   	errlog(c_ServiceName,"S31375",TPMSG,DEF_USR, DEF_SSSN,c_err_msg);
   	return -1;
 	}

	/**** Commit the transaction *****/
	if(tpcommit(0)== -1)
  {
		tpabort(0);
   	errlog(c_ServiceName,"S31380",TPMSG,c_usr_id,l_session_id,c_err_msg);
   	return -1;
  }

	fn_userlog(c_ServiceName,"Reduce wallet completed");

  return 0;
}

int fn_ins_bft(char c_op_type,long l_indx)
{
	int  i_trnsctn = 0;

	MEMSET(sql_bft_clm_mtch_accnt);

	strcpy(sql_bft_clm_mtch_accnt,mtch_id);
  sql_bft_fld_amnt = eq_alloc_amt;

	if(c_op_type == DEALLOCATE_FROM_SEGMENT || c_op_type == FO_DEALLOCATE_FROM_SEGMENT ||
		 c_op_type == CDX_DEALLOCATE_FROM_SEGMENT)
	{
		MEMSET(sql_bft_fld_dt);
		strcpy(sql_bft_fld_dt.arr,"NULL");
		SETLEN(sql_bft_fld_dt);
	}

	fn_userlog(c_ServiceName,"ins_bft:%s:%s:%s:%c:%d:",sql_bft_clm_mtch_accnt,sql_bft_fld_dt.arr,sql_bft_systm_trc_nmbr,c_op_type,i_err_cd);


	i_trnsctn = fn_begintran(c_ServiceName, c_err_msg);
  if(i_trnsctn == -1)
  {
  	errlog(c_ServiceName, "S31385", TPMSG, (char *)DEF_USR, DEF_SSSN, c_err_msg);
    return -1;
  }

	EXEC SQL 
		INSERT INTO BFT_BNK_FLD_TRNSCTN
			(
				BFT_FLD_DT,
				BFT_CLM_MTCH_ACCNT,
				BFT_SYSTM_TRC_NMBR,
				BFT_BNK_ACCNT_NMBR,
				BFT_TRNSCTN_TYP,
				BFT_FLD_AMNT,
				BFT_RMRKS,
				BFT_TBL_FLAG,
				BFT_ERR_CD,
				BFT_PRCSS_STTS,
				BFT_RSN_CD  /* To inidcate UB failre in which segment */
			)
			VALUES      
			(
				DECODE(:sql_bft_fld_dt,'NULL',SYSDATE ,
				TO_DATE(:sql_bft_fld_dt, 'yyyymmddhh24miss')),
				:sql_bft_clm_mtch_accnt,
				:sql_bft_systm_trc_nmbr,
				:sql_clb_bnk_acct_nmbr,
				DECODE(:c_op_type,'U','UB','D','UB','CR'),
				:sql_bft_fld_amnt,
				DECODE(:c_op_type,'W','Customer Withdraw failure through bat_cstm_dealloc',
				'Customer dealloc failure through bat_cstm_dealloc'),
				'CDS',
				/*** EBA failure aftre withdraw succes,errcd = -5*/
				DECODE(:i_err_cd||:c_op_type,'0W',-5,:i_err_cd),
				'N',
				:sql_bft_rsn_cd  
			);

	if(SQLCODE != 0)
  {
    errlog(c_ServiceName, "S31390", SQLMSG, (char *)DEF_USR, DEF_SSSN, c_err_msg);
    fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
    return -1;
  }

	fn_userlog(c_ServiceName,"BFT insert done :%d:%d:",SQLCODE,sqlca.sqlerrd[2]);

	i_trnsctn = fn_committran(c_ServiceName,i_trnsctn, c_err_msg);
  if(i_trnsctn == -1)
  {
  	errlog(c_ServiceName, "S31395", SQLMSG, (char *)DEF_USR, DEF_SSSN, c_err_msg);
    fn_aborttran(c_ServiceName, i_trnsctn, c_err_msg);
    return -1;
  }												

	return 0;
}

int fn_check_cdx_stts(long l_index)
{
	EXEC SQL BEGIN DECLARE SECTION;
  	char 		c_rout_crt[4]={0};
  	long 		li_len_tobuf;
  	double 	d_cdx_limit=0.00; 
		double 	d_ccb_dc_amt=0.00;
		double 	d_cbd_normal_amt=0.00;
		double 	d_cbd_tds_amt=0.00;
  	int   	ret_val;
  EXEC SQL END   DECLARE SECTION;	
	cdx_alloc_amt = 0;

	long  l_gid=1;
	
	fn_userlog (c_ServiceName,"CDX check %s ",mtch_id);

	tpfree((char *)ptr_fml_Sbuffer);
  tpfree((char *)ptr_fml_Rbuffer);

  ptr_fml_Sbuffer = (FBFR32 *)tpalloc("FML32",NULL,MIN_FML_BUF_LEN);
  if (ptr_fml_Sbuffer == NULL)
  {
    errlog(c_ServiceName, "S31400", TPMSG,(char *)c_user_id,l_session_id, c_err_msg);
    tpclose();
    tpterm();
    exit(0);
  }

  ptr_fml_Rbuffer = (FBFR32 *)tpalloc("FML32",NULL,MIN_FML_BUF_LEN);
  if (ptr_fml_Rbuffer == NULL)
  {
    errlog(c_ServiceName, "S31405", TPMSG,(char *)c_user_id,l_session_id, c_err_msg);
    tpfree((char *)ptr_fml_Sbuffer);
    tpclose();
    tpterm();
    exit(0);
  }

	strcpy(c_usr_id,"system");
  l_session_id=0;
  strcpy(c_xchng_cd,"*");
  strcpy(c_rout_crt,"333");		

	i_err[0]=Fadd32(ptr_fml_Sbuffer,FFO_USR_ID, (char *)c_usr_id , 0);
  i_err[1]=Fadd32(ptr_fml_Sbuffer,FFO_SSSN_ID, (char *)&l_session_id , 0);
  i_err[2]=Fadd32(ptr_fml_Sbuffer,FFO_EBA_MTCH_ACT_NO, (char *)mtch_id , 0);
	i_err[3]= Fadd32(ptr_fml_Sbuffer,FFO_TRD_DT, (char *)c_trd_dt , 0);
  i_err[4]= Fadd32(ptr_fml_Sbuffer,FFO_XCHNG_CD, (char *)c_xchng_cd , 0);
  i_err[5]= Fadd32(ptr_fml_Sbuffer,FFO_GID, (char *)&l_gid , 0);

  d_cdx_limit = 0.0;

	ret_val = tpcall("SCD_GET_LIMITS",(char*)ptr_fml_Sbuffer,0,(char **)&ptr_fml_Rbuffer,
								    &li_len_tobuf,0);
  if(ret_val == -1)
  {
    fn_errlog( c_ServiceName, "S31410", FMLMSG , c_err_msg );
		return (-1);
  }

	if ( Fget32(ptr_fml_Rbuffer,FFO_LIMIT,0,(char *)&d_cdx_limit,0) == -1 )
	{
		fn_errlog( c_ServiceName, "S31415", FMLMSG , c_err_msg );
		return -1;
	}

	fn_userlog (c_ServiceName,"CDX_LIMIT:%lf::",d_cdx_limit);


	EXEC SQL
     SELECT  NVL(SUM(CBD_DC_AMT - CBD_PI_PO_AMT - CBD_INT_ADJ_AMT),0)
        INTO  :d_cbd_tds_amt
        FROM  CBD_CDX_BNK_DBCR
        WHERE CBD_XCHNG_CD = 'NDX'
        AND   CBD_DC_FLG = 'D'
        AND   CBD_CLM_MTCH_ACCNT  = :mtch_id
        AND   CBD_PAYIN_DT <= to_date(:c_trd_dt, 'dd-Mon-yyyy' )
        AND   CBD_DC_AMT != CBD_PI_PO_AMT + CBD_INT_ADJ_AMT
        AND   CBD_GRP_ID = 9;

    if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
    {
      fn_errlog ( c_ServiceName, "S31420", SQLMSG, c_err_msg  );
      return (-1);
    }

    EXEC SQL
     SELECT  NVL(SUM(CBD_DC_AMT - CBD_PI_PO_AMT - CBD_INT_ADJ_AMT),0)
        INTO :d_cbd_normal_amt
        FROM  CBD_CDX_BNK_DBCR
        WHERE CBD_XCHNG_CD = 'NDX'
        AND   CBD_CLM_MTCH_ACCNT  = :mtch_id
        AND   CBD_PAYIN_DT <= to_date(:c_trd_dt, 'dd-Mon-yyyy' )
        AND   CBD_DC_AMT != CBD_PI_PO_AMT + CBD_INT_ADJ_AMT
        AND   CBD_GRP_ID = 1;

    if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
    {
      fn_errlog ( c_ServiceName, "S31425", SQLMSG, c_err_msg  );
      return (-1);
    }

	d_ccb_dc_amt = d_cbd_tds_amt + d_cbd_normal_amt;

	fn_userlog (c_ServiceName,"NDX:%lf:%lf:%lf:",d_cbd_tds_amt,d_cbd_normal_amt,d_ccb_dc_amt);	

  cdx_pipo_flg = (d_ccb_dc_amt != 0.00F ) ? 'Y' : 'N';
  cdx_alloc_amt=d_cdx_limit;

  if (cdx_pipo_flg == 'N' )
    cdx_pipo_flg =
      ( (fn_check_cdx_futures_open(l_index) == 0 )
                        &&
        (fn_check_cdx_options_open(l_index) == 0 )
      )
      ? 'N' : 'P';

  fn_userlog (c_ServiceName,"CDX Allocation  %lf Obligation %lf FLAG %c "
              , d_cdx_limit, d_ccb_dc_amt , cdx_pipo_flg );

	return 0;
}

int fn_check_cdx_futures_open(long l_index)
{
  fn_userlog (c_ServiceName,"Checking Open position-CDX Futures %s",mtch_id);

  EXEC SQL BEGIN DECLARE SECTION;
  long l_cfu_opnpstn_qty=0;
  EXEC SQL END   DECLARE SECTION;

  EXEC SQL
  SELECT	NVL(SUM(ABS(CFU_UOPNPSTN_QTY)),0)
  INTO    :l_cfu_opnpstn_qty
  FROM		CFU_CDX_FUT_UNDRLYNG_PSTN
  WHERE  	CFU_CLM_MTCH_ACCNT = :mtch_id
  AND 		CFU_XCHNG_CD = 'NDX'
  AND 		CFU_PRDCT_TYP in ( 'F' , 'P' )
  AND
    (     CFU_UOPNPSTN_QTY != 0
    OR    CFU_UIBUY_QTY    != 0
    OR    CFU_UISELL_QTY   != 0
    );

  if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
  {
    fn_errlog ( c_ServiceName, "S31430", SQLMSG, c_err_msg  );
    return (-1);
  }

	if ( DEBUG_MSG_LVL_3 )
	{
    fn_userlog (c_ServiceName,"Open position- CDX Futures %s %ld ", mtch_id
                , l_cfu_opnpstn_qty);
	}

  if (l_cfu_opnpstn_qty > 0 ) 
	{
		return(1);
	}

  return (0);
}

int fn_check_cdx_options_open(long l_index)
{
  fn_userlog (c_ServiceName,"Checking Open position-CDX Options %s",mtch_id);

  EXEC SQL BEGIN DECLARE SECTION;
  long l_cop_opnpstn_qty=0;
  EXEC SQL END   DECLARE SECTION;

  EXEC SQL
  SELECT	NVL(SUM(ABS(COP_OPNPSTN_QTY)),0)
  INTO  	:l_cop_opnpstn_qty
  FROM   	COP_CDX_OPTIONS_PSTN
  WHERE   COP_CLM_MTCH_ACCNT = :mtch_id
  AND 		COP_XCHNG_CD        = 'NDX'
  AND 		COP_PRDCT_TYP       = 'O'
  AND
    (     COP_OPNPSTN_QTY != 0
    OR    COP_IBUY_QTY    != 0
    OR    COP_ISELL_QTY   != 0
    );

  if ( SQLCODE != 0 && SQLCODE != NO_DATA_FOUND )
  {
    fn_errlog ( c_ServiceName, "S31435", SQLMSG, c_err_msg  );
    return (-1);
  }

  if ( DEBUG_MSG_LVL_3 )
    fn_userlog (c_ServiceName,"Open position- CDX Options %s %ld ", mtch_id
								, l_cop_opnpstn_qty);

  if (l_cop_opnpstn_qty > 0 ) 
	{
		return(1);
	}

  return (0);
}

int fn_deallocate_cdx(long l_index)
{
	int i_ret_cd = 0;
	int i_count;
	long l_recv_buff_len;
	char c_msg_typ;
	char c_event[256];

	if ( (long)(cdx_alloc_amt * 100 ) == 0 )
	{
  	return (CDX_DEALC_SUCCESS);
	}

  ptr_fml_Sbuffer = (FBFR32 *)tpalloc("FML32",NULL,MIN_FML_BUF_LEN);
  if (ptr_fml_Sbuffer == NULL)
  {
    errlog(c_ServiceName, "S31440", TPMSG,(char *)c_user_id,l_session_id, c_err_msg);
    tpclose();
    tpterm();
    exit(0);
  }

  ptr_fml_Rbuffer = (FBFR32 *)tpalloc("FML32",NULL,MIN_FML_BUF_LEN);
  if (ptr_fml_Rbuffer == NULL)
  {
    errlog(c_ServiceName, "S31445", TPMSG,(char *)c_user_id,l_session_id, c_err_msg);
    tpfree((char *)ptr_fml_Sbuffer);
    tpclose();
    tpterm();
    exit(0);
  }

	if(c_blk_dep_flg == BLOCK_MODEL)
  {
    c_msg_typ = 'D';
    strcpy(c_user_id,"system");
    l_session_id=0;
    strcpy(c_xchng_cd,"*");

    i_err[0] = Fadd32(ptr_fml_Sbuffer,FFO_USR_ID, (char *)c_user_id,0);
    i_err[1] = Fadd32(ptr_fml_Sbuffer,FFO_SSSN_ID, (char *)&l_session_id,0);
    i_err[2] = Fadd32(ptr_fml_Sbuffer,FFO_EBA_MTCH_ACT_NO, (char *)mtch_id, 0);
    i_err[3] = Fadd32(ptr_fml_Sbuffer,FFO_DR_CR_FLG, (char *)&c_msg_typ, 0);
    i_err[4] = Fadd32(ptr_fml_Sbuffer,FFO_AMOUNT, (char *)&cdx_alloc_amt, 0);
    i_err[5] = Fadd32(ptr_fml_Sbuffer,FFO_XCHNG_CD, (char *)c_xchng_cd, 0);

    for(i_count=0;i_count<6;i_count++)
    {
      if(i_err[i_count] == -1)
      {
        errlog(c_ServiceName, "S31450", FMLMSG,(char *)c_user_id,l_session_id, c_err_msg);
        tpfree((char *)ptr_fml_Sbuffer);
        tpfree((char *)ptr_fml_Rbuffer);
        tpclose();
        tpterm();
        exit(0);
      }
    }

    if(tpcall("SCD_BLK_ALLOC",(char *)ptr_fml_Sbuffer,0,
            (char **)&ptr_fml_Rbuffer,&l_recv_buff_len,TPNOTRAN|TPNOTIME) == -1)
    {
      fn_userlog(c_ServiceName,"Error in SCD_BLK_ALLOC call");
      errlog(c_ServiceName,"S31455",TPMSG,DEF_USR, DEF_SSSN,c_event);
      sprintf(c_msg,"CDX deallocation complete %lf"  , cdx_alloc_amt );
      fn_bat_pst_msg(c_ServiceName,c_msg,c_tag);
      return FO_DEALC_FAILURE;
    }
    else
    {
      fn_userlog(c_ServiceName,"Call to SFO_BLK_ALLOC for unblock from alocations is successfull");
    }
	}
  else
  {
		i_ret_cd = fn_call_inc_dec_wallet(CDX,l_index);
  	if(i_ret_cd != 0)
  	{
    	fn_userlog(c_ServiceName,"fn_call_inc_dec_wallet for CDX...");
    	errlog(c_ServiceName,"S31460",TPMSG,DEF_USR, DEF_SSSN,c_err_msg);
    	sprintf(c_msg,"CDX deallocation failure %lf"  , eq_alloc_amt );
    	fn_bat_pst_msg(c_ServiceName,c_msg,c_tag);
	
			if(i_ret_cd == -2)
    	{
      	return WTHDRAW_FAILURE;
    	}
    	else
    	{
    		return CDX_DEALC_FAILURE;
			}
  	}
	}

	fn_userlog (c_ServiceName,"CDX deallocation complete %lf",cdx_alloc_amt);
  sprintf(c_msg,"CDX deallocation complete %lf"  , cdx_alloc_amt );
  fn_bat_pst_msg(c_ServiceName,c_msg,c_tag);
  return CDX_DEALC_SUCCESS;
}
/***** End of Ver 1.3 ***/



